<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="manifest" href="./manifest.json">
    <meta name="theme-color" content="#3563a7">

    <link rel="icon" href="/favicon.ico" sizes="32x32">
    <link rel="icon" href="/favicon.svg" type="image/svg+xml">
    <meta name="robots" content="noindex">

    <title>探究ツール</title>

    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', function () {
                navigator.serviceWorker.register('./sw.js');
            });
        }
    </script>

    <script>!function (t, e) { "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e((t = "undefined" != typeof globalThis ? globalThis : t || self).turf = {}) }(this, (function (t) {
            "use strict"; function e(t) { return e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, e(t) } function n(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function r(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, h(r.key), r) } } function i(t, e, n) { return e && r(t.prototype, e), n && r(t, n), Object.defineProperty(t, "prototype", { writable: !1 }), t } function o(t, e, n) { return (e = h(e)) in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t } function a(t, e) { return function (t) { if (Array.isArray(t)) return t }(t) || function (t, e) { var n = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"]; if (null != n) { var r, i, o, a, s = [], u = !0, l = !1; try { if (o = (n = n.call(t)).next, 0 === e) { if (Object(n) !== n) return; u = !1 } else for (; !(u = (r = o.call(n)).done) && (s.push(r.value), s.length !== e); u = !0); } catch (t) { l = !0, i = t } finally { try { if (!u && null != n.return && (a = n.return(), Object(a) !== a)) return } finally { if (l) throw i } } return s } }(t, e) || u(t, e) || function () { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }() } function s(t) { return function (t) { if (Array.isArray(t)) return l(t) }(t) || function (t) { if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t) }(t) || u(t) || function () { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }() } function u(t, e) { if (t) { if ("string" == typeof t) return l(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? l(t, e) : void 0 } } function l(t, e) { (null == e || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } function c(t, e) { var n = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"]; if (!n) { if (Array.isArray(t) || (n = u(t)) || e && t && "number" == typeof t.length) { n && (t = n); var r = 0, i = function () { }; return { s: i, n: function () { return r >= t.length ? { done: !0 } : { done: !1, value: t[r++] } }, e: function (t) { throw t }, f: i } } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } var o, a = !0, s = !1; return { s: function () { n = n.call(t) }, n: function () { var t = n.next(); return a = t.done, t }, e: function (t) { s = !0, o = t }, f: function () { try { a || null == n.return || n.return() } finally { if (s) throw o } } } } function h(t) { var e = function (t, e) { if ("object" != typeof t || null === t) return t; var n = t[Symbol.toPrimitive]; if (void 0 !== n) { var r = n.call(t, e || "default"); if ("object" != typeof r) return r; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === e ? String : Number)(t) }(t, "string"); return "symbol" == typeof e ? e : String(e) } var f = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}; function p(t) { return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t } function g(t) { if (t.__esModule) return t; var e = t.default; if ("function" == typeof e) { var n = function t() { return this instanceof t ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments) }; n.prototype = e.prototype } else n = {}; return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(t).forEach((function (e) { var r = Object.getOwnPropertyDescriptor(t, e); Object.defineProperty(n, e, r.get ? r : { enumerable: !0, get: function () { return t[e] } }) })), n } var y, v, d = Object.prototype.toString, m = function (t) { var n = d.call(t), r = "[object Arguments]" === n; return r || (r = "[object Array]" !== n && null !== t && "object" === e(t) && "number" == typeof t.length && t.length >= 0 && "[object Function]" === d.call(t.callee)), r }; var _ = Array.prototype.slice, b = m, x = Object.keys, E = x ? function (t) { return x(t) } : function () { if (v) return y; var t; if (v = 1, !Object.keys) { var n = Object.prototype.hasOwnProperty, r = Object.prototype.toString, i = m, o = Object.prototype.propertyIsEnumerable, a = !o.call({ toString: null }, "toString"), s = o.call((function () { }), "prototype"), u = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"], l = function (t) { var e = t.constructor; return e && e.prototype === t }, c = { $applicationCache: !0, $console: !0, $external: !0, $frame: !0, $frameElement: !0, $frames: !0, $innerHeight: !0, $innerWidth: !0, $onmozfullscreenchange: !0, $onmozfullscreenerror: !0, $outerHeight: !0, $outerWidth: !0, $pageXOffset: !0, $pageYOffset: !0, $parent: !0, $scrollLeft: !0, $scrollTop: !0, $scrollX: !0, $scrollY: !0, $self: !0, $webkitIndexedDB: !0, $webkitStorageInfo: !0, $window: !0 }, h = function () { if ("undefined" == typeof window) return !1; for (var t in window) try { if (!c["$" + t] && n.call(window, t) && null !== window[t] && "object" === e(window[t])) try { l(window[t]) } catch (t) { return !0 } } catch (t) { return !0 } return !1 }(); t = function (t) { var o = null !== t && "object" === e(t), c = "[object Function]" === r.call(t), f = i(t), p = o && "[object String]" === r.call(t), g = []; if (!o && !c && !f) throw new TypeError("Object.keys called on a non-object"); var y = s && c; if (p && t.length > 0 && !n.call(t, 0)) for (var v = 0; v < t.length; ++v)g.push(String(v)); if (f && t.length > 0) for (var d = 0; d < t.length; ++d)g.push(String(d)); else for (var m in t) y && "prototype" === m || !n.call(t, m) || g.push(String(m)); if (a) for (var _ = function (t) { if ("undefined" == typeof window || !h) return l(t); try { return l(t) } catch (t) { return !1 } }(t), b = 0; b < u.length; ++b)_ && "constructor" === u[b] || !n.call(t, u[b]) || g.push(u[b]); return g } } return y = t }(), w = Object.keys; E.shim = function () { if (Object.keys) { var t = function () { var t = Object.keys(arguments); return t && t.length === arguments.length }(1, 2); t || (Object.keys = function (t) { return b(t) ? w(_.call(t)) : w(t) }) } else Object.keys = E; return Object.keys || E }; var k, S = E, I = function () { if ("function" != typeof Symbol || "function" != typeof Object.getOwnPropertySymbols) return !1; if ("symbol" === e(Symbol.iterator)) return !0; var t = {}, n = Symbol("test"), r = Object(n); if ("string" == typeof n) return !1; if ("[object Symbol]" !== Object.prototype.toString.call(n)) return !1; if ("[object Symbol]" !== Object.prototype.toString.call(r)) return !1; for (n in t[n] = 42, t) return !1; if ("function" == typeof Object.keys && 0 !== Object.keys(t).length) return !1; if ("function" == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(t).length) return !1; var i = Object.getOwnPropertySymbols(t); if (1 !== i.length || i[0] !== n) return !1; if (!Object.prototype.propertyIsEnumerable.call(t, n)) return !1; if ("function" == typeof Object.getOwnPropertyDescriptor) { var o = Object.getOwnPropertyDescriptor(t, n); if (42 !== o.value || !0 !== o.enumerable) return !1 } return !0 }, P = "undefined" != typeof Symbol && Symbol, N = I, M = function () { return "function" == typeof P && ("function" == typeof Symbol && ("symbol" === e(P("foo")) && ("symbol" === e(Symbol("bar")) && N()))) }, O = { foo: {} }, L = Object, R = Object.prototype.toString, C = Math.max, T = function (t, e) { for (var n = [], r = 0; r < t.length; r += 1)n[r] = t[r]; for (var i = 0; i < e.length; i += 1)n[i + t.length] = e[i]; return n }, A = function (t) { var e = this; if ("function" != typeof e || "[object Function]" !== R.apply(e)) throw new TypeError("Function.prototype.bind called on incompatible " + e); for (var n, r = function (t, e) { for (var n = [], r = e || 0, i = 0; r < t.length; r += 1, i += 1)n[i] = t[r]; return n }(arguments, 1), i = C(0, e.length - r.length), o = [], a = 0; a < i; a++)o[a] = "$" + a; if (n = Function("binder", "return function (" + function (t, e) { for (var n = "", r = 0; r < t.length; r += 1)n += t[r], r + 1 < t.length && (n += e); return n }(o, ",") + "){ return binder.apply(this,arguments); }")((function () { if (this instanceof n) { var i = e.apply(this, T(r, arguments)); return Object(i) === i ? i : this } return e.apply(t, T(r, arguments)) })), e.prototype) { var s = function () { }; s.prototype = e.prototype, n.prototype = new s, s.prototype = null } return n }, D = Function.prototype.bind || A, j = Function.prototype.call, F = Object.prototype.hasOwnProperty, B = D.call(j, F), q = SyntaxError, V = Function, G = TypeError, Y = function (t) { try { return V('"use strict"; return (' + t + ").constructor;")() } catch (t) { } }, z = Object.getOwnPropertyDescriptor; if (z) try { z({}, "") } catch (t) { z = null } var U = function () { throw new G }, X = z ? function () { try { return U } catch (t) { try { return z(arguments, "callee").get } catch (t) { return U } } }() : U, W = M(), H = { __proto__: O }.foo === O.foo && !({ __proto__: null } instanceof L), Z = Object.getPrototypeOf || (H ? function (t) { return t.__proto__ } : null), J = {}, $ = "undefined" != typeof Uint8Array && Z ? Z(Uint8Array) : k, Q = { "%AggregateError%": "undefined" == typeof AggregateError ? k : AggregateError, "%Array%": Array, "%ArrayBuffer%": "undefined" == typeof ArrayBuffer ? k : ArrayBuffer, "%ArrayIteratorPrototype%": W && Z ? Z([][Symbol.iterator]()) : k, "%AsyncFromSyncIteratorPrototype%": k, "%AsyncFunction%": J, "%AsyncGenerator%": J, "%AsyncGeneratorFunction%": J, "%AsyncIteratorPrototype%": J, "%Atomics%": "undefined" == typeof Atomics ? k : Atomics, "%BigInt%": "undefined" == typeof BigInt ? k : BigInt, "%BigInt64Array%": "undefined" == typeof BigInt64Array ? k : BigInt64Array, "%BigUint64Array%": "undefined" == typeof BigUint64Array ? k : BigUint64Array, "%Boolean%": Boolean, "%DataView%": "undefined" == typeof DataView ? k : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%eval%": eval, "%EvalError%": EvalError, "%Float32Array%": "undefined" == typeof Float32Array ? k : Float32Array, "%Float64Array%": "undefined" == typeof Float64Array ? k : Float64Array, "%FinalizationRegistry%": "undefined" == typeof FinalizationRegistry ? k : FinalizationRegistry, "%Function%": V, "%GeneratorFunction%": J, "%Int8Array%": "undefined" == typeof Int8Array ? k : Int8Array, "%Int16Array%": "undefined" == typeof Int16Array ? k : Int16Array, "%Int32Array%": "undefined" == typeof Int32Array ? k : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": W && Z ? Z(Z([][Symbol.iterator]())) : k, "%JSON%": "object" === ("undefined" == typeof JSON ? "undefined" : e(JSON)) ? JSON : k, "%Map%": "undefined" == typeof Map ? k : Map, "%MapIteratorPrototype%": "undefined" != typeof Map && W && Z ? Z((new Map)[Symbol.iterator]()) : k, "%Math%": Math, "%Number%": Number, "%Object%": Object, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": "undefined" == typeof Promise ? k : Promise, "%Proxy%": "undefined" == typeof Proxy ? k : Proxy, "%RangeError%": RangeError, "%ReferenceError%": ReferenceError, "%Reflect%": "undefined" == typeof Reflect ? k : Reflect, "%RegExp%": RegExp, "%Set%": "undefined" == typeof Set ? k : Set, "%SetIteratorPrototype%": "undefined" != typeof Set && W && Z ? Z((new Set)[Symbol.iterator]()) : k, "%SharedArrayBuffer%": "undefined" == typeof SharedArrayBuffer ? k : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": W && Z ? Z(""[Symbol.iterator]()) : k, "%Symbol%": W ? Symbol : k, "%SyntaxError%": q, "%ThrowTypeError%": X, "%TypedArray%": $, "%TypeError%": G, "%Uint8Array%": "undefined" == typeof Uint8Array ? k : Uint8Array, "%Uint8ClampedArray%": "undefined" == typeof Uint8ClampedArray ? k : Uint8ClampedArray, "%Uint16Array%": "undefined" == typeof Uint16Array ? k : Uint16Array, "%Uint32Array%": "undefined" == typeof Uint32Array ? k : Uint32Array, "%URIError%": URIError, "%WeakMap%": "undefined" == typeof WeakMap ? k : WeakMap, "%WeakRef%": "undefined" == typeof WeakRef ? k : WeakRef, "%WeakSet%": "undefined" == typeof WeakSet ? k : WeakSet }; if (Z) try { null.error } catch (t) { var K = Z(Z(t)); Q["%Error.prototype%"] = K } var tt = function t(e) { var n; if ("%AsyncFunction%" === e) n = Y("async function () {}"); else if ("%GeneratorFunction%" === e) n = Y("function* () {}"); else if ("%AsyncGeneratorFunction%" === e) n = Y("async function* () {}"); else if ("%AsyncGenerator%" === e) { var r = t("%AsyncGeneratorFunction%"); r && (n = r.prototype) } else if ("%AsyncIteratorPrototype%" === e) { var i = t("%AsyncGenerator%"); i && Z && (n = Z(i.prototype)) } return Q[e] = n, n }, et = { "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, nt = D, rt = B, it = nt.call(Function.call, Array.prototype.concat), ot = nt.call(Function.apply, Array.prototype.splice), at = nt.call(Function.call, String.prototype.replace), st = nt.call(Function.call, String.prototype.slice), ut = nt.call(Function.call, RegExp.prototype.exec), lt = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, ct = /\\(\\)?/g, ht = function (t, e) { var n, r = t; if (rt(et, r) && (r = "%" + (n = et[r])[0] + "%"), rt(Q, r)) { var i = Q[r]; if (i === J && (i = tt(r)), void 0 === i && !e) throw new G("intrinsic " + t + " exists, but is not available. Please file an issue!"); return { alias: n, name: r, value: i } } throw new q("intrinsic " + t + " does not exist!") }, ft = function (t, e) { if ("string" != typeof t || 0 === t.length) throw new G("intrinsic name must be a non-empty string"); if (arguments.length > 1 && "boolean" != typeof e) throw new G('"allowMissing" argument must be a boolean'); if (null === ut(/^%?[^%]*%?$/, t)) throw new q("`%` may not be present anywhere but at the beginning and end of the intrinsic name"); var n = function (t) { var e = st(t, 0, 1), n = st(t, -1); if ("%" === e && "%" !== n) throw new q("invalid intrinsic syntax, expected closing `%`"); if ("%" === n && "%" !== e) throw new q("invalid intrinsic syntax, expected opening `%`"); var r = []; return at(t, lt, (function (t, e, n, i) { r[r.length] = n ? at(i, ct, "$1") : e || t })), r }(t), r = n.length > 0 ? n[0] : "", i = ht("%" + r + "%", e), o = i.name, a = i.value, s = !1, u = i.alias; u && (r = u[0], ot(n, it([0, 1], u))); for (var l = 1, c = !0; l < n.length; l += 1) { var h = n[l], f = st(h, 0, 1), p = st(h, -1); if (('"' === f || "'" === f || "`" === f || '"' === p || "'" === p || "`" === p) && f !== p) throw new q("property names with quotes must have matching quotes"); if ("constructor" !== h && c || (s = !0), rt(Q, o = "%" + (r += "." + h) + "%")) a = Q[o]; else if (null != a) { if (!(h in a)) { if (!e) throw new G("base intrinsic for " + t + " exists, but the property is not available."); return } if (z && l + 1 >= n.length) { var g = z(a, h); a = (c = !!g) && "get" in g && !("originalValue" in g.get) ? g.get : a[h] } else c = rt(a, h), a = a[h]; c && !s && (Q[o] = a) } } return a }, pt = ft("%Object.defineProperty%", !0), gt = function () { if (pt) try { return pt({}, "a", { value: 1 }), !0 } catch (t) { return !1 } return !1 }; gt.hasArrayLengthDefineBug = function () { if (!gt()) return null; try { return 1 !== pt([], "length", { value: 1 }).length } catch (t) { return !0 } }; var yt = gt, vt = ft("%Object.getOwnPropertyDescriptor%", !0); if (vt) try { vt([], "length") } catch (t) { vt = null } var dt = vt, mt = yt(), _t = ft, bt = mt && _t("%Object.defineProperty%", !0); if (bt) try { bt({}, "a", { value: 1 }) } catch (t) { bt = !1 } var xt = _t("%SyntaxError%"), Et = _t("%TypeError%"), wt = dt, kt = function (t, n, r) { if (!t || "object" !== e(t) && "function" != typeof t) throw new Et("`obj` must be an object or a function`"); if ("string" != typeof n && "symbol" !== e(n)) throw new Et("`property` must be a string or a symbol`"); if (arguments.length > 3 && "boolean" != typeof arguments[3] && null !== arguments[3]) throw new Et("`nonEnumerable`, if provided, must be a boolean or null"); if (arguments.length > 4 && "boolean" != typeof arguments[4] && null !== arguments[4]) throw new Et("`nonWritable`, if provided, must be a boolean or null"); if (arguments.length > 5 && "boolean" != typeof arguments[5] && null !== arguments[5]) throw new Et("`nonConfigurable`, if provided, must be a boolean or null"); if (arguments.length > 6 && "boolean" != typeof arguments[6]) throw new Et("`loose`, if provided, must be a boolean"); var i = arguments.length > 3 ? arguments[3] : null, o = arguments.length > 4 ? arguments[4] : null, a = arguments.length > 5 ? arguments[5] : null, s = arguments.length > 6 && arguments[6], u = !!wt && wt(t, n); if (bt) bt(t, n, { configurable: null === a && u ? u.configurable : !a, enumerable: null === i && u ? u.enumerable : !i, value: r, writable: null === o && u ? u.writable : !o }); else { if (!s && (i || o || a)) throw new xt("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable."); t[n] = r } }, St = S, It = "function" == typeof Symbol && "symbol" === e(Symbol("foo")), Pt = Object.prototype.toString, Nt = Array.prototype.concat, Mt = kt, Ot = yt(), Lt = function (t, e, n, r) { if (e in t) if (!0 === r) { if (t[e] === n) return } else if ("function" != typeof (i = r) || "[object Function]" !== Pt.call(i) || !r()) return; var i; Ot ? Mt(t, e, n, !0) : Mt(t, e, n) }, Rt = function (t, e) { var n = arguments.length > 2 ? arguments[2] : {}, r = St(e); It && (r = Nt.call(r, Object.getOwnPropertySymbols(e))); for (var i = 0; i < r.length; i += 1)Lt(t, r[i], e[r[i]], n[r[i]]) }; Rt.supportsDescriptors = !!Ot; var Ct = Rt, Tt = { exports: {} }, At = ft, Dt = kt, jt = yt(), Ft = dt, Bt = At("%TypeError%"), qt = At("%Math.floor%"), Vt = function (t, e) { if ("function" != typeof t) throw new Bt("`fn` is not a function"); if ("number" != typeof e || e < 0 || e > 4294967295 || qt(e) !== e) throw new Bt("`length` must be a positive 32-bit integer"); var n = arguments.length > 2 && !!arguments[2], r = !0, i = !0; if ("length" in t && Ft) { var o = Ft(t, "length"); o && !o.configurable && (r = !1), o && !o.writable && (i = !1) } return (r || i || !n) && (jt ? Dt(t, "length", e, !0, !0) : Dt(t, "length", e)), t }; !function (t) { var e = D, n = ft, r = Vt, i = n("%TypeError%"), o = n("%Function.prototype.apply%"), a = n("%Function.prototype.call%"), s = n("%Reflect.apply%", !0) || e.call(a, o), u = n("%Object.defineProperty%", !0), l = n("%Math.max%"); if (u) try { u({}, "a", { value: 1 }) } catch (t) { u = null } t.exports = function (t) { if ("function" != typeof t) throw new i("a function is required"); var n = s(e, a, arguments); return r(n, 1 + l(0, t.length - (arguments.length - 1)), !0) }; var c = function () { return s(e, o, arguments) }; u ? u(t.exports, "apply", { value: c }) : t.exports.apply = c }(Tt); var Gt = Tt.exports, Yt = ft, zt = Gt, Ut = zt(Yt("String.prototype.indexOf")), Xt = function (t, e) { var n = Yt(t, !!e); return "function" == typeof n && Ut(t, ".prototype.") > -1 ? zt(n) : n }, Wt = S, Ht = I(), Zt = Xt, Jt = Object, $t = Zt("Array.prototype.push"), Qt = Zt("Object.prototype.propertyIsEnumerable"), Kt = Ht ? Object.getOwnPropertySymbols : null, te = function (t, e) { if (null == t) throw new TypeError("target must be an object"); var n = Jt(t); if (1 === arguments.length) return n; for (var r = 1; r < arguments.length; ++r) { var i = Jt(arguments[r]), o = Wt(i), a = Ht && (Object.getOwnPropertySymbols || Kt); if (a) for (var s = a(i), u = 0; u < s.length; ++u) { var l = s[u]; Qt(i, l) && $t(o, l) } for (var c = 0; c < o.length; ++c) { var h = o[c]; if (Qt(i, h)) { var f = i[h]; n[h] = f } } } return n }, ee = te, ne = function () { return Object.assign ? function () { if (!Object.assign) return !1; for (var t = "abcdefghijklmnopqrst", e = t.split(""), n = {}, r = 0; r < e.length; ++r)n[e[r]] = e[r]; var i = Object.assign({}, n), o = ""; for (var a in i) o += a; return t !== o }() || function () { if (!Object.assign || !Object.preventExtensions) return !1; var t = Object.preventExtensions({ 1: 2 }); try { Object.assign(t, "xy") } catch (e) { return "y" === t[1] } return !1 }() ? ee : Object.assign : ee }, re = Ct, ie = ne, oe = Ct, ae = te, se = ne, ue = function () { var t = ie(); return re(Object, { assign: t }, { assign: function () { return Object.assign !== t } }), t }, le = Gt.apply(se()), ce = function (t, e) { return le(Object, arguments) }; oe(ce, { getPolyfill: se, implementation: ae, shim: ue }); var he = ce, fe = function () { return "string" == typeof function () { }.name }, pe = Object.getOwnPropertyDescriptor; if (pe) try { pe([], "length") } catch (t) { pe = null } fe.functionsHaveConfigurableNames = function () { if (!fe() || !pe) return !1; var t = pe((function () { }), "name"); return !!t && !!t.configurable }; var ge = Function.prototype.bind; fe.boundFunctionsHaveNames = function () { return fe() && "function" == typeof ge && "" !== function () { }.bind().name }; var ye = fe, ve = kt, de = yt(), me = ye.functionsHaveConfigurableNames(), _e = TypeError, be = function (t, e) { if ("function" != typeof t) throw new _e("`fn` is not a function"); return arguments.length > 2 && !!arguments[2] && !me || (de ? ve(t, "name", e, !0, !0) : ve(t, "name", e)), t }, xe = Object, Ee = TypeError, we = be((function () { if (null != this && this !== xe(this)) throw new Ee("RegExp.prototype.flags getter called on non-object"); var t = ""; return this.hasIndices && (t += "d"), this.global && (t += "g"), this.ignoreCase && (t += "i"), this.multiline && (t += "m"), this.dotAll && (t += "s"), this.unicode && (t += "u"), this.unicodeSets && (t += "v"), this.sticky && (t += "y"), t }), "get flags", !0), ke = we, Se = Ct.supportsDescriptors, Ie = Object.getOwnPropertyDescriptor, Pe = function () { if (Se && "gim" === /a/gim.flags) { var t = Ie(RegExp.prototype, "flags"); if (t && "function" == typeof t.get && "boolean" == typeof RegExp.prototype.dotAll && "boolean" == typeof RegExp.prototype.hasIndices) { var e = "", n = {}; if (Object.defineProperty(n, "hasIndices", { get: function () { e += "d" } }), Object.defineProperty(n, "sticky", { get: function () { e += "y" } }), "dy" === e) return t.get } } return ke }, Ne = Ct.supportsDescriptors, Me = Pe, Oe = Object.getOwnPropertyDescriptor, Le = Object.defineProperty, Re = TypeError, Ce = Object.getPrototypeOf, Te = /a/, Ae = Ct, De = we, je = Pe, Fe = function () { if (!Ne || !Ce) throw new Re("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors"); var t = Me(), e = Ce(Te), n = Oe(e, "flags"); return n && n.get === t || Le(e, "flags", { configurable: !0, enumerable: !1, get: t }), t }, Be = Gt(je()); Ae(Be, { getPolyfill: je, implementation: De, shim: Fe }); var qe = Be, Ve = Symbol.iterator, Ge = "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, Ye = [], ze = [], Ue = "undefined" != typeof Uint8Array ? Uint8Array : Array, Xe = !1; function We() { Xe = !0; for (var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", e = 0; e < 64; ++e)Ye[e] = t[e], ze[t.charCodeAt(e)] = e; ze["-".charCodeAt(0)] = 62, ze["_".charCodeAt(0)] = 63 } function He(t, e, n) { for (var r, i, o = [], a = e; a < n; a += 3)r = (t[a] << 16) + (t[a + 1] << 8) + t[a + 2], o.push(Ye[(i = r) >> 18 & 63] + Ye[i >> 12 & 63] + Ye[i >> 6 & 63] + Ye[63 & i]); return o.join("") } function Ze(t) { var e; Xe || We(); for (var n = t.length, r = n % 3, i = "", o = [], a = 16383, s = 0, u = n - r; s < u; s += a)o.push(He(t, s, s + a > u ? u : s + a)); return 1 === r ? (e = t[n - 1], i += Ye[e >> 2], i += Ye[e << 4 & 63], i += "==") : 2 === r && (e = (t[n - 2] << 8) + t[n - 1], i += Ye[e >> 10], i += Ye[e >> 4 & 63], i += Ye[e << 2 & 63], i += "="), o.push(i), o.join("") } function Je(t, e, n, r, i) { var o, a, s = 8 * i - r - 1, u = (1 << s) - 1, l = u >> 1, c = -7, h = n ? i - 1 : 0, f = n ? -1 : 1, p = t[e + h]; for (h += f, o = p & (1 << -c) - 1, p >>= -c, c += s; c > 0; o = 256 * o + t[e + h], h += f, c -= 8); for (a = o & (1 << -c) - 1, o >>= -c, c += r; c > 0; a = 256 * a + t[e + h], h += f, c -= 8); if (0 === o) o = 1 - l; else { if (o === u) return a ? NaN : 1 / 0 * (p ? -1 : 1); a += Math.pow(2, r), o -= l } return (p ? -1 : 1) * a * Math.pow(2, o - r) } function $e(t, e, n, r, i, o) { var a, s, u, l = 8 * o - i - 1, c = (1 << l) - 1, h = c >> 1, f = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p = r ? 0 : o - 1, g = r ? 1 : -1, y = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0; for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (s = isNaN(e) ? 1 : 0, a = c) : (a = Math.floor(Math.log(e) / Math.LN2), e * (u = Math.pow(2, -a)) < 1 && (a--, u *= 2), (e += a + h >= 1 ? f / u : f * Math.pow(2, 1 - h)) * u >= 2 && (a++, u /= 2), a + h >= c ? (s = 0, a = c) : a + h >= 1 ? (s = (e * u - 1) * Math.pow(2, i), a += h) : (s = e * Math.pow(2, h - 1) * Math.pow(2, i), a = 0)); i >= 8; t[n + p] = 255 & s, p += g, s /= 256, i -= 8); for (a = a << i | s, l += i; l > 0; t[n + p] = 255 & a, p += g, a /= 256, l -= 8); t[n + p - g] |= 128 * y } var Qe = {}.toString, Ke = Array.isArray || function (t) { return "[object Array]" == Qe.call(t) }; function tn() { return nn.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823 } function en(t, e) { if (tn() < e) throw new RangeError("Invalid typed array length"); return nn.TYPED_ARRAY_SUPPORT ? (t = new Uint8Array(e)).__proto__ = nn.prototype : (null === t && (t = new nn(e)), t.length = e), t } function nn(t, e, n) { if (!(nn.TYPED_ARRAY_SUPPORT || this instanceof nn)) return new nn(t, e, n); if ("number" == typeof t) { if ("string" == typeof e) throw new Error("If encoding is specified then the first argument must be a string"); return an(this, t) } return rn(this, t, e, n) } function rn(t, e, n, r) { if ("number" == typeof e) throw new TypeError('"value" argument must not be a number'); return "undefined" != typeof ArrayBuffer && e instanceof ArrayBuffer ? function (t, e, n, r) { if (e.byteLength, n < 0 || e.byteLength < n) throw new RangeError("'offset' is out of bounds"); if (e.byteLength < n + (r || 0)) throw new RangeError("'length' is out of bounds"); e = void 0 === n && void 0 === r ? new Uint8Array(e) : void 0 === r ? new Uint8Array(e, n) : new Uint8Array(e, n, r); nn.TYPED_ARRAY_SUPPORT ? (t = e).__proto__ = nn.prototype : t = sn(t, e); return t }(t, e, n, r) : "string" == typeof e ? function (t, e, n) { "string" == typeof n && "" !== n || (n = "utf8"); if (!nn.isEncoding(n)) throw new TypeError('"encoding" must be a valid string encoding'); var r = 0 | cn(e, n); t = en(t, r); var i = t.write(e, n); i !== r && (t = t.slice(0, i)); return t }(t, e, n) : function (t, e) { if (ln(e)) { var n = 0 | un(e.length); return 0 === (t = en(t, n)).length || e.copy(t, 0, 0, n), t } if (e) { if ("undefined" != typeof ArrayBuffer && e.buffer instanceof ArrayBuffer || "length" in e) return "number" != typeof e.length || (r = e.length) != r ? en(t, 0) : sn(t, e); if ("Buffer" === e.type && Ke(e.data)) return sn(t, e.data) } var r; throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.") }(t, e) } function on(t) { if ("number" != typeof t) throw new TypeError('"size" argument must be a number'); if (t < 0) throw new RangeError('"size" argument must not be negative') } function an(t, e) { if (on(e), t = en(t, e < 0 ? 0 : 0 | un(e)), !nn.TYPED_ARRAY_SUPPORT) for (var n = 0; n < e; ++n)t[n] = 0; return t } function sn(t, e) { var n = e.length < 0 ? 0 : 0 | un(e.length); t = en(t, n); for (var r = 0; r < n; r += 1)t[r] = 255 & e[r]; return t } function un(t) { if (t >= tn()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + tn().toString(16) + " bytes"); return 0 | t } function ln(t) { return !(null == t || !t._isBuffer) } function cn(t, e) { if (ln(t)) return t.length; if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)) return t.byteLength; "string" != typeof t && (t = "" + t); var n = t.length; if (0 === n) return 0; for (var r = !1; ;)switch (e) { case "ascii": case "latin1": case "binary": return n; case "utf8": case "utf-8": case void 0: return jn(t).length; case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return 2 * n; case "hex": return n >>> 1; case "base64": return Fn(t).length; default: if (r) return jn(t).length; e = ("" + e).toLowerCase(), r = !0 } } function hn(t, e, n) { var r = !1; if ((void 0 === e || e < 0) && (e = 0), e > this.length) return ""; if ((void 0 === n || n > this.length) && (n = this.length), n <= 0) return ""; if ((n >>>= 0) <= (e >>>= 0)) return ""; for (t || (t = "utf8"); ;)switch (t) { case "hex": return In(this, e, n); case "utf8": case "utf-8": return En(this, e, n); case "ascii": return kn(this, e, n); case "latin1": case "binary": return Sn(this, e, n); case "base64": return xn(this, e, n); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return Pn(this, e, n); default: if (r) throw new TypeError("Unknown encoding: " + t); t = (t + "").toLowerCase(), r = !0 } } function fn(t, e, n) { var r = t[e]; t[e] = t[n], t[n] = r } function pn(t, e, n, r, i) { if (0 === t.length) return -1; if ("string" == typeof n ? (r = n, n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648), n = +n, isNaN(n) && (n = i ? 0 : t.length - 1), n < 0 && (n = t.length + n), n >= t.length) { if (i) return -1; n = t.length - 1 } else if (n < 0) { if (!i) return -1; n = 0 } if ("string" == typeof e && (e = nn.from(e, r)), ln(e)) return 0 === e.length ? -1 : gn(t, e, n, r, i); if ("number" == typeof e) return e &= 255, nn.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? i ? Uint8Array.prototype.indexOf.call(t, e, n) : Uint8Array.prototype.lastIndexOf.call(t, e, n) : gn(t, [e], n, r, i); throw new TypeError("val must be string, number or Buffer") } function gn(t, e, n, r, i) { var o, a = 1, s = t.length, u = e.length; if (void 0 !== r && ("ucs2" === (r = String(r).toLowerCase()) || "ucs-2" === r || "utf16le" === r || "utf-16le" === r)) { if (t.length < 2 || e.length < 2) return -1; a = 2, s /= 2, u /= 2, n /= 2 } function l(t, e) { return 1 === a ? t[e] : t.readUInt16BE(e * a) } if (i) { var c = -1; for (o = n; o < s; o++)if (l(t, o) === l(e, -1 === c ? 0 : o - c)) { if (-1 === c && (c = o), o - c + 1 === u) return c * a } else -1 !== c && (o -= o - c), c = -1 } else for (n + u > s && (n = s - u), o = n; o >= 0; o--) { for (var h = !0, f = 0; f < u; f++)if (l(t, o + f) !== l(e, f)) { h = !1; break } if (h) return o } return -1 } function yn(t, e, n, r) { n = Number(n) || 0; var i = t.length - n; r ? (r = Number(r)) > i && (r = i) : r = i; var o = e.length; if (o % 2 != 0) throw new TypeError("Invalid hex string"); r > o / 2 && (r = o / 2); for (var a = 0; a < r; ++a) { var s = parseInt(e.substr(2 * a, 2), 16); if (isNaN(s)) return a; t[n + a] = s } return a } function vn(t, e, n, r) { return Bn(jn(e, t.length - n), t, n, r) } function dn(t, e, n, r) { return Bn(function (t) { for (var e = [], n = 0; n < t.length; ++n)e.push(255 & t.charCodeAt(n)); return e }(e), t, n, r) } function mn(t, e, n, r) { return dn(t, e, n, r) } function _n(t, e, n, r) { return Bn(Fn(e), t, n, r) } function bn(t, e, n, r) { return Bn(function (t, e) { for (var n, r, i, o = [], a = 0; a < t.length && !((e -= 2) < 0); ++a)r = (n = t.charCodeAt(a)) >> 8, i = n % 256, o.push(i), o.push(r); return o }(e, t.length - n), t, n, r) } function xn(t, e, n) { return 0 === e && n === t.length ? Ze(t) : Ze(t.slice(e, n)) } function En(t, e, n) { n = Math.min(t.length, n); for (var r = [], i = e; i < n;) { var o, a, s, u, l = t[i], c = null, h = l > 239 ? 4 : l > 223 ? 3 : l > 191 ? 2 : 1; if (i + h <= n) switch (h) { case 1: l < 128 && (c = l); break; case 2: 128 == (192 & (o = t[i + 1])) && (u = (31 & l) << 6 | 63 & o) > 127 && (c = u); break; case 3: o = t[i + 1], a = t[i + 2], 128 == (192 & o) && 128 == (192 & a) && (u = (15 & l) << 12 | (63 & o) << 6 | 63 & a) > 2047 && (u < 55296 || u > 57343) && (c = u); break; case 4: o = t[i + 1], a = t[i + 2], s = t[i + 3], 128 == (192 & o) && 128 == (192 & a) && 128 == (192 & s) && (u = (15 & l) << 18 | (63 & o) << 12 | (63 & a) << 6 | 63 & s) > 65535 && u < 1114112 && (c = u) }null === c ? (c = 65533, h = 1) : c > 65535 && (c -= 65536, r.push(c >>> 10 & 1023 | 55296), c = 56320 | 1023 & c), r.push(c), i += h } return function (t) { var e = t.length; if (e <= wn) return String.fromCharCode.apply(String, t); var n = "", r = 0; for (; r < e;)n += String.fromCharCode.apply(String, t.slice(r, r += wn)); return n }(r) } nn.TYPED_ARRAY_SUPPORT = void 0 === Ge.TYPED_ARRAY_SUPPORT || Ge.TYPED_ARRAY_SUPPORT, tn(), nn.poolSize = 8192, nn._augment = function (t) { return t.__proto__ = nn.prototype, t }, nn.from = function (t, e, n) { return rn(null, t, e, n) }, nn.TYPED_ARRAY_SUPPORT && (nn.prototype.__proto__ = Uint8Array.prototype, nn.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && nn[Symbol.species]), nn.alloc = function (t, e, n) { return function (t, e, n, r) { return on(e), e <= 0 ? en(t, e) : void 0 !== n ? "string" == typeof r ? en(t, e).fill(n, r) : en(t, e).fill(n) : en(t, e) }(null, t, e, n) }, nn.allocUnsafe = function (t) { return an(null, t) }, nn.allocUnsafeSlow = function (t) { return an(null, t) }, nn.isBuffer = function (t) { return null != t && (!!t._isBuffer || qn(t) || function (t) { return "function" == typeof t.readFloatLE && "function" == typeof t.slice && qn(t.slice(0, 0)) }(t)) }, nn.compare = function (t, e) { if (!ln(t) || !ln(e)) throw new TypeError("Arguments must be Buffers"); if (t === e) return 0; for (var n = t.length, r = e.length, i = 0, o = Math.min(n, r); i < o; ++i)if (t[i] !== e[i]) { n = t[i], r = e[i]; break } return n < r ? -1 : r < n ? 1 : 0 }, nn.isEncoding = function (t) { switch (String(t).toLowerCase()) { case "hex": case "utf8": case "utf-8": case "ascii": case "latin1": case "binary": case "base64": case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return !0; default: return !1 } }, nn.concat = function (t, e) { if (!Ke(t)) throw new TypeError('"list" argument must be an Array of Buffers'); if (0 === t.length) return nn.alloc(0); var n; if (void 0 === e) for (e = 0, n = 0; n < t.length; ++n)e += t[n].length; var r = nn.allocUnsafe(e), i = 0; for (n = 0; n < t.length; ++n) { var o = t[n]; if (!ln(o)) throw new TypeError('"list" argument must be an Array of Buffers'); o.copy(r, i), i += o.length } return r }, nn.byteLength = cn, nn.prototype._isBuffer = !0, nn.prototype.swap16 = function () { var t = this.length; if (t % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits"); for (var e = 0; e < t; e += 2)fn(this, e, e + 1); return this }, nn.prototype.swap32 = function () { var t = this.length; if (t % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits"); for (var e = 0; e < t; e += 4)fn(this, e, e + 3), fn(this, e + 1, e + 2); return this }, nn.prototype.swap64 = function () { var t = this.length; if (t % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits"); for (var e = 0; e < t; e += 8)fn(this, e, e + 7), fn(this, e + 1, e + 6), fn(this, e + 2, e + 5), fn(this, e + 3, e + 4); return this }, nn.prototype.toString = function () { var t = 0 | this.length; return 0 === t ? "" : 0 === arguments.length ? En(this, 0, t) : hn.apply(this, arguments) }, nn.prototype.equals = function (t) { if (!ln(t)) throw new TypeError("Argument must be a Buffer"); return this === t || 0 === nn.compare(this, t) }, nn.prototype.inspect = function () { var t = ""; return this.length > 0 && (t = this.toString("hex", 0, 50).match(/.{2}/g).join(" "), this.length > 50 && (t += " ... ")), "<Buffer " + t + ">" }, nn.prototype.compare = function (t, e, n, r, i) { if (!ln(t)) throw new TypeError("Argument must be a Buffer"); if (void 0 === e && (e = 0), void 0 === n && (n = t ? t.length : 0), void 0 === r && (r = 0), void 0 === i && (i = this.length), e < 0 || n > t.length || r < 0 || i > this.length) throw new RangeError("out of range index"); if (r >= i && e >= n) return 0; if (r >= i) return -1; if (e >= n) return 1; if (this === t) return 0; for (var o = (i >>>= 0) - (r >>>= 0), a = (n >>>= 0) - (e >>>= 0), s = Math.min(o, a), u = this.slice(r, i), l = t.slice(e, n), c = 0; c < s; ++c)if (u[c] !== l[c]) { o = u[c], a = l[c]; break } return o < a ? -1 : a < o ? 1 : 0 }, nn.prototype.includes = function (t, e, n) { return -1 !== this.indexOf(t, e, n) }, nn.prototype.indexOf = function (t, e, n) { return pn(this, t, e, n, !0) }, nn.prototype.lastIndexOf = function (t, e, n) { return pn(this, t, e, n, !1) }, nn.prototype.write = function (t, e, n, r) { if (void 0 === e) r = "utf8", n = this.length, e = 0; else if (void 0 === n && "string" == typeof e) r = e, n = this.length, e = 0; else { if (!isFinite(e)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported"); e |= 0, isFinite(n) ? (n |= 0, void 0 === r && (r = "utf8")) : (r = n, n = void 0) } var i = this.length - e; if ((void 0 === n || n > i) && (n = i), t.length > 0 && (n < 0 || e < 0) || e > this.length) throw new RangeError("Attempt to write outside buffer bounds"); r || (r = "utf8"); for (var o = !1; ;)switch (r) { case "hex": return yn(this, t, e, n); case "utf8": case "utf-8": return vn(this, t, e, n); case "ascii": return dn(this, t, e, n); case "latin1": case "binary": return mn(this, t, e, n); case "base64": return _n(this, t, e, n); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return bn(this, t, e, n); default: if (o) throw new TypeError("Unknown encoding: " + r); r = ("" + r).toLowerCase(), o = !0 } }, nn.prototype.toJSON = function () { return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) } }; var wn = 4096; function kn(t, e, n) { var r = ""; n = Math.min(t.length, n); for (var i = e; i < n; ++i)r += String.fromCharCode(127 & t[i]); return r } function Sn(t, e, n) { var r = ""; n = Math.min(t.length, n); for (var i = e; i < n; ++i)r += String.fromCharCode(t[i]); return r } function In(t, e, n) { var r = t.length; (!e || e < 0) && (e = 0), (!n || n < 0 || n > r) && (n = r); for (var i = "", o = e; o < n; ++o)i += Dn(t[o]); return i } function Pn(t, e, n) { for (var r = t.slice(e, n), i = "", o = 0; o < r.length; o += 2)i += String.fromCharCode(r[o] + 256 * r[o + 1]); return i } function Nn(t, e, n) { if (t % 1 != 0 || t < 0) throw new RangeError("offset is not uint"); if (t + e > n) throw new RangeError("Trying to access beyond buffer length") } function Mn(t, e, n, r, i, o) { if (!ln(t)) throw new TypeError('"buffer" argument must be a Buffer instance'); if (e > i || e < o) throw new RangeError('"value" argument is out of bounds'); if (n + r > t.length) throw new RangeError("Index out of range") } function On(t, e, n, r) { e < 0 && (e = 65535 + e + 1); for (var i = 0, o = Math.min(t.length - n, 2); i < o; ++i)t[n + i] = (e & 255 << 8 * (r ? i : 1 - i)) >>> 8 * (r ? i : 1 - i) } function Ln(t, e, n, r) { e < 0 && (e = 4294967295 + e + 1); for (var i = 0, o = Math.min(t.length - n, 4); i < o; ++i)t[n + i] = e >>> 8 * (r ? i : 3 - i) & 255 } function Rn(t, e, n, r, i, o) { if (n + r > t.length) throw new RangeError("Index out of range"); if (n < 0) throw new RangeError("Index out of range") } function Cn(t, e, n, r, i) { return i || Rn(t, 0, n, 4), $e(t, e, n, r, 23, 4), n + 4 } function Tn(t, e, n, r, i) { return i || Rn(t, 0, n, 8), $e(t, e, n, r, 52, 8), n + 8 } nn.prototype.slice = function (t, e) { var n, r = this.length; if ((t = ~~t) < 0 ? (t += r) < 0 && (t = 0) : t > r && (t = r), (e = void 0 === e ? r : ~~e) < 0 ? (e += r) < 0 && (e = 0) : e > r && (e = r), e < t && (e = t), nn.TYPED_ARRAY_SUPPORT) (n = this.subarray(t, e)).__proto__ = nn.prototype; else { var i = e - t; n = new nn(i, void 0); for (var o = 0; o < i; ++o)n[o] = this[o + t] } return n }, nn.prototype.readUIntLE = function (t, e, n) { t |= 0, e |= 0, n || Nn(t, e, this.length); for (var r = this[t], i = 1, o = 0; ++o < e && (i *= 256);)r += this[t + o] * i; return r }, nn.prototype.readUIntBE = function (t, e, n) { t |= 0, e |= 0, n || Nn(t, e, this.length); for (var r = this[t + --e], i = 1; e > 0 && (i *= 256);)r += this[t + --e] * i; return r }, nn.prototype.readUInt8 = function (t, e) { return e || Nn(t, 1, this.length), this[t] }, nn.prototype.readUInt16LE = function (t, e) { return e || Nn(t, 2, this.length), this[t] | this[t + 1] << 8 }, nn.prototype.readUInt16BE = function (t, e) { return e || Nn(t, 2, this.length), this[t] << 8 | this[t + 1] }, nn.prototype.readUInt32LE = function (t, e) { return e || Nn(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3] }, nn.prototype.readUInt32BE = function (t, e) { return e || Nn(t, 4, this.length), 16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]) }, nn.prototype.readIntLE = function (t, e, n) { t |= 0, e |= 0, n || Nn(t, e, this.length); for (var r = this[t], i = 1, o = 0; ++o < e && (i *= 256);)r += this[t + o] * i; return r >= (i *= 128) && (r -= Math.pow(2, 8 * e)), r }, nn.prototype.readIntBE = function (t, e, n) { t |= 0, e |= 0, n || Nn(t, e, this.length); for (var r = e, i = 1, o = this[t + --r]; r > 0 && (i *= 256);)o += this[t + --r] * i; return o >= (i *= 128) && (o -= Math.pow(2, 8 * e)), o }, nn.prototype.readInt8 = function (t, e) { return e || Nn(t, 1, this.length), 128 & this[t] ? -1 * (255 - this[t] + 1) : this[t] }, nn.prototype.readInt16LE = function (t, e) { e || Nn(t, 2, this.length); var n = this[t] | this[t + 1] << 8; return 32768 & n ? 4294901760 | n : n }, nn.prototype.readInt16BE = function (t, e) { e || Nn(t, 2, this.length); var n = this[t + 1] | this[t] << 8; return 32768 & n ? 4294901760 | n : n }, nn.prototype.readInt32LE = function (t, e) { return e || Nn(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24 }, nn.prototype.readInt32BE = function (t, e) { return e || Nn(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3] }, nn.prototype.readFloatLE = function (t, e) { return e || Nn(t, 4, this.length), Je(this, t, !0, 23, 4) }, nn.prototype.readFloatBE = function (t, e) { return e || Nn(t, 4, this.length), Je(this, t, !1, 23, 4) }, nn.prototype.readDoubleLE = function (t, e) { return e || Nn(t, 8, this.length), Je(this, t, !0, 52, 8) }, nn.prototype.readDoubleBE = function (t, e) { return e || Nn(t, 8, this.length), Je(this, t, !1, 52, 8) }, nn.prototype.writeUIntLE = function (t, e, n, r) { (t = +t, e |= 0, n |= 0, r) || Mn(this, t, e, n, Math.pow(2, 8 * n) - 1, 0); var i = 1, o = 0; for (this[e] = 255 & t; ++o < n && (i *= 256);)this[e + o] = t / i & 255; return e + n }, nn.prototype.writeUIntBE = function (t, e, n, r) { (t = +t, e |= 0, n |= 0, r) || Mn(this, t, e, n, Math.pow(2, 8 * n) - 1, 0); var i = n - 1, o = 1; for (this[e + i] = 255 & t; --i >= 0 && (o *= 256);)this[e + i] = t / o & 255; return e + n }, nn.prototype.writeUInt8 = function (t, e, n) { return t = +t, e |= 0, n || Mn(this, t, e, 1, 255, 0), nn.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), this[e] = 255 & t, e + 1 }, nn.prototype.writeUInt16LE = function (t, e, n) { return t = +t, e |= 0, n || Mn(this, t, e, 2, 65535, 0), nn.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8) : On(this, t, e, !0), e + 2 }, nn.prototype.writeUInt16BE = function (t, e, n) { return t = +t, e |= 0, n || Mn(this, t, e, 2, 65535, 0), nn.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 8, this[e + 1] = 255 & t) : On(this, t, e, !1), e + 2 }, nn.prototype.writeUInt32LE = function (t, e, n) { return t = +t, e |= 0, n || Mn(this, t, e, 4, 4294967295, 0), nn.TYPED_ARRAY_SUPPORT ? (this[e + 3] = t >>> 24, this[e + 2] = t >>> 16, this[e + 1] = t >>> 8, this[e] = 255 & t) : Ln(this, t, e, !0), e + 4 }, nn.prototype.writeUInt32BE = function (t, e, n) { return t = +t, e |= 0, n || Mn(this, t, e, 4, 4294967295, 0), nn.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t) : Ln(this, t, e, !1), e + 4 }, nn.prototype.writeIntLE = function (t, e, n, r) { if (t = +t, e |= 0, !r) { var i = Math.pow(2, 8 * n - 1); Mn(this, t, e, n, i - 1, -i) } var o = 0, a = 1, s = 0; for (this[e] = 255 & t; ++o < n && (a *= 256);)t < 0 && 0 === s && 0 !== this[e + o - 1] && (s = 1), this[e + o] = (t / a >> 0) - s & 255; return e + n }, nn.prototype.writeIntBE = function (t, e, n, r) { if (t = +t, e |= 0, !r) { var i = Math.pow(2, 8 * n - 1); Mn(this, t, e, n, i - 1, -i) } var o = n - 1, a = 1, s = 0; for (this[e + o] = 255 & t; --o >= 0 && (a *= 256);)t < 0 && 0 === s && 0 !== this[e + o + 1] && (s = 1), this[e + o] = (t / a >> 0) - s & 255; return e + n }, nn.prototype.writeInt8 = function (t, e, n) { return t = +t, e |= 0, n || Mn(this, t, e, 1, 127, -128), nn.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), t < 0 && (t = 255 + t + 1), this[e] = 255 & t, e + 1 }, nn.prototype.writeInt16LE = function (t, e, n) { return t = +t, e |= 0, n || Mn(this, t, e, 2, 32767, -32768), nn.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8) : On(this, t, e, !0), e + 2 }, nn.prototype.writeInt16BE = function (t, e, n) { return t = +t, e |= 0, n || Mn(this, t, e, 2, 32767, -32768), nn.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 8, this[e + 1] = 255 & t) : On(this, t, e, !1), e + 2 }, nn.prototype.writeInt32LE = function (t, e, n) { return t = +t, e |= 0, n || Mn(this, t, e, 4, 2147483647, -2147483648), nn.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8, this[e + 2] = t >>> 16, this[e + 3] = t >>> 24) : Ln(this, t, e, !0), e + 4 }, nn.prototype.writeInt32BE = function (t, e, n) { return t = +t, e |= 0, n || Mn(this, t, e, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), nn.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t) : Ln(this, t, e, !1), e + 4 }, nn.prototype.writeFloatLE = function (t, e, n) { return Cn(this, t, e, !0, n) }, nn.prototype.writeFloatBE = function (t, e, n) { return Cn(this, t, e, !1, n) }, nn.prototype.writeDoubleLE = function (t, e, n) { return Tn(this, t, e, !0, n) }, nn.prototype.writeDoubleBE = function (t, e, n) { return Tn(this, t, e, !1, n) }, nn.prototype.copy = function (t, e, n, r) { if (n || (n = 0), r || 0 === r || (r = this.length), e >= t.length && (e = t.length), e || (e = 0), r > 0 && r < n && (r = n), r === n) return 0; if (0 === t.length || 0 === this.length) return 0; if (e < 0) throw new RangeError("targetStart out of bounds"); if (n < 0 || n >= this.length) throw new RangeError("sourceStart out of bounds"); if (r < 0) throw new RangeError("sourceEnd out of bounds"); r > this.length && (r = this.length), t.length - e < r - n && (r = t.length - e + n); var i, o = r - n; if (this === t && n < e && e < r) for (i = o - 1; i >= 0; --i)t[i + e] = this[i + n]; else if (o < 1e3 || !nn.TYPED_ARRAY_SUPPORT) for (i = 0; i < o; ++i)t[i + e] = this[i + n]; else Uint8Array.prototype.set.call(t, this.subarray(n, n + o), e); return o }, nn.prototype.fill = function (t, e, n, r) { if ("string" == typeof t) { if ("string" == typeof e ? (r = e, e = 0, n = this.length) : "string" == typeof n && (r = n, n = this.length), 1 === t.length) { var i = t.charCodeAt(0); i < 256 && (t = i) } if (void 0 !== r && "string" != typeof r) throw new TypeError("encoding must be a string"); if ("string" == typeof r && !nn.isEncoding(r)) throw new TypeError("Unknown encoding: " + r) } else "number" == typeof t && (t &= 255); if (e < 0 || this.length < e || this.length < n) throw new RangeError("Out of range index"); if (n <= e) return this; var o; if (e >>>= 0, n = void 0 === n ? this.length : n >>> 0, t || (t = 0), "number" == typeof t) for (o = e; o < n; ++o)this[o] = t; else { var a = ln(t) ? t : jn(new nn(t, r).toString()), s = a.length; for (o = 0; o < n - e; ++o)this[o + e] = a[o % s] } return this }; var An = /[^+\/0-9A-Za-z-_]/g; function Dn(t) { return t < 16 ? "0" + t.toString(16) : t.toString(16) } function jn(t, e) { var n; e = e || 1 / 0; for (var r = t.length, i = null, o = [], a = 0; a < r; ++a) { if ((n = t.charCodeAt(a)) > 55295 && n < 57344) { if (!i) { if (n > 56319) { (e -= 3) > -1 && o.push(239, 191, 189); continue } if (a + 1 === r) { (e -= 3) > -1 && o.push(239, 191, 189); continue } i = n; continue } if (n < 56320) { (e -= 3) > -1 && o.push(239, 191, 189), i = n; continue } n = 65536 + (i - 55296 << 10 | n - 56320) } else i && (e -= 3) > -1 && o.push(239, 191, 189); if (i = null, n < 128) { if ((e -= 1) < 0) break; o.push(n) } else if (n < 2048) { if ((e -= 2) < 0) break; o.push(n >> 6 | 192, 63 & n | 128) } else if (n < 65536) { if ((e -= 3) < 0) break; o.push(n >> 12 | 224, n >> 6 & 63 | 128, 63 & n | 128) } else { if (!(n < 1114112)) throw new Error("Invalid code point"); if ((e -= 4) < 0) break; o.push(n >> 18 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, 63 & n | 128) } } return o } function Fn(t) { return function (t) { var e, n, r, i, o, a; Xe || We(); var s = t.length; if (s % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4"); o = "=" === t[s - 2] ? 2 : "=" === t[s - 1] ? 1 : 0, a = new Ue(3 * s / 4 - o), r = o > 0 ? s - 4 : s; var u = 0; for (e = 0, n = 0; e < r; e += 4, n += 3)i = ze[t.charCodeAt(e)] << 18 | ze[t.charCodeAt(e + 1)] << 12 | ze[t.charCodeAt(e + 2)] << 6 | ze[t.charCodeAt(e + 3)], a[u++] = i >> 16 & 255, a[u++] = i >> 8 & 255, a[u++] = 255 & i; return 2 === o ? (i = ze[t.charCodeAt(e)] << 2 | ze[t.charCodeAt(e + 1)] >> 4, a[u++] = 255 & i) : 1 === o && (i = ze[t.charCodeAt(e)] << 10 | ze[t.charCodeAt(e + 1)] << 4 | ze[t.charCodeAt(e + 2)] >> 2, a[u++] = i >> 8 & 255, a[u++] = 255 & i), a }(function (t) { if ((t = function (t) { return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "") }(t).replace(An, "")).length < 2) return ""; for (; t.length % 4 != 0;)t += "="; return t }(t)) } function Bn(t, e, n, r) { for (var i = 0; i < r && !(i + n >= e.length || i >= t.length); ++i)e[i + n] = t[i]; return i } function qn(t) { return !!t.constructor && "function" == typeof t.constructor.isBuffer && t.constructor.isBuffer(t) } function Vn() { throw new Error("setTimeout has not been defined") } function Gn() { throw new Error("clearTimeout has not been defined") } var Yn = Vn, zn = Gn; function Un(t) { if (Yn === setTimeout) return setTimeout(t, 0); if ((Yn === Vn || !Yn) && setTimeout) return Yn = setTimeout, setTimeout(t, 0); try { return Yn(t, 0) } catch (e) { try { return Yn.call(null, t, 0) } catch (e) { return Yn.call(this, t, 0) } } } "function" == typeof Ge.setTimeout && (Yn = setTimeout), "function" == typeof Ge.clearTimeout && (zn = clearTimeout); var Xn, Wn = [], Hn = !1, Zn = -1; function Jn() { Hn && Xn && (Hn = !1, Xn.length ? Wn = Xn.concat(Wn) : Zn = -1, Wn.length && $n()) } function $n() { if (!Hn) { var t = Un(Jn); Hn = !0; for (var e = Wn.length; e;) { for (Xn = Wn, Wn = []; ++Zn < e;)Xn && Xn[Zn].run(); Zn = -1, e = Wn.length } Xn = null, Hn = !1, function (t) { if (zn === clearTimeout) return clearTimeout(t); if ((zn === Gn || !zn) && clearTimeout) return zn = clearTimeout, clearTimeout(t); try { return zn(t) } catch (e) { try { return zn.call(null, t) } catch (e) { return zn.call(this, t) } } }(t) } } function Qn(t, e) { this.fun = t, this.array = e } Qn.prototype.run = function () { this.fun.apply(null, this.array) }; function Kn() { } var tr = Kn, er = Kn, nr = Kn, rr = Kn, ir = Kn, or = Kn, ar = Kn; var sr = Ge.performance || {}, ur = sr.now || sr.mozNow || sr.msNow || sr.oNow || sr.webkitNow || function () { return (new Date).getTime() }; var lr = new Date; var cr = { nextTick: function (t) { var e = new Array(arguments.length - 1); if (arguments.length > 1) for (var n = 1; n < arguments.length; n++)e[n - 1] = arguments[n]; Wn.push(new Qn(t, e)), 1 !== Wn.length || Hn || Un($n) }, title: "browser", browser: !0, env: {}, argv: [], version: "", versions: {}, on: tr, addListener: er, once: nr, off: rr, removeListener: ir, removeAllListeners: or, emit: ar, binding: function (t) { throw new Error("process.binding is not supported") }, cwd: function () { return "/" }, chdir: function (t) { throw new Error("process.chdir is not supported") }, umask: function () { return 0 }, hrtime: function (t) { var e = .001 * ur.call(sr), n = Math.floor(e), r = Math.floor(e % 1 * 1e9); return t && (n -= t[0], (r -= t[1]) < 0 && (n--, r += 1e9)), [n, r] }, platform: "browser", release: {}, config: {}, uptime: function () { return (new Date - lr) / 1e3 } }, hr = "function" == typeof Object.create ? function (t, e) { t.super_ = e, t.prototype = Object.create(e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }) } : function (t, e) { t.super_ = e; var n = function () { }; n.prototype = e.prototype, t.prototype = new n, t.prototype.constructor = t }, fr = Object.getOwnPropertyDescriptors || function (t) { for (var e = Object.keys(t), n = {}, r = 0; r < e.length; r++)n[e[r]] = Object.getOwnPropertyDescriptor(t, e[r]); return n }, pr = /%[sdj%]/g; function gr(t) { if (!Or(t)) { for (var e = [], n = 0; n < arguments.length; n++)e.push(_r(arguments[n])); return e.join(" ") } n = 1; for (var r = arguments, i = r.length, o = String(t).replace(pr, (function (t) { if ("%%" === t) return "%"; if (n >= i) return t; switch (t) { case "%s": return String(r[n++]); case "%d": return Number(r[n++]); case "%j": try { return JSON.stringify(r[n++]) } catch (t) { return "[Circular]" } default: return t } })), a = r[n]; n < i; a = r[++n])Pr(a) || !Tr(a) ? o += " " + a : o += " " + _r(a); return o } function yr(t, e) { if (Rr(Ge.process)) return function () { return yr(t, e).apply(this, arguments) }; if (!0 === cr.noDeprecation) return t; var n = !1; return function () { if (!n) { if (cr.throwDeprecation) throw new Error(e); cr.traceDeprecation ? console.trace(e) : console.error(e), n = !0 } return t.apply(this, arguments) } } var vr, dr = {}; function mr(t) { if (Rr(vr) && (vr = cr.env.NODE_DEBUG || ""), t = t.toUpperCase(), !dr[t]) if (new RegExp("\\b" + t + "\\b", "i").test(vr)) { dr[t] = function () { var e = gr.apply(null, arguments); console.error("%s %d: %s", t, 0, e) } } else dr[t] = function () { }; return dr[t] } function _r(t, e) { var n = { seen: [], stylize: xr }; return arguments.length >= 3 && (n.depth = arguments[2]), arguments.length >= 4 && (n.colors = arguments[3]), Ir(e) ? n.showHidden = e : e && zr(n, e), Rr(n.showHidden) && (n.showHidden = !1), Rr(n.depth) && (n.depth = 2), Rr(n.colors) && (n.colors = !1), Rr(n.customInspect) && (n.customInspect = !0), n.colors && (n.stylize = br), Er(n, t, n.depth) } function br(t, e) { var n = _r.styles[e]; return n ? "[" + _r.colors[n][0] + "m" + t + "[" + _r.colors[n][1] + "m" : t } function xr(t, e) { return t } function Er(t, e, n) { if (t.customInspect && e && jr(e.inspect) && e.inspect !== _r && (!e.constructor || e.constructor.prototype !== e)) { var r = e.inspect(n, t); return Or(r) || (r = Er(t, r, n)), r } var i = function (t, e) { if (Rr(e)) return t.stylize("undefined", "undefined"); if (Or(e)) { var n = "'" + JSON.stringify(e).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'"; return t.stylize(n, "string") } if (Mr(e)) return t.stylize("" + e, "number"); if (Ir(e)) return t.stylize("" + e, "boolean"); if (Pr(e)) return t.stylize("null", "null") }(t, e); if (i) return i; var o = Object.keys(e), a = function (t) { var e = {}; return t.forEach((function (t, n) { e[t] = !0 })), e }(o); if (t.showHidden && (o = Object.getOwnPropertyNames(e)), Dr(e) && (o.indexOf("message") >= 0 || o.indexOf("description") >= 0)) return wr(e); if (0 === o.length) { if (jr(e)) { var s = e.name ? ": " + e.name : ""; return t.stylize("[Function" + s + "]", "special") } if (Cr(e)) return t.stylize(RegExp.prototype.toString.call(e), "regexp"); if (Ar(e)) return t.stylize(Date.prototype.toString.call(e), "date"); if (Dr(e)) return wr(e) } var u, l = "", c = !1, h = ["{", "}"]; (Sr(e) && (c = !0, h = ["[", "]"]), jr(e)) && (l = " [Function" + (e.name ? ": " + e.name : "") + "]"); return Cr(e) && (l = " " + RegExp.prototype.toString.call(e)), Ar(e) && (l = " " + Date.prototype.toUTCString.call(e)), Dr(e) && (l = " " + wr(e)), 0 !== o.length || c && 0 != e.length ? n < 0 ? Cr(e) ? t.stylize(RegExp.prototype.toString.call(e), "regexp") : t.stylize("[Object]", "special") : (t.seen.push(e), u = c ? function (t, e, n, r, i) { for (var o = [], a = 0, s = e.length; a < s; ++a)Ur(e, String(a)) ? o.push(kr(t, e, n, r, String(a), !0)) : o.push(""); return i.forEach((function (i) { i.match(/^\d+$/) || o.push(kr(t, e, n, r, i, !0)) })), o }(t, e, n, a, o) : o.map((function (r) { return kr(t, e, n, a, r, c) })), t.seen.pop(), function (t, e, n) { var r = t.reduce((function (t, e) { return e.indexOf("\n"), t + e.replace(/\u001b\[\d\d?m/g, "").length + 1 }), 0); if (r > 60) return n[0] + ("" === e ? "" : e + "\n ") + " " + t.join(",\n  ") + " " + n[1]; return n[0] + e + " " + t.join(", ") + " " + n[1] }(u, l, h)) : h[0] + l + h[1] } function wr(t) { return "[" + Error.prototype.toString.call(t) + "]" } function kr(t, e, n, r, i, o) { var a, s, u; if ((u = Object.getOwnPropertyDescriptor(e, i) || { value: e[i] }).get ? s = u.set ? t.stylize("[Getter/Setter]", "special") : t.stylize("[Getter]", "special") : u.set && (s = t.stylize("[Setter]", "special")), Ur(r, i) || (a = "[" + i + "]"), s || (t.seen.indexOf(u.value) < 0 ? (s = Pr(n) ? Er(t, u.value, null) : Er(t, u.value, n - 1)).indexOf("\n") > -1 && (s = o ? s.split("\n").map((function (t) { return "  " + t })).join("\n").substr(2) : "\n" + s.split("\n").map((function (t) { return "   " + t })).join("\n")) : s = t.stylize("[Circular]", "special")), Rr(a)) { if (o && i.match(/^\d+$/)) return s; (a = JSON.stringify("" + i)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (a = a.substr(1, a.length - 2), a = t.stylize(a, "name")) : (a = a.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), a = t.stylize(a, "string")) } return a + ": " + s } function Sr(t) { return Array.isArray(t) } function Ir(t) { return "boolean" == typeof t } function Pr(t) { return null === t } function Nr(t) { return null == t } function Mr(t) { return "number" == typeof t } function Or(t) { return "string" == typeof t } function Lr(t) { return "symbol" == typeof t } function Rr(t) { return void 0 === t } function Cr(t) { return Tr(t) && "[object RegExp]" === qr(t) } function Tr(t) { return "object" == typeof t && null !== t } function Ar(t) { return Tr(t) && "[object Date]" === qr(t) } function Dr(t) { return Tr(t) && ("[object Error]" === qr(t) || t instanceof Error) } function jr(t) { return "function" == typeof t } function Fr(t) { return null === t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t || "symbol" == typeof t || void 0 === t } function Br(t) { return nn.isBuffer(t) } function qr(t) { return Object.prototype.toString.call(t) } function Vr(t) { return t < 10 ? "0" + t.toString(10) : t.toString(10) } _r.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, _r.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }; var Gr = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]; function Yr() { var t, e; console.log("%s - %s", (t = new Date, e = [Vr(t.getHours()), Vr(t.getMinutes()), Vr(t.getSeconds())].join(":"), [t.getDate(), Gr[t.getMonth()], e].join(" ")), gr.apply(null, arguments)) } function zr(t, e) { if (!e || !Tr(e)) return t; for (var n = Object.keys(e), r = n.length; r--;)t[n[r]] = e[n[r]]; return t } function Ur(t, e) { return Object.prototype.hasOwnProperty.call(t, e) } var Xr = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0; function Wr(t) { if ("function" != typeof t) throw new TypeError('The "original" argument must be of type Function'); if (Xr && t[Xr]) { var e; if ("function" != typeof (e = t[Xr])) throw new TypeError('The "util.promisify.custom" argument must be of type Function'); return Object.defineProperty(e, Xr, { value: e, enumerable: !1, writable: !1, configurable: !0 }), e } function e() { for (var e, n, r = new Promise((function (t, r) { e = t, n = r })), i = [], o = 0; o < arguments.length; o++)i.push(arguments[o]); i.push((function (t, r) { t ? n(t) : e(r) })); try { t.apply(this, i) } catch (t) { n(t) } return r } return Object.setPrototypeOf(e, Object.getPrototypeOf(t)), Xr && Object.defineProperty(e, Xr, { value: e, enumerable: !1, writable: !1, configurable: !0 }), Object.defineProperties(e, fr(t)) } function Hr(t, e) { if (!t) { var n = new Error("Promise was rejected with a falsy value"); n.reason = t, t = n } return e(t) } function Zr(t) { if ("function" != typeof t) throw new TypeError('The "original" argument must be of type Function'); function e() { for (var e = [], n = 0; n < arguments.length; n++)e.push(arguments[n]); var r = e.pop(); if ("function" != typeof r) throw new TypeError("The last argument must be of type Function"); var i = this, o = function () { return r.apply(i, arguments) }; t.apply(this, e).then((function (t) { cr.nextTick(o.bind(null, null, t)) }), (function (t) { cr.nextTick(Hr.bind(null, t, o)) })) } return Object.setPrototypeOf(e, Object.getPrototypeOf(t)), Object.defineProperties(e, fr(t)), e } Wr.custom = Xr; var Jr = { inherits: hr, _extend: zr, log: Yr, isBuffer: Br, isPrimitive: Fr, isFunction: jr, isError: Dr, isDate: Ar, isObject: Tr, isRegExp: Cr, isUndefined: Rr, isSymbol: Lr, isString: Or, isNumber: Mr, isNullOrUndefined: Nr, isNull: Pr, isBoolean: Ir, isArray: Sr, inspect: _r, deprecate: yr, format: gr, debuglog: mr, promisify: Wr, callbackify: Zr }, $r = g(Object.freeze({ __proto__: null, format: gr, deprecate: yr, debuglog: mr, inspect: _r, isArray: Sr, isBoolean: Ir, isNull: Pr, isNullOrUndefined: Nr, isNumber: Mr, isString: Or, isSymbol: Lr, isUndefined: Rr, isRegExp: Cr, isObject: Tr, isDate: Ar, isError: Dr, isFunction: jr, isPrimitive: Fr, isBuffer: Br, log: Yr, inherits: hr, _extend: zr, promisify: Wr, callbackify: Zr, default: Jr })).inspect, Qr = "function" == typeof Map && Map.prototype, Kr = Object.getOwnPropertyDescriptor && Qr ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, ti = Qr && Kr && "function" == typeof Kr.get ? Kr.get : null, ei = Qr && Map.prototype.forEach, ni = "function" == typeof Set && Set.prototype, ri = Object.getOwnPropertyDescriptor && ni ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, ii = ni && ri && "function" == typeof ri.get ? ri.get : null, oi = ni && Set.prototype.forEach, ai = "function" == typeof WeakMap && WeakMap.prototype ? WeakMap.prototype.has : null, si = "function" == typeof WeakSet && WeakSet.prototype ? WeakSet.prototype.has : null, ui = "function" == typeof WeakRef && WeakRef.prototype ? WeakRef.prototype.deref : null, li = Boolean.prototype.valueOf, ci = Object.prototype.toString, hi = Function.prototype.toString, fi = String.prototype.match, pi = String.prototype.slice, gi = String.prototype.replace, yi = String.prototype.toUpperCase, vi = String.prototype.toLowerCase, di = RegExp.prototype.test, mi = Array.prototype.concat, _i = Array.prototype.join, bi = Array.prototype.slice, xi = Math.floor, Ei = "function" == typeof BigInt ? BigInt.prototype.valueOf : null, wi = Object.getOwnPropertySymbols, ki = "function" == typeof Symbol && "symbol" === e(Symbol.iterator) ? Symbol.prototype.toString : null, Si = "function" == typeof Symbol && "object" === e(Symbol.iterator), Ii = "function" == typeof Symbol && Symbol.toStringTag && (e(Symbol.toStringTag) === Si || "symbol") ? Symbol.toStringTag : null, Pi = Object.prototype.propertyIsEnumerable, Ni = ("function" == typeof Reflect ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function (t) { return t.__proto__ } : null); function Mi(t, e) { if (t === 1 / 0 || t === -1 / 0 || t != t || t && t > -1e3 && t < 1e3 || di.call(/e/, e)) return e; var n = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g; if ("number" == typeof t) { var r = t < 0 ? -xi(-t) : xi(t); if (r !== t) { var i = String(r), o = pi.call(e, i.length + 1); return gi.call(i, n, "$&_") + "." + gi.call(gi.call(o, /([0-9]{3})/g, "$&_"), /_$/, "") } } return gi.call(e, n, "$&_") } var Oi = $r, Li = Oi.custom, Ri = ji(Li) ? Li : null; function Ci(t, e, n) { var r = "double" === (n.quoteStyle || e) ? '"' : "'"; return r + t + r } function Ti(t) { return gi.call(String(t), /"/g, "&quot;") } function Ai(t) { return !("[object Array]" !== qi(t) || Ii && "object" === e(t) && Ii in t) } function Di(t) { return !("[object RegExp]" !== qi(t) || Ii && "object" === e(t) && Ii in t) } function ji(t) { if (Si) return t && "object" === e(t) && t instanceof Symbol; if ("symbol" === e(t)) return !0; if (!t || "object" !== e(t) || !ki) return !1; try { return ki.call(t), !0 } catch (t) { } return !1 } var Fi = Object.prototype.hasOwnProperty || function (t) { return t in this }; function Bi(t, e) { return Fi.call(t, e) } function qi(t) { return ci.call(t) } function Vi(t, e) { if (t.indexOf) return t.indexOf(e); for (var n = 0, r = t.length; n < r; n++)if (t[n] === e) return n; return -1 } function Gi(t, e) { if (t.length > e.maxStringLength) { var n = t.length - e.maxStringLength, r = "... " + n + " more character" + (n > 1 ? "s" : ""); return Gi(pi.call(t, 0, e.maxStringLength), e) + r } return Ci(gi.call(gi.call(t, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, Yi), "single", e) } function Yi(t) { var e = t.charCodeAt(0), n = { 8: "b", 9: "t", 10: "n", 12: "f", 13: "r" }[e]; return n ? "\\" + n : "\\x" + (e < 16 ? "0" : "") + yi.call(e.toString(16)) } function zi(t) { return "Object(" + t + ")" } function Ui(t) { return t + " { ? }" } function Xi(t, e, n, r) { return t + " (" + e + ") {" + (r ? Wi(n, r) : _i.call(n, ", ")) + "}" } function Wi(t, e) { if (0 === t.length) return ""; var n = "\n" + e.prev + e.base; return n + _i.call(t, "," + n) + "\n" + e.prev } function Hi(t, e) { var n = Ai(t), r = []; if (n) { r.length = t.length; for (var i = 0; i < t.length; i++)r[i] = Bi(t, i) ? e(t[i], t) : "" } var o, a = "function" == typeof wi ? wi(t) : []; if (Si) { o = {}; for (var s = 0; s < a.length; s++)o["$" + a[s]] = a[s] } for (var u in t) Bi(t, u) && (n && String(Number(u)) === u && u < t.length || Si && o["$" + u] instanceof Symbol || (di.call(/[^\w$]/, u) ? r.push(e(u, t) + ": " + e(t[u], t)) : r.push(u + ": " + e(t[u], t)))); if ("function" == typeof wi) for (var l = 0; l < a.length; l++)Pi.call(t, a[l]) && r.push("[" + e(a[l]) + "]: " + e(t[a[l]], t)); return r } var Zi = ft, Ji = Xt, $i = function t(n, r, i, o) { var a = r || {}; if (Bi(a, "quoteStyle") && "single" !== a.quoteStyle && "double" !== a.quoteStyle) throw new TypeError('option "quoteStyle" must be "single" or "double"'); if (Bi(a, "maxStringLength") && ("number" == typeof a.maxStringLength ? a.maxStringLength < 0 && a.maxStringLength !== 1 / 0 : null !== a.maxStringLength)) throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`'); var s = !Bi(a, "customInspect") || a.customInspect; if ("boolean" != typeof s && "symbol" !== s) throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`"); if (Bi(a, "indent") && null !== a.indent && "\t" !== a.indent && !(parseInt(a.indent, 10) === a.indent && a.indent > 0)) throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`'); if (Bi(a, "numericSeparator") && "boolean" != typeof a.numericSeparator) throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`'); var u = a.numericSeparator; if (void 0 === n) return "undefined"; if (null === n) return "null"; if ("boolean" == typeof n) return n ? "true" : "false"; if ("string" == typeof n) return Gi(n, a); if ("number" == typeof n) { if (0 === n) return 1 / 0 / n > 0 ? "0" : "-0"; var l = String(n); return u ? Mi(n, l) : l } if ("bigint" == typeof n) { var c = String(n) + "n"; return u ? Mi(n, c) : c } var h = void 0 === a.depth ? 5 : a.depth; if (void 0 === i && (i = 0), i >= h && h > 0 && "object" === e(n)) return Ai(n) ? "[Array]" : "[Object]"; var p = function (t, e) { var n; if ("\t" === t.indent) n = "\t"; else { if (!("number" == typeof t.indent && t.indent > 0)) return null; n = _i.call(Array(t.indent + 1), " ") } return { base: n, prev: _i.call(Array(e + 1), n) } }(a, i); if (void 0 === o) o = []; else if (Vi(o, n) >= 0) return "[Circular]"; function g(e, n, r) { if (n && (o = bi.call(o)).push(n), r) { var s = { depth: a.depth }; return Bi(a, "quoteStyle") && (s.quoteStyle = a.quoteStyle), t(e, s, i + 1, o) } return t(e, a, i + 1, o) } if ("function" == typeof n && !Di(n)) { var y = function (t) { if (t.name) return t.name; var e = fi.call(hi.call(t), /^function\s*([\w$]+)/); if (e) return e[1]; return null }(n), v = Hi(n, g); return "[Function" + (y ? ": " + y : " (anonymous)") + "]" + (v.length > 0 ? " { " + _i.call(v, ", ") + " }" : "") } if (ji(n)) { var d = Si ? gi.call(String(n), /^(Symbol\(.*\))_[^)]*$/, "$1") : ki.call(n); return "object" !== e(n) || Si ? d : zi(d) } if (function (t) { if (!t || "object" !== e(t)) return !1; if ("undefined" != typeof HTMLElement && t instanceof HTMLElement) return !0; return "string" == typeof t.nodeName && "function" == typeof t.getAttribute }(n)) { for (var m = "<" + vi.call(String(n.nodeName)), _ = n.attributes || [], b = 0; b < _.length; b++)m += " " + _[b].name + "=" + Ci(Ti(_[b].value), "double", a); return m += ">", n.childNodes && n.childNodes.length && (m += "..."), m += "</" + vi.call(String(n.nodeName)) + ">" } if (Ai(n)) { if (0 === n.length) return "[]"; var x = Hi(n, g); return p && !function (t) { for (var e = 0; e < t.length; e++)if (Vi(t[e], "\n") >= 0) return !1; return !0 }(x) ? "[" + Wi(x, p) + "]" : "[ " + _i.call(x, ", ") + " ]" } if (function (t) { return !("[object Error]" !== qi(t) || Ii && "object" === e(t) && Ii in t) }(n)) { var E = Hi(n, g); return "cause" in Error.prototype || !("cause" in n) || Pi.call(n, "cause") ? 0 === E.length ? "[" + String(n) + "]" : "{ [" + String(n) + "] " + _i.call(E, ", ") + " }" : "{ [" + String(n) + "] " + _i.call(mi.call("[cause]: " + g(n.cause), E), ", ") + " }" } if ("object" === e(n) && s) { if (Ri && "function" == typeof n[Ri] && Oi) return Oi(n, { depth: h - i }); if ("symbol" !== s && "function" == typeof n.inspect) return n.inspect() } if (function (t) { if (!ti || !t || "object" !== e(t)) return !1; try { ti.call(t); try { ii.call(t) } catch (t) { return !0 } return t instanceof Map } catch (t) { } return !1 }(n)) { var w = []; return ei && ei.call(n, (function (t, e) { w.push(g(e, n, !0) + " => " + g(t, n)) })), Xi("Map", ti.call(n), w, p) } if (function (t) { if (!ii || !t || "object" !== e(t)) return !1; try { ii.call(t); try { ti.call(t) } catch (t) { return !0 } return t instanceof Set } catch (t) { } return !1 }(n)) { var k = []; return oi && oi.call(n, (function (t) { k.push(g(t, n)) })), Xi("Set", ii.call(n), k, p) } if (function (t) { if (!ai || !t || "object" !== e(t)) return !1; try { ai.call(t, ai); try { si.call(t, si) } catch (t) { return !0 } return t instanceof WeakMap } catch (t) { } return !1 }(n)) return Ui("WeakMap"); if (function (t) { if (!si || !t || "object" !== e(t)) return !1; try { si.call(t, si); try { ai.call(t, ai) } catch (t) { return !0 } return t instanceof WeakSet } catch (t) { } return !1 }(n)) return Ui("WeakSet"); if (function (t) { if (!ui || !t || "object" !== e(t)) return !1; try { return ui.call(t), !0 } catch (t) { } return !1 }(n)) return Ui("WeakRef"); if (function (t) { return !("[object Number]" !== qi(t) || Ii && "object" === e(t) && Ii in t) }(n)) return zi(g(Number(n))); if (function (t) { if (!t || "object" !== e(t) || !Ei) return !1; try { return Ei.call(t), !0 } catch (t) { } return !1 }(n)) return zi(g(Ei.call(n))); if (function (t) { return !("[object Boolean]" !== qi(t) || Ii && "object" === e(t) && Ii in t) }(n)) return zi(li.call(n)); if (function (t) { return !("[object String]" !== qi(t) || Ii && "object" === e(t) && Ii in t) }(n)) return zi(g(String(n))); if ("undefined" != typeof window && n === window) return "{ [object Window] }"; if (n === f) return "{ [object globalThis] }"; if (!function (t) { return !("[object Date]" !== qi(t) || Ii && "object" === e(t) && Ii in t) }(n) && !Di(n)) { var S = Hi(n, g), I = Ni ? Ni(n) === Object.prototype : n instanceof Object || n.constructor === Object, P = n instanceof Object ? "" : "null prototype", N = !I && Ii && Object(n) === n && Ii in n ? pi.call(qi(n), 8, -1) : P ? "Object" : "", M = (I || "function" != typeof n.constructor ? "" : n.constructor.name ? n.constructor.name + " " : "") + (N || P ? "[" + _i.call(mi.call([], N || [], P || []), ": ") + "] " : ""); return 0 === S.length ? M + "{}" : p ? M + "{" + Wi(S, p) + "}" : M + "{ " + _i.call(S, ", ") + " }" } return String(n) }, Qi = Zi("%TypeError%"), Ki = Zi("%WeakMap%", !0), to = Zi("%Map%", !0), eo = Ji("WeakMap.prototype.get", !0), no = Ji("WeakMap.prototype.set", !0), ro = Ji("WeakMap.prototype.has", !0), io = Ji("Map.prototype.get", !0), oo = Ji("Map.prototype.set", !0), ao = Ji("Map.prototype.has", !0), so = function (t, e) { for (var n, r = t; null !== (n = r.next); r = n)if (n.key === e) return r.next = n.next, n.next = t.next, t.next = n, n }, uo = function (t) { return t != t }, lo = function (t, e) { return 0 === t && 0 === e ? 1 / t == 1 / e : t === e || !(!uo(t) || !uo(e)) }, co = lo, ho = function () { return "function" == typeof Object.is ? Object.is : co }, fo = ho, po = Ct, go = Ct, yo = lo, vo = ho, mo = function () { var t = fo(); return po(Object, { is: t }, { is: function () { return Object.is !== t } }), t }, _o = Gt(vo(), Object); go(_o, { getPolyfill: vo, implementation: yo, shim: mo }); var bo = _o, xo = I, Eo = function () { return xo() && !!Symbol.toStringTag }, wo = Eo(), ko = Xt("Object.prototype.toString"), So = function (t) { return !(wo && t && "object" === e(t) && Symbol.toStringTag in t) && "[object Arguments]" === ko(t) }, Io = function (t) { return !!So(t) || null !== t && "object" === e(t) && "number" == typeof t.length && t.length >= 0 && "[object Array]" !== ko(t) && "[object Function]" === ko(t.callee) }, Po = function () { return So(arguments) }(); So.isLegacyArguments = Io; var No, Mo, Oo = Po ? So : Io, Lo = {}.toString, Ro = Array.isArray || function (t) { return "[object Array]" == Lo.call(t) }, Co = Function.prototype.toString, To = "object" === ("undefined" == typeof Reflect ? "undefined" : e(Reflect)) && null !== Reflect && Reflect.apply; if ("function" == typeof To && "function" == typeof Object.defineProperty) try { No = Object.defineProperty({}, "length", { get: function () { throw Mo } }), Mo = {}, To((function () { throw 42 }), null, No) } catch (t) { t !== Mo && (To = null) } else To = null; var Ao = /^\s*class\b/, Do = function (t) { try { var e = Co.call(t); return Ao.test(e) } catch (t) { return !1 } }, jo = function (t) { try { return !Do(t) && (Co.call(t), !0) } catch (t) { return !1 } }, Fo = Object.prototype.toString, Bo = "function" == typeof Symbol && !!Symbol.toStringTag, qo = !(0 in [,]), Vo = function () { return !1 }; if ("object" === ("undefined" == typeof document ? "undefined" : e(document))) { var Go = document.all; Fo.call(Go) === Fo.call(document.all) && (Vo = function (t) { if ((qo || !t) && (void 0 === t || "object" === e(t))) try { var n = Fo.call(t); return ("[object HTMLAllCollection]" === n || "[object HTML document.all class]" === n || "[object HTMLCollection]" === n || "[object Object]" === n) && null == t("") } catch (t) { } return !1 }) } var Yo = To ? function (t) { if (Vo(t)) return !0; if (!t) return !1; if ("function" != typeof t && "object" !== e(t)) return !1; try { To(t, null, No) } catch (t) { if (t !== Mo) return !1 } return !Do(t) && jo(t) } : function (t) { if (Vo(t)) return !0; if (!t) return !1; if ("function" != typeof t && "object" !== e(t)) return !1; if (Bo) return jo(t); if (Do(t)) return !1; var n = Fo.call(t); return !("[object Function]" !== n && "[object GeneratorFunction]" !== n && !/^\[object HTML/.test(n)) && jo(t) }, zo = Yo, Uo = Object.prototype.toString, Xo = Object.prototype.hasOwnProperty, Wo = function (t, e, n) { if (!zo(e)) throw new TypeError("iterator must be a function"); var r; arguments.length >= 3 && (r = n), "[object Array]" === Uo.call(t) ? function (t, e, n) { for (var r = 0, i = t.length; r < i; r++)Xo.call(t, r) && (null == n ? e(t[r], r, t) : e.call(n, t[r], r, t)) }(t, e, r) : "string" == typeof t ? function (t, e, n) { for (var r = 0, i = t.length; r < i; r++)null == n ? e(t.charAt(r), r, t) : e.call(n, t.charAt(r), r, t) }(t, e, r) : function (t, e, n) { for (var r in t) Xo.call(t, r) && (null == n ? e(t[r], r, t) : e.call(n, t[r], r, t)) }(t, e, r) }, Ho = ["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"], Zo = "undefined" == typeof globalThis ? f : globalThis, Jo = Wo, $o = function () { for (var t = [], e = 0; e < Ho.length; e++)"function" == typeof Zo[Ho[e]] && (t[t.length] = Ho[e]); return t }, Qo = Gt, Ko = Xt, ta = dt, ea = Ko("Object.prototype.toString"), na = Eo(), ra = "undefined" == typeof globalThis ? f : globalThis, ia = $o(), oa = Ko("String.prototype.slice"), aa = Object.getPrototypeOf, sa = Ko("Array.prototype.indexOf", !0) || function (t, e) { for (var n = 0; n < t.length; n += 1)if (t[n] === e) return n; return -1 }, ua = { __proto__: null }; Jo(ia, na && ta && aa ? function (t) { var e = new ra[t]; if (Symbol.toStringTag in e) { var n = aa(e), r = ta(n, Symbol.toStringTag); if (!r) { var i = aa(n); r = ta(i, Symbol.toStringTag) } ua["$" + t] = Qo(r.get) } } : function (t) { var e = new ra[t], n = e.slice || e.set; n && (ua["$" + t] = Qo(n)) }); var la, ca, ha, fa, pa = function (t) { if (!t || "object" !== e(t)) return !1; if (!na) { var n = oa(ea(t), 8, -1); return sa(ia, n) > -1 ? n : "Object" === n && function (t) { var e = !1; return Jo(ua, (function (n, r) { if (!e) try { n(t), e = oa(r, 1) } catch (t) { } })), e }(t) } return ta ? function (t) { var e = !1; return Jo(ua, (function (n, r) { if (!e) try { "$" + n(t) === r && (e = oa(r, 1)) } catch (t) { } })), e }(t) : null }, ga = pa, ya = Gt, va = Xt, da = ft, ma = function (t) { return !!ga(t) }, _a = da("ArrayBuffer", !0), ba = da("Float32Array", !0), xa = va("ArrayBuffer.prototype.byteLength", !0), Ea = _a && !xa && (new _a).slice, wa = Ea && ya(Ea), ka = xa || wa ? function (t) { if (!t || "object" !== e(t)) return !1; try { return xa ? xa(t) : wa(t, 0), !0 } catch (t) { return !1 } } : ba ? function (t) { try { return new ba(t).buffer === t && !ma(t) } catch (n) { return "object" === e(t) && "RangeError" === n.name } } : function (t) { return !1 }, Sa = Date.prototype.getDay, Ia = Object.prototype.toString, Pa = Eo(), Na = Xt, Ma = Eo(); if (Ma) { la = Na("Object.prototype.hasOwnProperty"), ca = Na("RegExp.prototype.exec"), ha = {}; var Oa = function () { throw ha }; fa = { toString: Oa, valueOf: Oa }, "symbol" === e(Symbol.toPrimitive) && (fa[Symbol.toPrimitive] = Oa) } var La = Na("Object.prototype.toString"), Ra = Object.getOwnPropertyDescriptor, Ca = Ma ? function (t) { if (!t || "object" !== e(t)) return !1; var n = Ra(t, "lastIndex"); if (!(n && la(n, "value"))) return !1; try { ca(t, fa) } catch (t) { return t === ha } } : function (t) { return !(!t || "object" !== e(t) && "function" != typeof t) && "[object RegExp]" === La(t) }, Ta = Xt("SharedArrayBuffer.prototype.byteLength", !0), Aa = Ta ? function (t) { if (!t || "object" !== e(t)) return !1; try { return Ta(t), !0 } catch (t) { return !1 } } : function (t) { return !1 }, Da = String.prototype.valueOf, ja = Object.prototype.toString, Fa = Eo(), Ba = Number.prototype.toString, qa = Object.prototype.toString, Va = Eo(), Ga = Xt, Ya = Ga("Boolean.prototype.toString"), za = Ga("Object.prototype.toString"), Ua = Eo(), Xa = { exports: {} }, Wa = Object.prototype.toString; if (M()) { var Ha = Symbol.prototype.toString, Za = /^Symbol\(.*\)$/; Xa.exports = function (t) { if ("symbol" === e(t)) return !0; if ("[object Symbol]" !== Wa.call(t)) return !1; try { return function (t) { return "symbol" === e(t.valueOf()) && Za.test(Ha.call(t)) }(t) } catch (t) { return !1 } } } else Xa.exports = function (t) { return !1 }; var Ja = Xa.exports, $a = { exports: {} }, Qa = "undefined" != typeof BigInt && BigInt; if ("function" == typeof Qa && "function" == typeof BigInt && "bigint" == typeof Qa(42) && "bigint" == typeof BigInt(42)) { var Ka = BigInt.prototype.valueOf; $a.exports = function (t) { return null != t && "boolean" != typeof t && "string" != typeof t && "number" != typeof t && "symbol" !== e(t) && "function" != typeof t && ("bigint" == typeof t || function (t) { try { return Ka.call(t), !0 } catch (t) { } return !1 }(t)) } } else $a.exports = function (t) { return !1 }; var ts, es = $a.exports, ns = function (t) { return "string" == typeof t || "object" === e(t) && (Fa ? function (t) { try { return Da.call(t), !0 } catch (t) { return !1 } }(t) : "[object String]" === ja.call(t)) }, rs = function (t) { return "number" == typeof t || "object" === e(t) && (Va ? function (t) { try { return Ba.call(t), !0 } catch (t) { return !1 } }(t) : "[object Number]" === qa.call(t)) }, is = function (t) { return "boolean" == typeof t || null !== t && "object" === e(t) && (Ua && Symbol.toStringTag in t ? function (t) { try { return Ya(t), !0 } catch (t) { return !1 } }(t) : "[object Boolean]" === za(t)) }, os = Ja, as = es, ss = "function" == typeof Map && Map.prototype ? Map : null, us = "function" == typeof Set && Set.prototype ? Set : null; ss || (ts = function (t) { return !1 }); var ls = ss ? Map.prototype.has : null, cs = us ? Set.prototype.has : null; ts || ls || (ts = function (t) { return !1 }); var hs, fs = ts || function (t) { if (!t || "object" !== e(t)) return !1; try { if (ls.call(t), cs) try { cs.call(t) } catch (t) { return !0 } return t instanceof ss } catch (t) { } return !1 }, ps = "function" == typeof Map && Map.prototype ? Map : null, gs = "function" == typeof Set && Set.prototype ? Set : null; gs || (hs = function (t) { return !1 }); var ys = ps ? Map.prototype.has : null, vs = gs ? Set.prototype.has : null; hs || vs || (hs = function (t) { return !1 }); var ds, ms = hs || function (t) { if (!t || "object" !== e(t)) return !1; try { if (vs.call(t), ys) try { ys.call(t) } catch (t) { return !0 } return t instanceof gs } catch (t) { } return !1 }, _s = "function" == typeof WeakMap && WeakMap.prototype ? WeakMap : null, bs = "function" == typeof WeakSet && WeakSet.prototype ? WeakSet : null; _s || (ds = function (t) { return !1 }); var xs = _s ? _s.prototype.has : null, Es = bs ? bs.prototype.has : null; ds || xs || (ds = function (t) { return !1 }); var ws = ds || function (t) { if (!t || "object" !== e(t)) return !1; try { if (xs.call(t, xs), Es) try { Es.call(t, Es) } catch (t) { return !0 } return t instanceof _s } catch (t) { } return !1 }, ks = { exports: {} }, Ss = Xt, Is = ft("%WeakSet%", !0), Ps = Ss("WeakSet.prototype.has", !0); if (Ps) { var Ns = Ss("WeakMap.prototype.has", !0); ks.exports = function (t) { if (!t || "object" !== e(t)) return !1; try { if (Ps(t, Ps), Ns) try { Ns(t, Ns) } catch (t) { return !0 } return t instanceof Is } catch (t) { } return !1 } } else ks.exports = function (t) { return !1 }; var Ms = ks.exports, Os = fs, Ls = ms, Rs = ws, Cs = Ms, Ts = Xt("ArrayBuffer.prototype.byteLength", !0), As = ka, Ds = he, js = Xt, Fs = qe, Bs = ft, qs = function (t) { if (null != t && void 0 !== t[Ve]) return t[Ve]() }, Vs = function () { var t, n, r, i = { assert: function (t) { if (!i.has(t)) throw new Qi("Side channel does not contain " + $i(t)) }, get: function (i) { if (Ki && i && ("object" === e(i) || "function" == typeof i)) { if (t) return eo(t, i) } else if (to) { if (n) return io(n, i) } else if (r) return function (t, e) { var n = so(t, e); return n && n.value }(r, i) }, has: function (i) { if (Ki && i && ("object" === e(i) || "function" == typeof i)) { if (t) return ro(t, i) } else if (to) { if (n) return ao(n, i) } else if (r) return function (t, e) { return !!so(t, e) }(r, i); return !1 }, set: function (i, o) { Ki && i && ("object" === e(i) || "function" == typeof i) ? (t || (t = new Ki), no(t, i, o)) : to ? (n || (n = new to), oo(n, i, o)) : (r || (r = { key: {}, next: null }), function (t, e, n) { var r = so(t, e); r ? r.value = n : t.next = { key: e, next: t.next, value: n } }(r, i, o)) } }; return i }, Gs = bo, Ys = Oo, zs = Ro, Us = ka, Xs = function (t) { return "object" === e(t) && null !== t && (Pa ? function (t) { try { return Sa.call(t), !0 } catch (t) { return !1 } }(t) : "[object Date]" === Ia.call(t)) }, Ws = Ca, Hs = Aa, Zs = S, Js = function (t) { return null == t || "object" !== e(t) && "function" != typeof t ? null : ns(t) ? "String" : rs(t) ? "Number" : is(t) ? "Boolean" : os(t) ? "Symbol" : as(t) ? "BigInt" : void 0 }, $s = function (t) { if (t && "object" === e(t)) { if (Os(t)) return "Map"; if (Ls(t)) return "Set"; if (Rs(t)) return "WeakMap"; if (Cs(t)) return "WeakSet" } return !1 }, Qs = pa, Ks = function (t) { return As(t) ? Ts ? Ts(t) : t.byteLength : NaN }, tu = js("SharedArrayBuffer.prototype.byteLength", !0), eu = js("Date.prototype.getTime"), nu = Object.getPrototypeOf, ru = js("Object.prototype.toString"), iu = Bs("%Set%", !0), ou = js("Map.prototype.has", !0), au = js("Map.prototype.get", !0), su = js("Map.prototype.size", !0), uu = js("Set.prototype.add", !0), lu = js("Set.prototype.delete", !0), cu = js("Set.prototype.has", !0), hu = js("Set.prototype.size", !0); function fu(t, e, n, r) { for (var i, o = qs(t); (i = o.next()) && !i.done;)if (du(e, i.value, n, r)) return lu(t, i.value), !0; return !1 } function pu(t) { return void 0 === t ? null : "object" !== e(t) ? "symbol" !== e(t) && ("string" != typeof t && "number" != typeof t || +t == +t) : void 0 } function gu(t, e, n, r, i, o) { var a = pu(n); if (null != a) return a; var s = au(e, a), u = Ds({}, i, { strict: !1 }); return !(void 0 === s && !ou(e, a) || !du(r, s, u, o)) && (!ou(t, a) && du(r, s, u, o)) } function yu(t, e, n) { var r = pu(n); return null != r ? r : cu(e, r) && !cu(t, r) } function vu(t, e, n, r, i, o) { for (var a, s, u = qs(t); (a = u.next()) && !a.done;)if (du(n, s = a.value, i, o) && du(r, au(e, s), i, o)) return lu(t, s), !0; return !1 } function du(t, n, r, i) { var o = r || {}; if (o.strict ? Gs(t, n) : t === n) return !0; if (Js(t) !== Js(n)) return !1; if (!t || !n || "object" !== e(t) && "object" !== e(n)) return o.strict ? Gs(t, n) : t == n; var a, s = i.has(t), u = i.has(n); if (s && u) { if (i.get(t) === i.get(n)) return !0 } else a = {}; return s || i.set(t, a), u || i.set(n, a), function (t, n, r, i) { var o, a; if (e(t) !== e(n)) return !1; if (null == t || null == n) return !1; if (ru(t) !== ru(n)) return !1; if (Ys(t) !== Ys(n)) return !1; var s = zs(t), u = zs(n); if (s !== u) return !1; var l = t instanceof Error, c = n instanceof Error; if (l !== c) return !1; if ((l || c) && (t.name !== n.name || t.message !== n.message)) return !1; var h = Ws(t), f = Ws(n); if (h !== f) return !1; if ((h || f) && (t.source !== n.source || Fs(t) !== Fs(n))) return !1; var p = Xs(t), g = Xs(n); if (p !== g) return !1; if ((p || g) && eu(t) !== eu(n)) return !1; if (r.strict && nu && nu(t) !== nu(n)) return !1; var y = Qs(t), v = Qs(n); if (y !== v) return !1; if (y || v) { if (t.length !== n.length) return !1; for (o = 0; o < t.length; o++)if (t[o] !== n[o]) return !1; return !0 } var d = mu(t), m = mu(n); if (d !== m) return !1; if (d || m) { if (t.length !== n.length) return !1; for (o = 0; o < t.length; o++)if (t[o] !== n[o]) return !1; return !0 } var _ = Us(t), b = Us(n); if (_ !== b) return !1; if (_ || b) return Ks(t) === Ks(n) && ("function" == typeof Uint8Array && du(new Uint8Array(t), new Uint8Array(n), r, i)); var x = Hs(t), E = Hs(n); if (x !== E) return !1; if (x || E) return tu(t) === tu(n) && ("function" == typeof Uint8Array && du(new Uint8Array(t), new Uint8Array(n), r, i)); if (e(t) !== e(n)) return !1; var w = Zs(t), k = Zs(n); if (w.length !== k.length) return !1; for (w.sort(), k.sort(), o = w.length - 1; o >= 0; o--)if (w[o] != k[o]) return !1; for (o = w.length - 1; o >= 0; o--)if (!du(t[a = w[o]], n[a], r, i)) return !1; var S = $s(t), I = $s(n); if (S !== I) return !1; if ("Set" === S || "Set" === I) return function (t, n, r, i) { if (hu(t) !== hu(n)) return !1; var o, a, s, u = qs(t), l = qs(n); for (; (o = u.next()) && !o.done;)if (o.value && "object" === e(o.value)) s || (s = new iu), uu(s, o.value); else if (!cu(n, o.value)) { if (r.strict) return !1; if (!yu(t, n, o.value)) return !1; s || (s = new iu), uu(s, o.value) } if (s) { for (; (a = l.next()) && !a.done;)if (a.value && "object" === e(a.value)) { if (!fu(s, a.value, r.strict, i)) return !1 } else if (!r.strict && !cu(t, a.value) && !fu(s, a.value, r.strict, i)) return !1; return 0 === hu(s) } return !0 }(t, n, r, i); if ("Map" === S) return function (t, n, r, i) { if (su(t) !== su(n)) return !1; var o, a, s, u, l, c, h = qs(t), f = qs(n); for (; (o = h.next()) && !o.done;)if (u = o.value[0], l = o.value[1], u && "object" === e(u)) s || (s = new iu), uu(s, u); else if (void 0 === (c = au(n, u)) && !ou(n, u) || !du(l, c, r, i)) { if (r.strict) return !1; if (!gu(t, n, u, l, r, i)) return !1; s || (s = new iu), uu(s, u) } if (s) { for (; (a = f.next()) && !a.done;)if (u = a.value[0], c = a.value[1], u && "object" === e(u)) { if (!vu(s, t, u, c, r, i)) return !1 } else if (!(r.strict || t.has(u) && du(au(t, u), c, r, i) || vu(s, t, u, c, Ds({}, r, { strict: !1 }), i))) return !1; return 0 === hu(s) } return !0 }(t, n, r, i); return !0 }(t, n, o, i) } function mu(t) { return !(!t || "object" !== e(t) || "number" != typeof t.length) && ("function" == typeof t.copy && "function" == typeof t.slice && (!(t.length > 0 && "number" != typeof t[0]) && !!(t.constructor && t.constructor.isBuffer && t.constructor.isBuffer(t)))) } var _u = p((function (t, e, n) { return du(t, e, n, Vs()) })), bu = Object.defineProperty, xu = function (t, e) { return bu(t, "name", { value: e, configurable: !0 }) }, Eu = function () { function t(e) { var r, i, o; n(this, t), this.direction = !1, this.compareProperties = !0, this.precision = Math.pow(10, -(null != (r = null == e ? void 0 : e.precision) ? r : 17)), this.direction = null != (i = null == e ? void 0 : e.direction) && i, this.compareProperties = null == (o = null == e ? void 0 : e.compareProperties) || o } return i(t, [{ key: "compare", value: function (t, e) { var n = this; if (t.type !== e.type) return !1; if (!ku(t, e)) return !1; switch (t.type) { case "Point": return this.compareCoord(t.coordinates, e.coordinates); case "LineString": return this.compareLine(t.coordinates, e.coordinates); case "Polygon": return this.comparePolygon(t, e); case "GeometryCollection": return this.compareGeometryCollection(t, e); case "Feature": return this.compareFeature(t, e); case "FeatureCollection": return this.compareFeatureCollection(t, e); default: if (t.type.startsWith("Multi")) { var r = Su(t), i = Su(e); return r.every((function (t) { return i.some((function (e) { return n.compare(t, e) })) })) } }return !1 } }, { key: "compareCoord", value: function (t, e) { var n = this; return t.length === e.length && t.every((function (t, r) { return Math.abs(t - e[r]) < n.precision })) } }, { key: "compareLine", value: function (t, e) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]; if (!ku(t, e)) return !1; var i = t, o = e; if (r && !this.compareCoord(i[0], o[0])) { var a = this.fixStartIndex(o, i); if (!a) return !1; o = a } var s = this.compareCoord(i[n], o[n]); return this.direction || s ? this.comparePath(i, o) : !!this.compareCoord(i[n], o[o.length - (1 + n)]) && this.comparePath(i.slice().reverse(), o) } }, { key: "fixStartIndex", value: function (t, e) { for (var n, r = -1, i = 0; i < t.length; i++)if (this.compareCoord(t[i], e[0])) { r = i; break } return r >= 0 && (n = [].concat(t.slice(r, t.length), t.slice(1, r + 1))), n } }, { key: "comparePath", value: function (t, e) { var n = this; return t.every((function (t, r) { return n.compareCoord(t, e[r]) })) } }, { key: "comparePolygon", value: function (t, e) { var n = this; if (this.compareLine(t.coordinates[0], e.coordinates[0], 1, !0)) { var r = t.coordinates.slice(1, t.coordinates.length), i = e.coordinates.slice(1, e.coordinates.length); return r.every((function (t) { return i.some((function (e) { return n.compareLine(t, e, 1, !0) })) })) } return !1 } }, { key: "compareGeometryCollection", value: function (t, e) { var n = this; return ku(t.geometries, e.geometries) && this.compareBBox(t, e) && t.geometries.every((function (t, r) { return n.compare(t, e.geometries[r]) })) } }, { key: "compareFeature", value: function (t, e) { return t.id === e.id && (!this.compareProperties || _u(t.properties, e.properties)) && this.compareBBox(t, e) && this.compare(t.geometry, e.geometry) } }, { key: "compareFeatureCollection", value: function (t, e) { var n = this; return ku(t.features, e.features) && this.compareBBox(t, e) && t.features.every((function (t, r) { return n.compare(t, e.features[r]) })) } }, { key: "compareBBox", value: function (t, e) { return Boolean(!t.bbox && !e.bbox) || !(!t.bbox || !e.bbox) && this.compareCoord(t.bbox, e.bbox) } }]), t }(); xu(Eu, "GeojsonEquality"); var wu = Eu; function ku(t, e) { return t.coordinates ? t.coordinates.length === e.coordinates.length : t.length === e.length } function Su(t) { return t.coordinates.map((function (e) { return { type: t.type.replace("Multi", ""), coordinates: e } })) } xu(ku, "sameLength"), xu(Su, "explode"); var Iu = 6371008.8, Pu = { centimeters: 100 * Iu, centimetres: 100 * Iu, degrees: 360 / (2 * Math.PI), feet: 3.28084 * Iu, inches: 39.37 * Iu, kilometers: Iu / 1e3, kilometres: Iu / 1e3, meters: Iu, metres: Iu, miles: Iu / 1609.344, millimeters: 1e3 * Iu, millimetres: 1e3 * Iu, nauticalmiles: Iu / 1852, radians: 1, yards: 1.0936 * Iu }, Nu = { acres: 247105e-9, centimeters: 1e4, centimetres: 1e4, feet: 10.763910417, hectares: 1e-4, inches: 1550.003100006, kilometers: 1e-6, kilometres: 1e-6, meters: 1, metres: 1, miles: 386e-9, nauticalmiles: 2.9155334959812285e-7, millimeters: 1e6, millimetres: 1e6, yards: 1.195990046 }; function Mu(t, e) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r = { type: "Feature" }; return (0 === n.id || n.id) && (r.id = n.id), n.bbox && (r.bbox = n.bbox), r.properties = e || {}, r.geometry = t, r } function Ou(t, e) { switch (t) { case "Point": return Lu(e).geometry; case "LineString": return Au(e).geometry; case "Polygon": return Cu(e).geometry; case "MultiPoint": return Bu(e).geometry; case "MultiLineString": return Fu(e).geometry; case "MultiPolygon": return qu(e).geometry; default: throw new Error(t + " is invalid") } } function Lu(t, e) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; if (!t) throw new Error("coordinates is required"); if (!Array.isArray(t)) throw new Error("coordinates must be an Array"); if (t.length < 2) throw new Error("coordinates must be at least 2 numbers long"); if (!$u(t[0]) || !$u(t[1])) throw new Error("coordinates must contain numbers"); return Mu({ type: "Point", coordinates: t }, e, n) } function Ru(t, e) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; return ju(t.map((function (t) { return Lu(t, e) })), n) } function Cu(t, e) { var n, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, i = c(t); try { for (i.s(); !(n = i.n()).done;) { var o = n.value; if (o.length < 4) throw new Error("Each LinearRing of a Polygon must have 4 or more Positions."); if (o[o.length - 1].length !== o[0].length) throw new Error("First and last Position are not equivalent."); for (var a = 0; a < o[o.length - 1].length; a++)if (o[o.length - 1][a] !== o[0][a]) throw new Error("First and last Position are not equivalent.") } } catch (t) { i.e(t) } finally { i.f() } return Mu({ type: "Polygon", coordinates: t }, e, r) } function Tu(t, e) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; return ju(t.map((function (t) { return Cu(t, e) })), n) } function Au(t, e) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; if (t.length < 2) throw new Error("coordinates must be an array of two or more positions"); return Mu({ type: "LineString", coordinates: t }, e, n) } function Du(t, e) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; return ju(t.map((function (t) { return Au(t, e) })), n) } function ju(t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = { type: "FeatureCollection" }; return e.id && (n.id = e.id), e.bbox && (n.bbox = e.bbox), n.features = t, n } function Fu(t, e) { return Mu({ type: "MultiLineString", coordinates: t }, e, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}) } function Bu(t, e) { return Mu({ type: "MultiPoint", coordinates: t }, e, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}) } function qu(t, e) { return Mu({ type: "MultiPolygon", coordinates: t }, e, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}) } function Vu(t, e) { return Mu({ type: "GeometryCollection", geometries: t }, e, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}) } function Gu(t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0; if (e && !(e >= 0)) throw new Error("precision must be a positive number"); var n = Math.pow(10, e || 0); return Math.round(t * n) / n } function Yu(t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "kilometers", n = Pu[e]; if (!n) throw new Error(e + " units is invalid"); return t * n } function zu(t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "kilometers", n = Pu[e]; if (!n) throw new Error(e + " units is invalid"); return t / n } function Uu(t, e) { return Wu(zu(t, e)) } function Xu(t) { var e = t % 360; return e < 0 && (e += 360), e } function Wu(t) { return 180 * (t % (2 * Math.PI)) / Math.PI } function Hu(t) { return t % 360 * Math.PI / 180 } function Zu(t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "kilometers", n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "kilometers"; if (!(t >= 0)) throw new Error("length must be a positive number"); return Yu(zu(t, e), n) } function Ju(t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "meters", n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "kilometers"; if (!(t >= 0)) throw new Error("area must be a positive number"); var r = Nu[e]; if (!r) throw new Error("invalid original units"); var i = Nu[n]; if (!i) throw new Error("invalid final units"); return t / r * i } function $u(t) { return !isNaN(t) && null !== t && !Array.isArray(t) } function Qu(t) { return null !== t && "object" === e(t) && !Array.isArray(t) } function Ku(t) { if (!t) throw new Error("bbox is required"); if (!Array.isArray(t)) throw new Error("bbox must be an Array"); if (4 !== t.length && 6 !== t.length) throw new Error("bbox must be an Array of 4 or 6 numbers"); t.forEach((function (t) { if (!$u(t)) throw new Error("bbox must only contain numbers") })) } function tl(t) { if (!t) throw new Error("id is required"); if (-1 === ["string", "number"].indexOf(e(t))) throw new Error("id must be a number or a string") } xu(Mu, "feature"), xu(Ou, "geometry"), xu(Lu, "point"), xu(Ru, "points"), xu(Cu, "polygon"), xu(Tu, "polygons"), xu(Au, "lineString"), xu(Du, "lineStrings"), xu(ju, "featureCollection"), xu(Fu, "multiLineString"), xu(Bu, "multiPoint"), xu(qu, "multiPolygon"), xu(Vu, "geometryCollection"), xu(Gu, "round"), xu(Yu, "radiansToLength"), xu(zu, "lengthToRadians"), xu(Uu, "lengthToDegrees"), xu(Xu, "bearingToAzimuth"), xu(Wu, "radiansToDegrees"), xu(Hu, "degreesToRadians"), xu(Zu, "convertLength"), xu(Ju, "convertArea"), xu($u, "isNumber"), xu(Qu, "isObject"), xu(Ku, "validateBBox"), xu(tl, "validateId"); var el = Object.freeze({ __proto__: null, GeojsonEquality: wu, areaFactors: Nu, bearingToAzimuth: Xu, convertArea: Ju, convertLength: Zu, degreesToRadians: Hu, earthRadius: Iu, factors: Pu, feature: Mu, featureCollection: ju, geometry: Ou, geometryCollection: Vu, isNumber: $u, isObject: Qu, lengthToDegrees: Uu, lengthToRadians: zu, lineString: Au, lineStrings: Du, multiLineString: Fu, multiPoint: Bu, multiPolygon: qu, point: Lu, points: Ru, polygon: Cu, polygons: Tu, radiansToDegrees: Wu, radiansToLength: Yu, round: Gu, validateBBox: Ku, validateId: tl }), nl = Object.defineProperty, rl = function (t, e) { return nl(t, "name", { value: e, configurable: !0 }) }; function il(t) { if (!t) throw new Error("coord is required"); if (!Array.isArray(t)) { if ("Feature" === t.type && null !== t.geometry && "Point" === t.geometry.type) return s(t.geometry.coordinates); if ("Point" === t.type) return s(t.coordinates) } if (Array.isArray(t) && t.length >= 2 && !Array.isArray(t[0]) && !Array.isArray(t[1])) return s(t); throw new Error("coord must be GeoJSON Point or an Array of numbers") } function ol(t) { if (Array.isArray(t)) return t; if ("Feature" === t.type) { if (null !== t.geometry) return t.geometry.coordinates } else if (t.coordinates) return t.coordinates; throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array") } function al(t) { if (t.length > 1 && $u(t[0]) && $u(t[1])) return !0; if (Array.isArray(t[0]) && t[0].length) return al(t[0]); throw new Error("coordinates must only contain numbers") } function sl(t, e, n) { if (!e || !n) throw new Error("type and name required"); if (!t || t.type !== e) throw new Error("Invalid input to " + n + ": must be a " + e + ", given " + t.type) } function ul(t, e, n) { if (!t) throw new Error("No feature passed"); if (!n) throw new Error(".featureOf() requires a name"); if (!t || "Feature" !== t.type || !t.geometry) throw new Error("Invalid input to " + n + ", Feature with geometry required"); if (!t.geometry || t.geometry.type !== e) throw new Error("Invalid input to " + n + ": must be a " + e + ", given " + t.geometry.type) } function ll(t, e, n) { if (!t) throw new Error("No featureCollection passed"); if (!n) throw new Error(".collectionOf() requires a name"); if (!t || "FeatureCollection" !== t.type) throw new Error("Invalid input to " + n + ", FeatureCollection required"); var r, i = c(t.features); try { for (i.s(); !(r = i.n()).done;) { var o = r.value; if (!o || "Feature" !== o.type || !o.geometry) throw new Error("Invalid input to " + n + ", Feature with geometry required"); if (!o.geometry || o.geometry.type !== e) throw new Error("Invalid input to " + n + ": must be a " + e + ", given " + o.geometry.type) } } catch (t) { i.e(t) } finally { i.f() } } function cl(t) { return "Feature" === t.type ? t.geometry : t } function hl(t, e) { return "FeatureCollection" === t.type ? "FeatureCollection" : "GeometryCollection" === t.type ? "GeometryCollection" : "Feature" === t.type && null !== t.geometry ? t.geometry.type : t.type } rl(il, "getCoord"), rl(ol, "getCoords"), rl(al, "containsNumber"), rl(sl, "geojsonType"), rl(ul, "featureOf"), rl(ll, "collectionOf"), rl(cl, "getGeom"), rl(hl, "getType"); var fl = Object.freeze({ __proto__: null, collectionOf: ll, containsNumber: al, featureOf: ul, geojsonType: sl, getCoord: il, getCoords: ol, getGeom: cl, getType: hl }), pl = Object.defineProperty, gl = function (t, e) { return pl(t, "name", { value: e, configurable: !0 }) }; function yl(t, e) { if (!0 === (arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}).final) return vl(t, e); var n = il(t), r = il(e), i = Hu(n[0]), o = Hu(r[0]), a = Hu(n[1]), s = Hu(r[1]), u = Math.sin(o - i) * Math.cos(s), l = Math.cos(a) * Math.sin(s) - Math.sin(a) * Math.cos(s) * Math.cos(o - i); return Wu(Math.atan2(u, l)) } function vl(t, e) { var n = yl(e, t); return n = (n + 180) % 360 } gl(yl, "bearing"), gl(vl, "calculateFinalBearing"); function dl(t, e, n) { var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, i = il(t), o = Hu(i[0]), a = Hu(i[1]), s = Hu(n), u = zu(e, r.units), l = Math.asin(Math.sin(a) * Math.cos(u) + Math.cos(a) * Math.sin(u) * Math.cos(s)); return Lu([Wu(o + Math.atan2(Math.sin(s) * Math.sin(u) * Math.cos(a), Math.cos(u) - Math.sin(a) * Math.sin(l))), Wu(l)], r.properties) } (0, Object.defineProperty)(dl, "name", { value: "destination", configurable: !0 }); var ml = Object.defineProperty; function _l(t, e) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r = il(t), i = il(e), o = Hu(i[1] - r[1]), a = Hu(i[0] - r[0]), s = Hu(r[1]), u = Hu(i[1]), l = Math.pow(Math.sin(o / 2), 2) + Math.pow(Math.sin(a / 2), 2) * Math.cos(s) * Math.cos(u); return Yu(2 * Math.atan2(Math.sqrt(l), Math.sqrt(1 - l)), n.units) } !function (t, e) { ml(t, "name", { value: e, configurable: !0 }) }(_l, "distance"); var bl = Object.defineProperty; function xl(t, e) { for (var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r = cl(t).coordinates, i = 0, o = 0; o < r.length && !(e >= i && o === r.length - 1); o++) { if (i >= e) { var a = e - i; if (a) { var s = yl(r[o], r[o - 1]) - 180; return dl(r[o], a, s, n) } return Lu(r[o]) } i += _l(r[o], r[o + 1], n) } return Lu(r[r.length - 1]) } !function (t, e) { bl(t, "name", { value: e, configurable: !0 }) }(xl, "along"); var El = Object.defineProperty, wl = function (t, e) { return El(t, "name", { value: e, configurable: !0 }) }; function kl(t, e) { var n; return (n = (arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}).final ? Sl(il(e), il(t)) : Sl(il(t), il(e))) > 180 ? -(360 - n) : n } function Sl(t, e) { var n = Hu(t[1]), r = Hu(e[1]), i = Hu(e[0] - t[0]); i > Math.PI && (i -= 2 * Math.PI), i < -Math.PI && (i += 2 * Math.PI); var o = Math.log(Math.tan(r / 2 + Math.PI / 4) / Math.tan(n / 2 + Math.PI / 4)); return (Wu(Math.atan2(i, o)) + 360) % 360 } wl(kl, "rhumbBearing"), wl(Sl, "calculateRhumbBearing"); var Il = Object.defineProperty; function Pl(t, e, n) { var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}; if (!Qu(r)) throw new Error("options is invalid"); if (!t) throw new Error("startPoint is required"); if (!e) throw new Error("midPoint is required"); if (!n) throw new Error("endPoint is required"); var i = t, o = e, a = n, s = Xu(!0 !== r.mercator ? yl(i, o) : kl(i, o)), u = Xu(!0 !== r.mercator ? yl(a, o) : kl(a, o)), l = Math.abs(s - u); return !0 === r.explementary ? 360 - l : l } !function (t, e) { Il(t, "name", { value: e, configurable: !0 }) }(Pl, "angle"); var Nl = Object.defineProperty, Ml = function (t, e) { return Nl(t, "name", { value: e, configurable: !0 }) }; function Ol(t, e, n) { if (null !== t) for (var r, i, o, a, s, u, l, c, h = 0, f = 0, p = t.type, g = "FeatureCollection" === p, y = "Feature" === p, v = g ? t.features.length : 1, d = 0; d < v; d++) { s = (c = !!(l = g ? t.features[d].geometry : y ? t.geometry : t) && "GeometryCollection" === l.type) ? l.geometries.length : 1; for (var m = 0; m < s; m++) { var _ = 0, b = 0; if (null !== (a = c ? l.geometries[m] : l)) { u = a.coordinates; var x = a.type; switch (h = !n || "Polygon" !== x && "MultiPolygon" !== x ? 0 : 1, x) { case null: break; case "Point": if (!1 === e(u, f, d, _, b)) return !1; f++, _++; break; case "LineString": case "MultiPoint": for (r = 0; r < u.length; r++) { if (!1 === e(u[r], f, d, _, b)) return !1; f++, "MultiPoint" === x && _++ } "LineString" === x && _++; break; case "Polygon": case "MultiLineString": for (r = 0; r < u.length; r++) { for (i = 0; i < u[r].length - h; i++) { if (!1 === e(u[r][i], f, d, _, b)) return !1; f++ } "MultiLineString" === x && _++, "Polygon" === x && b++ } "Polygon" === x && _++; break; case "MultiPolygon": for (r = 0; r < u.length; r++) { for (b = 0, i = 0; i < u[r].length; i++) { for (o = 0; o < u[r][i].length - h; o++) { if (!1 === e(u[r][i][o], f, d, _, b)) return !1; f++ } b++ } _++ } break; case "GeometryCollection": for (r = 0; r < a.geometries.length; r++)if (!1 === Ol(a.geometries[r], e, n)) return !1; break; default: throw new Error("Unknown Geometry Type") } } } } } function Ll(t, e, n, r) { var i = n; return Ol(t, (function (t, r, o, a, s) { i = 0 === r && void 0 === n ? t : e(i, t, r, o, a, s) }), r), i } function Rl(t, e) { var n; switch (t.type) { case "FeatureCollection": for (n = 0; n < t.features.length && !1 !== e(t.features[n].properties, n); n++); break; case "Feature": e(t.properties, 0) } } function Cl(t, e, n) { var r = n; return Rl(t, (function (t, i) { r = 0 === i && void 0 === n ? t : e(r, t, i) })), r } function Tl(t, e) { if ("Feature" === t.type) e(t, 0); else if ("FeatureCollection" === t.type) for (var n = 0; n < t.features.length && !1 !== e(t.features[n], n); n++); } function Al(t, e, n) { var r = n; return Tl(t, (function (t, i) { r = 0 === i && void 0 === n ? t : e(r, t, i) })), r } function Dl(t) { var e = []; return Ol(t, (function (t) { e.push(t) })), e } function jl(t, e) { var n, r, i, o, a, s, u, l, c, h, f = 0, p = "FeatureCollection" === t.type, g = "Feature" === t.type, y = p ? t.features.length : 1; for (n = 0; n < y; n++) { for (s = p ? t.features[n].geometry : g ? t.geometry : t, l = p ? t.features[n].properties : g ? t.properties : {}, c = p ? t.features[n].bbox : g ? t.bbox : void 0, h = p ? t.features[n].id : g ? t.id : void 0, a = (u = !!s && "GeometryCollection" === s.type) ? s.geometries.length : 1, i = 0; i < a; i++)if (null !== (o = u ? s.geometries[i] : s)) switch (o.type) { case "Point": case "LineString": case "MultiPoint": case "Polygon": case "MultiLineString": case "MultiPolygon": if (!1 === e(o, f, l, c, h)) return !1; break; case "GeometryCollection": for (r = 0; r < o.geometries.length; r++)if (!1 === e(o.geometries[r], f, l, c, h)) return !1; break; default: throw new Error("Unknown Geometry Type") } else if (!1 === e(null, f, l, c, h)) return !1; f++ } } function Fl(t, e, n) { var r = n; return jl(t, (function (t, i, o, a, s) { r = 0 === i && void 0 === n ? t : e(r, t, i, o, a, s) })), r } function Bl(t, e) { jl(t, (function (t, n, r, i, o) { var a, s = null === t ? null : t.type; switch (s) { case null: case "Point": case "LineString": case "Polygon": return !1 !== e(Mu(t, r, { bbox: i, id: o }), n, 0) && void 0 }switch (s) { case "MultiPoint": a = "Point"; break; case "MultiLineString": a = "LineString"; break; case "MultiPolygon": a = "Polygon" }for (var u = 0; u < t.coordinates.length; u++) { var l = t.coordinates[u]; if (!1 === e(Mu({ type: a, coordinates: l }, r), n, u)) return !1 } })) } function ql(t, e, n) { var r = n; return Bl(t, (function (t, i, o) { r = 0 === i && 0 === o && void 0 === n ? t : e(r, t, i, o) })), r } function Vl(t, e) { Bl(t, (function (t, n, r) { var i = 0; if (t.geometry) { var o = t.geometry.type; if ("Point" !== o && "MultiPoint" !== o) { var a, s = 0, u = 0, l = 0; return !1 !== Ol(t, (function (o, c, h, f, p) { if (void 0 === a || n > s || f > u || p > l) return a = o, s = n, u = f, l = p, void (i = 0); var g = Au([a, o], t.properties); if (!1 === e(g, n, r, p, i)) return !1; i++, a = o })) && void 0 } } })) } function Gl(t, e, n) { var r = n, i = !1; return Vl(t, (function (t, o, a, s, u) { r = !1 === i && void 0 === n ? t : e(r, t, o, a, s, u), i = !0 })), r } function Yl(t, e) { if (!t) throw new Error("geojson is required"); Bl(t, (function (t, n, r) { if (null !== t.geometry) { var i = t.geometry.type, o = t.geometry.coordinates; switch (i) { case "LineString": if (!1 === e(t, n, r, 0, 0)) return !1; break; case "Polygon": for (var a = 0; a < o.length; a++)if (!1 === e(Au(o[a], t.properties), n, r, a)) return !1 } } })) } function zl(t, e, n) { var r = n; return Yl(t, (function (t, i, o, a) { r = 0 === i && void 0 === n ? t : e(r, t, i, o, a) })), r } function Ul(t, e) { if (!Qu(e = e || {})) throw new Error("options is invalid"); var n, r = e.featureIndex || 0, i = e.multiFeatureIndex || 0, o = e.geometryIndex || 0, a = e.segmentIndex || 0, s = e.properties; switch (t.type) { case "FeatureCollection": r < 0 && (r = t.features.length + r), s = s || t.features[r].properties, n = t.features[r].geometry; break; case "Feature": s = s || t.properties, n = t.geometry; break; case "Point": case "MultiPoint": return null; case "LineString": case "Polygon": case "MultiLineString": case "MultiPolygon": n = t; break; default: throw new Error("geojson is invalid") }if (null === n) return null; var u = n.coordinates; switch (n.type) { case "Point": case "MultiPoint": return null; case "LineString": return a < 0 && (a = u.length + a - 1), Au([u[a], u[a + 1]], s, e); case "Polygon": return o < 0 && (o = u.length + o), a < 0 && (a = u[o].length + a - 1), Au([u[o][a], u[o][a + 1]], s, e); case "MultiLineString": return i < 0 && (i = u.length + i), a < 0 && (a = u[i].length + a - 1), Au([u[i][a], u[i][a + 1]], s, e); case "MultiPolygon": return i < 0 && (i = u.length + i), o < 0 && (o = u[i].length + o), a < 0 && (a = u[i][o].length - a - 1), Au([u[i][o][a], u[i][o][a + 1]], s, e) }throw new Error("geojson is invalid") } function Xl(t, e) { if (!Qu(e = e || {})) throw new Error("options is invalid"); var n, r = e.featureIndex || 0, i = e.multiFeatureIndex || 0, o = e.geometryIndex || 0, a = e.coordIndex || 0, s = e.properties; switch (t.type) { case "FeatureCollection": r < 0 && (r = t.features.length + r), s = s || t.features[r].properties, n = t.features[r].geometry; break; case "Feature": s = s || t.properties, n = t.geometry; break; case "Point": case "MultiPoint": return null; case "LineString": case "Polygon": case "MultiLineString": case "MultiPolygon": n = t; break; default: throw new Error("geojson is invalid") }if (null === n) return null; var u = n.coordinates; switch (n.type) { case "Point": return Lu(u, s, e); case "MultiPoint": return i < 0 && (i = u.length + i), Lu(u[i], s, e); case "LineString": return a < 0 && (a = u.length + a), Lu(u[a], s, e); case "Polygon": return o < 0 && (o = u.length + o), a < 0 && (a = u[o].length + a), Lu(u[o][a], s, e); case "MultiLineString": return i < 0 && (i = u.length + i), a < 0 && (a = u[i].length + a), Lu(u[i][a], s, e); case "MultiPolygon": return i < 0 && (i = u.length + i), o < 0 && (o = u[i].length + o), a < 0 && (a = u[i][o].length - a), Lu(u[i][o][a], s, e) }throw new Error("geojson is invalid") } Ml(Ol, "coordEach"), Ml(Ll, "coordReduce"), Ml(Rl, "propEach"), Ml(Cl, "propReduce"), Ml(Tl, "featureEach"), Ml(Al, "featureReduce"), Ml(Dl, "coordAll"), Ml(jl, "geomEach"), Ml(Fl, "geomReduce"), Ml(Bl, "flattenEach"), Ml(ql, "flattenReduce"), Ml(Vl, "segmentEach"), Ml(Gl, "segmentReduce"), Ml(Yl, "lineEach"), Ml(zl, "lineReduce"), Ml(Ul, "findSegment"), Ml(Xl, "findPoint"); var Wl = Object.freeze({ __proto__: null, coordAll: Dl, coordEach: Ol, coordReduce: Ll, featureEach: Tl, featureReduce: Al, findPoint: Xl, findSegment: Ul, flattenEach: Bl, flattenReduce: ql, geomEach: jl, geomReduce: Fl, lineEach: Yl, lineReduce: zl, propEach: Rl, propReduce: Cl, segmentEach: Vl, segmentReduce: Gl }), Hl = Object.defineProperty, Zl = function (t, e) { return Hl(t, "name", { value: e, configurable: !0 }) }; function Jl(t) { return Fl(t, (function (t, e) { return t + $l(e) }), 0) } function $l(t) { var e, n = 0; switch (t.type) { case "Polygon": return Ql(t.coordinates); case "MultiPolygon": for (e = 0; e < t.coordinates.length; e++)n += Ql(t.coordinates[e]); return n; case "Point": case "MultiPoint": case "LineString": case "MultiLineString": return 0 }return 0 } function Ql(t) { var e = 0; if (t && t.length > 0) { e += Math.abs(ec(t[0])); for (var n = 1; n < t.length; n++)e -= Math.abs(ec(t[n])) } return e } Zl(Jl, "area"), Zl($l, "calculateArea"), Zl(Ql, "polygonArea"); var Kl = Iu * Iu / 2, tc = Math.PI / 180; function ec(t) { var e = t.length; if (e <= 2) return 0; for (var n = 0, r = 0; r < e;) { var i = t[r], o = t[r + 1 === e ? 0 : r + 1], a = t[r + 2 >= e ? (r + 2) % e : r + 2], s = i[0] * tc, u = o[1] * tc; n += (a[0] * tc - s) * Math.sin(u), r++ } return n * Kl } Zl(ec, "ringArea"); var nc = Object.defineProperty; function rc(t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (null != t.bbox && !0 !== e.recompute) return t.bbox; var n = [1 / 0, 1 / 0, -1 / 0, -1 / 0]; return Ol(t, (function (t) { n[0] > t[0] && (n[0] = t[0]), n[1] > t[1] && (n[1] = t[1]), n[2] < t[0] && (n[2] = t[0]), n[3] < t[1] && (n[3] = t[1]) })), n } !function (t, e) { nc(t, "name", { value: e, configurable: !0 }) }(rc, "bbox"); var ic = Object.defineProperty, oc = function (t, e) { return ic(t, "name", { value: e, configurable: !0 }) }; function ac(t, e, n) { var r, i, o, a, s, u = t.length, l = lc(t[0], e), c = []; for (n || (n = []), r = 1; r < u; r++) { for (a = t[r - 1], i = o = lc(s = t[r], e); ;) { if (!(l | i)) { c.push(a), i !== o ? (c.push(s), r < u - 1 && (n.push(c), c = [])) : r === u - 1 && c.push(s); break } if (l & i) break; l ? l = lc(a = uc(a, s, l, e), e) : i = lc(s = uc(a, s, i, e), e) } l = o } return c.length && n.push(c), n } function sc(t, e) { var n, r, i, o, a, s, u; for (r = 1; r <= 8; r *= 2) { for (n = [], o = !(lc(i = t[t.length - 1], e) & r), a = 0; a < t.length; a++)(u = !(lc(s = t[a], e) & r)) !== o && n.push(uc(i, s, r, e)), u && n.push(s), i = s, o = u; if (!(t = n).length) break } return n } function uc(t, e, n, r) { return 8 & n ? [t[0] + (e[0] - t[0]) * (r[3] - t[1]) / (e[1] - t[1]), r[3]] : 4 & n ? [t[0] + (e[0] - t[0]) * (r[1] - t[1]) / (e[1] - t[1]), r[1]] : 2 & n ? [r[2], t[1] + (e[1] - t[1]) * (r[2] - t[0]) / (e[0] - t[0])] : 1 & n ? [r[0], t[1] + (e[1] - t[1]) * (r[0] - t[0]) / (e[0] - t[0])] : null } function lc(t, e) { var n = 0; return t[0] < e[0] ? n |= 1 : t[0] > e[2] && (n |= 2), t[1] < e[1] ? n |= 4 : t[1] > e[3] && (n |= 8), n } function cc(t, e) { var n = cl(t), r = n.type, i = "Feature" === t.type ? t.properties : {}, o = n.coordinates; switch (r) { case "LineString": case "MultiLineString": var a = []; return "LineString" === r && (o = [o]), o.forEach((function (t) { ac(t, e, a) })), 1 === a.length ? Au(a[0], i) : Fu(a, i); case "Polygon": return Cu(hc(o, e), i); case "MultiPolygon": return qu(o.map((function (t) { return hc(t, e) })), i); default: throw new Error("geometry " + r + " not supported") } } function hc(t, e) { var n, r = [], i = c(t); try { for (i.s(); !(n = i.n()).done;) { var o = sc(n.value, e); o.length > 0 && (o[0][0] === o[o.length - 1][0] && o[0][1] === o[o.length - 1][1] || o.push(o[0]), o.length >= 4 && r.push(o)) } } catch (t) { i.e(t) } finally { i.f() } return r } oc(ac, "lineclip"), oc(sc, "polygonclip"), oc(uc, "intersect"), oc(lc, "bitCode"), oc(cc, "bboxClip"), oc(hc, "clipPolygon"); var fc = Object.defineProperty; function pc(t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = Number(t[0]), r = Number(t[1]), i = Number(t[2]), o = Number(t[3]); if (6 === t.length) throw new Error("@turf/bbox-polygon does not support BBox with 6 positions"); var a = [n, r]; return Cu([[a, [i, r], [i, o], [n, o], a]], e.properties, { bbox: t, id: e.id }) } !function (t, e) { fc(t, "name", { value: e, configurable: !0 }) }(pc, "bboxPolygon"); var gc = Object.defineProperty, yc = function (t, e) { return gc(t, "name", { value: e, configurable: !0 }) }, vc = function () { function t(e) { n(this, t), this.points = e.points || [], this.duration = e.duration || 1e4, this.sharpness = e.sharpness || .85, this.centers = [], this.controls = [], this.stepLength = e.stepLength || 60, this.length = this.points.length, this.delay = 0; for (var r = 0; r < this.length; r++)this.points[r].z = this.points[r].z || 0; for (var i = 0; i < this.length - 1; i++) { var o = this.points[i], a = this.points[i + 1]; this.centers.push({ x: (o.x + a.x) / 2, y: (o.y + a.y) / 2, z: (o.z + a.z) / 2 }) } this.controls.push([this.points[0], this.points[0]]); for (var s = 0; s < this.centers.length - 1; s++) { var u = this.points[s + 1].x - (this.centers[s].x + this.centers[s + 1].x) / 2, l = this.points[s + 1].y - (this.centers[s].y + this.centers[s + 1].y) / 2, c = this.points[s + 1].z - (this.centers[s].y + this.centers[s + 1].z) / 2; this.controls.push([{ x: (1 - this.sharpness) * this.points[s + 1].x + this.sharpness * (this.centers[s].x + u), y: (1 - this.sharpness) * this.points[s + 1].y + this.sharpness * (this.centers[s].y + l), z: (1 - this.sharpness) * this.points[s + 1].z + this.sharpness * (this.centers[s].z + c) }, { x: (1 - this.sharpness) * this.points[s + 1].x + this.sharpness * (this.centers[s + 1].x + u), y: (1 - this.sharpness) * this.points[s + 1].y + this.sharpness * (this.centers[s + 1].y + l), z: (1 - this.sharpness) * this.points[s + 1].z + this.sharpness * (this.centers[s + 1].z + c) }]) } return this.controls.push([this.points[this.length - 1], this.points[this.length - 1]]), this.steps = this.cacheSteps(this.stepLength), this } return i(t, [{ key: "cacheSteps", value: function (t) { var e = [], n = this.pos(0); e.push(0); for (var r = 0; r < this.duration; r += 10) { var i = this.pos(r); Math.sqrt((i.x - n.x) * (i.x - n.x) + (i.y - n.y) * (i.y - n.y) + (i.z - n.z) * (i.z - n.z)) > t && (e.push(r), n = i) } return e } }, { key: "vector", value: function (t) { var e = this.pos(t + 10), n = this.pos(t - 10); return { angle: 180 * Math.atan2(e.y - n.y, e.x - n.x) / 3.14, speed: Math.sqrt((n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y) + (n.z - e.z) * (n.z - e.z)) } } }, { key: "pos", value: function (t) { var e = t - this.delay; e < 0 && (e = 0), e > this.duration && (e = this.duration - 1); var n = e / this.duration; if (n >= 1) return this.points[this.length - 1]; var r = Math.floor((this.points.length - 1) * n); return mc((this.length - 1) * n - r, this.points[r], this.controls[r][1], this.controls[r + 1][0], this.points[r + 1]) } }]), t }(); yc(vc, "Spline"); var dc = vc; function mc(t, e, n, r, i) { var o = _c(t); return { x: i.x * o[0] + r.x * o[1] + n.x * o[2] + e.x * o[3], y: i.y * o[0] + r.y * o[1] + n.y * o[2] + e.y * o[3], z: i.z * o[0] + r.z * o[1] + n.z * o[2] + e.z * o[3] } } function _c(t) { var e = t * t; return [e * t, 3 * e * (1 - t), 3 * t * (1 - t) * (1 - t), (1 - t) * (1 - t) * (1 - t)] } function bc(t) { for (var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = e.resolution || 1e4, r = e.sharpness || .85, i = [], o = cl(t).coordinates.map((function (t) { return { x: t[0], y: t[1] } })), a = new dc({ duration: n, points: o, sharpness: r }), s = yc((function (t) { var e = a.pos(t); Math.floor(t / 100) % 2 == 0 && i.push([e.x, e.y]) }), "pushCoord"), u = 0; u < a.duration; u += 10)s(u); return s(a.duration), Au(i, e.properties) } yc(mc, "bezier"), yc(_c, "B"), yc(bc, "bezierSpline"); var xc = Object.defineProperty; function Ec(t) { for (var e, n, r = ol(t), i = 0, o = 1; o < r.length;)e = n || r[0], i += ((n = r[o])[0] - e[0]) * (n[1] + e[1]), o++; return i > 0 } !function (t, e) { xc(t, "name", { value: e, configurable: !0 }) }(Ec, "booleanClockwise"); var wc = Object.defineProperty; function kc(t) { var e = cl(t).coordinates; if (e[0].length <= 4) return !1; for (var n = !1, r = e[0].length - 1, i = 0; i < r; i++) { var o = e[0][(i + 2) % r][0] - e[0][(i + 1) % r][0], a = e[0][(i + 2) % r][1] - e[0][(i + 1) % r][1], s = e[0][i][0] - e[0][(i + 1) % r][0], u = o * (e[0][i][1] - e[0][(i + 1) % r][1]) - a * s; if (0 === i) n = u > 0; else if (n !== u > 0) return !0 } return !1 } function Sc(t, e) { for (var n = 0, r = 0, i = 0, o = 0, a = 0, s = 0, u = 0, l = 0, c = null, h = null, f = t[0], p = t[1], g = e.length; n < g; n++) { r = 0; var y = e[n].length - 1, v = e[n]; if ((c = v[0])[0] !== v[y][0] && c[1] !== v[y][1]) throw new Error("First and last coordinates in a ring must be the same"); for (a = c[0] - f, s = c[1] - p; r < y; r++)if (l = (h = v[r + 1])[1] - p, s < 0 && l < 0 || s > 0 && l > 0) s = l, a = (c = h)[0] - f; else { if (u = h[0] - t[0], l > 0 && s <= 0) { if ((o = a * l - u * s) > 0) i += 1; else if (0 === o) return 0 } else if (s > 0 && l <= 0) { if ((o = a * l - u * s) < 0) i += 1; else if (0 === o) return 0 } else if (0 === l && s < 0) { if (0 === (o = a * l - u * s)) return 0 } else if (0 === s && l < 0) { if (0 === (o = a * l - u * s)) return 0 } else if (0 === s && 0 === l) { if (u <= 0 && a >= 0) return 0; if (a <= 0 && u >= 0) return 0 } c = h, s = l, a = u } } return i % 2 != 0 } !function (t, e) { wc(t, "name", { value: e, configurable: !0 }) }(kc, "booleanConcave"); var Ic = Object.defineProperty, Pc = function (t, e) { return Ic(t, "name", { value: e, configurable: !0 }) }; function Nc(t, e) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; if (!t) throw new Error("point is required"); if (!e) throw new Error("polygon is required"); var r = il(t), i = cl(e), o = i.type, a = e.bbox, s = i.coordinates; if (a && !1 === Mc(r, a)) return !1; "Polygon" === o && (s = [s]); for (var u = !1, l = 0; l < s.length; ++l) { var c = Sc(r, s[l]); if (0 === c) return !n.ignoreBoundary; c && (u = !0) } return u } function Mc(t, e) { return e[0] <= t[0] && e[1] <= t[1] && e[2] >= t[0] && e[3] >= t[1] } Pc(Nc, "booleanPointInPolygon"), Pc(Mc, "inBBox"); var Oc = Object.defineProperty, Lc = function (t, e) { return Oc(t, "name", { value: e, configurable: !0 }) }; function Rc(t, e) { for (var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r = il(t), i = ol(e), o = 0; o < i.length - 1; o++) { var a = !1; if (n.ignoreEndVertices && (0 === o && (a = "start"), o === i.length - 2 && (a = "end"), 0 === o && o + 1 === i.length - 1 && (a = "both")), Cc(i[o], i[o + 1], r, a, void 0 === n.epsilon ? null : n.epsilon)) return !0 } return !1 } function Cc(t, e, n, r, i) { var o = n[0], a = n[1], s = t[0], u = t[1], l = e[0], c = e[1], h = l - s, f = c - u, p = (n[0] - s) * f - (n[1] - u) * h; if (null !== i) { if (Math.abs(p) > i) return !1 } else if (0 !== p) return !1; return r ? "start" === r ? Math.abs(h) >= Math.abs(f) ? h > 0 ? s < o && o <= l : l <= o && o < s : f > 0 ? u < a && a <= c : c <= a && a < u : "end" === r ? Math.abs(h) >= Math.abs(f) ? h > 0 ? s <= o && o < l : l < o && o <= s : f > 0 ? u <= a && a < c : c < a && a <= u : "both" === r && (Math.abs(h) >= Math.abs(f) ? h > 0 ? s < o && o < l : l < o && o < s : f > 0 ? u < a && a < c : c < a && a < u) : Math.abs(h) >= Math.abs(f) ? h > 0 ? s <= o && o <= l : l <= o && o <= s : f > 0 ? u <= a && a <= c : c <= a && a <= u } Lc(Rc, "booleanPointOnLine"), Lc(Cc, "isPointOnLineSegment"); var Tc = Object.defineProperty, Ac = function (t, e) { return Tc(t, "name", { value: e, configurable: !0 }) }; function Dc(t, e) { var n = cl(t), r = cl(e), i = n.type, o = r.type, a = n.coordinates, s = r.coordinates; switch (i) { case "Point": if ("Point" === o) return Xc(a, s); throw new Error("feature2 " + o + " geometry not supported"); case "MultiPoint": switch (o) { case "Point": return Fc(n, r); case "MultiPoint": return Bc(n, r); default: throw new Error("feature2 " + o + " geometry not supported") }case "LineString": switch (o) { case "Point": return Rc(r, n, { ignoreEndVertices: !0 }); case "LineString": return Gc(n, r); case "MultiPoint": return qc(n, r); default: throw new Error("feature2 " + o + " geometry not supported") }case "Polygon": switch (o) { case "Point": return Nc(r, n, { ignoreBoundary: !0 }); case "LineString": return Yc(n, r); case "Polygon": return zc(n, r); case "MultiPoint": return Vc(n, r); default: throw new Error("feature2 " + o + " geometry not supported") }case "MultiPolygon": if ("Polygon" === o) return jc(n, r); throw new Error("feature2 " + o + " geometry not supported"); default: throw new Error("feature1 " + i + " geometry not supported") } } function jc(t, e) { return t.coordinates.some((function (t) { return zc({ type: "Polygon", coordinates: t }, e) })) } function Fc(t, e) { var n, r = !1; for (n = 0; n < t.coordinates.length; n++)if (Xc(t.coordinates[n], e.coordinates)) { r = !0; break } return r } function Bc(t, e) { var n, r = c(e.coordinates); try { for (r.s(); !(n = r.n()).done;) { var i, o = n.value, a = !1, s = c(t.coordinates); try { for (s.s(); !(i = s.n()).done;) { if (Xc(o, i.value)) { a = !0; break } } } catch (t) { s.e(t) } finally { s.f() } if (!a) return !1 } } catch (t) { r.e(t) } finally { r.f() } return !0 } function qc(t, e) { var n, r = !1, i = c(e.coordinates); try { for (i.s(); !(n = i.n()).done;) { var o = n.value; if (Rc(o, t, { ignoreEndVertices: !0 }) && (r = !0), !Rc(o, t)) return !1 } } catch (t) { i.e(t) } finally { i.f() } return !!r } function Vc(t, e) { var n, r = c(e.coordinates); try { for (r.s(); !(n = r.n()).done;) { if (!Nc(n.value, t, { ignoreBoundary: !0 })) return !1 } } catch (t) { r.e(t) } finally { r.f() } return !0 } function Gc(t, e) { var n, r = !1, i = c(e.coordinates); try { for (i.s(); !(n = i.n()).done;) { var o = n.value; if (Rc({ type: "Point", coordinates: o }, t, { ignoreEndVertices: !0 }) && (r = !0), !Rc({ type: "Point", coordinates: o }, t, { ignoreEndVertices: !1 })) return !1 } } catch (t) { i.e(t) } finally { i.f() } return r } function Yc(t, e) { var n = !1, r = 0; if (!Uc(rc(t), rc(e))) return !1; for (; r < e.coordinates.length - 1; r++) { if (Nc({ type: "Point", coordinates: Wc(e.coordinates[r], e.coordinates[r + 1]) }, t, { ignoreBoundary: !0 })) { n = !0; break } } return n } function zc(t, e) { if ("Feature" === t.type && null === t.geometry) return !1; if ("Feature" === e.type && null === e.geometry) return !1; if (!Uc(rc(t), rc(e))) return !1; var n, r = c(cl(e).coordinates); try { for (r.s(); !(n = r.n()).done;) { var i, o = c(n.value); try { for (o.s(); !(i = o.n()).done;) { if (!Nc(i.value, t)) return !1 } } catch (t) { o.e(t) } finally { o.f() } } } catch (t) { r.e(t) } finally { r.f() } return !0 } function Uc(t, e) { return !(t[0] > e[0]) && (!(t[2] < e[2]) && (!(t[1] > e[1]) && !(t[3] < e[3]))) } function Xc(t, e) { return t[0] === e[0] && t[1] === e[1] } function Wc(t, e) { return [(t[0] + e[0]) / 2, (t[1] + e[1]) / 2] } Ac(Dc, "booleanContains"), Ac(jc, "isPolygonInMultiPolygon"), Ac(Fc, "isPointInMultiPoint"), Ac(Bc, "isMultiPointInMultiPoint"), Ac(qc, "isMultiPointOnLine"), Ac(Vc, "isMultiPointInPoly"), Ac(Gc, "isLineOnLine"), Ac(Yc, "isLineInPoly"), Ac(zc, "isPolyInPoly"), Ac(Uc, "doBBoxOverlap"), Ac(Xc, "compareCoords"), Ac(Wc, "getMidpoint"); var Hc = function () { function t() { var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Zc; if (n(this, t), this.data = e, this.length = this.data.length, this.compare = r, this.length > 0) for (var i = (this.length >> 1) - 1; i >= 0; i--)this._down(i) } return i(t, [{ key: "push", value: function (t) { this.data.push(t), this.length++, this._up(this.length - 1) } }, { key: "pop", value: function () { if (0 !== this.length) { var t = this.data[0], e = this.data.pop(); return this.length--, this.length > 0 && (this.data[0] = e, this._down(0)), t } } }, { key: "peek", value: function () { return this.data[0] } }, { key: "_up", value: function (t) { for (var e = this.data, n = this.compare, r = e[t]; t > 0;) { var i = t - 1 >> 1, o = e[i]; if (n(r, o) >= 0) break; e[t] = o, t = i } e[t] = r } }, { key: "_down", value: function (t) { for (var e = this.data, n = this.compare, r = this.length >> 1, i = e[t]; t < r;) { var o = 1 + (t << 1), a = e[o], s = o + 1; if (s < this.length && n(e[s], a) < 0 && (o = s, a = e[s]), n(a, i) >= 0) break; e[t] = a, t = o } e[t] = i } }]), t }(); function Zc(t, e) { return t < e ? -1 : t > e ? 1 : 0 } function Jc(t, e) { return t.p.x > e.p.x ? 1 : t.p.x < e.p.x ? -1 : t.p.y !== e.p.y ? t.p.y > e.p.y ? 1 : -1 : 1 } function $c(t, e) { return t.rightSweepEvent.p.x > e.rightSweepEvent.p.x ? 1 : t.rightSweepEvent.p.x < e.rightSweepEvent.p.x ? -1 : t.rightSweepEvent.p.y !== e.rightSweepEvent.p.y ? t.rightSweepEvent.p.y < e.rightSweepEvent.p.y ? 1 : -1 : 1 } var Qc = function () { function t(e, r, i, o) { n(this, t), this.p = { x: e[0], y: e[1] }, this.featureId = r, this.ringId = i, this.eventId = o, this.otherEvent = null, this.isLeftEndpoint = null } return i(t, [{ key: "isSamePoint", value: function (t) { return this.p.x === t.p.x && this.p.y === t.p.y } }]), t }(); var Kc = 0, th = 0, eh = 0; function nh(t, e) { var n = "Feature" === t.type ? t.geometry : t, r = n.coordinates; "Polygon" !== n.type && "MultiLineString" !== n.type || (r = [r]), "LineString" === n.type && (r = [[r]]); for (var i = 0; i < r.length; i++)for (var o = 0; o < r[i].length; o++) { var a = r[i][o][0], s = null; th += 1; for (var u = 0; u < r[i][o].length - 1; u++) { s = r[i][o][u + 1]; var l = new Qc(a, Kc, th, eh), c = new Qc(s, Kc, th, eh + 1); l.otherEvent = c, c.otherEvent = l, Jc(l, c) > 0 ? (c.isLeftEndpoint = !0, l.isLeftEndpoint = !1) : (l.isLeftEndpoint = !0, c.isLeftEndpoint = !1), e.push(l), e.push(c), a = s, eh += 1 } } Kc += 1 } var rh = i((function t(e) { n(this, t), this.leftSweepEvent = e, this.rightSweepEvent = e.otherEvent })); function ih(t, e) { if (null === t || null === e) return !1; if (t.leftSweepEvent.ringId === e.leftSweepEvent.ringId && (t.rightSweepEvent.isSamePoint(e.leftSweepEvent) || t.rightSweepEvent.isSamePoint(e.leftSweepEvent) || t.rightSweepEvent.isSamePoint(e.rightSweepEvent) || t.leftSweepEvent.isSamePoint(e.leftSweepEvent) || t.leftSweepEvent.isSamePoint(e.rightSweepEvent))) return !1; var n = t.leftSweepEvent.p.x, r = t.leftSweepEvent.p.y, i = t.rightSweepEvent.p.x, o = t.rightSweepEvent.p.y, a = e.leftSweepEvent.p.x, s = e.leftSweepEvent.p.y, u = e.rightSweepEvent.p.x, l = e.rightSweepEvent.p.y, c = (l - s) * (i - n) - (u - a) * (o - r), h = (u - a) * (r - s) - (l - s) * (n - a), f = (i - n) * (r - s) - (o - r) * (n - a); if (0 === c) return !1; var p = h / c, g = f / c; return p >= 0 && p <= 1 && g >= 0 && g <= 1 && [n + p * (i - n), r + p * (o - r)] } function oh(t, e) { var n = new Hc([], Jc); return function (t, e) { if ("FeatureCollection" === t.type) for (var n = t.features, r = 0; r < n.length; r++)nh(n[r], e); else nh(t, e) }(t, n), function (t, e) { e = e || !1; for (var n = [], r = new Hc([], $c); t.length;) { var i = t.pop(); if (i.isLeftEndpoint) { for (var o = new rh(i), a = 0; a < r.data.length; a++) { var s = r.data[a]; if (!e || s.leftSweepEvent.featureId !== i.featureId) { var u = ih(o, s); !1 !== u && n.push(u) } } r.push(o) } else !1 === i.isLeftEndpoint && r.pop() } return n }(n, e) } var ah = Object.defineProperty, sh = oh; function uh(t, e) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r = n.removeDuplicates, i = void 0 === r || r, o = n.ignoreSelfIntersections, a = void 0 !== o && o, s = []; "FeatureCollection" === t.type ? s = s.concat(t.features) : "Feature" === t.type ? s.push(t) : "LineString" !== t.type && "Polygon" !== t.type && "MultiLineString" !== t.type && "MultiPolygon" !== t.type || s.push(Mu(t)), "FeatureCollection" === e.type ? s = s.concat(e.features) : "Feature" === e.type ? s.push(e) : "LineString" !== e.type && "Polygon" !== e.type && "MultiLineString" !== e.type && "MultiPolygon" !== e.type || s.push(Mu(e)); var u = sh(ju(s), a), l = []; if (i) { var c = {}; u.forEach((function (t) { var e = t.join(","); c[e] || (c[e] = !0, l.push(t)) })) } else l = u; return ju(l.map((function (t) { return Lu(t) }))) } !function (t, e) { ah(t, "name", { value: e, configurable: !0 }) }(uh, "lineIntersect"); var lh = Object.defineProperty, ch = function (t, e) { return lh(t, "name", { value: e, configurable: !0 }) }; function hh(t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = cl(t); switch (e.properties || "Feature" !== t.type || (e.properties = t.properties), n.type) { case "Polygon": return fh(n, e); case "MultiPolygon": return ph(n, e); default: throw new Error("invalid poly") } } function fh(t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; return gh(cl(t).coordinates, e.properties ? e.properties : "Feature" === t.type ? t.properties : {}) } function ph(t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = cl(t).coordinates, r = e.properties ? e.properties : "Feature" === t.type ? t.properties : {}, i = []; return n.forEach((function (t) { i.push(gh(t, r)) })), ju(i) } function gh(t, e) { return t.length > 1 ? Fu(t, e) : Au(t[0], e) } ch(hh, "polygonToLine"), ch(fh, "singlePolygonToLine"), ch(ph, "multiPolygonToLine"), ch(gh, "coordsToLine"); var yh = Object.defineProperty, vh = function (t, e) { return yh(t, "name", { value: e, configurable: !0 }) }; function dh(t, e) { var n = cl(t), r = cl(e), i = n.type, o = r.type; switch (i) { case "MultiPoint": switch (o) { case "LineString": return mh(n, r); case "Polygon": return xh(n, r); default: throw new Error("feature2 " + o + " geometry not supported") }case "LineString": switch (o) { case "MultiPoint": return mh(r, n); case "LineString": return _h(n, r); case "Polygon": return bh(n, r); default: throw new Error("feature2 " + o + " geometry not supported") }case "Polygon": switch (o) { case "MultiPoint": return xh(r, n); case "LineString": return bh(r, n); default: throw new Error("feature2 " + o + " geometry not supported") }default: throw new Error("feature1 " + i + " geometry not supported") } } function mh(t, e) { for (var n = !1, r = !1, i = t.coordinates.length, o = 0; o < i && !n && !r;) { for (var a = 0; a < e.coordinates.length - 1; a++) { var s = !0; 0 !== a && a !== e.coordinates.length - 2 || (s = !1), Eh(e.coordinates[a], e.coordinates[a + 1], t.coordinates[o], s) ? n = !0 : r = !0 } o++ } return n && r } function _h(t, e) { if (uh(t, e).features.length > 0) for (var n = 0; n < t.coordinates.length - 1; n++)for (var r = 0; r < e.coordinates.length - 1; r++) { var i = !0; if (0 !== r && r !== e.coordinates.length - 2 || (i = !1), Eh(t.coordinates[n], t.coordinates[n + 1], e.coordinates[r], i)) return !0 } return !1 } function bh(t, e) { return uh(t, hh(e)).features.length > 0 } function xh(t, e) { for (var n = !1, r = !1, i = t.coordinates.length, o = 0; o < i && (!n || !r); o++)Nc(Lu(t.coordinates[o]), e) ? n = !0 : r = !0; return r && n } function Eh(t, e, n, r) { var i = n[0] - t[0], o = n[1] - t[1], a = e[0] - t[0], s = e[1] - t[1]; return 0 == i * s - o * a && (r ? Math.abs(a) >= Math.abs(s) ? a > 0 ? t[0] <= n[0] && n[0] <= e[0] : e[0] <= n[0] && n[0] <= t[0] : s > 0 ? t[1] <= n[1] && n[1] <= e[1] : e[1] <= n[1] && n[1] <= t[1] : Math.abs(a) >= Math.abs(s) ? a > 0 ? t[0] < n[0] && n[0] < e[0] : e[0] < n[0] && n[0] < t[0] : s > 0 ? t[1] < n[1] && n[1] < e[1] : e[1] < n[1] && n[1] < t[1]) } vh(dh, "booleanCrosses"), vh(mh, "doMultiPointAndLineStringCross"), vh(_h, "doLineStringsCross"), vh(bh, "doLineStringAndPolygonCross"), vh(xh, "doesMultiPointCrossPoly"), vh(Eh, "isPointOnLineSegment"); var wh = Object.defineProperty, kh = function (t, e) { return wh(t, "name", { value: e, configurable: !0 }) }; function Sh(t, e) { var n = !0; return Bl(t, (function (t) { Bl(e, (function (e) { if (!1 === n) return !1; n = Ih(t.geometry, e.geometry) })) })), n } function Ih(t, e) { switch (t.type) { case "Point": switch (e.type) { case "Point": return !Rh(t.coordinates, e.coordinates); case "LineString": return !Ph(e, t); case "Polygon": return !Nc(t, e) }break; case "LineString": switch (e.type) { case "Point": return !Ph(t, e); case "LineString": return !Nh(t, e); case "Polygon": return !Mh(e, t) }break; case "Polygon": switch (e.type) { case "Point": return !Nc(e, t); case "LineString": return !Mh(t, e); case "Polygon": return !Oh(e, t) } }return !1 } function Ph(t, e) { for (var n = 0; n < t.coordinates.length - 1; n++)if (Lh(t.coordinates[n], t.coordinates[n + 1], e.coordinates)) return !0; return !1 } function Nh(t, e) { return uh(t, e).features.length > 0 } function Mh(t, e) { var n, r = c(e.coordinates); try { for (r.s(); !(n = r.n()).done;) { if (Nc(n.value, t)) return !0 } } catch (t) { r.e(t) } finally { r.f() } return uh(e, hh(t)).features.length > 0 } function Oh(t, e) { var n, r = c(t.coordinates[0]); try { for (r.s(); !(n = r.n()).done;) { if (Nc(n.value, e)) return !0 } } catch (t) { r.e(t) } finally { r.f() } var i, o = c(e.coordinates[0]); try { for (o.s(); !(i = o.n()).done;) { if (Nc(i.value, t)) return !0 } } catch (t) { o.e(t) } finally { o.f() } return uh(hh(t), hh(e)).features.length > 0 } function Lh(t, e, n) { var r = n[0] - t[0], i = n[1] - t[1], o = e[0] - t[0], a = e[1] - t[1]; return 0 == r * a - i * o && (Math.abs(o) >= Math.abs(a) ? o > 0 ? t[0] <= n[0] && n[0] <= e[0] : e[0] <= n[0] && n[0] <= t[0] : a > 0 ? t[1] <= n[1] && n[1] <= e[1] : e[1] <= n[1] && n[1] <= t[1]) } function Rh(t, e) { return t[0] === e[0] && t[1] === e[1] } kh(Sh, "booleanDisjoint"), kh(Ih, "disjoint"), kh(Ph, "isPointOnLine"), kh(Nh, "isLineOnLine"), kh(Mh, "isLineInPoly"), kh(Oh, "isPolyInPoly"), kh(Lh, "isPointOnLineSegment"), kh(Rh, "compareCoords"); var Ch = Object.defineProperty, Th = function (t, e) { return Ch(t, "name", { value: e, configurable: !0 }) }; function Ah(t) { var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r = "object" === e(n) ? n.mutate : n; if (!t) throw new Error("geojson is required"); var i = hl(t), o = []; switch (i) { case "LineString": o = Dh(t, i); break; case "MultiLineString": case "Polygon": ol(t).forEach((function (t) { o.push(Dh(t, i)) })); break; case "MultiPolygon": ol(t).forEach((function (t) { var e = []; t.forEach((function (t) { e.push(Dh(t, i)) })), o.push(e) })); break; case "Point": return t; case "MultiPoint": var a = {}; ol(t).forEach((function (t) { var e = t.join("-"); Object.prototype.hasOwnProperty.call(a, e) || (o.push(t), a[e] = !0) })); break; default: throw new Error(i + " geometry not supported") }return t.coordinates ? !0 === r ? (t.coordinates = o, t) : { type: i, coordinates: o } : !0 === r ? (t.geometry.coordinates = o, t) : Mu({ type: i, coordinates: o }, t.properties, { bbox: t.bbox, id: t.id }) } function Dh(t, e) { var n = ol(t); if (2 === n.length && !jh(n[0], n[1])) return n; var r = [], i = n.length - 1, o = r.length; r.push(n[0]); for (var a = 1; a < i; a++) { var s = r[r.length - 1]; n[a][0] === s[0] && n[a][1] === s[1] || (r.push(n[a]), (o = r.length) > 2 && Fh(r[o - 3], r[o - 1], r[o - 2]) && r.splice(r.length - 2, 1)) } if (r.push(n[n.length - 1]), o = r.length, ("Polygon" === e || "MultiPolygon" === e) && jh(n[0], n[n.length - 1]) && o < 4) throw new Error("invalid polygon"); return "LineString" === e && o < 3 || Fh(r[o - 3], r[o - 1], r[o - 2]) && r.splice(r.length - 2, 1), r } function jh(t, e) { return t[0] === e[0] && t[1] === e[1] } function Fh(t, e, n) { var r = n[0], i = n[1], o = t[0], a = t[1], s = e[0], u = e[1], l = s - o, c = u - a; return 0 === (r - o) * c - (i - a) * l && (Math.abs(l) >= Math.abs(c) ? l > 0 ? o <= r && r <= s : s <= r && r <= o : c > 0 ? a <= i && i <= u : u <= i && i <= a) } Th(Ah, "cleanCoords"), Th(Dh, "cleanLine"), Th(jh, "equals"), Th(Fh, "isPointOnLineSegment"); var Bh = Object.defineProperty; function qh(t, e) { var n = (arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}).precision; if ("number" != typeof (n = null == n || isNaN(n) ? 6 : n) || !(n >= 0)) throw new Error("precision must be a positive number"); return cl(t).type === cl(e).type && new wu({ precision: n }).compare(Ah(t), Ah(e)) } !function (t, e) { Bh(t, "name", { value: e, configurable: !0 }) }(qh, "booleanEqual"); var Vh = Object.defineProperty; function Gh(t, e) { var n = !1; return Bl(t, (function (t) { Bl(e, (function (e) { if (!0 === n) return !0; n = !Sh(t.geometry, e.geometry) })) })), n } function Yh(t, e, n, r, i) { zh(t, e, n || 0, r || t.length - 1, i || Xh) } function zh(t, e, n, r, i) { for (; r > n;) { if (r - n > 600) { var o = r - n + 1, a = e - n + 1, s = Math.log(o), u = .5 * Math.exp(2 * s / 3), l = .5 * Math.sqrt(s * u * (o - u) / o) * (a - o / 2 < 0 ? -1 : 1); zh(t, e, Math.max(n, Math.floor(e - a * u / o + l)), Math.min(r, Math.floor(e + (o - a) * u / o + l)), i) } var c = t[e], h = n, f = r; for (Uh(t, n, e), i(t[r], c) > 0 && Uh(t, n, r); h < f;) { for (Uh(t, h, f), h++, f--; i(t[h], c) < 0;)h++; for (; i(t[f], c) > 0;)f-- } 0 === i(t[n], c) ? Uh(t, n, f) : Uh(t, ++f, r), f <= e && (n = f + 1), e <= f && (r = f - 1) } } function Uh(t, e, n) { var r = t[e]; t[e] = t[n], t[n] = r } function Xh(t, e) { return t < e ? -1 : t > e ? 1 : 0 } !function (t, e) { Vh(t, "name", { value: e, configurable: !0 }) }(Gh, "booleanIntersects"); var Wh = function () { function t() { var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 9; n(this, t), this._maxEntries = Math.max(4, e), this._minEntries = Math.max(2, Math.ceil(.4 * this._maxEntries)), this.clear() } return i(t, [{ key: "all", value: function () { return this._all(this.data, []) } }, { key: "search", value: function (t) { var e = this.data, n = []; if (!rf(t, e)) return n; for (var r = this.toBBox, i = []; e;) { for (var o = 0; o < e.children.length; o++) { var a = e.children[o], s = e.leaf ? r(a) : a; rf(t, s) && (e.leaf ? n.push(a) : nf(t, s) ? this._all(a, n) : i.push(a)) } e = i.pop() } return n } }, { key: "collides", value: function (t) { var e = this.data; if (!rf(t, e)) return !1; for (var n = []; e;) { for (var r = 0; r < e.children.length; r++) { var i = e.children[r], o = e.leaf ? this.toBBox(i) : i; if (rf(t, o)) { if (e.leaf || nf(t, o)) return !0; n.push(i) } } e = n.pop() } return !1 } }, { key: "load", value: function (t) { if (!t || !t.length) return this; if (t.length < this._minEntries) { for (var e = 0; e < t.length; e++)this.insert(t[e]); return this } var n = this._build(t.slice(), 0, t.length - 1, 0); if (this.data.children.length) if (this.data.height === n.height) this._splitRoot(this.data, n); else { if (this.data.height < n.height) { var r = this.data; this.data = n, n = r } this._insert(n, this.data.height - n.height - 1, !0) } else this.data = n; return this } }, { key: "insert", value: function (t) { return t && this._insert(t, this.data.height - 1), this } }, { key: "clear", value: function () { return this.data = of([]), this } }, { key: "remove", value: function (t, e) { if (!t) return this; for (var n, r, i, o = this.data, a = this.toBBox(t), s = [], u = []; o || s.length;) { if (o || (o = s.pop(), r = s[s.length - 1], n = u.pop(), i = !0), o.leaf) { var l = Hh(t, o.children, e); if (-1 !== l) return o.children.splice(l, 1), s.push(o), this._condense(s), this } i || o.leaf || !nf(o, a) ? r ? (n++, o = r.children[n], i = !1) : o = null : (s.push(o), u.push(n), n = 0, r = o, o = o.children[0]) } return this } }, { key: "toBBox", value: function (t) { return t } }, { key: "compareMinX", value: function (t, e) { return t.minX - e.minX } }, { key: "compareMinY", value: function (t, e) { return t.minY - e.minY } }, { key: "toJSON", value: function () { return this.data } }, { key: "fromJSON", value: function (t) { return this.data = t, this } }, { key: "_all", value: function (t, e) { for (var n = []; t;)t.leaf ? e.push.apply(e, s(t.children)) : n.push.apply(n, s(t.children)), t = n.pop(); return e } }, { key: "_build", value: function (t, e, n, r) { var i, o = n - e + 1, a = this._maxEntries; if (o <= a) return Zh(i = of(t.slice(e, n + 1)), this.toBBox), i; r || (r = Math.ceil(Math.log(o) / Math.log(a)), a = Math.ceil(o / Math.pow(a, r - 1))), (i = of([])).leaf = !1, i.height = r; var s = Math.ceil(o / a), u = s * Math.ceil(Math.sqrt(a)); af(t, e, n, u, this.compareMinX); for (var l = e; l <= n; l += u) { var c = Math.min(l + u - 1, n); af(t, l, c, s, this.compareMinY); for (var h = l; h <= c; h += s) { var f = Math.min(h + s - 1, c); i.children.push(this._build(t, h, f, r - 1)) } } return Zh(i, this.toBBox), i } }, { key: "_chooseSubtree", value: function (t, e, n, r) { for (; r.push(e), !e.leaf && r.length - 1 !== n;) { for (var i = 1 / 0, o = 1 / 0, a = void 0, s = 0; s < e.children.length; s++) { var u = e.children[s], l = tf(u), c = (h = t, f = u, (Math.max(f.maxX, h.maxX) - Math.min(f.minX, h.minX)) * (Math.max(f.maxY, h.maxY) - Math.min(f.minY, h.minY)) - l); c < o ? (o = c, i = l < i ? l : i, a = u) : c === o && l < i && (i = l, a = u) } e = a || e.children[0] } var h, f; return e } }, { key: "_insert", value: function (t, e, n) { var r = n ? t : this.toBBox(t), i = [], o = this._chooseSubtree(r, this.data, e, i); for (o.children.push(t), $h(o, r); e >= 0 && i[e].children.length > this._maxEntries;)this._split(i, e), e--; this._adjustParentBBoxes(r, i, e) } }, { key: "_split", value: function (t, e) { var n = t[e], r = n.children.length, i = this._minEntries; this._chooseSplitAxis(n, i, r); var o = this._chooseSplitIndex(n, i, r), a = of(n.children.splice(o, n.children.length - o)); a.height = n.height, a.leaf = n.leaf, Zh(n, this.toBBox), Zh(a, this.toBBox), e ? t[e - 1].children.push(a) : this._splitRoot(n, a) } }, { key: "_splitRoot", value: function (t, e) { this.data = of([t, e]), this.data.height = t.height + 1, this.data.leaf = !1, Zh(this.data, this.toBBox) } }, { key: "_chooseSplitIndex", value: function (t, e, n) { for (var r, i, o, a, s, u, l, c = 1 / 0, h = 1 / 0, f = e; f <= n - e; f++) { var p = Jh(t, 0, f, this.toBBox), g = Jh(t, f, n, this.toBBox), y = (i = p, o = g, a = void 0, s = void 0, u = void 0, l = void 0, a = Math.max(i.minX, o.minX), s = Math.max(i.minY, o.minY), u = Math.min(i.maxX, o.maxX), l = Math.min(i.maxY, o.maxY), Math.max(0, u - a) * Math.max(0, l - s)), v = tf(p) + tf(g); y < c ? (c = y, r = f, h = v < h ? v : h) : y === c && v < h && (h = v, r = f) } return r || n - e } }, { key: "_chooseSplitAxis", value: function (t, e, n) { var r = t.leaf ? this.compareMinX : Qh, i = t.leaf ? this.compareMinY : Kh; this._allDistMargin(t, e, n, r) < this._allDistMargin(t, e, n, i) && t.children.sort(r) } }, { key: "_allDistMargin", value: function (t, e, n, r) { t.children.sort(r); for (var i = this.toBBox, o = Jh(t, 0, e, i), a = Jh(t, n - e, n, i), s = ef(o) + ef(a), u = e; u < n - e; u++) { var l = t.children[u]; $h(o, t.leaf ? i(l) : l), s += ef(o) } for (var c = n - e - 1; c >= e; c--) { var h = t.children[c]; $h(a, t.leaf ? i(h) : h), s += ef(a) } return s } }, { key: "_adjustParentBBoxes", value: function (t, e, n) { for (var r = n; r >= 0; r--)$h(e[r], t) } }, { key: "_condense", value: function (t) { for (var e, n = t.length - 1; n >= 0; n--)0 === t[n].children.length ? n > 0 ? (e = t[n - 1].children).splice(e.indexOf(t[n]), 1) : this.clear() : Zh(t[n], this.toBBox) } }]), t }(); function Hh(t, e, n) { if (!n) return e.indexOf(t); for (var r = 0; r < e.length; r++)if (n(t, e[r])) return r; return -1 } function Zh(t, e) { Jh(t, 0, t.children.length, e, t) } function Jh(t, e, n, r, i) { i || (i = of(null)), i.minX = 1 / 0, i.minY = 1 / 0, i.maxX = -1 / 0, i.maxY = -1 / 0; for (var o = e; o < n; o++) { var a = t.children[o]; $h(i, t.leaf ? r(a) : a) } return i } function $h(t, e) { return t.minX = Math.min(t.minX, e.minX), t.minY = Math.min(t.minY, e.minY), t.maxX = Math.max(t.maxX, e.maxX), t.maxY = Math.max(t.maxY, e.maxY), t } function Qh(t, e) { return t.minX - e.minX } function Kh(t, e) { return t.minY - e.minY } function tf(t) { return (t.maxX - t.minX) * (t.maxY - t.minY) } function ef(t) { return t.maxX - t.minX + (t.maxY - t.minY) } function nf(t, e) { return t.minX <= e.minX && t.minY <= e.minY && e.maxX <= t.maxX && e.maxY <= t.maxY } function rf(t, e) { return e.minX <= t.maxX && e.minY <= t.maxY && e.maxX >= t.minX && e.maxY >= t.minY } function of(t) { return { children: t, height: 1, leaf: !0, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 } } function af(t, e, n, r, i) { for (var o = [e, n]; o.length;)if (!((n = o.pop()) - (e = o.pop()) <= r)) { var a = e + Math.ceil((n - e) / r / 2) * r; Yh(t, a, e, n, i), o.push(e, a, a, n) } } var sf = Object.freeze({ __proto__: null, default: Wh }), uf = Object.defineProperty; function lf(t) { var e = new Wh(t); return e.insert = function (t) { if ("Feature" !== t.type) throw new Error("invalid feature"); return t.bbox = t.bbox ? t.bbox : rc(t), Wh.prototype.insert.call(this, t) }, e.load = function (t) { var e = []; return Array.isArray(t) ? t.forEach((function (t) { if ("Feature" !== t.type) throw new Error("invalid features"); t.bbox = t.bbox ? t.bbox : rc(t), e.push(t) })) : Tl(t, (function (t) { if ("Feature" !== t.type) throw new Error("invalid features"); t.bbox = t.bbox ? t.bbox : rc(t), e.push(t) })), Wh.prototype.load.call(this, e) }, e.remove = function (t, e) { if ("Feature" !== t.type) throw new Error("invalid feature"); return t.bbox = t.bbox ? t.bbox : rc(t), Wh.prototype.remove.call(this, t, e) }, e.clear = function () { return Wh.prototype.clear.call(this) }, e.search = function (t) { return ju(Wh.prototype.search.call(this, this.toBBox(t))) }, e.collides = function (t) { return Wh.prototype.collides.call(this, this.toBBox(t)) }, e.all = function () { return ju(Wh.prototype.all.call(this)) }, e.toJSON = function () { return Wh.prototype.toJSON.call(this) }, e.fromJSON = function (t) { return Wh.prototype.fromJSON.call(this, t) }, e.toBBox = function (t) { var e; if (t.bbox) e = t.bbox; else if (Array.isArray(t) && 4 === t.length) e = t; else if (Array.isArray(t) && 6 === t.length) e = [t[0], t[1], t[3], t[4]]; else if ("Feature" === t.type) e = rc(t); else { if ("FeatureCollection" !== t.type) throw new Error("invalid geojson"); e = rc(t) } return { minX: e[0], minY: e[1], maxX: e[2], maxY: e[3] } }, e } !function (t, e) { uf(t, "name", { value: e, configurable: !0 }) }(lf, "geojsonRbush"); var cf = Object.defineProperty, hf = function (t, e) { return cf(t, "name", { value: e, configurable: !0 }) }; function ff(t) { if (!t) throw new Error("geojson is required"); var e = []; return Bl(t, (function (t) { pf(t, e) })), ju(e) } function pf(t, e) { var n = [], r = t.geometry; if (null !== r) { switch (r.type) { case "Polygon": n = ol(r); break; case "LineString": n = [ol(r)] }n.forEach((function (n) { gf(n, t.properties).forEach((function (t) { t.id = e.length, e.push(t) })) })) } } function gf(t, e) { var n = []; return t.reduce((function (t, r) { var i = Au([t, r], e); return i.bbox = yf(t, r), n.push(i), r })), n } function yf(t, e) { var n = t[0], r = t[1], i = e[0], o = e[1]; return [n < i ? n : i, r < o ? r : o, n > i ? n : i, r > o ? r : o] } hf(ff, "lineSegment"), hf(pf, "lineSegmentFeature"), hf(gf, "createSegments"), hf(yf, "bbox"); var vf = Object.defineProperty, df = Object.defineProperties, mf = Object.getOwnPropertyDescriptors, _f = Object.getOwnPropertySymbols, bf = Object.prototype.hasOwnProperty, xf = Object.prototype.propertyIsEnumerable, Ef = function (t, e, n) { return e in t ? vf(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n }, wf = function (t, e) { for (var n in e || (e = {})) bf.call(e, n) && Ef(t, n, e[n]); if (_f) { var r, i = c(_f(e)); try { for (i.s(); !(r = i.n()).done;) { n = r.value; xf.call(e, n) && Ef(t, n, e[n]) } } catch (t) { i.e(t) } finally { i.f() } } return t }, kf = function (t, e) { return df(t, mf(e)) }; function Sf(t, e) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; if (!t || !e) throw new Error("lines and pt are required arguments"); var r = Lu([1 / 0, 1 / 0], { dist: 1 / 0, index: -1, location: -1 }), i = 0; return Bl(t, (function (t) { for (var o = ol(t), a = 0; a < o.length - 1; a++) { var s = Lu(o[a]); s.properties.dist = _l(e, s, n); var u = Lu(o[a + 1]); u.properties.dist = _l(e, u, n); var l = _l(s, u, n), c = Math.max(s.properties.dist, u.properties.dist), h = yl(s, u), f = dl(e, c, h + 90, n), p = dl(e, c, h - 90, n), g = uh(Au([f.geometry.coordinates, p.geometry.coordinates]), Au([s.geometry.coordinates, u.geometry.coordinates])), y = void 0; g.features.length > 0 && g.features[0] && (y = kf(wf({}, g.features[0]), { properties: { dist: _l(e, g.features[0], n), location: i + _l(s, g.features[0], n) } })), s.properties.dist < r.properties.dist && (r = kf(wf({}, s), { properties: kf(wf({}, s.properties), { index: a, location: i }) })), u.properties.dist < r.properties.dist && (r = kf(wf({}, u), { properties: kf(wf({}, u.properties), { index: a + 1, location: i + l }) })), y && y.properties.dist < r.properties.dist && (r = kf(wf({}, y), { properties: kf(wf({}, y.properties), { index: a }) })), i += l } })), r } !function (t, e) { vf(t, "name", { value: e, configurable: !0 }) }(Sf, "nearestPointOnLine"); var If = Object.defineProperty, Pf = function (t, e) { return If(t, "name", { value: e, configurable: !0 }) }; function Nf(t, e) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; if (!Qu(n = n || {})) throw new Error("options is invalid"); var r, i = n.tolerance || 0, o = [], a = lf(), s = ff(t); a.load(s); var u = []; return Vl(e, (function (t) { var e = !1; t && (Tl(a.search(t), (function (n) { if (!1 === e) { var o = ol(t).sort(), a = ol(n).sort(); if (_u(o, a)) e = !0, r = r ? Mf(r, t) || r : t; else if (0 === i ? Rc(o[0], n) && Rc(o[1], n) : Sf(n, o[0]).properties.dist <= i && Sf(n, o[1]).properties.dist <= i) e = !0, r = r ? Mf(r, t) || r : t; else if (0 === i ? Rc(a[0], t) && Rc(a[1], t) : Sf(t, a[0]).properties.dist <= i && Sf(t, a[1]).properties.dist <= i) if (r) { var s = Mf(r, n); s ? r = s : u.push(n) } else r = n } })), !1 === e && r && (o.push(r), u.length && (o = o.concat(u), u = []), r = void 0)) })), r && o.push(r), ju(o) } function Mf(t, e) { var n = ol(e), r = ol(t), i = r[0], o = r[r.length - 1], a = t.geometry.coordinates; if (_u(n[0], i)) a.unshift(n[1]); else if (_u(n[0], o)) a.push(n[1]); else if (_u(n[1], i)) a.unshift(n[0]); else { if (!_u(n[1], o)) return; a.push(n[0]) } return t } Pf(Nf, "lineOverlap"), Pf(Mf, "concatSegment"); var Of = Object.defineProperty; function Lf(t, e) { var n = cl(t), r = cl(e), i = n.type, o = r.type; if ("MultiPoint" === i && "MultiPoint" !== o || ("LineString" === i || "MultiLineString" === i) && "LineString" !== o && "MultiLineString" !== o || ("Polygon" === i || "MultiPolygon" === i) && "Polygon" !== o && "MultiPolygon" !== o) throw new Error("features must be of the same type"); if ("Point" === i) throw new Error("Point geometry not supported"); if (new wu({ precision: 6 }).compare(t, e)) return !1; var a = 0; switch (i) { case "MultiPoint": for (var s = 0; s < n.coordinates.length; s++)for (var u = 0; u < r.coordinates.length; u++) { var l = n.coordinates[s], c = r.coordinates[u]; if (l[0] === c[0] && l[1] === c[1]) return !0 } return !1; case "LineString": case "MultiLineString": Vl(t, (function (t) { Vl(e, (function (e) { Nf(t, e).features.length && a++ })) })); break; case "Polygon": case "MultiPolygon": Vl(t, (function (t) { Vl(e, (function (e) { uh(t, e).features.length && a++ })) })) }return a > 0 } !function (t, e) { Of(t, "name", { value: e, configurable: !0 }) }(Lf, "booleanOverlap"); var Rf = Object.defineProperty, Cf = function (t, e) { return Rf(t, "name", { value: e, configurable: !0 }) }; function Tf(t, e) { if (!t) throw new Error("line1 is required"); if (!e) throw new Error("line2 is required"); if ("LineString" !== Df(t, "line1")) throw new Error("line1 must be a LineString"); if ("LineString" !== Df(e, "line2")) throw new Error("line2 must be a LineString"); for (var n = ff(Ah(t)).features, r = ff(Ah(e)).features, i = 0; i < n.length; i++) { var o = n[i].geometry.coordinates; if (!r[i]) break; if (!Af(o, r[i].geometry.coordinates)) return !1 } return !0 } function Af(t, e) { var n = Xu(kl(t[0], t[1])), r = Xu(kl(e[0], e[1])); return n === r || (r - n) % 180 == 0 } function Df(t, e) { if (t.geometry && t.geometry.type) return t.geometry.type; if (t.type) return t.type; throw new Error("Invalid GeoJSON object for " + e) } Cf(Tf, "booleanParallel"), Cf(Af, "isParallel"), Cf(Df, "getType"); var jf = Object.defineProperty, Ff = function (t, e) { return jf(t, "name", { value: e, configurable: !0 }) }; function Bf(t, e) { var n = cl(t), r = cl(e), i = n.type, o = r.type; switch (i) { case "Point": switch (o) { case "LineString": return qf(n, r); case "MultiLineString": for (var a = !1, s = 0; s < r.coordinates.length; s++)qf(n, { type: "LineString", coordinates: r.coordinates[s] }) && (a = !0); return a; case "Polygon": for (var u = 0; u < r.coordinates.length; u++)if (Rc(n, { type: "LineString", coordinates: r.coordinates[u] })) return !0; return !1; case "MultiPolygon": for (u = 0; u < r.coordinates.length; u++)for (s = 0; s < r.coordinates[u].length; s++)if (Rc(n, { type: "LineString", coordinates: r.coordinates[u][s] })) return !0; return !1; default: throw new Error("feature2 " + o + " geometry not supported") }case "MultiPoint": switch (o) { case "LineString": for (a = !1, u = 0; u < n.coordinates.length; u++)if (a || qf({ type: "Point", coordinates: n.coordinates[u] }, r) && (a = !0), Rc({ type: "Point", coordinates: n.coordinates[u] }, r, { ignoreEndVertices: !0 })) return !1; return a; case "MultiLineString": for (a = !1, u = 0; u < n.coordinates.length; u++)for (s = 0; s < r.coordinates.length; s++)if (a || qf({ type: "Point", coordinates: n.coordinates[u] }, { type: "LineString", coordinates: r.coordinates[s] }) && (a = !0), Rc({ type: "Point", coordinates: n.coordinates[u] }, { type: "LineString", coordinates: r.coordinates[s] }, { ignoreEndVertices: !0 })) return !1; return a; case "Polygon": for (a = !1, u = 0; u < n.coordinates.length; u++)if (a || Rc({ type: "Point", coordinates: n.coordinates[u] }, { type: "LineString", coordinates: r.coordinates[0] }) && (a = !0), Nc({ type: "Point", coordinates: n.coordinates[u] }, r, { ignoreBoundary: !0 })) return !1; return a; case "MultiPolygon": for (a = !1, u = 0; u < n.coordinates.length; u++)for (s = 0; s < r.coordinates.length; s++)if (a || Rc({ type: "Point", coordinates: n.coordinates[u] }, { type: "LineString", coordinates: r.coordinates[s][0] }) && (a = !0), Nc({ type: "Point", coordinates: n.coordinates[u] }, { type: "Polygon", coordinates: r.coordinates[s] }, { ignoreBoundary: !0 })) return !1; return a; default: throw new Error("feature2 " + o + " geometry not supported") }case "LineString": switch (o) { case "Point": return qf(r, n); case "MultiPoint": for (a = !1, u = 0; u < r.coordinates.length; u++)if (a || qf({ type: "Point", coordinates: r.coordinates[u] }, n) && (a = !0), Rc({ type: "Point", coordinates: r.coordinates[u] }, n, { ignoreEndVertices: !0 })) return !1; return a; case "LineString": var l = !1; if (qf({ type: "Point", coordinates: n.coordinates[0] }, r) && (l = !0), qf({ type: "Point", coordinates: n.coordinates[n.coordinates.length - 1] }, r) && (l = !0), !1 === l) return !1; for (u = 0; u < n.coordinates.length; u++)if (Rc({ type: "Point", coordinates: n.coordinates[u] }, r, { ignoreEndVertices: !0 })) return !1; return l; case "MultiLineString": for (l = !1, u = 0; u < r.coordinates.length; u++) { qf({ type: "Point", coordinates: n.coordinates[0] }, { type: "LineString", coordinates: r.coordinates[u] }) && (l = !0), qf({ type: "Point", coordinates: n.coordinates[n.coordinates.length - 1] }, { type: "LineString", coordinates: r.coordinates[u] }) && (l = !0); for (s = 0; s < n.coordinates[u].length; s++)if (Rc({ type: "Point", coordinates: n.coordinates[s] }, { type: "LineString", coordinates: r.coordinates[u] }, { ignoreEndVertices: !0 })) return !1 } return l; case "Polygon": for (a = !1, u = 0; u < n.coordinates.length; u++)if (a || Rc({ type: "Point", coordinates: n.coordinates[u] }, { type: "LineString", coordinates: r.coordinates[0] }) && (a = !0), Nc({ type: "Point", coordinates: n.coordinates[u] }, r, { ignoreBoundary: !0 })) return !1; return a; case "MultiPolygon": for (a = !1, u = 0; u < n.coordinates.length; u++) { for (s = 0; s < r.coordinates.length; s++)a || Rc({ type: "Point", coordinates: n.coordinates[u] }, { type: "LineString", coordinates: r.coordinates[s][0] }) && (a = !0); if (Nc({ type: "Point", coordinates: n.coordinates[u] }, r, { ignoreBoundary: !0 })) return !1 } return a; default: throw new Error("feature2 " + o + " geometry not supported") }case "MultiLineString": switch (o) { case "Point": for (u = 0; u < n.coordinates.length; u++)if (qf(r, { type: "LineString", coordinates: n.coordinates[u] })) return !0; return !1; case "MultiPoint": for (a = !1, u = 0; u < n.coordinates.length; u++)for (s = 0; s < r.coordinates.length; s++)if (a || qf({ type: "Point", coordinates: r.coordinates[s] }, { type: "LineString", coordinates: n.coordinates[s] }) && (a = !0), Rc({ type: "Point", coordinates: r.coordinates[s] }, { type: "LineString", coordinates: n.coordinates[s] }, { ignoreEndVertices: !0 })) return !1; return a; case "LineString": for (l = !1, u = 0; u < n.coordinates.length; u++) { qf({ type: "Point", coordinates: n.coordinates[u][0] }, r) && (l = !0), qf({ type: "Point", coordinates: n.coordinates[u][n.coordinates[u].length - 1] }, r) && (l = !0); for (s = 0; s < r.coordinates.length; s++)if (Rc({ type: "Point", coordinates: r.coordinates[s] }, { type: "LineString", coordinates: n.coordinates[u] }, { ignoreEndVertices: !0 })) return !1 } return l; case "MultiLineString": for (l = !1, u = 0; u < n.coordinates.length; u++)for (s = 0; s < r.coordinates.length; s++) { qf({ type: "Point", coordinates: n.coordinates[u][0] }, { type: "LineString", coordinates: r.coordinates[s] }) && (l = !0), qf({ type: "Point", coordinates: n.coordinates[u][n.coordinates[u].length - 1] }, { type: "LineString", coordinates: r.coordinates[s] }) && (l = !0); for (var c = 0; c < n.coordinates[u].length; c++)if (Rc({ type: "Point", coordinates: n.coordinates[u][c] }, { type: "LineString", coordinates: r.coordinates[s] }, { ignoreEndVertices: !0 })) return !1 } return l; case "Polygon": for (a = !1, u = 0; u < n.coordinates.length; u++)for (s = 0; s < n.coordinates.length; s++)if (a || Rc({ type: "Point", coordinates: n.coordinates[u][s] }, { type: "LineString", coordinates: r.coordinates[0] }) && (a = !0), Nc({ type: "Point", coordinates: n.coordinates[u][s] }, r, { ignoreBoundary: !0 })) return !1; return a; case "MultiPolygon": for (a = !1, u = 0; u < r.coordinates[0].length; u++)for (s = 0; s < n.coordinates.length; s++)for (c = 0; c < n.coordinates[s].length; c++)if (a || Rc({ type: "Point", coordinates: n.coordinates[s][c] }, { type: "LineString", coordinates: r.coordinates[0][u] }) && (a = !0), Nc({ type: "Point", coordinates: n.coordinates[s][c] }, { type: "Polygon", coordinates: [r.coordinates[0][u]] }, { ignoreBoundary: !0 })) return !1; return a; default: throw new Error("feature2 " + o + " geometry not supported") }case "Polygon": switch (o) { case "Point": for (u = 0; u < n.coordinates.length; u++)if (Rc(r, { type: "LineString", coordinates: n.coordinates[u] })) return !0; return !1; case "MultiPoint": for (a = !1, u = 0; u < r.coordinates.length; u++)if (a || Rc({ type: "Point", coordinates: r.coordinates[u] }, { type: "LineString", coordinates: n.coordinates[0] }) && (a = !0), Nc({ type: "Point", coordinates: r.coordinates[u] }, n, { ignoreBoundary: !0 })) return !1; return a; case "LineString": for (a = !1, u = 0; u < r.coordinates.length; u++)if (a || Rc({ type: "Point", coordinates: r.coordinates[u] }, { type: "LineString", coordinates: n.coordinates[0] }) && (a = !0), Nc({ type: "Point", coordinates: r.coordinates[u] }, n, { ignoreBoundary: !0 })) return !1; return a; case "MultiLineString": for (a = !1, u = 0; u < r.coordinates.length; u++)for (s = 0; s < r.coordinates[u].length; s++)if (a || Rc({ type: "Point", coordinates: r.coordinates[u][s] }, { type: "LineString", coordinates: n.coordinates[0] }) && (a = !0), Nc({ type: "Point", coordinates: r.coordinates[u][s] }, n, { ignoreBoundary: !0 })) return !1; return a; case "Polygon": for (a = !1, u = 0; u < n.coordinates[0].length; u++)if (a || Rc({ type: "Point", coordinates: n.coordinates[0][u] }, { type: "LineString", coordinates: r.coordinates[0] }) && (a = !0), Nc({ type: "Point", coordinates: n.coordinates[0][u] }, r, { ignoreBoundary: !0 })) return !1; return a; case "MultiPolygon": for (a = !1, u = 0; u < r.coordinates[0].length; u++)for (s = 0; s < n.coordinates[0].length; s++)if (a || Rc({ type: "Point", coordinates: n.coordinates[0][s] }, { type: "LineString", coordinates: r.coordinates[0][u] }) && (a = !0), Nc({ type: "Point", coordinates: n.coordinates[0][s] }, { type: "Polygon", coordinates: r.coordinates[0][u] }, { ignoreBoundary: !0 })) return !1; return a; default: throw new Error("feature2 " + o + " geometry not supported") }case "MultiPolygon": switch (o) { case "Point": for (u = 0; u < n.coordinates[0].length; u++)if (Rc(r, { type: "LineString", coordinates: n.coordinates[0][u] })) return !0; return !1; case "MultiPoint": for (a = !1, u = 0; u < n.coordinates[0].length; u++)for (s = 0; s < r.coordinates.length; s++)if (a || Rc({ type: "Point", coordinates: r.coordinates[s] }, { type: "LineString", coordinates: n.coordinates[0][u] }) && (a = !0), Nc({ type: "Point", coordinates: r.coordinates[s] }, { type: "Polygon", coordinates: n.coordinates[0][u] }, { ignoreBoundary: !0 })) return !1; return a; case "LineString": for (a = !1, u = 0; u < n.coordinates[0].length; u++)for (s = 0; s < r.coordinates.length; s++)if (a || Rc({ type: "Point", coordinates: r.coordinates[s] }, { type: "LineString", coordinates: n.coordinates[0][u] }) && (a = !0), Nc({ type: "Point", coordinates: r.coordinates[s] }, { type: "Polygon", coordinates: n.coordinates[0][u] }, { ignoreBoundary: !0 })) return !1; return a; case "MultiLineString": for (a = !1, u = 0; u < n.coordinates.length; u++)for (s = 0; s < r.coordinates.length; s++)for (c = 0; c < r.coordinates[s].length; c++)if (a || Rc({ type: "Point", coordinates: r.coordinates[s][c] }, { type: "LineString", coordinates: n.coordinates[u][0] }) && (a = !0), Nc({ type: "Point", coordinates: r.coordinates[s][c] }, { type: "Polygon", coordinates: [n.coordinates[u][0]] }, { ignoreBoundary: !0 })) return !1; return a; case "Polygon": for (a = !1, u = 0; u < n.coordinates[0].length; u++)for (s = 0; s < n.coordinates[0][u].length; s++)if (a || Rc({ type: "Point", coordinates: n.coordinates[0][u][s] }, { type: "LineString", coordinates: r.coordinates[0] }) && (a = !0), Nc({ type: "Point", coordinates: n.coordinates[0][u][s] }, r, { ignoreBoundary: !0 })) return !1; return a; case "MultiPolygon": for (a = !1, u = 0; u < n.coordinates[0].length; u++)for (s = 0; s < r.coordinates[0].length; s++)for (c = 0; c < n.coordinates[0].length; c++)if (a || Rc({ type: "Point", coordinates: n.coordinates[0][u][c] }, { type: "LineString", coordinates: r.coordinates[0][s] }) && (a = !0), Nc({ type: "Point", coordinates: n.coordinates[0][u][c] }, { type: "Polygon", coordinates: r.coordinates[0][s] }, { ignoreBoundary: !0 })) return !1; return a; default: throw new Error("feature2 " + o + " geometry not supported") }default: throw new Error("feature1 " + i + " geometry not supported") } } function qf(t, e) { return !!Vf(e.coordinates[0], t.coordinates) || !!Vf(e.coordinates[e.coordinates.length - 1], t.coordinates) } function Vf(t, e) { return t[0] === e[0] && t[1] === e[1] } Ff(Bf, "booleanTouches"), Ff(qf, "isPointOnLineEnd"), Ff(Vf, "compareCoords"); var Gf = Object.defineProperty, Yf = function (t, e) { return Gf(t, "name", { value: e, configurable: !0 }) }; function zf(t) { if (!t.type) return !1; var e = cl(t), n = e.type, r = e.coordinates; switch (n) { case "Point": return r.length > 1; case "MultiPoint": for (var i = 0; i < r.length; i++)if (r[i].length < 2) return !1; return !0; case "LineString": if (r.length < 2) return !1; for (i = 0; i < r.length; i++)if (r[i].length < 2) return !1; return !0; case "MultiLineString": if (r.length < 2) return !1; for (i = 0; i < r.length; i++)if (r[i].length < 2) return !1; return !0; case "Polygon": for (i = 0; i < e.coordinates.length; i++) { if (r[i].length < 4) return !1; if (!Uf(r[i])) return !1; if (Xf(r[i])) return !1; if (i > 0 && uh(Cu([r[0]]), Cu([r[i]])).features.length > 1) return !1 } return !0; case "MultiPolygon": for (i = 0; i < e.coordinates.length; i++)for (var o = e.coordinates[i], a = 0; a < o.length; a++) { if (o[a].length < 4) return !1; if (!Uf(o[a])) return !1; if (Xf(o[a])) return !1; if (0 === a && !Wf(o, e.coordinates, i)) return !1; if (a > 0 && uh(Cu([o[0]]), Cu([o[a]])).features.length > 1) return !1 } return !0; default: return !1 } } function Uf(t) { return t[0][0] === t[t.length - 1][0] || t[0][1] === t[t.length - 1][1] } function Xf(t) { for (var e = 0; e < t.length - 1; e++)for (var n = t[e], r = e + 1; r < t.length - 2; r++) { if (Rc(n, Au([t[r], t[r + 1]]))) return !0 } return !1 } function Wf(t, e, n) { for (var r = Cu(t), i = n + 1; i < e.length; i++)if (!Sh(r, Cu(e[i])) && dh(r, Au(e[i][0]))) return !1; return !0 } Yf(zf, "booleanValid"), Yf(Uf, "checkRingsClose"), Yf(Xf, "checkRingsForSpikesPunctures"), Yf(Wf, "checkPolygonAgainstOthers"); var Hf = Object.defineProperty, Zf = function (t, e) { return Hf(t, "name", { value: e, configurable: !0 }) }; function Jf(t, e) { var n = cl(t), r = cl(e), i = n.type, o = r.type; switch (i) { case "Point": switch (o) { case "MultiPoint": return $f(n, r); case "LineString": return Rc(n, r, { ignoreEndVertices: !0 }); case "Polygon": case "MultiPolygon": return Nc(n, r, { ignoreBoundary: !0 }); default: throw new Error("feature2 " + o + " geometry not supported") }case "MultiPoint": switch (o) { case "MultiPoint": return Qf(n, r); case "LineString": return Kf(n, r); case "Polygon": case "MultiPolygon": return tp(n, r); default: throw new Error("feature2 " + o + " geometry not supported") }case "LineString": switch (o) { case "LineString": return ep(n, r); case "Polygon": case "MultiPolygon": return np(n, r); default: throw new Error("feature2 " + o + " geometry not supported") }case "Polygon": switch (o) { case "Polygon": case "MultiPolygon": return rp(n, r); default: throw new Error("feature2 " + o + " geometry not supported") }default: throw new Error("feature1 " + i + " geometry not supported") } } function $f(t, e) { var n, r = !1; for (n = 0; n < e.coordinates.length; n++)if (op(e.coordinates[n], t.coordinates)) { r = !0; break } return r } function Qf(t, e) { for (var n = 0; n < t.coordinates.length; n++) { for (var r = !1, i = 0; i < e.coordinates.length; i++)op(t.coordinates[n], e.coordinates[i]) && (r = !0); if (!r) return !1 } return !0 } function Kf(t, e) { for (var n = !1, r = 0; r < t.coordinates.length; r++) { if (!Rc(t.coordinates[r], e)) return !1; n || (n = Rc(t.coordinates[r], e, { ignoreEndVertices: !0 })) } return n } function tp(t, e) { for (var n = !0, r = !1, i = 0; i < t.coordinates.length; i++) { if (!(r = Nc(t.coordinates[i], e))) { n = !1; break } r = Nc(t.coordinates[i], e, { ignoreBoundary: !0 }) } return n && r } function ep(t, e) { for (var n = 0; n < t.coordinates.length; n++)if (!Rc(t.coordinates[n], e)) return !1; return !0 } function np(t, e) { if (!ip(rc(e), rc(t))) return !1; for (var n = !1, r = 0; r < t.coordinates.length; r++) { if (!Nc(t.coordinates[r], e)) return !1; if (n || (n = Nc(t.coordinates[r], e, { ignoreBoundary: !0 })), !n && r < t.coordinates.length - 1) n = Nc(ap(t.coordinates[r], t.coordinates[r + 1]), e, { ignoreBoundary: !0 }) } return n } function rp(t, e) { var n = rc(t); if (!ip(rc(e), n)) return !1; for (var r = 0; r < t.coordinates[0].length; r++)if (!Nc(t.coordinates[0][r], e)) return !1; return !0 } function ip(t, e) { return !(t[0] > e[0]) && (!(t[2] < e[2]) && (!(t[1] > e[1]) && !(t[3] < e[3]))) } function op(t, e) { return t[0] === e[0] && t[1] === e[1] } function ap(t, e) { return [(t[0] + e[0]) / 2, (t[1] + e[1]) / 2] } Zf(Jf, "booleanWithin"), Zf($f, "isPointInMultiPoint"), Zf(Qf, "isMultiPointInMultiPoint"), Zf(Kf, "isMultiPointOnLine"), Zf(tp, "isMultiPointInPoly"), Zf(ep, "isLineOnLine"), Zf(np, "isLineInPoly"), Zf(rp, "isPolyInPoly"), Zf(ip, "doBBoxOverlap"), Zf(op, "compareCoords"), Zf(ap, "getMidpoint"); var sp = Object.defineProperty; function up(t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = rc(t); return Lu([(n[0] + n[2]) / 2, (n[1] + n[3]) / 2], e.properties, e) } !function (t, e) { sp(t, "name", { value: e, configurable: !0 }) }(up, "center"); var lp = { exports: {} }; !function (t, n) { t.exports = function () { function t(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function n(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r) } } function r(t, e, r) { return e && n(t.prototype, e), r && n(t, r), t } function i(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && a(t, e) } function o(t) { return o = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t) }, o(t) } function a(t, e) { return a = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t }, a(t, e) } function s() { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (t) { return !1 } } function u(t, e, n) { return u = s() ? Reflect.construct : function (t, e, n) { var r = [null]; r.push.apply(r, e); var i = new (Function.bind.apply(t, r)); return n && a(i, n.prototype), i }, u.apply(null, arguments) } function l(t) { var e = "function" == typeof Map ? new Map : void 0; return l = function (t) { if (null === t || (n = t, -1 === Function.toString.call(n).indexOf("[native code]"))) return t; var n; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== e) { if (e.has(t)) return e.get(t); e.set(t, r) } function r() { return u(t, arguments, o(this).constructor) } return r.prototype = Object.create(t.prototype, { constructor: { value: r, enumerable: !1, writable: !0, configurable: !0 } }), a(r, t) }, l(t) } function c(t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function h(t, n) { if (n && ("object" == e(n) || "function" == typeof n)) return n; if (void 0 !== n) throw new TypeError("Derived constructors may only return object or undefined"); return c(t) } function f(t) { var e = s(); return function () { var n, r = o(t); if (e) { var i = o(this).constructor; n = Reflect.construct(r, arguments, i) } else n = r.apply(this, arguments); return h(this, n) } } function p(t, e, n) { return p = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, n) { var r = function (t, e) { for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = o(t));); return t }(t, e); if (r) { var i = Object.getOwnPropertyDescriptor(r, e); return i.get ? i.get.call(n) : i.value } }, p(t, e, n || t) } function g(t) { return function (t) { if (Array.isArray(t)) return v(t) }(t) || function (t) { if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t) }(t) || y(t) || function () { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }() } function y(t, e) { if (t) { if ("string" == typeof t) return v(t, e); var n = Object.prototype.toString.call(t).slice(8, -1); return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? v(t, e) : void 0 } } function v(t, e) { (null == e || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } function d(t, e) { var n = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"]; if (!n) { if (Array.isArray(t) || (n = y(t)) || e && t && "number" == typeof t.length) { n && (t = n); var r = 0, i = function () { }; return { s: i, n: function () { return r >= t.length ? { done: !0 } : { done: !1, value: t[r++] } }, e: function (t) { throw t }, f: i } } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } var o, a = !0, s = !1; return { s: function () { n = n.call(t) }, n: function () { var t = n.next(); return a = t.done, t }, e: function (t) { s = !0, o = t }, f: function () { try { a || null == n.return || n.return() } finally { if (s) throw o } } } } var m = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "getEndCapStyle", value: function () { return this._endCapStyle } }, { key: "isSingleSided", value: function () { return this._isSingleSided } }, { key: "setQuadrantSegments", value: function (t) { this._quadrantSegments = t, 0 === this._quadrantSegments && (this._joinStyle = e.JOIN_BEVEL), this._quadrantSegments < 0 && (this._joinStyle = e.JOIN_MITRE, this._mitreLimit = Math.abs(this._quadrantSegments)), t <= 0 && (this._quadrantSegments = 1), this._joinStyle !== e.JOIN_ROUND && (this._quadrantSegments = e.DEFAULT_QUADRANT_SEGMENTS) } }, { key: "getJoinStyle", value: function () { return this._joinStyle } }, { key: "setJoinStyle", value: function (t) { this._joinStyle = t } }, { key: "setSimplifyFactor", value: function (t) { this._simplifyFactor = t < 0 ? 0 : t } }, { key: "getSimplifyFactor", value: function () { return this._simplifyFactor } }, { key: "getQuadrantSegments", value: function () { return this._quadrantSegments } }, { key: "setEndCapStyle", value: function (t) { this._endCapStyle = t } }, { key: "getMitreLimit", value: function () { return this._mitreLimit } }, { key: "setMitreLimit", value: function (t) { this._mitreLimit = t } }, { key: "setSingleSided", value: function (t) { this._isSingleSided = t } }], [{ key: "constructor_", value: function () { if (this._quadrantSegments = e.DEFAULT_QUADRANT_SEGMENTS, this._endCapStyle = e.CAP_ROUND, this._joinStyle = e.JOIN_ROUND, this._mitreLimit = e.DEFAULT_MITRE_LIMIT, this._isSingleSided = !1, this._simplifyFactor = e.DEFAULT_SIMPLIFY_FACTOR, 0 === arguments.length); else if (1 === arguments.length) { var t = arguments[0]; this.setQuadrantSegments(t) } else if (2 === arguments.length) { var n = arguments[0], r = arguments[1]; this.setQuadrantSegments(n), this.setEndCapStyle(r) } else if (4 === arguments.length) { var i = arguments[0], o = arguments[1], a = arguments[2], s = arguments[3]; this.setQuadrantSegments(i), this.setEndCapStyle(o), this.setJoinStyle(a), this.setMitreLimit(s) } } }, { key: "bufferDistanceError", value: function (t) { var e = Math.PI / 2 / t; return 1 - Math.cos(e / 2) } }]), e }(); m.CAP_ROUND = 1, m.CAP_FLAT = 2, m.CAP_SQUARE = 3, m.JOIN_ROUND = 1, m.JOIN_MITRE = 2, m.JOIN_BEVEL = 3, m.DEFAULT_QUADRANT_SEGMENTS = 8, m.DEFAULT_MITRE_LIMIT = 5, m.DEFAULT_SIMPLIFY_FACTOR = .01; var _ = function (e) { i(o, e); var n = f(o); function o(e) { var r; return t(this, o), (r = n.call(this, e)).name = Object.keys({ Exception: o })[0], r } return r(o, [{ key: "toString", value: function () { return this.message } }]), o }(l(Error)), b = function (e) { i(r, e); var n = f(r); function r(e) { var i; return t(this, r), (i = n.call(this, e)).name = Object.keys({ IllegalArgumentException: r })[0], i } return r }(_), x = function () { function e() { t(this, e) } return r(e, [{ key: "filter", value: function (t) { } }]), e }(); function E() { } function w() { } function k() { } var S, I, P, N, M, O, L, R, C = function () { function e() { t(this, e) } return r(e, null, [{ key: "equalsWithTolerance", value: function (t, e, n) { return Math.abs(t - e) <= n } }]), e }(), T = function () { function e(n, r) { t(this, e), this.low = r || 0, this.high = n || 0 } return r(e, null, [{ key: "toBinaryString", value: function (t) { var e, n = ""; for (e = 2147483648; e > 0; e >>>= 1)n += (t.high & e) === e ? "1" : "0"; for (e = 2147483648; e > 0; e >>>= 1)n += (t.low & e) === e ? "1" : "0"; return n } }]), e }(); function A() { } function D() { } A.NaN = NaN, A.isNaN = function (t) { return Number.isNaN(t) }, A.isInfinite = function (t) { return !Number.isFinite(t) }, A.MAX_VALUE = Number.MAX_VALUE, A.POSITIVE_INFINITY = Number.POSITIVE_INFINITY, A.NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY, "function" == typeof Float64Array && "function" == typeof Int32Array ? (O = 2146435072, L = new Float64Array(1), R = new Int32Array(L.buffer), A.doubleToLongBits = function (t) { L[0] = t; var e = 0 | R[0], n = 0 | R[1]; return (n & O) === O && 0 != (1048575 & n) && 0 !== e && (e = 0, n = 2146959360), new T(n, e) }, A.longBitsToDouble = function (t) { return R[0] = t.low, R[1] = t.high, L[0] }) : (S = 1023, I = Math.log2, P = Math.floor, N = Math.pow, M = function () { for (var t = 53; t > 0; t--) { var e = N(2, t) - 1; if (P(I(e)) + 1 === t) return e } return 0 }(), A.doubleToLongBits = function (t) { var e, n, r, i, o, a, s, u, l; if (t < 0 || 1 / t === Number.NEGATIVE_INFINITY ? (a = 1 << 31, t = -t) : a = 0, 0 === t) return new T(u = a, l = 0); if (t === 1 / 0) return new T(u = 2146435072 | a, l = 0); if (t != t) return new T(u = 2146959360, l = 0); if (i = 0, l = 0, (e = P(t)) > 1) if (e <= M) (i = P(I(e))) <= 20 ? (l = 0, u = e << 20 - i & 1048575) : (l = e % (n = N(2, r = i - 20)) << 32 - r, u = e / n & 1048575); else for (r = e, l = 0; 0 !== (r = P(n = r / 2));)i++, l >>>= 1, l |= (1 & u) << 31, u >>>= 1, n !== r && (u |= 524288); if (s = i + S, o = 0 === e, e = t - e, i < 52 && 0 !== e) for (r = 0; ;) { if ((n = 2 * e) >= 1 ? (e = n - 1, o ? (s--, o = !1) : (r <<= 1, r |= 1, i++)) : (e = n, o ? 0 == --s && (i++, o = !1) : (r <<= 1, i++)), 20 === i) u |= r, r = 0; else if (52 === i) { l |= r; break } if (1 === n) { i < 20 ? u |= r << 20 - i : i < 52 && (l |= r << 52 - i); break } } return u |= s << 20, new T(u |= a, l) }, A.longBitsToDouble = function (t) { var e, n, r, i, o = t.high, a = t.low, s = o & 1 << 31 ? -1 : 1; for (r = ((2146435072 & o) >> 20) - S, i = 0, n = 1 << 19, e = 1; e <= 20; e++)o & n && (i += N(2, -e)), n >>>= 1; for (n = 1 << 31, e = 21; e <= 52; e++)a & n && (i += N(2, -e)), n >>>= 1; if (-1023 === r) { if (0 === i) return 0 * s; r = -1022 } else { if (1024 === r) return 0 === i ? s / 0 : NaN; i += 1 } return s * i * N(2, r) }); var j = function (e) { i(r, e); var n = f(r); function r(e) { var i; return t(this, r), (i = n.call(this, e)).name = Object.keys({ RuntimeException: r })[0], i } return r }(_), F = function (e) { i(o, e); var n = f(o); function o() { var e; return t(this, o), e = n.call(this), o.constructor_.apply(c(e), arguments), e } return r(o, null, [{ key: "constructor_", value: function () { if (0 === arguments.length) j.constructor_.call(this); else if (1 === arguments.length) { var t = arguments[0]; j.constructor_.call(this, t) } } }]), o }(j), B = function () { function e() { t(this, e) } return r(e, null, [{ key: "shouldNeverReachHere", value: function () { if (0 === arguments.length) e.shouldNeverReachHere(null); else if (1 === arguments.length) { var t = arguments[0]; throw new F("Should never reach here" + (null !== t ? ": " + t : "")) } } }, { key: "isTrue", value: function () { if (1 === arguments.length) { var t = arguments[0]; e.isTrue(t, null) } else if (2 === arguments.length) { var n = arguments[1]; if (!arguments[0]) throw null === n ? new F : new F(n) } } }, { key: "equals", value: function () { if (2 === arguments.length) { var t = arguments[0], n = arguments[1]; e.equals(t, n, null) } else if (3 === arguments.length) { var r = arguments[0], i = arguments[1], o = arguments[2]; if (!i.equals(r)) throw new F("Expected " + r + " but encountered " + i + (null !== o ? ": " + o : "")) } } }]), e }(), q = new ArrayBuffer(8), V = new Float64Array(q), G = new Int32Array(q), Y = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "getM", value: function () { return A.NaN } }, { key: "setOrdinate", value: function (t, n) { switch (t) { case e.X: this.x = n; break; case e.Y: this.y = n; break; case e.Z: this.setZ(n); break; default: throw new b("Invalid ordinate index: " + t) } } }, { key: "equals2D", value: function () { if (1 === arguments.length) { var t = arguments[0]; return this.x === t.x && this.y === t.y } if (2 === arguments.length) { var e = arguments[0], n = arguments[1]; return !!C.equalsWithTolerance(this.x, e.x, n) && !!C.equalsWithTolerance(this.y, e.y, n) } } }, { key: "setM", value: function (t) { throw new b("Invalid ordinate index: " + e.M) } }, { key: "getZ", value: function () { return this.z } }, { key: "getOrdinate", value: function (t) { switch (t) { case e.X: return this.x; case e.Y: return this.y; case e.Z: return this.getZ() }throw new b("Invalid ordinate index: " + t) } }, { key: "equals3D", value: function (t) { return this.x === t.x && this.y === t.y && (this.getZ() === t.getZ() || A.isNaN(this.getZ()) && A.isNaN(t.getZ())) } }, { key: "equals", value: function (t) { return t instanceof e && this.equals2D(t) } }, { key: "equalInZ", value: function (t, e) { return C.equalsWithTolerance(this.getZ(), t.getZ(), e) } }, { key: "setX", value: function (t) { this.x = t } }, { key: "compareTo", value: function (t) { var e = t; return this.x < e.x ? -1 : this.x > e.x ? 1 : this.y < e.y ? -1 : this.y > e.y ? 1 : 0 } }, { key: "getX", value: function () { return this.x } }, { key: "setZ", value: function (t) { this.z = t } }, { key: "clone", value: function () { try { return null } catch (t) { if (t instanceof CloneNotSupportedException) return B.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"), null; throw t } } }, { key: "copy", value: function () { return new e(this) } }, { key: "toString", value: function () { return "(" + this.x + ", " + this.y + ", " + this.getZ() + ")" } }, { key: "distance3D", value: function (t) { var e = this.x - t.x, n = this.y - t.y, r = this.getZ() - t.getZ(); return Math.sqrt(e * e + n * n + r * r) } }, { key: "getY", value: function () { return this.y } }, { key: "setY", value: function (t) { this.y = t } }, { key: "distance", value: function (t) { var e = this.x - t.x, n = this.y - t.y; return Math.sqrt(e * e + n * n) } }, { key: "hashCode", value: function () { var t = 17; return 37 * (t = 37 * t + e.hashCode(this.x)) + e.hashCode(this.y) } }, { key: "setCoordinate", value: function (t) { this.x = t.x, this.y = t.y, this.z = t.getZ() } }, { key: "interfaces_", get: function () { return [E, w, k] } }], [{ key: "constructor_", value: function () { if (this.x = null, this.y = null, this.z = null, 0 === arguments.length) e.constructor_.call(this, 0, 0); else if (1 === arguments.length) { var t = arguments[0]; e.constructor_.call(this, t.x, t.y, t.getZ()) } else if (2 === arguments.length) { var n = arguments[0], r = arguments[1]; e.constructor_.call(this, n, r, e.NULL_ORDINATE) } else if (3 === arguments.length) { var i = arguments[0], o = arguments[1], a = arguments[2]; this.x = i, this.y = o, this.z = a } } }, { key: "hashCode", value: function (t) { return V[0] = t, G[0] ^ G[1] } }]), e }(), z = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "compare", value: function (t, n) { var r = e.compare(t.x, n.x); if (0 !== r) return r; var i = e.compare(t.y, n.y); return 0 !== i ? i : this._dimensionsToTest <= 2 ? 0 : e.compare(t.getZ(), n.getZ()) } }, { key: "interfaces_", get: function () { return [D] } }], [{ key: "constructor_", value: function () { if (this._dimensionsToTest = 2, 0 === arguments.length) e.constructor_.call(this, 2); else if (1 === arguments.length) { var t = arguments[0]; if (2 !== t && 3 !== t) throw new b("only 2 or 3 dimensions may be specified"); this._dimensionsToTest = t } } }, { key: "compare", value: function (t, e) { return t < e ? -1 : t > e ? 1 : A.isNaN(t) ? A.isNaN(e) ? 0 : -1 : A.isNaN(e) ? 1 : 0 } }]), e }(); Y.DimensionalComparator = z, Y.NULL_ORDINATE = A.NaN, Y.X = 0, Y.Y = 1, Y.Z = 2, Y.M = 3; var U = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "getArea", value: function () { return this.getWidth() * this.getHeight() } }, { key: "equals", value: function (t) { if (!(t instanceof e)) return !1; var n = t; return this.isNull() ? n.isNull() : this._maxx === n.getMaxX() && this._maxy === n.getMaxY() && this._minx === n.getMinX() && this._miny === n.getMinY() } }, { key: "intersection", value: function (t) { if (this.isNull() || t.isNull() || !this.intersects(t)) return new e; var n = this._minx > t._minx ? this._minx : t._minx, r = this._miny > t._miny ? this._miny : t._miny; return new e(n, this._maxx < t._maxx ? this._maxx : t._maxx, r, this._maxy < t._maxy ? this._maxy : t._maxy) } }, { key: "isNull", value: function () { return this._maxx < this._minx } }, { key: "getMaxX", value: function () { return this._maxx } }, { key: "covers", value: function () { if (1 === arguments.length) { if (arguments[0] instanceof Y) { var t = arguments[0]; return this.covers(t.x, t.y) } if (arguments[0] instanceof e) { var n = arguments[0]; return !this.isNull() && !n.isNull() && n.getMinX() >= this._minx && n.getMaxX() <= this._maxx && n.getMinY() >= this._miny && n.getMaxY() <= this._maxy } } else if (2 === arguments.length) { var r = arguments[0], i = arguments[1]; return !this.isNull() && r >= this._minx && r <= this._maxx && i >= this._miny && i <= this._maxy } } }, { key: "intersects", value: function () { if (1 === arguments.length) { if (arguments[0] instanceof e) { var t = arguments[0]; return !this.isNull() && !t.isNull() && !(t._minx > this._maxx || t._maxx < this._minx || t._miny > this._maxy || t._maxy < this._miny) } if (arguments[0] instanceof Y) { var n = arguments[0]; return this.intersects(n.x, n.y) } } else if (2 === arguments.length) { if (arguments[0] instanceof Y && arguments[1] instanceof Y) { var r = arguments[0], i = arguments[1]; return !(this.isNull() || (r.x < i.x ? r.x : i.x) > this._maxx || (r.x > i.x ? r.x : i.x) < this._minx || (r.y < i.y ? r.y : i.y) > this._maxy || (r.y > i.y ? r.y : i.y) < this._miny) } if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) { var o = arguments[0], a = arguments[1]; return !this.isNull() && !(o > this._maxx || o < this._minx || a > this._maxy || a < this._miny) } } } }, { key: "getMinY", value: function () { return this._miny } }, { key: "getDiameter", value: function () { if (this.isNull()) return 0; var t = this.getWidth(), e = this.getHeight(); return Math.sqrt(t * t + e * e) } }, { key: "getMinX", value: function () { return this._minx } }, { key: "expandToInclude", value: function () { if (1 === arguments.length) { if (arguments[0] instanceof Y) { var t = arguments[0]; this.expandToInclude(t.x, t.y) } else if (arguments[0] instanceof e) { var n = arguments[0]; if (n.isNull()) return null; this.isNull() ? (this._minx = n.getMinX(), this._maxx = n.getMaxX(), this._miny = n.getMinY(), this._maxy = n.getMaxY()) : (n._minx < this._minx && (this._minx = n._minx), n._maxx > this._maxx && (this._maxx = n._maxx), n._miny < this._miny && (this._miny = n._miny), n._maxy > this._maxy && (this._maxy = n._maxy)) } } else if (2 === arguments.length) { var r = arguments[0], i = arguments[1]; this.isNull() ? (this._minx = r, this._maxx = r, this._miny = i, this._maxy = i) : (r < this._minx && (this._minx = r), r > this._maxx && (this._maxx = r), i < this._miny && (this._miny = i), i > this._maxy && (this._maxy = i)) } } }, { key: "minExtent", value: function () { if (this.isNull()) return 0; var t = this.getWidth(), e = this.getHeight(); return t < e ? t : e } }, { key: "getWidth", value: function () { return this.isNull() ? 0 : this._maxx - this._minx } }, { key: "compareTo", value: function (t) { var e = t; return this.isNull() ? e.isNull() ? 0 : -1 : e.isNull() ? 1 : this._minx < e._minx ? -1 : this._minx > e._minx ? 1 : this._miny < e._miny ? -1 : this._miny > e._miny ? 1 : this._maxx < e._maxx ? -1 : this._maxx > e._maxx ? 1 : this._maxy < e._maxy ? -1 : this._maxy > e._maxy ? 1 : 0 } }, { key: "translate", value: function (t, e) { if (this.isNull()) return null; this.init(this.getMinX() + t, this.getMaxX() + t, this.getMinY() + e, this.getMaxY() + e) } }, { key: "copy", value: function () { return new e(this) } }, { key: "toString", value: function () { return "Env[" + this._minx + " : " + this._maxx + ", " + this._miny + " : " + this._maxy + "]" } }, { key: "setToNull", value: function () { this._minx = 0, this._maxx = -1, this._miny = 0, this._maxy = -1 } }, { key: "disjoint", value: function (t) { return !(!this.isNull() && !t.isNull()) || t._minx > this._maxx || t._maxx < this._minx || t._miny > this._maxy || t._maxy < this._miny } }, { key: "getHeight", value: function () { return this.isNull() ? 0 : this._maxy - this._miny } }, { key: "maxExtent", value: function () { if (this.isNull()) return 0; var t = this.getWidth(), e = this.getHeight(); return t > e ? t : e } }, { key: "expandBy", value: function () { if (1 === arguments.length) { var t = arguments[0]; this.expandBy(t, t) } else if (2 === arguments.length) { var e = arguments[0], n = arguments[1]; if (this.isNull()) return null; this._minx -= e, this._maxx += e, this._miny -= n, this._maxy += n, (this._minx > this._maxx || this._miny > this._maxy) && this.setToNull() } } }, { key: "contains", value: function () { if (1 === arguments.length) { if (arguments[0] instanceof e) { var t = arguments[0]; return this.covers(t) } if (arguments[0] instanceof Y) { var n = arguments[0]; return this.covers(n) } } else if (2 === arguments.length) { var r = arguments[0], i = arguments[1]; return this.covers(r, i) } } }, { key: "centre", value: function () { return this.isNull() ? null : new Y((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2) } }, { key: "init", value: function () { if (0 === arguments.length) this.setToNull(); else if (1 === arguments.length) { if (arguments[0] instanceof Y) { var t = arguments[0]; this.init(t.x, t.x, t.y, t.y) } else if (arguments[0] instanceof e) { var n = arguments[0]; this._minx = n._minx, this._maxx = n._maxx, this._miny = n._miny, this._maxy = n._maxy } } else if (2 === arguments.length) { var r = arguments[0], i = arguments[1]; this.init(r.x, i.x, r.y, i.y) } else if (4 === arguments.length) { var o = arguments[0], a = arguments[1], s = arguments[2], u = arguments[3]; o < a ? (this._minx = o, this._maxx = a) : (this._minx = a, this._maxx = o), s < u ? (this._miny = s, this._maxy = u) : (this._miny = u, this._maxy = s) } } }, { key: "getMaxY", value: function () { return this._maxy } }, { key: "distance", value: function (t) { if (this.intersects(t)) return 0; var e = 0; this._maxx < t._minx ? e = t._minx - this._maxx : this._minx > t._maxx && (e = this._minx - t._maxx); var n = 0; return this._maxy < t._miny ? n = t._miny - this._maxy : this._miny > t._maxy && (n = this._miny - t._maxy), 0 === e ? n : 0 === n ? e : Math.sqrt(e * e + n * n) } }, { key: "hashCode", value: function () { var t = 17; return 37 * (t = 37 * (t = 37 * (t = 37 * t + Y.hashCode(this._minx)) + Y.hashCode(this._maxx)) + Y.hashCode(this._miny)) + Y.hashCode(this._maxy) } }, { key: "interfaces_", get: function () { return [E, k] } }], [{ key: "constructor_", value: function () { if (this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, 0 === arguments.length) this.init(); else if (1 === arguments.length) { if (arguments[0] instanceof Y) { var t = arguments[0]; this.init(t.x, t.x, t.y, t.y) } else if (arguments[0] instanceof e) { var n = arguments[0]; this.init(n) } } else if (2 === arguments.length) { var r = arguments[0], i = arguments[1]; this.init(r.x, i.x, r.y, i.y) } else if (4 === arguments.length) { var o = arguments[0], a = arguments[1], s = arguments[2], u = arguments[3]; this.init(o, a, s, u) } } }, { key: "intersects", value: function () { if (3 === arguments.length) { var t = arguments[0], e = arguments[1], n = arguments[2]; return n.x >= (t.x < e.x ? t.x : e.x) && n.x <= (t.x > e.x ? t.x : e.x) && n.y >= (t.y < e.y ? t.y : e.y) && n.y <= (t.y > e.y ? t.y : e.y) } if (4 === arguments.length) { var r = arguments[0], i = arguments[1], o = arguments[2], a = arguments[3], s = Math.min(o.x, a.x), u = Math.max(o.x, a.x), l = Math.min(r.x, i.x), c = Math.max(r.x, i.x); return !(l > u || c < s || (s = Math.min(o.y, a.y), u = Math.max(o.y, a.y), l = Math.min(r.y, i.y), c = Math.max(r.y, i.y), l > u || c < s)) } } }]), e }(), X = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "isGeometryCollection", value: function () { return this.getTypeCode() === e.TYPECODE_GEOMETRYCOLLECTION } }, { key: "getFactory", value: function () { return this._factory } }, { key: "getGeometryN", value: function (t) { return this } }, { key: "getArea", value: function () { return 0 } }, { key: "isRectangle", value: function () { return !1 } }, { key: "equalsExact", value: function (t) { return this === t || this.equalsExact(t, 0) } }, { key: "geometryChanged", value: function () { this.apply(e.geometryChangedFilter) } }, { key: "geometryChangedAction", value: function () { this._envelope = null } }, { key: "equalsNorm", value: function (t) { return null !== t && this.norm().equalsExact(t.norm()) } }, { key: "getLength", value: function () { return 0 } }, { key: "getNumGeometries", value: function () { return 1 } }, { key: "compareTo", value: function () { var t; if (1 === arguments.length) { var e = arguments[0]; return t = e, this.getTypeCode() !== t.getTypeCode() ? this.getTypeCode() - t.getTypeCode() : this.isEmpty() && t.isEmpty() ? 0 : this.isEmpty() ? -1 : t.isEmpty() ? 1 : this.compareToSameClass(e) } if (2 === arguments.length) { var n = arguments[0], r = arguments[1]; return t = n, this.getTypeCode() !== t.getTypeCode() ? this.getTypeCode() - t.getTypeCode() : this.isEmpty() && t.isEmpty() ? 0 : this.isEmpty() ? -1 : t.isEmpty() ? 1 : this.compareToSameClass(n, r) } } }, { key: "getUserData", value: function () { return this._userData } }, { key: "getSRID", value: function () { return this._SRID } }, { key: "getEnvelope", value: function () { return this.getFactory().toGeometry(this.getEnvelopeInternal()) } }, { key: "checkNotGeometryCollection", value: function (t) { if (t.getTypeCode() === e.TYPECODE_GEOMETRYCOLLECTION) throw new b("This method does not support GeometryCollection arguments") } }, { key: "equal", value: function (t, e, n) { return 0 === n ? t.equals(e) : t.distance(e) <= n } }, { key: "norm", value: function () { var t = this.copy(); return t.normalize(), t } }, { key: "reverse", value: function () { var t = this.reverseInternal(); return null != this.envelope && (t.envelope = this.envelope.copy()), t.setSRID(this.getSRID()), t } }, { key: "copy", value: function () { var t = this.copyInternal(); return t.envelope = null == this._envelope ? null : this._envelope.copy(), t._SRID = this._SRID, t._userData = this._userData, t } }, { key: "getPrecisionModel", value: function () { return this._factory.getPrecisionModel() } }, { key: "getEnvelopeInternal", value: function () { return null === this._envelope && (this._envelope = this.computeEnvelopeInternal()), new U(this._envelope) } }, { key: "setSRID", value: function (t) { this._SRID = t } }, { key: "setUserData", value: function (t) { this._userData = t } }, { key: "compare", value: function (t, e) { for (var n = t.iterator(), r = e.iterator(); n.hasNext() && r.hasNext();) { var i = n.next(), o = r.next(), a = i.compareTo(o); if (0 !== a) return a } return n.hasNext() ? 1 : r.hasNext() ? -1 : 0 } }, { key: "hashCode", value: function () { return this.getEnvelopeInternal().hashCode() } }, { key: "isEquivalentClass", value: function (t) { return this.getClass() === t.getClass() } }, { key: "isGeometryCollectionOrDerived", value: function () { return this.getTypeCode() === e.TYPECODE_GEOMETRYCOLLECTION || this.getTypeCode() === e.TYPECODE_MULTIPOINT || this.getTypeCode() === e.TYPECODE_MULTILINESTRING || this.getTypeCode() === e.TYPECODE_MULTIPOLYGON } }, { key: "interfaces_", get: function () { return [w, E, k] } }, { key: "getClass", value: function () { return e } }], [{ key: "hasNonEmptyElements", value: function (t) { for (var e = 0; e < t.length; e++)if (!t[e].isEmpty()) return !0; return !1 } }, { key: "hasNullElements", value: function (t) { for (var e = 0; e < t.length; e++)if (null === t[e]) return !0; return !1 } }]), e }(); X.constructor_ = function (t) { t && (this._envelope = null, this._userData = null, this._factory = t, this._SRID = t.getSRID()) }, X.TYPECODE_POINT = 0, X.TYPECODE_MULTIPOINT = 1, X.TYPECODE_LINESTRING = 2, X.TYPECODE_LINEARRING = 3, X.TYPECODE_MULTILINESTRING = 4, X.TYPECODE_POLYGON = 5, X.TYPECODE_MULTIPOLYGON = 6, X.TYPECODE_GEOMETRYCOLLECTION = 7, X.TYPENAME_POINT = "Point", X.TYPENAME_MULTIPOINT = "MultiPoint", X.TYPENAME_LINESTRING = "LineString", X.TYPENAME_LINEARRING = "LinearRing", X.TYPENAME_MULTILINESTRING = "MultiLineString", X.TYPENAME_POLYGON = "Polygon", X.TYPENAME_MULTIPOLYGON = "MultiPolygon", X.TYPENAME_GEOMETRYCOLLECTION = "GeometryCollection", X.geometryChangedFilter = { get interfaces_() { return [x] }, filter: function (t) { t.geometryChangedAction() } }; var W = function () { function e() { t(this, e) } return r(e, null, [{ key: "toLocationSymbol", value: function (t) { switch (t) { case e.EXTERIOR: return "e"; case e.BOUNDARY: return "b"; case e.INTERIOR: return "i"; case e.NONE: return "-" }throw new b("Unknown location value: " + t) } }]), e }(); W.INTERIOR = 0, W.BOUNDARY = 1, W.EXTERIOR = 2, W.NONE = -1; var H = function () { function e() { t(this, e) } return r(e, [{ key: "add", value: function () { } }, { key: "addAll", value: function () { } }, { key: "isEmpty", value: function () { } }, { key: "iterator", value: function () { } }, { key: "size", value: function () { } }, { key: "toArray", value: function () { } }, { key: "remove", value: function () { } }]), e }(), Z = function (e) { i(r, e); var n = f(r); function r(e) { var i; return t(this, r), (i = n.call(this, e)).name = Object.keys({ NoSuchElementException: r })[0], i } return r }(_), J = function (e) { i(r, e); var n = f(r); function r(e) { var i; return t(this, r), (i = n.call(this, e)).name = Object.keys({ UnsupportedOperationException: r })[0], i } return r }(_), $ = function (e) { i(o, e); var n = f(o); function o() { return t(this, o), n.apply(this, arguments) } return r(o, [{ key: "contains", value: function () { } }]), o }(H), Q = function (e, n) { i(a, e); var o = f(a); function a(e) { var n; return t(this, a), (n = o.call(this)).map = new Map, e instanceof H && n.addAll(e), n } return r(a, [{ key: "contains", value: function (t) { var e = t.hashCode ? t.hashCode() : t; return !!this.map.has(e) } }, { key: "add", value: function (t) { var e = t.hashCode ? t.hashCode() : t; return !this.map.has(e) && !!this.map.set(e, t) } }, { key: "addAll", value: function (t) { var e, n = d(t); try { for (n.s(); !(e = n.n()).done;) { var r = e.value; this.add(r) } } catch (t) { n.e(t) } finally { n.f() } return !0 } }, { key: "remove", value: function () { throw new J } }, { key: "size", value: function () { return this.map.size } }, { key: "isEmpty", value: function () { return 0 === this.map.size } }, { key: "toArray", value: function () { return Array.from(this.map.values()) } }, { key: "iterator", value: function () { return new K(this.map) } }, { key: n, value: function () { return this.map } }]), a }($, Symbol.iterator), K = function () { function e(n) { t(this, e), this.iterator = n.values(); var r = this.iterator.next(), i = r.done, o = r.value; this.done = i, this.value = o } return r(e, [{ key: "next", value: function () { if (this.done) throw new Z; var t = this.value, e = this.iterator.next(), n = e.done, r = e.value; return this.done = n, this.value = r, t } }, { key: "hasNext", value: function () { return !this.done } }, { key: "remove", value: function () { throw new J } }]), e }(), tt = function () { function e() { t(this, e) } return r(e, null, [{ key: "opposite", value: function (t) { return t === e.LEFT ? e.RIGHT : t === e.RIGHT ? e.LEFT : t } }]), e }(); tt.ON = 0, tt.LEFT = 1, tt.RIGHT = 2; var et = function (e) { i(r, e); var n = f(r); function r(e) { var i; return t(this, r), (i = n.call(this, e)).name = Object.keys({ EmptyStackException: r })[0], i } return r }(_), nt = function (e) { i(r, e); var n = f(r); function r(e) { var i; return t(this, r), (i = n.call(this, e)).name = Object.keys({ IndexOutOfBoundsException: r })[0], i } return r }(_), rt = function (e) { i(o, e); var n = f(o); function o() { return t(this, o), n.apply(this, arguments) } return r(o, [{ key: "get", value: function () { } }, { key: "set", value: function () { } }, { key: "isEmpty", value: function () { } }]), o }(H), it = function (e) { i(o, e); var n = f(o); function o() { var e; return t(this, o), (e = n.call(this)).array = [], e } return r(o, [{ key: "add", value: function (t) { return this.array.push(t), !0 } }, { key: "get", value: function (t) { if (t < 0 || t >= this.size()) throw new nt; return this.array[t] } }, { key: "push", value: function (t) { return this.array.push(t), t } }, { key: "pop", value: function () { if (0 === this.array.length) throw new et; return this.array.pop() } }, { key: "peek", value: function () { if (0 === this.array.length) throw new et; return this.array[this.array.length - 1] } }, { key: "empty", value: function () { return 0 === this.array.length } }, { key: "isEmpty", value: function () { return this.empty() } }, { key: "search", value: function (t) { return this.array.indexOf(t) } }, { key: "size", value: function () { return this.array.length } }, { key: "toArray", value: function () { return this.array.slice() } }]), o }(rt); function ot(t, e) { return t.interfaces_ && t.interfaces_.indexOf(e) > -1 } var at = function () { function e(n) { t(this, e), this.str = n } return r(e, [{ key: "append", value: function (t) { this.str += t } }, { key: "setCharAt", value: function (t, e) { this.str = this.str.substr(0, t) + e + this.str.substr(t + 1) } }, { key: "toString", value: function () { return this.str } }]), e }(), st = function () { function e(n) { t(this, e), this.value = n } return r(e, [{ key: "intValue", value: function () { return this.value } }, { key: "compareTo", value: function (t) { return this.value < t ? -1 : this.value > t ? 1 : 0 } }], [{ key: "compare", value: function (t, e) { return t < e ? -1 : t > e ? 1 : 0 } }, { key: "isNan", value: function (t) { return Number.isNaN(t) } }, { key: "valueOf", value: function (t) { return new e(t) } }]), e }(), ut = function () { function e() { t(this, e) } return r(e, null, [{ key: "isWhitespace", value: function (t) { return t <= 32 && t >= 0 || 127 === t } }, { key: "toUpperCase", value: function (t) { return t.toUpperCase() } }]), e }(), lt = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "le", value: function (t) { return this._hi < t._hi || this._hi === t._hi && this._lo <= t._lo } }, { key: "extractSignificantDigits", value: function (t, n) { var r = this.abs(), i = e.magnitude(r._hi), o = e.TEN.pow(i); (r = r.divide(o)).gt(e.TEN) ? (r = r.divide(e.TEN), i += 1) : r.lt(e.ONE) && (r = r.multiply(e.TEN), i -= 1); for (var a = i + 1, s = new at, u = e.MAX_PRINT_DIGITS - 1, l = 0; l <= u; l++) { t && l === a && s.append("."); var c = Math.trunc(r._hi); if (c < 0) break; var h = !1, f = 0; c > 9 ? (h = !0, f = "9") : f = "0" + c, s.append(f), r = r.subtract(e.valueOf(c)).multiply(e.TEN), h && r.selfAdd(e.TEN); var p = !0, g = e.magnitude(r._hi); if (g < 0 && Math.abs(g) >= u - l && (p = !1), !p) break } return n[0] = i, s.toString() } }, { key: "sqr", value: function () { return this.multiply(this) } }, { key: "doubleValue", value: function () { return this._hi + this._lo } }, { key: "subtract", value: function () { if (arguments[0] instanceof e) { var t = arguments[0]; return this.add(t.negate()) } if ("number" == typeof arguments[0]) { var n = arguments[0]; return this.add(-n) } } }, { key: "equals", value: function () { if (1 === arguments.length && arguments[0] instanceof e) { var t = arguments[0]; return this._hi === t._hi && this._lo === t._lo } } }, { key: "isZero", value: function () { return 0 === this._hi && 0 === this._lo } }, { key: "selfSubtract", value: function () { if (arguments[0] instanceof e) { var t = arguments[0]; return this.isNaN() ? this : this.selfAdd(-t._hi, -t._lo) } if ("number" == typeof arguments[0]) { var n = arguments[0]; return this.isNaN() ? this : this.selfAdd(-n, 0) } } }, { key: "getSpecialNumberString", value: function () { return this.isZero() ? "0.0" : this.isNaN() ? "NaN " : null } }, { key: "min", value: function (t) { return this.le(t) ? this : t } }, { key: "selfDivide", value: function () { if (1 === arguments.length) { if (arguments[0] instanceof e) { var t = arguments[0]; return this.selfDivide(t._hi, t._lo) } if ("number" == typeof arguments[0]) { var n = arguments[0]; return this.selfDivide(n, 0) } } else if (2 === arguments.length) { var r = arguments[0], i = arguments[1], o = null, a = null, s = null, u = null, l = null, c = null, h = null, f = null; return l = this._hi / r, f = (o = (c = e.SPLIT * l) - (o = c - l)) * (s = (f = e.SPLIT * r) - (s = f - r)) - (h = l * r) + o * (u = r - s) + (a = l - o) * s + a * u, f = l + (c = (this._hi - h - f + this._lo - l * i) / r), this._hi = f, this._lo = l - f + c, this } } }, { key: "dump", value: function () { return "DD<" + this._hi + ", " + this._lo + ">" } }, { key: "divide", value: function () { if (arguments[0] instanceof e) { var t = arguments[0], n = null, r = null, i = null, o = null, a = null, s = null, u = null, l = null; return r = (a = this._hi / t._hi) - (n = (s = e.SPLIT * a) - (n = s - a)), l = n * (i = (l = e.SPLIT * t._hi) - (i = l - t._hi)) - (u = a * t._hi) + n * (o = t._hi - i) + r * i + r * o, new e(l = a + (s = (this._hi - u - l + this._lo - a * t._lo) / t._hi), a - l + s) } if ("number" == typeof arguments[0]) { var c = arguments[0]; return A.isNaN(c) ? e.createNaN() : e.copy(this).selfDivide(c, 0) } } }, { key: "ge", value: function (t) { return this._hi > t._hi || this._hi === t._hi && this._lo >= t._lo } }, { key: "pow", value: function (t) { if (0 === t) return e.valueOf(1); var n = new e(this), r = e.valueOf(1), i = Math.abs(t); if (i > 1) for (; i > 0;)i % 2 == 1 && r.selfMultiply(n), (i /= 2) > 0 && (n = n.sqr()); else r = n; return t < 0 ? r.reciprocal() : r } }, { key: "ceil", value: function () { if (this.isNaN()) return e.NaN; var t = Math.ceil(this._hi), n = 0; return t === this._hi && (n = Math.ceil(this._lo)), new e(t, n) } }, { key: "compareTo", value: function (t) { var e = t; return this._hi < e._hi ? -1 : this._hi > e._hi ? 1 : this._lo < e._lo ? -1 : this._lo > e._lo ? 1 : 0 } }, { key: "rint", value: function () { return this.isNaN() ? this : this.add(.5).floor() } }, { key: "setValue", value: function () { if (arguments[0] instanceof e) { var t = arguments[0]; return this.init(t), this } if ("number" == typeof arguments[0]) { var n = arguments[0]; return this.init(n), this } } }, { key: "max", value: function (t) { return this.ge(t) ? this : t } }, { key: "sqrt", value: function () { if (this.isZero()) return e.valueOf(0); if (this.isNegative()) return e.NaN; var t = 1 / Math.sqrt(this._hi), n = this._hi * t, r = e.valueOf(n), i = this.subtract(r.sqr())._hi * (.5 * t); return r.add(i) } }, { key: "selfAdd", value: function () { if (1 === arguments.length) { if (arguments[0] instanceof e) { var t = arguments[0]; return this.selfAdd(t._hi, t._lo) } if ("number" == typeof arguments[0]) { var n = arguments[0], r = null, i = null, o = null, a = null, s = null, u = null; return a = (o = this._hi + n) - (s = o - this._hi), i = (u = (a = n - s + (this._hi - a)) + this._lo) + (o - (r = o + u)), this._hi = r + i, this._lo = i + (r - this._hi), this } } else if (2 === arguments.length) { var l = arguments[0], c = arguments[1], h = null, f = null, p = null, g = null, y = null, v = null, d = null; g = this._hi + l, f = this._lo + c, y = g - (v = g - this._hi), p = f - (d = f - this._lo); var m = (h = g + (v = (y = l - v + (this._hi - y)) + f)) + (v = (p = c - d + (this._lo - p)) + (v + (g - h))), _ = v + (h - m); return this._hi = m, this._lo = _, this } } }, { key: "selfMultiply", value: function () { if (1 === arguments.length) { if (arguments[0] instanceof e) { var t = arguments[0]; return this.selfMultiply(t._hi, t._lo) } if ("number" == typeof arguments[0]) { var n = arguments[0]; return this.selfMultiply(n, 0) } } else if (2 === arguments.length) { var r = arguments[0], i = arguments[1], o = null, a = null, s = null, u = null, l = null, c = null; o = (l = e.SPLIT * this._hi) - this._hi, c = e.SPLIT * r, o = l - o, a = this._hi - o, s = c - r; var h = (l = this._hi * r) + (c = o * (s = c - s) - l + o * (u = r - s) + a * s + a * u + (this._hi * i + this._lo * r)), f = c + (o = l - h); return this._hi = h, this._lo = f, this } } }, { key: "selfSqr", value: function () { return this.selfMultiply(this) } }, { key: "floor", value: function () { if (this.isNaN()) return e.NaN; var t = Math.floor(this._hi), n = 0; return t === this._hi && (n = Math.floor(this._lo)), new e(t, n) } }, { key: "negate", value: function () { return this.isNaN() ? this : new e(-this._hi, -this._lo) } }, { key: "clone", value: function () { try { return null } catch (t) { if (t instanceof CloneNotSupportedException) return null; throw t } } }, { key: "multiply", value: function () { if (arguments[0] instanceof e) { var t = arguments[0]; return t.isNaN() ? e.createNaN() : e.copy(this).selfMultiply(t) } if ("number" == typeof arguments[0]) { var n = arguments[0]; return A.isNaN(n) ? e.createNaN() : e.copy(this).selfMultiply(n, 0) } } }, { key: "isNaN", value: function () { return A.isNaN(this._hi) } }, { key: "intValue", value: function () { return Math.trunc(this._hi) } }, { key: "toString", value: function () { var t = e.magnitude(this._hi); return t >= -3 && t <= 20 ? this.toStandardNotation() : this.toSciNotation() } }, { key: "toStandardNotation", value: function () { var t = this.getSpecialNumberString(); if (null !== t) return t; var n = new Array(1).fill(null), r = this.extractSignificantDigits(!0, n), i = n[0] + 1, o = r; if ("." === r.charAt(0)) o = "0" + r; else if (i < 0) o = "0." + e.stringOfChar("0", -i) + r; else if (-1 === r.indexOf(".")) { var a = i - r.length; o = r + e.stringOfChar("0", a) + ".0" } return this.isNegative() ? "-" + o : o } }, { key: "reciprocal", value: function () { var t, n, r, i, o = null, a = null, s = null, u = null; t = (r = 1 / this._hi) - (o = (s = e.SPLIT * r) - (o = s - r)), a = (u = e.SPLIT * this._hi) - this._hi; var l = r + (s = (1 - (i = r * this._hi) - (u = o * (a = u - a) - i + o * (n = this._hi - a) + t * a + t * n) - r * this._lo) / this._hi); return new e(l, r - l + s) } }, { key: "toSciNotation", value: function () { if (this.isZero()) return e.SCI_NOT_ZERO; var t = this.getSpecialNumberString(); if (null !== t) return t; var n = new Array(1).fill(null), r = this.extractSignificantDigits(!1, n), i = e.SCI_NOT_EXPONENT_CHAR + n[0]; if ("0" === r.charAt(0)) throw new IllegalStateException("Found leading zero: " + r); var o = ""; r.length > 1 && (o = r.substring(1)); var a = r.charAt(0) + "." + o; return this.isNegative() ? "-" + a + i : a + i } }, { key: "abs", value: function () { return this.isNaN() ? e.NaN : this.isNegative() ? this.negate() : new e(this) } }, { key: "isPositive", value: function () { return this._hi > 0 || 0 === this._hi && this._lo > 0 } }, { key: "lt", value: function (t) { return this._hi < t._hi || this._hi === t._hi && this._lo < t._lo } }, { key: "add", value: function () { if (arguments[0] instanceof e) { var t = arguments[0]; return e.copy(this).selfAdd(t) } if ("number" == typeof arguments[0]) { var n = arguments[0]; return e.copy(this).selfAdd(n) } } }, { key: "init", value: function () { if (1 === arguments.length) { if ("number" == typeof arguments[0]) { var t = arguments[0]; this._hi = t, this._lo = 0 } else if (arguments[0] instanceof e) { var n = arguments[0]; this._hi = n._hi, this._lo = n._lo } } else if (2 === arguments.length) { var r = arguments[0], i = arguments[1]; this._hi = r, this._lo = i } } }, { key: "gt", value: function (t) { return this._hi > t._hi || this._hi === t._hi && this._lo > t._lo } }, { key: "isNegative", value: function () { return this._hi < 0 || 0 === this._hi && this._lo < 0 } }, { key: "trunc", value: function () { return this.isNaN() ? e.NaN : this.isPositive() ? this.floor() : this.ceil() } }, { key: "signum", value: function () { return this._hi > 0 ? 1 : this._hi < 0 ? -1 : this._lo > 0 ? 1 : this._lo < 0 ? -1 : 0 } }, { key: "interfaces_", get: function () { return [k, E, w] } }], [{ key: "constructor_", value: function () { if (this._hi = 0, this._lo = 0, 0 === arguments.length) this.init(0); else if (1 === arguments.length) { if ("number" == typeof arguments[0]) { var t = arguments[0]; this.init(t) } else if (arguments[0] instanceof e) { var n = arguments[0]; this.init(n) } else if ("string" == typeof arguments[0]) { var r = arguments[0]; e.constructor_.call(this, e.parse(r)) } } else if (2 === arguments.length) { var i = arguments[0], o = arguments[1]; this.init(i, o) } } }, { key: "determinant", value: function () { if ("number" == typeof arguments[3] && "number" == typeof arguments[2] && "number" == typeof arguments[0] && "number" == typeof arguments[1]) { var t = arguments[0], n = arguments[1], r = arguments[2], i = arguments[3]; return e.determinant(e.valueOf(t), e.valueOf(n), e.valueOf(r), e.valueOf(i)) } if (arguments[3] instanceof e && arguments[2] instanceof e && arguments[0] instanceof e && arguments[1] instanceof e) { var o = arguments[1], a = arguments[2], s = arguments[3]; return arguments[0].multiply(s).selfSubtract(o.multiply(a)) } } }, { key: "sqr", value: function (t) { return e.valueOf(t).selfMultiply(t) } }, { key: "valueOf", value: function () { if ("string" == typeof arguments[0]) { var t = arguments[0]; return e.parse(t) } if ("number" == typeof arguments[0]) return new e(arguments[0]) } }, { key: "sqrt", value: function (t) { return e.valueOf(t).sqrt() } }, { key: "parse", value: function (t) { for (var n = 0, r = t.length; ut.isWhitespace(t.charAt(n));)n++; var i = !1; if (n < r) { var o = t.charAt(n); "-" !== o && "+" !== o || (n++, "-" === o && (i = !0)) } for (var a = new e, s = 0, u = 0, l = 0, c = !1; !(n >= r);) { var h = t.charAt(n); if (n++, ut.isDigit(h)) { var f = h - "0"; a.selfMultiply(e.TEN), a.selfAdd(f), s++ } else { if ("." !== h) { if ("e" === h || "E" === h) { var p = t.substring(n); try { l = st.parseInt(p) } catch (e) { throw e instanceof NumberFormatException ? new NumberFormatException("Invalid exponent " + p + " in string " + t) : e } break } throw new NumberFormatException("Unexpected character '" + h + "' at position " + n + " in string " + t) } u = s, c = !0 } } var g = a; c || (u = s); var y = s - u - l; if (0 === y) g = a; else if (y > 0) { var v = e.TEN.pow(y); g = a.divide(v) } else if (y < 0) { var d = e.TEN.pow(-y); g = a.multiply(d) } return i ? g.negate() : g } }, { key: "createNaN", value: function () { return new e(A.NaN, A.NaN) } }, { key: "copy", value: function (t) { return new e(t) } }, { key: "magnitude", value: function (t) { var e = Math.abs(t), n = Math.log(e) / Math.log(10), r = Math.trunc(Math.floor(n)); return 10 * Math.pow(10, r) <= e && (r += 1), r } }, { key: "stringOfChar", value: function (t, e) { for (var n = new at, r = 0; r < e; r++)n.append(t); return n.toString() } }]), e }(); lt.PI = new lt(3.141592653589793, 12246467991473532e-32), lt.TWO_PI = new lt(6.283185307179586, 24492935982947064e-32), lt.PI_2 = new lt(1.5707963267948966, 6123233995736766e-32), lt.E = new lt(2.718281828459045, 14456468917292502e-32), lt.NaN = new lt(A.NaN, A.NaN), lt.EPS = 123259516440783e-46, lt.SPLIT = 134217729, lt.MAX_PRINT_DIGITS = 32, lt.TEN = lt.valueOf(10), lt.ONE = lt.valueOf(1), lt.SCI_NOT_EXPONENT_CHAR = "E", lt.SCI_NOT_ZERO = "0.0E0"; var ct = function () { function e() { t(this, e) } return r(e, null, [{ key: "orientationIndex", value: function (t, n, r) { var i = e.orientationIndexFilter(t, n, r); if (i <= 1) return i; var o = lt.valueOf(n.x).selfAdd(-t.x), a = lt.valueOf(n.y).selfAdd(-t.y), s = lt.valueOf(r.x).selfAdd(-n.x), u = lt.valueOf(r.y).selfAdd(-n.y); return o.selfMultiply(u).selfSubtract(a.selfMultiply(s)).signum() } }, { key: "signOfDet2x2", value: function () { if (arguments[3] instanceof lt && arguments[2] instanceof lt && arguments[0] instanceof lt && arguments[1] instanceof lt) { var t = arguments[1], e = arguments[2], n = arguments[3]; return arguments[0].multiply(n).selfSubtract(t.multiply(e)).signum() } if ("number" == typeof arguments[3] && "number" == typeof arguments[2] && "number" == typeof arguments[0] && "number" == typeof arguments[1]) { var r = arguments[0], i = arguments[1], o = arguments[2], a = arguments[3], s = lt.valueOf(r), u = lt.valueOf(i), l = lt.valueOf(o), c = lt.valueOf(a); return s.multiply(c).selfSubtract(u.multiply(l)).signum() } } }, { key: "intersection", value: function (t, e, n, r) { var i = new lt(t.y).selfSubtract(e.y), o = new lt(e.x).selfSubtract(t.x), a = new lt(t.x).selfMultiply(e.y).selfSubtract(new lt(e.x).selfMultiply(t.y)), s = new lt(n.y).selfSubtract(r.y), u = new lt(r.x).selfSubtract(n.x), l = new lt(n.x).selfMultiply(r.y).selfSubtract(new lt(r.x).selfMultiply(n.y)), c = o.multiply(l).selfSubtract(u.multiply(a)), h = s.multiply(a).selfSubtract(i.multiply(l)), f = i.multiply(u).selfSubtract(s.multiply(o)), p = c.selfDivide(f).doubleValue(), g = h.selfDivide(f).doubleValue(); return A.isNaN(p) || A.isInfinite(p) || A.isNaN(g) || A.isInfinite(g) ? null : new Y(p, g) } }, { key: "orientationIndexFilter", value: function (t, n, r) { var i = null, o = (t.x - r.x) * (n.y - r.y), a = (t.y - r.y) * (n.x - r.x), s = o - a; if (o > 0) { if (a <= 0) return e.signum(s); i = o + a } else { if (!(o < 0)) return e.signum(s); if (a >= 0) return e.signum(s); i = -o - a } var u = e.DP_SAFE_EPSILON * i; return s >= u || -s >= u ? e.signum(s) : 2 } }, { key: "signum", value: function (t) { return t > 0 ? 1 : t < 0 ? -1 : 0 } }]), e }(); ct.DP_SAFE_EPSILON = 1e-15; var ht = function () { function e() { t(this, e) } return r(e, [{ key: "getM", value: function (t) { if (this.hasM()) { var e = this.getDimension() - this.getMeasures(); return this.getOrdinate(t, e) } return A.NaN } }, { key: "setOrdinate", value: function (t, e, n) { } }, { key: "getZ", value: function (t) { return this.hasZ() ? this.getOrdinate(t, 2) : A.NaN } }, { key: "size", value: function () { } }, { key: "getOrdinate", value: function (t, e) { } }, { key: "getCoordinate", value: function () { } }, { key: "getCoordinateCopy", value: function (t) { } }, { key: "createCoordinate", value: function () { } }, { key: "getDimension", value: function () { } }, { key: "hasM", value: function () { return this.getMeasures() > 0 } }, { key: "getX", value: function (t) { } }, { key: "hasZ", value: function () { return this.getDimension() - this.getMeasures() > 2 } }, { key: "getMeasures", value: function () { return 0 } }, { key: "expandEnvelope", value: function (t) { } }, { key: "copy", value: function () { } }, { key: "getY", value: function (t) { } }, { key: "toCoordinateArray", value: function () { } }, { key: "interfaces_", get: function () { return [w] } }]), e }(); ht.X = 0, ht.Y = 1, ht.Z = 2, ht.M = 3; var ft = function () { function e() { t(this, e) } return r(e, null, [{ key: "index", value: function (t, e, n) { return ct.orientationIndex(t, e, n) } }, { key: "isCCW", value: function () { if (arguments[0] instanceof Array) { var t = arguments[0], n = t.length - 1; if (n < 3) throw new b("Ring has fewer than 4 points, so orientation cannot be determined"); for (var r = t[0], i = 0, o = 1; o <= n; o++) { var a = t[o]; a.y > r.y && (r = a, i = o) } var s = i; do { (s -= 1) < 0 && (s = n) } while (t[s].equals2D(r) && s !== i); var u = i; do { u = (u + 1) % n } while (t[u].equals2D(r) && u !== i); var l = t[s], c = t[u]; if (l.equals2D(r) || c.equals2D(r) || l.equals2D(c)) return !1; var h = e.index(l, r, c); return 0 === h ? l.x > c.x : h > 0 } if (ot(arguments[0], ht)) { var f = arguments[0], p = f.size() - 1; if (p < 3) throw new b("Ring has fewer than 4 points, so orientation cannot be determined"); for (var g = f.getCoordinate(0), y = 0, v = 1; v <= p; v++) { var d = f.getCoordinate(v); d.y > g.y && (g = d, y = v) } var m = null, _ = y; do { (_ -= 1) < 0 && (_ = p), m = f.getCoordinate(_) } while (m.equals2D(g) && _ !== y); var x = null, E = y; do { E = (E + 1) % p, x = f.getCoordinate(E) } while (x.equals2D(g) && E !== y); if (m.equals2D(g) || x.equals2D(g) || m.equals2D(x)) return !1; var w = e.index(m, g, x); return 0 === w ? m.x > x.x : w > 0 } } }]), e }(); ft.CLOCKWISE = -1, ft.RIGHT = ft.CLOCKWISE, ft.COUNTERCLOCKWISE = 1, ft.LEFT = ft.COUNTERCLOCKWISE, ft.COLLINEAR = 0, ft.STRAIGHT = ft.COLLINEAR; var pt = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "getCoordinate", value: function () { return this._minCoord } }, { key: "getRightmostSide", value: function (t, e) { var n = this.getRightmostSideOfSegment(t, e); return n < 0 && (n = this.getRightmostSideOfSegment(t, e - 1)), n < 0 && (this._minCoord = null, this.checkForRightmostCoordinate(t)), n } }, { key: "findRightmostEdgeAtVertex", value: function () { var t = this._minDe.getEdge().getCoordinates(); B.isTrue(this._minIndex > 0 && this._minIndex < t.length, "rightmost point expected to be interior vertex of edge"); var e = t[this._minIndex - 1], n = t[this._minIndex + 1], r = ft.index(this._minCoord, n, e), i = !1; (e.y < this._minCoord.y && n.y < this._minCoord.y && r === ft.COUNTERCLOCKWISE || e.y > this._minCoord.y && n.y > this._minCoord.y && r === ft.CLOCKWISE) && (i = !0), i && (this._minIndex = this._minIndex - 1) } }, { key: "getRightmostSideOfSegment", value: function (t, e) { var n = t.getEdge().getCoordinates(); if (e < 0 || e + 1 >= n.length) return -1; if (n[e].y === n[e + 1].y) return -1; var r = tt.LEFT; return n[e].y < n[e + 1].y && (r = tt.RIGHT), r } }, { key: "getEdge", value: function () { return this._orientedDe } }, { key: "checkForRightmostCoordinate", value: function (t) { for (var e = t.getEdge().getCoordinates(), n = 0; n < e.length - 1; n++)(null === this._minCoord || e[n].x > this._minCoord.x) && (this._minDe = t, this._minIndex = n, this._minCoord = e[n]) } }, { key: "findRightmostEdgeAtNode", value: function () { var t = this._minDe.getNode().getEdges(); this._minDe = t.getRightmostEdge(), this._minDe.isForward() || (this._minDe = this._minDe.getSym(), this._minIndex = this._minDe.getEdge().getCoordinates().length - 1) } }, { key: "findEdge", value: function (t) { for (var e = t.iterator(); e.hasNext();) { var n = e.next(); n.isForward() && this.checkForRightmostCoordinate(n) } B.isTrue(0 !== this._minIndex || this._minCoord.equals(this._minDe.getCoordinate()), "inconsistency in rightmost processing"), 0 === this._minIndex ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(), this._orientedDe = this._minDe, this.getRightmostSide(this._minDe, this._minIndex) === tt.LEFT && (this._orientedDe = this._minDe.getSym()) } }], [{ key: "constructor_", value: function () { this._minIndex = -1, this._minCoord = null, this._minDe = null, this._orientedDe = null } }]), e }(), gt = function (e) { i(o, e); var n = f(o); function o(e, r) { var i; return t(this, o), (i = n.call(this, r ? e + " [ " + r + " ]" : e)).pt = r ? new Y(r) : void 0, i.name = Object.keys({ TopologyException: o })[0], i } return r(o, [{ key: "getCoordinate", value: function () { return this.pt } }]), o }(j), yt = function () { function e() { t(this, e), this.array = [] } return r(e, [{ key: "addLast", value: function (t) { this.array.push(t) } }, { key: "removeFirst", value: function () { return this.array.shift() } }, { key: "isEmpty", value: function () { return 0 === this.array.length } }]), e }(), vt = function (e, n) { i(a, e); var o = f(a); function a(e) { var n; return t(this, a), (n = o.call(this)).array = [], e instanceof H && n.addAll(e), n } return r(a, [{ key: "interfaces_", get: function () { return [rt, H] } }, { key: "ensureCapacity", value: function () { } }, { key: "add", value: function (t) { return 1 === arguments.length ? this.array.push(t) : this.array.splice(arguments[0], 0, arguments[1]), !0 } }, { key: "clear", value: function () { this.array = [] } }, { key: "addAll", value: function (t) { var e, n = d(t); try { for (n.s(); !(e = n.n()).done;) { var r = e.value; this.array.push(r) } } catch (t) { n.e(t) } finally { n.f() } } }, { key: "set", value: function (t, e) { var n = this.array[t]; return this.array[t] = e, n } }, { key: "iterator", value: function () { return new dt(this) } }, { key: "get", value: function (t) { if (t < 0 || t >= this.size()) throw new nt; return this.array[t] } }, { key: "isEmpty", value: function () { return 0 === this.array.length } }, { key: "sort", value: function (t) { t ? this.array.sort((function (e, n) { return t.compare(e, n) })) : this.array.sort() } }, { key: "size", value: function () { return this.array.length } }, { key: "toArray", value: function () { return this.array.slice() } }, { key: "remove", value: function (t) { for (var e = 0, n = this.array.length; e < n; e++)if (this.array[e] === t) return !!this.array.splice(e, 1); return !1 } }, { key: n, value: function () { return this.array.values() } }]), a }(rt, Symbol.iterator), dt = function () { function e(n) { t(this, e), this.arrayList = n, this.position = 0 } return r(e, [{ key: "next", value: function () { if (this.position === this.arrayList.size()) throw new Z; return this.arrayList.get(this.position++) } }, { key: "hasNext", value: function () { return this.position < this.arrayList.size() } }, { key: "set", value: function (t) { return this.arrayList.set(this.position - 1, t) } }, { key: "remove", value: function () { this.arrayList.remove(this.arrayList.get(this.position)) } }]), e }(), mt = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "clearVisitedEdges", value: function () { for (var t = this._dirEdgeList.iterator(); t.hasNext();)t.next().setVisited(!1) } }, { key: "getRightmostCoordinate", value: function () { return this._rightMostCoord } }, { key: "computeNodeDepth", value: function (t) { for (var e = null, n = t.getEdges().iterator(); n.hasNext();) { var r = n.next(); if (r.isVisited() || r.getSym().isVisited()) { e = r; break } } if (null === e) throw new gt("unable to find edge to compute depths at " + t.getCoordinate()); t.getEdges().computeDepths(e); for (var i = t.getEdges().iterator(); i.hasNext();) { var o = i.next(); o.setVisited(!0), this.copySymDepths(o) } } }, { key: "computeDepth", value: function (t) { this.clearVisitedEdges(); var e = this._finder.getEdge(); e.getNode(), e.getLabel(), e.setEdgeDepths(tt.RIGHT, t), this.copySymDepths(e), this.computeDepths(e) } }, { key: "create", value: function (t) { this.addReachable(t), this._finder.findEdge(this._dirEdgeList), this._rightMostCoord = this._finder.getCoordinate() } }, { key: "findResultEdges", value: function () { for (var t = this._dirEdgeList.iterator(); t.hasNext();) { var e = t.next(); e.getDepth(tt.RIGHT) >= 1 && e.getDepth(tt.LEFT) <= 0 && !e.isInteriorAreaEdge() && e.setInResult(!0) } } }, { key: "computeDepths", value: function (t) { var e = new Q, n = new yt, r = t.getNode(); for (n.addLast(r), e.add(r), t.setVisited(!0); !n.isEmpty();) { var i = n.removeFirst(); e.add(i), this.computeNodeDepth(i); for (var o = i.getEdges().iterator(); o.hasNext();) { var a = o.next().getSym(); if (!a.isVisited()) { var s = a.getNode(); e.contains(s) || (n.addLast(s), e.add(s)) } } } } }, { key: "compareTo", value: function (t) { var e = t; return this._rightMostCoord.x < e._rightMostCoord.x ? -1 : this._rightMostCoord.x > e._rightMostCoord.x ? 1 : 0 } }, { key: "getEnvelope", value: function () { if (null === this._env) { for (var t = new U, e = this._dirEdgeList.iterator(); e.hasNext();)for (var n = e.next().getEdge().getCoordinates(), r = 0; r < n.length - 1; r++)t.expandToInclude(n[r]); this._env = t } return this._env } }, { key: "addReachable", value: function (t) { var e = new it; for (e.add(t); !e.empty();) { var n = e.pop(); this.add(n, e) } } }, { key: "copySymDepths", value: function (t) { var e = t.getSym(); e.setDepth(tt.LEFT, t.getDepth(tt.RIGHT)), e.setDepth(tt.RIGHT, t.getDepth(tt.LEFT)) } }, { key: "add", value: function (t, e) { t.setVisited(!0), this._nodes.add(t); for (var n = t.getEdges().iterator(); n.hasNext();) { var r = n.next(); this._dirEdgeList.add(r); var i = r.getSym().getNode(); i.isVisited() || e.push(i) } } }, { key: "getNodes", value: function () { return this._nodes } }, { key: "getDirectedEdges", value: function () { return this._dirEdgeList } }, { key: "interfaces_", get: function () { return [E] } }], [{ key: "constructor_", value: function () { this._finder = null, this._dirEdgeList = new vt, this._nodes = new vt, this._rightMostCoord = null, this._env = null, this._finder = new pt } }]), e }(), _t = function () { function e() { t(this, e) } return r(e, null, [{ key: "intersection", value: function (t, e, n, r) { var i = t.x < e.x ? t.x : e.x, o = t.y < e.y ? t.y : e.y, a = t.x > e.x ? t.x : e.x, s = t.y > e.y ? t.y : e.y, u = n.x < r.x ? n.x : r.x, l = n.y < r.y ? n.y : r.y, c = n.x > r.x ? n.x : r.x, h = n.y > r.y ? n.y : r.y, f = ((i > u ? i : u) + (a < c ? a : c)) / 2, p = ((o > l ? o : l) + (s < h ? s : h)) / 2, g = t.x - f, y = t.y - p, v = e.x - f, d = e.y - p, m = n.x - f, _ = n.y - p, b = r.x - f, x = r.y - p, E = y - d, w = v - g, k = g * d - v * y, S = _ - x, I = b - m, P = m * x - b * _, N = E * I - S * w, M = (w * P - I * k) / N, O = (S * k - E * P) / N; return A.isNaN(M) || A.isInfinite(M) || A.isNaN(O) || A.isInfinite(O) ? null : new Y(M + f, O + p) } }]), e }(), bt = function () { function e() { t(this, e) } return r(e, null, [{ key: "arraycopy", value: function (t, e, n, r, i) { for (var o = 0, a = e; a < e + i; a++)n[r + o] = t[a], o++ } }, { key: "getProperty", value: function (t) { return { "line.separator": "\n" }[t] } }]), e }(), xt = function () { function e() { t(this, e) } return r(e, null, [{ key: "log10", value: function (t) { var n = Math.log(t); return A.isInfinite(n) || A.isNaN(n) ? n : n / e.LOG_10 } }, { key: "min", value: function (t, e, n, r) { var i = t; return e < i && (i = e), n < i && (i = n), r < i && (i = r), i } }, { key: "clamp", value: function () { if ("number" == typeof arguments[2] && "number" == typeof arguments[0] && "number" == typeof arguments[1]) { var t = arguments[0], e = arguments[1], n = arguments[2]; return t < e ? e : t > n ? n : t } if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) { var r = arguments[0], i = arguments[1], o = arguments[2]; return r < i ? i : r > o ? o : r } } }, { key: "wrap", value: function (t, e) { return t < 0 ? e - -t % e : t % e } }, { key: "max", value: function () { if (3 === arguments.length) { var t = arguments[1], e = arguments[2], n = arguments[0]; return t > n && (n = t), e > n && (n = e), n } if (4 === arguments.length) { var r = arguments[1], i = arguments[2], o = arguments[3], a = arguments[0]; return r > a && (a = r), i > a && (a = i), o > a && (a = o), a } } }, { key: "average", value: function (t, e) { return (t + e) / 2 } }]), e }(); xt.LOG_10 = Math.log(10); var Et = function () { function e() { t(this, e) } return r(e, null, [{ key: "segmentToSegment", value: function (t, n, r, i) { if (t.equals(n)) return e.pointToSegment(t, r, i); if (r.equals(i)) return e.pointToSegment(i, t, n); var o = !1; if (U.intersects(t, n, r, i)) { var a = (n.x - t.x) * (i.y - r.y) - (n.y - t.y) * (i.x - r.x); if (0 === a) o = !0; else { var s = (t.y - r.y) * (i.x - r.x) - (t.x - r.x) * (i.y - r.y), u = ((t.y - r.y) * (n.x - t.x) - (t.x - r.x) * (n.y - t.y)) / a, l = s / a; (l < 0 || l > 1 || u < 0 || u > 1) && (o = !0) } } else o = !0; return o ? xt.min(e.pointToSegment(t, r, i), e.pointToSegment(n, r, i), e.pointToSegment(r, t, n), e.pointToSegment(i, t, n)) : 0 } }, { key: "pointToSegment", value: function (t, e, n) { if (e.x === n.x && e.y === n.y) return t.distance(e); var r = (n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y), i = ((t.x - e.x) * (n.x - e.x) + (t.y - e.y) * (n.y - e.y)) / r; if (i <= 0) return t.distance(e); if (i >= 1) return t.distance(n); var o = ((e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)) / r; return Math.abs(o) * Math.sqrt(r) } }, { key: "pointToLinePerpendicular", value: function (t, e, n) { var r = (n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y), i = ((e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)) / r; return Math.abs(i) * Math.sqrt(r) } }, { key: "pointToSegmentString", value: function (t, n) { if (0 === n.length) throw new b("Line array must contain at least one vertex"); for (var r = t.distance(n[0]), i = 0; i < n.length - 1; i++) { var o = e.pointToSegment(t, n[i], n[i + 1]); o < r && (r = o) } return r } }]), e }(), wt = function () { function e() { t(this, e) } return r(e, [{ key: "create", value: function () { if (1 === arguments.length) arguments[0] instanceof Array || ot(arguments[0], ht); else if (2 === arguments.length); else if (3 === arguments.length) { var t = arguments[0], e = arguments[1]; return this.create(t, e) } } }]), e }(), kt = function () { function e() { t(this, e) } return r(e, [{ key: "filter", value: function (t) { } }]), e }(), St = function () { function e() { t(this, e) } return r(e, null, [{ key: "ofLine", value: function (t) { var e = t.size(); if (e <= 1) return 0; var n = 0, r = new Y; t.getCoordinate(0, r); for (var i = r.x, o = r.y, a = 1; a < e; a++) { t.getCoordinate(a, r); var s = r.x, u = r.y, l = s - i, c = u - o; n += Math.sqrt(l * l + c * c), i = s, o = u } return n } }]), e }(), It = function e() { t(this, e) }, Pt = function () { function e() { t(this, e) } return r(e, null, [{ key: "copyCoord", value: function (t, e, n, r) { for (var i = Math.min(t.getDimension(), n.getDimension()), o = 0; o < i; o++)n.setOrdinate(r, o, t.getOrdinate(e, o)) } }, { key: "isRing", value: function (t) { var e = t.size(); return 0 === e || !(e <= 3) && t.getOrdinate(0, ht.X) === t.getOrdinate(e - 1, ht.X) && t.getOrdinate(0, ht.Y) === t.getOrdinate(e - 1, ht.Y) } }, { key: "scroll", value: function () { if (2 === arguments.length) { if (ot(arguments[0], ht) && Number.isInteger(arguments[1])) { var t = arguments[0], n = arguments[1]; e.scroll(t, n, e.isRing(t)) } else if (ot(arguments[0], ht) && arguments[1] instanceof Y) { var r = arguments[0], i = arguments[1], o = e.indexOf(i, r); if (o <= 0) return null; e.scroll(r, o) } } else if (3 === arguments.length) { var a = arguments[0], s = arguments[1], u = arguments[2]; if (s <= 0) return null; for (var l = a.copy(), c = u ? a.size() - 1 : a.size(), h = 0; h < c; h++)for (var f = 0; f < a.getDimension(); f++)a.setOrdinate(h, f, l.getOrdinate((s + h) % c, f)); if (u) for (var p = 0; p < a.getDimension(); p++)a.setOrdinate(c, p, a.getOrdinate(0, p)) } } }, { key: "isEqual", value: function (t, e) { var n = t.size(); if (n !== e.size()) return !1; for (var r = Math.min(t.getDimension(), e.getDimension()), i = 0; i < n; i++)for (var o = 0; o < r; o++) { var a = t.getOrdinate(i, o), s = e.getOrdinate(i, o); if (!(t.getOrdinate(i, o) === e.getOrdinate(i, o) || A.isNaN(a) && A.isNaN(s))) return !1 } return !0 } }, { key: "minCoordinateIndex", value: function () { if (1 === arguments.length) { var t = arguments[0]; return e.minCoordinateIndex(t, 0, t.size() - 1) } if (3 === arguments.length) { for (var n = arguments[0], r = arguments[2], i = -1, o = null, a = arguments[1]; a <= r; a++) { var s = n.getCoordinate(a); (null === o || o.compareTo(s) > 0) && (o = s, i = a) } return i } } }, { key: "extend", value: function (t, n, r) { var i = t.create(r, n.getDimension()), o = n.size(); if (e.copy(n, 0, i, 0, o), o > 0) for (var a = o; a < r; a++)e.copy(n, o - 1, i, a, 1); return i } }, { key: "reverse", value: function (t) { for (var n = t.size() - 1, r = Math.trunc(n / 2), i = 0; i <= r; i++)e.swap(t, i, n - i) } }, { key: "swap", value: function (t, e, n) { if (e === n) return null; for (var r = 0; r < t.getDimension(); r++) { var i = t.getOrdinate(e, r); t.setOrdinate(e, r, t.getOrdinate(n, r)), t.setOrdinate(n, r, i) } } }, { key: "copy", value: function (t, n, r, i, o) { for (var a = 0; a < o; a++)e.copyCoord(t, n + a, r, i + a) } }, { key: "ensureValidRing", value: function (t, n) { var r = n.size(); return 0 === r ? n : r <= 3 ? e.createClosedRing(t, n, 4) : n.getOrdinate(0, ht.X) === n.getOrdinate(r - 1, ht.X) && n.getOrdinate(0, ht.Y) === n.getOrdinate(r - 1, ht.Y) ? n : e.createClosedRing(t, n, r + 1) } }, { key: "indexOf", value: function (t, e) { for (var n = 0; n < e.size(); n++)if (t.x === e.getOrdinate(n, ht.X) && t.y === e.getOrdinate(n, ht.Y)) return n; return -1 } }, { key: "createClosedRing", value: function (t, n, r) { var i = t.create(r, n.getDimension()), o = n.size(); e.copy(n, 0, i, 0, o); for (var a = o; a < r; a++)e.copy(n, 0, i, a, 1); return i } }, { key: "minCoordinate", value: function (t) { for (var e = null, n = 0; n < t.size(); n++) { var r = t.getCoordinate(n); (null === e || e.compareTo(r) > 0) && (e = r) } return e } }]), e }(), Nt = function () { function e() { t(this, e) } return r(e, null, [{ key: "toDimensionSymbol", value: function (t) { switch (t) { case e.FALSE: return e.SYM_FALSE; case e.TRUE: return e.SYM_TRUE; case e.DONTCARE: return e.SYM_DONTCARE; case e.P: return e.SYM_P; case e.L: return e.SYM_L; case e.A: return e.SYM_A }throw new b("Unknown dimension value: " + t) } }, { key: "toDimensionValue", value: function (t) { switch (ut.toUpperCase(t)) { case e.SYM_FALSE: return e.FALSE; case e.SYM_TRUE: return e.TRUE; case e.SYM_DONTCARE: return e.DONTCARE; case e.SYM_P: return e.P; case e.SYM_L: return e.L; case e.SYM_A: return e.A }throw new b("Unknown dimension symbol: " + t) } }]), e }(); Nt.P = 0, Nt.L = 1, Nt.A = 2, Nt.FALSE = -1, Nt.TRUE = -2, Nt.DONTCARE = -3, Nt.SYM_FALSE = "F", Nt.SYM_TRUE = "T", Nt.SYM_DONTCARE = "*", Nt.SYM_P = "0", Nt.SYM_L = "1", Nt.SYM_A = "2"; var Mt = function () { function e() { t(this, e) } return r(e, [{ key: "filter", value: function (t) { } }]), e }(), Ot = function () { function e() { t(this, e) } return r(e, [{ key: "filter", value: function (t, e) { } }, { key: "isDone", value: function () { } }, { key: "isGeometryChanged", value: function () { } }]), e }(), Lt = function (e) { i(a, e); var n = f(a); function a() { var e; return t(this, a), e = n.call(this), a.constructor_.apply(c(e), arguments), e } return r(a, [{ key: "computeEnvelopeInternal", value: function () { return this.isEmpty() ? new U : this._points.expandEnvelope(new U) } }, { key: "isRing", value: function () { return this.isClosed() && this.isSimple() } }, { key: "getCoordinates", value: function () { return this._points.toCoordinateArray() } }, { key: "copyInternal", value: function () { return new a(this._points.copy(), this._factory) } }, { key: "equalsExact", value: function () { if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof X) { var t = arguments[0], e = arguments[1]; if (!this.isEquivalentClass(t)) return !1; var n = t; if (this._points.size() !== n._points.size()) return !1; for (var r = 0; r < this._points.size(); r++)if (!this.equal(this._points.getCoordinate(r), n._points.getCoordinate(r), e)) return !1; return !0 } return p(o(a.prototype), "equalsExact", this).apply(this, arguments) } }, { key: "normalize", value: function () { for (var t = 0; t < Math.trunc(this._points.size() / 2); t++) { var e = this._points.size() - 1 - t; if (!this._points.getCoordinate(t).equals(this._points.getCoordinate(e))) { if (this._points.getCoordinate(t).compareTo(this._points.getCoordinate(e)) > 0) { var n = this._points.copy(); Pt.reverse(n), this._points = n } return null } } } }, { key: "getCoordinate", value: function () { return this.isEmpty() ? null : this._points.getCoordinate(0) } }, { key: "getBoundaryDimension", value: function () { return this.isClosed() ? Nt.FALSE : 0 } }, { key: "isClosed", value: function () { return !this.isEmpty() && this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1)) } }, { key: "reverseInternal", value: function () { var t = this._points.copy(); return Pt.reverse(t), this.getFactory().createLineString(t) } }, { key: "getEndPoint", value: function () { return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1) } }, { key: "getTypeCode", value: function () { return X.TYPECODE_LINESTRING } }, { key: "getDimension", value: function () { return 1 } }, { key: "getLength", value: function () { return St.ofLine(this._points) } }, { key: "getNumPoints", value: function () { return this._points.size() } }, { key: "compareToSameClass", value: function () { if (1 === arguments.length) { for (var t = arguments[0], e = 0, n = 0; e < this._points.size() && n < t._points.size();) { var r = this._points.getCoordinate(e).compareTo(t._points.getCoordinate(n)); if (0 !== r) return r; e++, n++ } return e < this._points.size() ? 1 : n < t._points.size() ? -1 : 0 } if (2 === arguments.length) { var i = arguments[0]; return arguments[1].compare(this._points, i._points) } } }, { key: "apply", value: function () { if (ot(arguments[0], kt)) for (var t = arguments[0], e = 0; e < this._points.size(); e++)t.filter(this._points.getCoordinate(e)); else if (ot(arguments[0], Ot)) { var n = arguments[0]; if (0 === this._points.size()) return null; for (var r = 0; r < this._points.size() && (n.filter(this._points, r), !n.isDone()); r++); n.isGeometryChanged() && this.geometryChanged() } else (ot(arguments[0], Mt) || ot(arguments[0], x)) && arguments[0].filter(this) } }, { key: "getBoundary", value: function () { throw new J } }, { key: "isEquivalentClass", value: function (t) { return t instanceof a } }, { key: "getCoordinateN", value: function (t) { return this._points.getCoordinate(t) } }, { key: "getGeometryType", value: function () { return X.TYPENAME_LINESTRING } }, { key: "getCoordinateSequence", value: function () { return this._points } }, { key: "isEmpty", value: function () { return 0 === this._points.size() } }, { key: "init", value: function (t) { if (null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])), 1 === t.size()) throw new b("Invalid number of points in LineString (found " + t.size() + " - must be 0 or >= 2)"); this._points = t } }, { key: "isCoordinate", value: function (t) { for (var e = 0; e < this._points.size(); e++)if (this._points.getCoordinate(e).equals(t)) return !0; return !1 } }, { key: "getStartPoint", value: function () { return this.isEmpty() ? null : this.getPointN(0) } }, { key: "getPointN", value: function (t) { return this.getFactory().createPoint(this._points.getCoordinate(t)) } }, { key: "interfaces_", get: function () { return [It] } }], [{ key: "constructor_", value: function () { if (this._points = null, 0 === arguments.length); else if (2 === arguments.length) { var t = arguments[0], e = arguments[1]; X.constructor_.call(this, e), this.init(t) } } }]), a }(X), Rt = function e() { t(this, e) }, Ct = function (e) { i(a, e); var n = f(a); function a() { var e; return t(this, a), e = n.call(this), a.constructor_.apply(c(e), arguments), e } return r(a, [{ key: "computeEnvelopeInternal", value: function () { if (this.isEmpty()) return new U; var t = new U; return t.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0)), t } }, { key: "getCoordinates", value: function () { return this.isEmpty() ? [] : [this.getCoordinate()] } }, { key: "copyInternal", value: function () { return new a(this._coordinates.copy(), this._factory) } }, { key: "equalsExact", value: function () { if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof X) { var t = arguments[0], e = arguments[1]; return !!this.isEquivalentClass(t) && (!(!this.isEmpty() || !t.isEmpty()) || this.isEmpty() === t.isEmpty() && this.equal(t.getCoordinate(), this.getCoordinate(), e)) } return p(o(a.prototype), "equalsExact", this).apply(this, arguments) } }, { key: "normalize", value: function () { } }, { key: "getCoordinate", value: function () { return 0 !== this._coordinates.size() ? this._coordinates.getCoordinate(0) : null } }, { key: "getBoundaryDimension", value: function () { return Nt.FALSE } }, { key: "reverseInternal", value: function () { return this.getFactory().createPoint(this._coordinates.copy()) } }, { key: "getTypeCode", value: function () { return X.TYPECODE_POINT } }, { key: "getDimension", value: function () { return 0 } }, { key: "getNumPoints", value: function () { return this.isEmpty() ? 0 : 1 } }, { key: "getX", value: function () { if (null === this.getCoordinate()) throw new IllegalStateException("getX called on empty Point"); return this.getCoordinate().x } }, { key: "compareToSameClass", value: function () { if (1 === arguments.length) { var t = arguments[0]; return this.getCoordinate().compareTo(t.getCoordinate()) } if (2 === arguments.length) { var e = arguments[0]; return arguments[1].compare(this._coordinates, e._coordinates) } } }, { key: "apply", value: function () { if (ot(arguments[0], kt)) { var t = arguments[0]; if (this.isEmpty()) return null; t.filter(this.getCoordinate()) } else if (ot(arguments[0], Ot)) { var e = arguments[0]; if (this.isEmpty()) return null; e.filter(this._coordinates, 0), e.isGeometryChanged() && this.geometryChanged() } else (ot(arguments[0], Mt) || ot(arguments[0], x)) && arguments[0].filter(this) } }, { key: "getBoundary", value: function () { return this.getFactory().createGeometryCollection() } }, { key: "getGeometryType", value: function () { return X.TYPENAME_POINT } }, { key: "getCoordinateSequence", value: function () { return this._coordinates } }, { key: "getY", value: function () { if (null === this.getCoordinate()) throw new IllegalStateException("getY called on empty Point"); return this.getCoordinate().y } }, { key: "isEmpty", value: function () { return 0 === this._coordinates.size() } }, { key: "init", value: function (t) { null === t && (t = this.getFactory().getCoordinateSequenceFactory().create([])), B.isTrue(t.size() <= 1), this._coordinates = t } }, { key: "isSimple", value: function () { return !0 } }, { key: "interfaces_", get: function () { return [Rt] } }], [{ key: "constructor_", value: function () { this._coordinates = null; var t = arguments[0], e = arguments[1]; X.constructor_.call(this, e), this.init(t) } }]), a }(X), Tt = function () { function e() { t(this, e) } return r(e, null, [{ key: "ofRing", value: function () { if (arguments[0] instanceof Array) { var t = arguments[0]; return Math.abs(e.ofRingSigned(t)) } if (ot(arguments[0], ht)) { var n = arguments[0]; return Math.abs(e.ofRingSigned(n)) } } }, { key: "ofRingSigned", value: function () { if (arguments[0] instanceof Array) { var t = arguments[0]; if (t.length < 3) return 0; for (var e = 0, n = t[0].x, r = 1; r < t.length - 1; r++) { var i = t[r].x - n, o = t[r + 1].y; e += i * (t[r - 1].y - o) } return e / 2 } if (ot(arguments[0], ht)) { var a = arguments[0], s = a.size(); if (s < 3) return 0; var u = new Y, l = new Y, c = new Y; a.getCoordinate(0, l), a.getCoordinate(1, c); var h = l.x; c.x -= h; for (var f = 0, p = 1; p < s - 1; p++)u.y = l.y, l.x = c.x, l.y = c.y, a.getCoordinate(p + 1, c), c.x -= h, f += l.x * (u.y - c.y); return f / 2 } } }]), e }(), At = function () { function e() { t(this, e) } return r(e, null, [{ key: "sort", value: function () { var t = arguments, e = arguments[0]; if (1 === arguments.length) e.sort((function (t, e) { return t.compareTo(e) })); else if (2 === arguments.length) e.sort((function (e, n) { return t[1].compare(e, n) })); else if (3 === arguments.length) { var n = e.slice(arguments[1], arguments[2]); n.sort(); var r = e.slice(0, arguments[1]).concat(n, e.slice(arguments[2], e.length)); e.splice(0, e.length); var i, o = d(r); try { for (o.s(); !(i = o.n()).done;) { var a = i.value; e.push(a) } } catch (t) { o.e(t) } finally { o.f() } } else if (4 === arguments.length) { var s = e.slice(arguments[1], arguments[2]); s.sort((function (e, n) { return t[3].compare(e, n) })); var u = e.slice(0, arguments[1]).concat(s, e.slice(arguments[2], e.length)); e.splice(0, e.length); var l, c = d(u); try { for (c.s(); !(l = c.n()).done;) { var h = l.value; e.push(h) } } catch (t) { c.e(t) } finally { c.f() } } } }, { key: "asList", value: function (t) { var e, n = new vt, r = d(t); try { for (r.s(); !(e = r.n()).done;) { var i = e.value; n.add(i) } } catch (t) { r.e(t) } finally { r.f() } return n } }, { key: "copyOf", value: function (t, e) { return t.slice(0, e) } }]), e }(), Dt = function e() { t(this, e) }, jt = function (e) { i(a, e); var n = f(a); function a() { var e; return t(this, a), e = n.call(this), a.constructor_.apply(c(e), arguments), e } return r(a, [{ key: "computeEnvelopeInternal", value: function () { return this._shell.getEnvelopeInternal() } }, { key: "getCoordinates", value: function () { if (this.isEmpty()) return []; for (var t = new Array(this.getNumPoints()).fill(null), e = -1, n = this._shell.getCoordinates(), r = 0; r < n.length; r++)t[++e] = n[r]; for (var i = 0; i < this._holes.length; i++)for (var o = this._holes[i].getCoordinates(), a = 0; a < o.length; a++)t[++e] = o[a]; return t } }, { key: "getArea", value: function () { var t = 0; t += Tt.ofRing(this._shell.getCoordinateSequence()); for (var e = 0; e < this._holes.length; e++)t -= Tt.ofRing(this._holes[e].getCoordinateSequence()); return t } }, { key: "copyInternal", value: function () { for (var t = this._shell.copy(), e = new Array(this._holes.length).fill(null), n = 0; n < this._holes.length; n++)e[n] = this._holes[n].copy(); return new a(t, e, this._factory) } }, { key: "isRectangle", value: function () { if (0 !== this.getNumInteriorRing()) return !1; if (null === this._shell) return !1; if (5 !== this._shell.getNumPoints()) return !1; for (var t = this._shell.getCoordinateSequence(), e = this.getEnvelopeInternal(), n = 0; n < 5; n++) { var r = t.getX(n); if (r !== e.getMinX() && r !== e.getMaxX()) return !1; var i = t.getY(n); if (i !== e.getMinY() && i !== e.getMaxY()) return !1 } for (var o = t.getX(0), a = t.getY(0), s = 1; s <= 4; s++) { var u = t.getX(s), l = t.getY(s); if (u !== o == (l !== a)) return !1; o = u, a = l } return !0 } }, { key: "equalsExact", value: function () { if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof X) { var t = arguments[0], e = arguments[1]; if (!this.isEquivalentClass(t)) return !1; var n = t, r = this._shell, i = n._shell; if (!r.equalsExact(i, e)) return !1; if (this._holes.length !== n._holes.length) return !1; for (var s = 0; s < this._holes.length; s++)if (!this._holes[s].equalsExact(n._holes[s], e)) return !1; return !0 } return p(o(a.prototype), "equalsExact", this).apply(this, arguments) } }, { key: "normalize", value: function () { if (0 === arguments.length) { this._shell = this.normalized(this._shell, !0); for (var t = 0; t < this._holes.length; t++)this._holes[t] = this.normalized(this._holes[t], !1); At.sort(this._holes) } else if (2 === arguments.length) { var e = arguments[0], n = arguments[1]; if (e.isEmpty()) return null; var r = e.getCoordinateSequence(), i = Pt.minCoordinateIndex(r, 0, r.size() - 2); Pt.scroll(r, i, !0), ft.isCCW(r) === n && Pt.reverse(r) } } }, { key: "getCoordinate", value: function () { return this._shell.getCoordinate() } }, { key: "getNumInteriorRing", value: function () { return this._holes.length } }, { key: "getBoundaryDimension", value: function () { return 1 } }, { key: "reverseInternal", value: function () { for (var t = this.getExteriorRing().reverse(), e = new Array(this.getNumInteriorRing()).fill(null), n = 0; n < e.length; n++)e[n] = this.getInteriorRingN(n).reverse(); return this.getFactory().createPolygon(t, e) } }, { key: "getTypeCode", value: function () { return X.TYPECODE_POLYGON } }, { key: "getDimension", value: function () { return 2 } }, { key: "getLength", value: function () { var t = 0; t += this._shell.getLength(); for (var e = 0; e < this._holes.length; e++)t += this._holes[e].getLength(); return t } }, { key: "getNumPoints", value: function () { for (var t = this._shell.getNumPoints(), e = 0; e < this._holes.length; e++)t += this._holes[e].getNumPoints(); return t } }, { key: "convexHull", value: function () { return this.getExteriorRing().convexHull() } }, { key: "normalized", value: function (t, e) { var n = t.copy(); return this.normalize(n, e), n } }, { key: "compareToSameClass", value: function () { if (1 === arguments.length) { var t = arguments[0], e = this._shell, n = t._shell; return e.compareToSameClass(n) } if (2 === arguments.length) { var r = arguments[1], i = arguments[0], o = this._shell, a = i._shell, s = o.compareToSameClass(a, r); if (0 !== s) return s; for (var u = this.getNumInteriorRing(), l = i.getNumInteriorRing(), c = 0; c < u && c < l;) { var h = this.getInteriorRingN(c), f = i.getInteriorRingN(c), p = h.compareToSameClass(f, r); if (0 !== p) return p; c++ } return c < u ? 1 : c < l ? -1 : 0 } } }, { key: "apply", value: function () { if (ot(arguments[0], kt)) { var t = arguments[0]; this._shell.apply(t); for (var e = 0; e < this._holes.length; e++)this._holes[e].apply(t) } else if (ot(arguments[0], Ot)) { var n = arguments[0]; if (this._shell.apply(n), !n.isDone()) for (var r = 0; r < this._holes.length && (this._holes[r].apply(n), !n.isDone()); r++); n.isGeometryChanged() && this.geometryChanged() } else if (ot(arguments[0], Mt)) arguments[0].filter(this); else if (ot(arguments[0], x)) { var i = arguments[0]; i.filter(this), this._shell.apply(i); for (var o = 0; o < this._holes.length; o++)this._holes[o].apply(i) } } }, { key: "getBoundary", value: function () { if (this.isEmpty()) return this.getFactory().createMultiLineString(); var t = new Array(this._holes.length + 1).fill(null); t[0] = this._shell; for (var e = 0; e < this._holes.length; e++)t[e + 1] = this._holes[e]; return t.length <= 1 ? this.getFactory().createLinearRing(t[0].getCoordinateSequence()) : this.getFactory().createMultiLineString(t) } }, { key: "getGeometryType", value: function () { return X.TYPENAME_POLYGON } }, { key: "getExteriorRing", value: function () { return this._shell } }, { key: "isEmpty", value: function () { return this._shell.isEmpty() } }, { key: "getInteriorRingN", value: function (t) { return this._holes[t] } }, { key: "interfaces_", get: function () { return [Dt] } }], [{ key: "constructor_", value: function () { this._shell = null, this._holes = null; var t = arguments[0], e = arguments[1], n = arguments[2]; if (X.constructor_.call(this, n), null === t && (t = this.getFactory().createLinearRing()), null === e && (e = []), X.hasNullElements(e)) throw new b("holes must not contain null elements"); if (t.isEmpty() && X.hasNonEmptyElements(e)) throw new b("shell is empty but holes are not"); this._shell = t, this._holes = e } }]), a }(X), Ft = function (e) { i(r, e); var n = f(r); function r() { return t(this, r), n.apply(this, arguments) } return r }($), Bt = function (e) { i(o, e); var n = f(o); function o(e) { var r; return t(this, o), (r = n.call(this)).array = [], e instanceof H && r.addAll(e), r } return r(o, [{ key: "contains", value: function (t) { var e, n = d(this.array); try { for (n.s(); !(e = n.n()).done;)if (0 === e.value.compareTo(t)) return !0 } catch (t) { n.e(t) } finally { n.f() } return !1 } }, { key: "add", value: function (t) { if (this.contains(t)) return !1; for (var e = 0, n = this.array.length; e < n; e++)if (1 === this.array[e].compareTo(t)) return !!this.array.splice(e, 0, t); return this.array.push(t), !0 } }, { key: "addAll", value: function (t) { var e, n = d(t); try { for (n.s(); !(e = n.n()).done;) { var r = e.value; this.add(r) } } catch (t) { n.e(t) } finally { n.f() } return !0 } }, { key: "remove", value: function () { throw new J } }, { key: "size", value: function () { return this.array.length } }, { key: "isEmpty", value: function () { return 0 === this.array.length } }, { key: "toArray", value: function () { return this.array.slice() } }, { key: "iterator", value: function () { return new qt(this.array) } }]), o }(Ft), qt = function () { function e(n) { t(this, e), this.array = n, this.position = 0 } return r(e, [{ key: "next", value: function () { if (this.position === this.array.length) throw new Z; return this.array[this.position++] } }, { key: "hasNext", value: function () { return this.position < this.array.length } }, { key: "remove", value: function () { throw new J } }]), e }(), Vt = function (e) { i(a, e); var n = f(a); function a() { var e; return t(this, a), e = n.call(this), a.constructor_.apply(c(e), arguments), e } return r(a, [{ key: "computeEnvelopeInternal", value: function () { for (var t = new U, e = 0; e < this._geometries.length; e++)t.expandToInclude(this._geometries[e].getEnvelopeInternal()); return t } }, { key: "getGeometryN", value: function (t) { return this._geometries[t] } }, { key: "getCoordinates", value: function () { for (var t = new Array(this.getNumPoints()).fill(null), e = -1, n = 0; n < this._geometries.length; n++)for (var r = this._geometries[n].getCoordinates(), i = 0; i < r.length; i++)t[++e] = r[i]; return t } }, { key: "getArea", value: function () { for (var t = 0, e = 0; e < this._geometries.length; e++)t += this._geometries[e].getArea(); return t } }, { key: "copyInternal", value: function () { for (var t = new Array(this._geometries.length).fill(null), e = 0; e < t.length; e++)t[e] = this._geometries[e].copy(); return new a(t, this._factory) } }, { key: "equalsExact", value: function () { if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof X) { var t = arguments[0], e = arguments[1]; if (!this.isEquivalentClass(t)) return !1; var n = t; if (this._geometries.length !== n._geometries.length) return !1; for (var r = 0; r < this._geometries.length; r++)if (!this._geometries[r].equalsExact(n._geometries[r], e)) return !1; return !0 } return p(o(a.prototype), "equalsExact", this).apply(this, arguments) } }, { key: "normalize", value: function () { for (var t = 0; t < this._geometries.length; t++)this._geometries[t].normalize(); At.sort(this._geometries) } }, { key: "getCoordinate", value: function () { return this.isEmpty() ? null : this._geometries[0].getCoordinate() } }, { key: "getBoundaryDimension", value: function () { for (var t = Nt.FALSE, e = 0; e < this._geometries.length; e++)t = Math.max(t, this._geometries[e].getBoundaryDimension()); return t } }, { key: "reverseInternal", value: function () { for (var t = this._geometries.length, e = new vt(t), n = 0; n < t; n++)e.add(this._geometries[n].reverse()); return this.getFactory().buildGeometry(e) } }, { key: "getTypeCode", value: function () { return X.TYPECODE_GEOMETRYCOLLECTION } }, { key: "getDimension", value: function () { for (var t = Nt.FALSE, e = 0; e < this._geometries.length; e++)t = Math.max(t, this._geometries[e].getDimension()); return t } }, { key: "getLength", value: function () { for (var t = 0, e = 0; e < this._geometries.length; e++)t += this._geometries[e].getLength(); return t } }, { key: "getNumPoints", value: function () { for (var t = 0, e = 0; e < this._geometries.length; e++)t += this._geometries[e].getNumPoints(); return t } }, { key: "getNumGeometries", value: function () { return this._geometries.length } }, { key: "compareToSameClass", value: function () { if (1 === arguments.length) { var t = arguments[0], e = new Bt(At.asList(this._geometries)), n = new Bt(At.asList(t._geometries)); return this.compare(e, n) } if (2 === arguments.length) { for (var r = arguments[1], i = arguments[0], o = this.getNumGeometries(), a = i.getNumGeometries(), s = 0; s < o && s < a;) { var u = this.getGeometryN(s), l = i.getGeometryN(s), c = u.compareToSameClass(l, r); if (0 !== c) return c; s++ } return s < o ? 1 : s < a ? -1 : 0 } } }, { key: "apply", value: function () { if (ot(arguments[0], kt)) for (var t = arguments[0], e = 0; e < this._geometries.length; e++)this._geometries[e].apply(t); else if (ot(arguments[0], Ot)) { var n = arguments[0]; if (0 === this._geometries.length) return null; for (var r = 0; r < this._geometries.length && (this._geometries[r].apply(n), !n.isDone()); r++); n.isGeometryChanged() && this.geometryChanged() } else if (ot(arguments[0], Mt)) { var i = arguments[0]; i.filter(this); for (var o = 0; o < this._geometries.length; o++)this._geometries[o].apply(i) } else if (ot(arguments[0], x)) { var a = arguments[0]; a.filter(this); for (var s = 0; s < this._geometries.length; s++)this._geometries[s].apply(a) } } }, { key: "getBoundary", value: function () { return X.checkNotGeometryCollection(this), B.shouldNeverReachHere(), null } }, { key: "getGeometryType", value: function () { return X.TYPENAME_GEOMETRYCOLLECTION } }, { key: "isEmpty", value: function () { for (var t = 0; t < this._geometries.length; t++)if (!this._geometries[t].isEmpty()) return !1; return !0 } }], [{ key: "constructor_", value: function () { if (this._geometries = null, 0 === arguments.length); else if (2 === arguments.length) { var t = arguments[0], e = arguments[1]; if (X.constructor_.call(this, e), null === t && (t = []), X.hasNullElements(t)) throw new b("geometries must not contain null elements"); this._geometries = t } } }]), a }(X), Gt = function (e) { i(a, e); var n = f(a); function a() { var e; return t(this, a), e = n.call(this), a.constructor_.apply(c(e), arguments), e } return r(a, [{ key: "copyInternal", value: function () { for (var t = new Array(this._geometries.length).fill(null), e = 0; e < t.length; e++)t[e] = this._geometries[e].copy(); return new a(t, this._factory) } }, { key: "isValid", value: function () { return !0 } }, { key: "equalsExact", value: function () { if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof X) { var t = arguments[0], e = arguments[1]; return !!this.isEquivalentClass(t) && p(o(a.prototype), "equalsExact", this).call(this, t, e) } return p(o(a.prototype), "equalsExact", this).apply(this, arguments) } }, { key: "getCoordinate", value: function () { if (1 === arguments.length && Number.isInteger(arguments[0])) { var t = arguments[0]; return this._geometries[t].getCoordinate() } return p(o(a.prototype), "getCoordinate", this).apply(this, arguments) } }, { key: "getBoundaryDimension", value: function () { return Nt.FALSE } }, { key: "getTypeCode", value: function () { return X.TYPECODE_MULTIPOINT } }, { key: "getDimension", value: function () { return 0 } }, { key: "getBoundary", value: function () { return this.getFactory().createGeometryCollection() } }, { key: "getGeometryType", value: function () { return X.TYPENAME_MULTIPOINT } }, { key: "interfaces_", get: function () { return [Rt] } }], [{ key: "constructor_", value: function () { var t = arguments[0], e = arguments[1]; Vt.constructor_.call(this, t, e) } }]), a }(Vt), Yt = function (e) { i(a, e); var n = f(a); function a() { var e; return t(this, a), e = n.call(this), a.constructor_.apply(c(e), arguments), e } return r(a, [{ key: "copyInternal", value: function () { return new a(this._points.copy(), this._factory) } }, { key: "getBoundaryDimension", value: function () { return Nt.FALSE } }, { key: "isClosed", value: function () { return !!this.isEmpty() || p(o(a.prototype), "isClosed", this).call(this) } }, { key: "reverseInternal", value: function () { var t = this._points.copy(); return Pt.reverse(t), this.getFactory().createLinearRing(t) } }, { key: "getTypeCode", value: function () { return X.TYPECODE_LINEARRING } }, { key: "validateConstruction", value: function () { if (!this.isEmpty() && !p(o(a.prototype), "isClosed", this).call(this)) throw new b("Points of LinearRing do not form a closed linestring"); if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < a.MINIMUM_VALID_SIZE) throw new b("Invalid number of points in LinearRing (found " + this.getCoordinateSequence().size() + " - must be 0 or >= 4)") } }, { key: "getGeometryType", value: function () { return X.TYPENAME_LINEARRING } }], [{ key: "constructor_", value: function () { var t = arguments[0], e = arguments[1]; Lt.constructor_.call(this, t, e), this.validateConstruction() } }]), a }(Lt); Yt.MINIMUM_VALID_SIZE = 4; var zt = function (e) { i(o, e); var n = f(o); function o() { var e; return t(this, o), e = n.call(this), o.constructor_.apply(c(e), arguments), e } return r(o, [{ key: "setOrdinate", value: function (t, e) { switch (t) { case o.X: this.x = e; break; case o.Y: this.y = e; break; default: throw new b("Invalid ordinate index: " + t) } } }, { key: "getZ", value: function () { return Y.NULL_ORDINATE } }, { key: "getOrdinate", value: function (t) { switch (t) { case o.X: return this.x; case o.Y: return this.y }throw new b("Invalid ordinate index: " + t) } }, { key: "setZ", value: function (t) { throw new b("CoordinateXY dimension 2 does not support z-ordinate") } }, { key: "copy", value: function () { return new o(this) } }, { key: "toString", value: function () { return "(" + this.x + ", " + this.y + ")" } }, { key: "setCoordinate", value: function (t) { this.x = t.x, this.y = t.y, this.z = t.getZ() } }], [{ key: "constructor_", value: function () { if (0 === arguments.length) Y.constructor_.call(this); else if (1 === arguments.length) { if (arguments[0] instanceof o) { var t = arguments[0]; Y.constructor_.call(this, t.x, t.y) } else if (arguments[0] instanceof Y) { var e = arguments[0]; Y.constructor_.call(this, e.x, e.y) } } else if (2 === arguments.length) { var n = arguments[0], r = arguments[1]; Y.constructor_.call(this, n, r, Y.NULL_ORDINATE) } } }]), o }(Y); zt.X = 0, zt.Y = 1, zt.Z = -1, zt.M = -1; var Ut = function (e) { i(o, e); var n = f(o); function o() { var e; return t(this, o), e = n.call(this), o.constructor_.apply(c(e), arguments), e } return r(o, [{ key: "getM", value: function () { return this._m } }, { key: "setOrdinate", value: function (t, e) { switch (t) { case o.X: this.x = e; break; case o.Y: this.y = e; break; case o.M: this._m = e; break; default: throw new b("Invalid ordinate index: " + t) } } }, { key: "setM", value: function (t) { this._m = t } }, { key: "getZ", value: function () { return Y.NULL_ORDINATE } }, { key: "getOrdinate", value: function (t) { switch (t) { case o.X: return this.x; case o.Y: return this.y; case o.M: return this._m }throw new b("Invalid ordinate index: " + t) } }, { key: "setZ", value: function (t) { throw new b("CoordinateXY dimension 2 does not support z-ordinate") } }, { key: "copy", value: function () { return new o(this) } }, { key: "toString", value: function () { return "(" + this.x + ", " + this.y + " m=" + this.getM() + ")" } }, { key: "setCoordinate", value: function (t) { this.x = t.x, this.y = t.y, this.z = t.getZ(), this._m = t.getM() } }], [{ key: "constructor_", value: function () { if (this._m = null, 0 === arguments.length) Y.constructor_.call(this), this._m = 0; else if (1 === arguments.length) { if (arguments[0] instanceof o) { var t = arguments[0]; Y.constructor_.call(this, t.x, t.y), this._m = t._m } else if (arguments[0] instanceof Y) { var e = arguments[0]; Y.constructor_.call(this, e.x, e.y), this._m = this.getM() } } else if (3 === arguments.length) { var n = arguments[0], r = arguments[1], i = arguments[2]; Y.constructor_.call(this, n, r, Y.NULL_ORDINATE), this._m = i } } }]), o }(Y); Ut.X = 0, Ut.Y = 1, Ut.Z = -1, Ut.M = 2; var Xt = function (e) { i(o, e); var n = f(o); function o() { var e; return t(this, o), e = n.call(this), o.constructor_.apply(c(e), arguments), e } return r(o, [{ key: "getM", value: function () { return this._m } }, { key: "setOrdinate", value: function (t, e) { switch (t) { case Y.X: this.x = e; break; case Y.Y: this.y = e; break; case Y.Z: this.z = e; break; case Y.M: this._m = e; break; default: throw new b("Invalid ordinate index: " + t) } } }, { key: "setM", value: function (t) { this._m = t } }, { key: "getOrdinate", value: function (t) { switch (t) { case Y.X: return this.x; case Y.Y: return this.y; case Y.Z: return this.getZ(); case Y.M: return this.getM() }throw new b("Invalid ordinate index: " + t) } }, { key: "copy", value: function () { return new o(this) } }, { key: "toString", value: function () { return "(" + this.x + ", " + this.y + ", " + this.getZ() + " m=" + this.getM() + ")" } }, { key: "setCoordinate", value: function (t) { this.x = t.x, this.y = t.y, this.z = t.getZ(), this._m = t.getM() } }], [{ key: "constructor_", value: function () { if (this._m = null, 0 === arguments.length) Y.constructor_.call(this), this._m = 0; else if (1 === arguments.length) { if (arguments[0] instanceof o) { var t = arguments[0]; Y.constructor_.call(this, t), this._m = t._m } else if (arguments[0] instanceof Y) { var e = arguments[0]; Y.constructor_.call(this, e), this._m = this.getM() } } else if (4 === arguments.length) { var n = arguments[0], r = arguments[1], i = arguments[2], a = arguments[3]; Y.constructor_.call(this, n, r, i), this._m = a } } }]), o }(Y), Wt = function () { function e() { t(this, e) } return r(e, null, [{ key: "measures", value: function (t) { return t instanceof zt ? 0 : t instanceof Ut || t instanceof Xt ? 1 : 0 } }, { key: "dimension", value: function (t) { return t instanceof zt ? 2 : t instanceof Ut ? 3 : t instanceof Xt ? 4 : 3 } }, { key: "create", value: function () { if (1 === arguments.length) { var t = arguments[0]; return e.create(t, 0) } if (2 === arguments.length) { var n = arguments[0], r = arguments[1]; return 2 === n ? new zt : 3 === n && 0 === r ? new Y : 3 === n && 1 === r ? new Ut : 4 === n && 1 === r ? new Xt : new Y } } }]), e }(), Ht = function (e) { i(a, e); var n = f(a); function a() { var e; return t(this, a), e = n.call(this), a.constructor_.apply(c(e), arguments), e } return r(a, [{ key: "getCoordinate", value: function (t) { return this.get(t) } }, { key: "addAll", value: function () { if (2 === arguments.length && "boolean" == typeof arguments[1] && ot(arguments[0], H)) { for (var t = arguments[1], e = !1, n = arguments[0].iterator(); n.hasNext();)this.add(n.next(), t), e = !0; return e } return p(o(a.prototype), "addAll", this).apply(this, arguments) } }, { key: "clone", value: function () { for (var t = p(o(a.prototype), "clone", this).call(this), e = 0; e < this.size(); e++)t.add(e, this.get(e).clone()); return t } }, { key: "toCoordinateArray", value: function () { if (0 === arguments.length) return this.toArray(a.coordArrayType); if (1 === arguments.length) { if (arguments[0]) return this.toArray(a.coordArrayType); for (var t = this.size(), e = new Array(t).fill(null), n = 0; n < t; n++)e[n] = this.get(t - n - 1); return e } } }, { key: "add", value: function () { if (1 === arguments.length) { var t = arguments[0]; return p(o(a.prototype), "add", this).call(this, t) } if (2 === arguments.length) { if (arguments[0] instanceof Array && "boolean" == typeof arguments[1]) { var e = arguments[0], n = arguments[1]; return this.add(e, n, !0), !0 } if (arguments[0] instanceof Y && "boolean" == typeof arguments[1]) { var r = arguments[0]; if (!arguments[1] && this.size() >= 1 && this.get(this.size() - 1).equals2D(r)) return null; p(o(a.prototype), "add", this).call(this, r) } else if (arguments[0] instanceof Object && "boolean" == typeof arguments[1]) { var i = arguments[0], s = arguments[1]; return this.add(i, s), !0 } } else if (3 === arguments.length) { if ("boolean" == typeof arguments[2] && arguments[0] instanceof Array && "boolean" == typeof arguments[1]) { var u = arguments[0], l = arguments[1]; if (arguments[2]) for (var c = 0; c < u.length; c++)this.add(u[c], l); else for (var h = u.length - 1; h >= 0; h--)this.add(u[h], l); return !0 } if ("boolean" == typeof arguments[2] && Number.isInteger(arguments[0]) && arguments[1] instanceof Y) { var f = arguments[0], g = arguments[1]; if (!arguments[2]) { var y = this.size(); if (y > 0) { if (f > 0 && this.get(f - 1).equals2D(g)) return null; if (f < y && this.get(f).equals2D(g)) return null } } p(o(a.prototype), "add", this).call(this, f, g) } } else if (4 === arguments.length) { var v = arguments[0], d = arguments[1], m = arguments[2], _ = arguments[3], b = 1; m > _ && (b = -1); for (var x = m; x !== _; x += b)this.add(v[x], d); return !0 } } }, { key: "closeRing", value: function () { if (this.size() > 0) { var t = this.get(0).copy(); this.add(t, !1) } } }], [{ key: "constructor_", value: function () { if (0 === arguments.length); else if (1 === arguments.length) { var t = arguments[0]; this.ensureCapacity(t.length), this.add(t, !0) } else if (2 === arguments.length) { var e = arguments[0], n = arguments[1]; this.ensureCapacity(e.length), this.add(e, n) } } }]), a }(vt); Ht.coordArrayType = new Array(0).fill(null); var Zt = function () { function e() { t(this, e) } return r(e, null, [{ key: "isRing", value: function (t) { return !(t.length < 4 || !t[0].equals2D(t[t.length - 1])) } }, { key: "ptNotInList", value: function (t, n) { for (var r = 0; r < t.length; r++) { var i = t[r]; if (e.indexOf(i, n) < 0) return i } return null } }, { key: "scroll", value: function (t, n) { var r = e.indexOf(n, t); if (r < 0) return null; var i = new Array(t.length).fill(null); bt.arraycopy(t, r, i, 0, t.length - r), bt.arraycopy(t, 0, i, t.length - r, r), bt.arraycopy(i, 0, t, 0, t.length) } }, { key: "equals", value: function () { if (2 === arguments.length) { var t = arguments[0], e = arguments[1]; if (t === e) return !0; if (null === t || null === e) return !1; if (t.length !== e.length) return !1; for (var n = 0; n < t.length; n++)if (!t[n].equals(e[n])) return !1; return !0 } if (3 === arguments.length) { var r = arguments[0], i = arguments[1], o = arguments[2]; if (r === i) return !0; if (null === r || null === i) return !1; if (r.length !== i.length) return !1; for (var a = 0; a < r.length; a++)if (0 !== o.compare(r[a], i[a])) return !1; return !0 } } }, { key: "intersection", value: function (t, e) { for (var n = new Ht, r = 0; r < t.length; r++)e.intersects(t[r]) && n.add(t[r], !0); return n.toCoordinateArray() } }, { key: "measures", value: function (t) { if (null === t || 0 === t.length) return 0; var e, n = 0, r = d(t); try { for (r.s(); !(e = r.n()).done;) { var i = e.value; n = Math.max(n, Wt.measures(i)) } } catch (t) { r.e(t) } finally { r.f() } return n } }, { key: "hasRepeatedPoints", value: function (t) { for (var e = 1; e < t.length; e++)if (t[e - 1].equals(t[e])) return !0; return !1 } }, { key: "removeRepeatedPoints", value: function (t) { return e.hasRepeatedPoints(t) ? new Ht(t, !1).toCoordinateArray() : t } }, { key: "reverse", value: function (t) { for (var e = t.length - 1, n = Math.trunc(e / 2), r = 0; r <= n; r++) { var i = t[r]; t[r] = t[e - r], t[e - r] = i } } }, { key: "removeNull", value: function (t) { for (var e = 0, n = 0; n < t.length; n++)null !== t[n] && e++; var r = new Array(e).fill(null); if (0 === e) return r; for (var i = 0, o = 0; o < t.length; o++)null !== t[o] && (r[i++] = t[o]); return r } }, { key: "copyDeep", value: function () { if (1 === arguments.length) { for (var t = arguments[0], e = new Array(t.length).fill(null), n = 0; n < t.length; n++)e[n] = t[n].copy(); return e } if (5 === arguments.length) for (var r = arguments[0], i = arguments[1], o = arguments[2], a = arguments[3], s = arguments[4], u = 0; u < s; u++)o[a + u] = r[i + u].copy() } }, { key: "isEqualReversed", value: function (t, e) { for (var n = 0; n < t.length; n++) { var r = t[n], i = e[t.length - n - 1]; if (0 !== r.compareTo(i)) return !1 } return !0 } }, { key: "envelope", value: function (t) { for (var e = new U, n = 0; n < t.length; n++)e.expandToInclude(t[n]); return e } }, { key: "toCoordinateArray", value: function (t) { return t.toArray(e.coordArrayType) } }, { key: "dimension", value: function (t) { if (null === t || 0 === t.length) return 3; var e, n = 0, r = d(t); try { for (r.s(); !(e = r.n()).done;) { var i = e.value; n = Math.max(n, Wt.dimension(i)) } } catch (t) { r.e(t) } finally { r.f() } return n } }, { key: "atLeastNCoordinatesOrNothing", value: function (t, e) { return e.length >= t ? e : [] } }, { key: "indexOf", value: function (t, e) { for (var n = 0; n < e.length; n++)if (t.equals(e[n])) return n; return -1 } }, { key: "increasingDirection", value: function (t) { for (var e = 0; e < Math.trunc(t.length / 2); e++) { var n = t.length - 1 - e, r = t[e].compareTo(t[n]); if (0 !== r) return r } return 1 } }, { key: "compare", value: function (t, e) { for (var n = 0; n < t.length && n < e.length;) { var r = t[n].compareTo(e[n]); if (0 !== r) return r; n++ } return n < e.length ? -1 : n < t.length ? 1 : 0 } }, { key: "minCoordinate", value: function (t) { for (var e = null, n = 0; n < t.length; n++)(null === e || e.compareTo(t[n]) > 0) && (e = t[n]); return e } }, { key: "extract", value: function (t, e, n) { e = xt.clamp(e, 0, t.length); var r = (n = xt.clamp(n, -1, t.length)) - e + 1; n < 0 && (r = 0), e >= t.length && (r = 0), n < e && (r = 0); var i = new Array(r).fill(null); if (0 === r) return i; for (var o = 0, a = e; a <= n; a++)i[o++] = t[a]; return i } }]), e }(), Jt = function () { function e() { t(this, e) } return r(e, [{ key: "compare", value: function (t, e) { var n = t, r = e; return Zt.compare(n, r) } }, { key: "interfaces_", get: function () { return [D] } }]), e }(), $t = function () { function e() { t(this, e) } return r(e, [{ key: "compare", value: function (t, e) { var n = t, r = e; if (n.length < r.length) return -1; if (n.length > r.length) return 1; if (0 === n.length) return 0; var i = Zt.compare(n, r); return Zt.isEqualReversed(n, r) ? 0 : i } }, { key: "OLDcompare", value: function (t, e) { var n = t, r = e; if (n.length < r.length) return -1; if (n.length > r.length) return 1; if (0 === n.length) return 0; for (var i = Zt.increasingDirection(n), o = Zt.increasingDirection(r), a = i > 0 ? 0 : n.length - 1, s = o > 0 ? 0 : n.length - 1, u = 0; u < n.length; u++) { var l = n[a].compareTo(r[s]); if (0 !== l) return l; a += i, s += o } return 0 } }, { key: "interfaces_", get: function () { return [D] } }]), e }(); Zt.ForwardComparator = Jt, Zt.BidirectionalComparator = $t, Zt.coordArrayType = new Array(0).fill(null); var Qt = function () { function e(n) { t(this, e), this.str = n } return r(e, [{ key: "append", value: function (t) { this.str += t } }, { key: "setCharAt", value: function (t, e) { this.str = this.str.substr(0, t) + e + this.str.substr(t + 1) } }, { key: "toString", value: function () { return this.str } }]), e }(), Kt = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "getM", value: function (t) { return this.hasM() ? this._coordinates[t].getM() : A.NaN } }, { key: "setOrdinate", value: function (t, e, n) { switch (e) { case ht.X: this._coordinates[t].x = n; break; case ht.Y: this._coordinates[t].y = n; break; default: this._coordinates[t].setOrdinate(e, n) } } }, { key: "getZ", value: function (t) { return this.hasZ() ? this._coordinates[t].getZ() : A.NaN } }, { key: "size", value: function () { return this._coordinates.length } }, { key: "getOrdinate", value: function (t, e) { switch (e) { case ht.X: return this._coordinates[t].x; case ht.Y: return this._coordinates[t].y; default: return this._coordinates[t].getOrdinate(e) } } }, { key: "getCoordinate", value: function () { if (1 === arguments.length) { var t = arguments[0]; return this._coordinates[t] } if (2 === arguments.length) { var e = arguments[0]; arguments[1].setCoordinate(this._coordinates[e]) } } }, { key: "getCoordinateCopy", value: function (t) { var e = this.createCoordinate(); return e.setCoordinate(this._coordinates[t]), e } }, { key: "createCoordinate", value: function () { return Wt.create(this.getDimension(), this.getMeasures()) } }, { key: "getDimension", value: function () { return this._dimension } }, { key: "getX", value: function (t) { return this._coordinates[t].x } }, { key: "getMeasures", value: function () { return this._measures } }, { key: "expandEnvelope", value: function (t) { for (var e = 0; e < this._coordinates.length; e++)t.expandToInclude(this._coordinates[e]); return t } }, { key: "copy", value: function () { for (var t = new Array(this.size()).fill(null), n = 0; n < this._coordinates.length; n++) { var r = this.createCoordinate(); r.setCoordinate(this._coordinates[n]), t[n] = r } return new e(t, this._dimension, this._measures) } }, { key: "toString", value: function () { if (this._coordinates.length > 0) { var t = new Qt(17 * this._coordinates.length); t.append("("), t.append(this._coordinates[0]); for (var e = 1; e < this._coordinates.length; e++)t.append(", "), t.append(this._coordinates[e]); return t.append(")"), t.toString() } return "()" } }, { key: "getY", value: function (t) { return this._coordinates[t].y } }, { key: "toCoordinateArray", value: function () { return this._coordinates } }, { key: "interfaces_", get: function () { return [ht, k] } }], [{ key: "constructor_", value: function () { if (this._dimension = 3, this._measures = 0, this._coordinates = null, 1 === arguments.length) { if (arguments[0] instanceof Array) { var t = arguments[0]; e.constructor_.call(this, t, Zt.dimension(t), Zt.measures(t)) } else if (Number.isInteger(arguments[0])) { var n = arguments[0]; this._coordinates = new Array(n).fill(null); for (var r = 0; r < n; r++)this._coordinates[r] = new Y } else if (ot(arguments[0], ht)) { var i = arguments[0]; if (null === i) return this._coordinates = new Array(0).fill(null), null; this._dimension = i.getDimension(), this._measures = i.getMeasures(), this._coordinates = new Array(i.size()).fill(null); for (var o = 0; o < this._coordinates.length; o++)this._coordinates[o] = i.getCoordinateCopy(o) } } else if (2 === arguments.length) { if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) { var a = arguments[0], s = arguments[1]; e.constructor_.call(this, a, s, Zt.measures(a)) } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) { var u = arguments[0], l = arguments[1]; this._coordinates = new Array(u).fill(null), this._dimension = l; for (var c = 0; c < u; c++)this._coordinates[c] = Wt.create(l) } } else if (3 === arguments.length) if (Number.isInteger(arguments[2]) && arguments[0] instanceof Array && Number.isInteger(arguments[1])) { var h = arguments[0], f = arguments[1], p = arguments[2]; this._dimension = f, this._measures = p, this._coordinates = null === h ? new Array(0).fill(null) : h } else if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) { var g = arguments[0], y = arguments[1], v = arguments[2]; this._coordinates = new Array(g).fill(null), this._dimension = y, this._measures = v; for (var d = 0; d < g; d++)this._coordinates[d] = this.createCoordinate() } } }]), e }(), te = function () { function e() { t(this, e) } return r(e, [{ key: "readResolve", value: function () { return e.instance() } }, { key: "create", value: function () { if (1 === arguments.length) { if (arguments[0] instanceof Array) return new Kt(arguments[0]); if (ot(arguments[0], ht)) return new Kt(arguments[0]) } else { if (2 === arguments.length) { var t = arguments[1]; return t > 3 && (t = 3), t < 2 && (t = 2), new Kt(arguments[0], t) } if (3 === arguments.length) { var e = arguments[2], n = arguments[1] - e; return e > 1 && (e = 1), n > 3 && (n = 3), n < 2 && (n = 2), new Kt(arguments[0], n + e, e) } } } }, { key: "interfaces_", get: function () { return [wt, k] } }], [{ key: "instance", value: function () { return e.instanceObject } }]), e }(); te.instanceObject = new te; var ee = function (e) { i(a, e); var n = f(a); function a() { var e; return t(this, a), e = n.call(this), a.constructor_.apply(c(e), arguments), e } return r(a, [{ key: "copyInternal", value: function () { for (var t = new Array(this._geometries.length).fill(null), e = 0; e < t.length; e++)t[e] = this._geometries[e].copy(); return new a(t, this._factory) } }, { key: "equalsExact", value: function () { if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof X) { var t = arguments[0], e = arguments[1]; return !!this.isEquivalentClass(t) && p(o(a.prototype), "equalsExact", this).call(this, t, e) } return p(o(a.prototype), "equalsExact", this).apply(this, arguments) } }, { key: "getBoundaryDimension", value: function () { return 1 } }, { key: "getTypeCode", value: function () { return X.TYPECODE_MULTIPOLYGON } }, { key: "getDimension", value: function () { return 2 } }, { key: "getBoundary", value: function () { if (this.isEmpty()) return this.getFactory().createMultiLineString(); for (var t = new vt, e = 0; e < this._geometries.length; e++)for (var n = this._geometries[e].getBoundary(), r = 0; r < n.getNumGeometries(); r++)t.add(n.getGeometryN(r)); var i = new Array(t.size()).fill(null); return this.getFactory().createMultiLineString(t.toArray(i)) } }, { key: "getGeometryType", value: function () { return X.TYPENAME_MULTIPOLYGON } }, { key: "interfaces_", get: function () { return [Dt] } }], [{ key: "constructor_", value: function () { var t = arguments[0], e = arguments[1]; Vt.constructor_.call(this, t, e) } }]), a }(Vt), ne = function () { function e() { t(this, e) } return r(e, [{ key: "get", value: function () { } }, { key: "put", value: function () { } }, { key: "size", value: function () { } }, { key: "values", value: function () { } }, { key: "entrySet", value: function () { } }]), e }(), re = function (e) { i(o, e); var n = f(o); function o() { var e; return t(this, o), (e = n.call(this)).map = new Map, e } return r(o, [{ key: "get", value: function (t) { return this.map.get(t) || null } }, { key: "put", value: function (t, e) { return this.map.set(t, e), e } }, { key: "values", value: function () { for (var t = new vt, e = this.map.values(), n = e.next(); !n.done;)t.add(n.value), n = e.next(); return t } }, { key: "entrySet", value: function () { var t = new Q; return this.map.entries().forEach((function (e) { return t.add(e) })), t } }, { key: "size", value: function () { return this.map.size() } }]), o }(ne), ie = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "equals", value: function (t) { if (!(t instanceof e)) return !1; var n = t; return this._modelType === n._modelType && this._scale === n._scale } }, { key: "compareTo", value: function (t) { var e = t, n = this.getMaximumSignificantDigits(), r = e.getMaximumSignificantDigits(); return st.compare(n, r) } }, { key: "getScale", value: function () { return this._scale } }, { key: "isFloating", value: function () { return this._modelType === e.FLOATING || this._modelType === e.FLOATING_SINGLE } }, { key: "getType", value: function () { return this._modelType } }, { key: "toString", value: function () { var t = "UNKNOWN"; return this._modelType === e.FLOATING ? t = "Floating" : this._modelType === e.FLOATING_SINGLE ? t = "Floating-Single" : this._modelType === e.FIXED && (t = "Fixed (Scale=" + this.getScale() + ")"), t } }, { key: "makePrecise", value: function () { if ("number" == typeof arguments[0]) { var t = arguments[0]; return A.isNaN(t) || this._modelType === e.FLOATING_SINGLE ? t : this._modelType === e.FIXED ? Math.round(t * this._scale) / this._scale : t } if (arguments[0] instanceof Y) { var n = arguments[0]; if (this._modelType === e.FLOATING) return null; n.x = this.makePrecise(n.x), n.y = this.makePrecise(n.y) } } }, { key: "getMaximumSignificantDigits", value: function () { var t = 16; return this._modelType === e.FLOATING ? t = 16 : this._modelType === e.FLOATING_SINGLE ? t = 6 : this._modelType === e.FIXED && (t = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))), t } }, { key: "setScale", value: function (t) { this._scale = Math.abs(t) } }, { key: "interfaces_", get: function () { return [k, E] } }], [{ key: "constructor_", value: function () { if (this._modelType = null, this._scale = null, 0 === arguments.length) this._modelType = e.FLOATING; else if (1 === arguments.length) if (arguments[0] instanceof oe) { var t = arguments[0]; this._modelType = t, t === e.FIXED && this.setScale(1) } else if ("number" == typeof arguments[0]) { var n = arguments[0]; this._modelType = e.FIXED, this.setScale(n) } else if (arguments[0] instanceof e) { var r = arguments[0]; this._modelType = r._modelType, this._scale = r._scale } } }, { key: "mostPrecise", value: function (t, e) { return t.compareTo(e) >= 0 ? t : e } }]), e }(), oe = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "readResolve", value: function () { return e.nameToTypeMap.get(this._name) } }, { key: "toString", value: function () { return this._name } }, { key: "interfaces_", get: function () { return [k] } }], [{ key: "constructor_", value: function () { this._name = null; var t = arguments[0]; this._name = t, e.nameToTypeMap.put(t, this) } }]), e }(); oe.nameToTypeMap = new re, ie.Type = oe, ie.FIXED = new oe("FIXED"), ie.FLOATING = new oe("FLOATING"), ie.FLOATING_SINGLE = new oe("FLOATING SINGLE"), ie.maximumPreciseValue = 9007199254740992; var ae = function (e) { i(a, e); var n = f(a); function a() { var e; return t(this, a), e = n.call(this), a.constructor_.apply(c(e), arguments), e } return r(a, [{ key: "copyInternal", value: function () { for (var t = new Array(this._geometries.length).fill(null), e = 0; e < t.length; e++)t[e] = this._geometries[e].copy(); return new a(t, this._factory) } }, { key: "equalsExact", value: function () { if (2 === arguments.length && "number" == typeof arguments[1] && arguments[0] instanceof X) { var t = arguments[0], e = arguments[1]; return !!this.isEquivalentClass(t) && p(o(a.prototype), "equalsExact", this).call(this, t, e) } return p(o(a.prototype), "equalsExact", this).apply(this, arguments) } }, { key: "getBoundaryDimension", value: function () { return this.isClosed() ? Nt.FALSE : 0 } }, { key: "isClosed", value: function () { if (this.isEmpty()) return !1; for (var t = 0; t < this._geometries.length; t++)if (!this._geometries[t].isClosed()) return !1; return !0 } }, { key: "getTypeCode", value: function () { return X.TYPECODE_MULTILINESTRING } }, { key: "getDimension", value: function () { return 1 } }, { key: "getBoundary", value: function () { throw new J } }, { key: "getGeometryType", value: function () { return X.TYPENAME_MULTILINESTRING } }, { key: "interfaces_", get: function () { return [It] } }], [{ key: "constructor_", value: function () { var t = arguments[0], e = arguments[1]; Vt.constructor_.call(this, t, e) } }]), a }(Vt), se = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "createEmpty", value: function (t) { switch (t) { case -1: return this.createGeometryCollection(); case 0: return this.createPoint(); case 1: return this.createLineString(); case 2: return this.createPolygon(); default: throw new b("Invalid dimension: " + t) } } }, { key: "toGeometry", value: function (t) { return t.isNull() ? this.createPoint() : t.getMinX() === t.getMaxX() && t.getMinY() === t.getMaxY() ? this.createPoint(new Y(t.getMinX(), t.getMinY())) : t.getMinX() === t.getMaxX() || t.getMinY() === t.getMaxY() ? this.createLineString([new Y(t.getMinX(), t.getMinY()), new Y(t.getMaxX(), t.getMaxY())]) : this.createPolygon(this.createLinearRing([new Y(t.getMinX(), t.getMinY()), new Y(t.getMinX(), t.getMaxY()), new Y(t.getMaxX(), t.getMaxY()), new Y(t.getMaxX(), t.getMinY()), new Y(t.getMinX(), t.getMinY())]), null) } }, { key: "createLineString", value: function () { if (0 === arguments.length) return this.createLineString(this.getCoordinateSequenceFactory().create([])); if (1 === arguments.length) { if (arguments[0] instanceof Array) { var t = arguments[0]; return this.createLineString(null !== t ? this.getCoordinateSequenceFactory().create(t) : null) } if (ot(arguments[0], ht)) return new Lt(arguments[0], this) } } }, { key: "createMultiLineString", value: function () { return 0 === arguments.length ? new ae(null, this) : 1 === arguments.length ? new ae(arguments[0], this) : void 0 } }, { key: "buildGeometry", value: function (t) { for (var n = null, r = !1, i = !1, o = t.iterator(); o.hasNext();) { var a = o.next(), s = a.getTypeCode(); null === n && (n = s), s !== n && (r = !0), a instanceof Vt && (i = !0) } if (null === n) return this.createGeometryCollection(); if (r || i) return this.createGeometryCollection(e.toGeometryArray(t)); var u = t.iterator().next(); if (t.size() > 1) { if (u instanceof jt) return this.createMultiPolygon(e.toPolygonArray(t)); if (u instanceof Lt) return this.createMultiLineString(e.toLineStringArray(t)); if (u instanceof Ct) return this.createMultiPoint(e.toPointArray(t)); B.shouldNeverReachHere("Unhandled geometry type: " + u.getGeometryType()) } return u } }, { key: "createMultiPointFromCoords", value: function (t) { return this.createMultiPoint(null !== t ? this.getCoordinateSequenceFactory().create(t) : null) } }, { key: "createPoint", value: function () { if (0 === arguments.length) return this.createPoint(this.getCoordinateSequenceFactory().create([])); if (1 === arguments.length) { if (arguments[0] instanceof Y) { var t = arguments[0]; return this.createPoint(null !== t ? this.getCoordinateSequenceFactory().create([t]) : null) } if (ot(arguments[0], ht)) return new Ct(arguments[0], this) } } }, { key: "getCoordinateSequenceFactory", value: function () { return this._coordinateSequenceFactory } }, { key: "createPolygon", value: function () { if (0 === arguments.length) return this.createPolygon(null, null); if (1 === arguments.length) { if (ot(arguments[0], ht)) { var t = arguments[0]; return this.createPolygon(this.createLinearRing(t)) } if (arguments[0] instanceof Array) { var e = arguments[0]; return this.createPolygon(this.createLinearRing(e)) } if (arguments[0] instanceof Yt) { var n = arguments[0]; return this.createPolygon(n, null) } } else if (2 === arguments.length) return new jt(arguments[0], arguments[1], this) } }, { key: "getSRID", value: function () { return this._SRID } }, { key: "createGeometryCollection", value: function () { return 0 === arguments.length ? new Vt(null, this) : 1 === arguments.length ? new Vt(arguments[0], this) : void 0 } }, { key: "getPrecisionModel", value: function () { return this._precisionModel } }, { key: "createLinearRing", value: function () { if (0 === arguments.length) return this.createLinearRing(this.getCoordinateSequenceFactory().create([])); if (1 === arguments.length) { if (arguments[0] instanceof Array) { var t = arguments[0]; return this.createLinearRing(null !== t ? this.getCoordinateSequenceFactory().create(t) : null) } if (ot(arguments[0], ht)) return new Yt(arguments[0], this) } } }, { key: "createMultiPolygon", value: function () { return 0 === arguments.length ? new ee(null, this) : 1 === arguments.length ? new ee(arguments[0], this) : void 0 } }, { key: "createMultiPoint", value: function () { if (0 === arguments.length) return new Gt(null, this); if (1 === arguments.length) { if (arguments[0] instanceof Array) return new Gt(arguments[0], this); if (ot(arguments[0], ht)) { var t = arguments[0]; if (null === t) return this.createMultiPoint(new Array(0).fill(null)); for (var e = new Array(t.size()).fill(null), n = 0; n < t.size(); n++) { var r = this.getCoordinateSequenceFactory().create(1, t.getDimension(), t.getMeasures()); Pt.copy(t, n, r, 0, 1), e[n] = this.createPoint(r) } return this.createMultiPoint(e) } } } }, { key: "interfaces_", get: function () { return [k] } }], [{ key: "constructor_", value: function () { if (this._precisionModel = null, this._coordinateSequenceFactory = null, this._SRID = null, 0 === arguments.length) e.constructor_.call(this, new ie, 0); else if (1 === arguments.length) { if (ot(arguments[0], wt)) { var t = arguments[0]; e.constructor_.call(this, new ie, 0, t) } else if (arguments[0] instanceof ie) { var n = arguments[0]; e.constructor_.call(this, n, 0, e.getDefaultCoordinateSequenceFactory()) } } else if (2 === arguments.length) { var r = arguments[0], i = arguments[1]; e.constructor_.call(this, r, i, e.getDefaultCoordinateSequenceFactory()) } else if (3 === arguments.length) { var o = arguments[0], a = arguments[1], s = arguments[2]; this._precisionModel = o, this._coordinateSequenceFactory = s, this._SRID = a } } }, { key: "toMultiPolygonArray", value: function (t) { var e = new Array(t.size()).fill(null); return t.toArray(e) } }, { key: "toGeometryArray", value: function (t) { if (null === t) return null; var e = new Array(t.size()).fill(null); return t.toArray(e) } }, { key: "getDefaultCoordinateSequenceFactory", value: function () { return te.instance() } }, { key: "toMultiLineStringArray", value: function (t) { var e = new Array(t.size()).fill(null); return t.toArray(e) } }, { key: "toLineStringArray", value: function (t) { var e = new Array(t.size()).fill(null); return t.toArray(e) } }, { key: "toMultiPointArray", value: function (t) { var e = new Array(t.size()).fill(null); return t.toArray(e) } }, { key: "toLinearRingArray", value: function (t) { var e = new Array(t.size()).fill(null); return t.toArray(e) } }, { key: "toPointArray", value: function (t) { var e = new Array(t.size()).fill(null); return t.toArray(e) } }, { key: "toPolygonArray", value: function (t) { var e = new Array(t.size()).fill(null); return t.toArray(e) } }, { key: "createPointFromInternalCoord", value: function (t, e) { return e.getPrecisionModel().makePrecise(t), e.getFactory().createPoint(t) } }]), e }(), ue = "XY", le = "XYZ", ce = "XYM", he = "XYZM", fe = { POINT: "Point", LINE_STRING: "LineString", LINEAR_RING: "LinearRing", POLYGON: "Polygon", MULTI_POINT: "MultiPoint", MULTI_LINE_STRING: "MultiLineString", MULTI_POLYGON: "MultiPolygon", GEOMETRY_COLLECTION: "GeometryCollection", CIRCLE: "Circle" }, pe = "EMPTY", ge = 1, ye = 2, ve = 3, de = 4, me = 5, _e = 6; for (var be in fe) fe[be].toUpperCase(); var xe = function () { function e(n) { t(this, e), this.wkt = n, this.index_ = -1 } return r(e, [{ key: "isAlpha_", value: function (t) { return t >= "a" && t <= "z" || t >= "A" && t <= "Z" } }, { key: "isNumeric_", value: function (t, e) { return t >= "0" && t <= "9" || "." == t && !(void 0 !== e && e) } }, { key: "isWhiteSpace_", value: function (t) { return " " == t || "\t" == t || "\r" == t || "\n" == t } }, { key: "nextChar_", value: function () { return this.wkt.charAt(++this.index_) } }, { key: "nextToken", value: function () { var t, e = this.nextChar_(), n = this.index_, r = e; if ("(" == e) t = ye; else if ("," == e) t = me; else if (")" == e) t = ve; else if (this.isNumeric_(e) || "-" == e) t = de, r = this.readNumber_(); else if (this.isAlpha_(e)) t = ge, r = this.readText_(); else { if (this.isWhiteSpace_(e)) return this.nextToken(); if ("" !== e) throw new Error("Unexpected character: " + e); t = _e } return { position: n, value: r, type: t } } }, { key: "readNumber_", value: function () { var t, e = this.index_, n = !1, r = !1; do { "." == t ? n = !0 : "e" != t && "E" != t || (r = !0), t = this.nextChar_() } while (this.isNumeric_(t, n) || !r && ("e" == t || "E" == t) || r && ("-" == t || "+" == t)); return parseFloat(this.wkt.substring(e, this.index_--)) } }, { key: "readText_", value: function () { var t, e = this.index_; do { t = this.nextChar_() } while (this.isAlpha_(t)); return this.wkt.substring(e, this.index_--).toUpperCase() } }]), e }(), Ee = function () { function e(n, r) { t(this, e), this.lexer_ = n, this.token_, this.layout_ = ue, this.factory = r } return r(e, [{ key: "consume_", value: function () { this.token_ = this.lexer_.nextToken() } }, { key: "isTokenType", value: function (t) { return this.token_.type == t } }, { key: "match", value: function (t) { var e = this.isTokenType(t); return e && this.consume_(), e } }, { key: "parse", value: function () { return this.consume_(), this.parseGeometry_() } }, { key: "parseGeometryLayout_", value: function () { var t = ue, e = this.token_; if (this.isTokenType(ge)) { var n = e.value; "Z" === n ? t = le : "M" === n ? t = ce : "ZM" === n && (t = he), t !== ue && this.consume_() } return t } }, { key: "parseGeometryCollectionText_", value: function () { if (this.match(ye)) { var t = []; do { t.push(this.parseGeometry_()) } while (this.match(me)); if (this.match(ve)) return t } else if (this.isEmptyGeometry_()) return []; throw new Error(this.formatErrorMessage_()) } }, { key: "parsePointText_", value: function () { if (this.match(ye)) { var t = this.parsePoint_(); if (this.match(ve)) return t } else if (this.isEmptyGeometry_()) return null; throw new Error(this.formatErrorMessage_()) } }, { key: "parseLineStringText_", value: function () { if (this.match(ye)) { var t = this.parsePointList_(); if (this.match(ve)) return t } else if (this.isEmptyGeometry_()) return []; throw new Error(this.formatErrorMessage_()) } }, { key: "parsePolygonText_", value: function () { if (this.match(ye)) { var t = this.parseLineStringTextList_(); if (this.match(ve)) return t } else if (this.isEmptyGeometry_()) return []; throw new Error(this.formatErrorMessage_()) } }, { key: "parseMultiPointText_", value: function () { var t; if (this.match(ye)) { if (t = this.token_.type == ye ? this.parsePointTextList_() : this.parsePointList_(), this.match(ve)) return t } else if (this.isEmptyGeometry_()) return []; throw new Error(this.formatErrorMessage_()) } }, { key: "parseMultiLineStringText_", value: function () { if (this.match(ye)) { var t = this.parseLineStringTextList_(); if (this.match(ve)) return t } else if (this.isEmptyGeometry_()) return []; throw new Error(this.formatErrorMessage_()) } }, { key: "parseMultiPolygonText_", value: function () { if (this.match(ye)) { var t = this.parsePolygonTextList_(); if (this.match(ve)) return t } else if (this.isEmptyGeometry_()) return []; throw new Error(this.formatErrorMessage_()) } }, { key: "parsePoint_", value: function () { for (var t = [], e = this.layout_.length, n = 0; n < e; ++n) { var r = this.token_; if (!this.match(de)) break; t.push(r.value) } if (t.length == e) return t; throw new Error(this.formatErrorMessage_()) } }, { key: "parsePointList_", value: function () { for (var t = [this.parsePoint_()]; this.match(me);)t.push(this.parsePoint_()); return t } }, { key: "parsePointTextList_", value: function () { for (var t = [this.parsePointText_()]; this.match(me);)t.push(this.parsePointText_()); return t } }, { key: "parseLineStringTextList_", value: function () { for (var t = [this.parseLineStringText_()]; this.match(me);)t.push(this.parseLineStringText_()); return t } }, { key: "parsePolygonTextList_", value: function () { for (var t = [this.parsePolygonText_()]; this.match(me);)t.push(this.parsePolygonText_()); return t } }, { key: "isEmptyGeometry_", value: function () { var t = this.isTokenType(ge) && this.token_.value == pe; return t && this.consume_(), t } }, { key: "formatErrorMessage_", value: function () { return "Unexpected `" + this.token_.value + "` at position " + this.token_.position + " in `" + this.lexer_.wkt + "`" } }, { key: "parseGeometry_", value: function () { var t = this.factory, e = function (t) { return u(Y, g(t)) }, n = function (n) { var r = n.map((function (n) { return t.createLinearRing(n.map(e)) })); return r.length > 1 ? t.createPolygon(r[0], r.slice(1)) : t.createPolygon(r[0]) }, r = this.token_; if (this.match(ge)) { var i = r.value; if (this.layout_ = this.parseGeometryLayout_(), "GEOMETRYCOLLECTION" == i) { var o = this.parseGeometryCollectionText_(); return t.createGeometryCollection(o) } switch (i) { case "POINT": var a = this.parsePointText_(); return a ? t.createPoint(u(Y, g(a))) : t.createPoint(); case "LINESTRING": var s = this.parseLineStringText_().map(e); return t.createLineString(s); case "LINEARRING": var l = this.parseLineStringText_().map(e); return t.createLinearRing(l); case "POLYGON": var c = this.parsePolygonText_(); return c && 0 !== c.length ? n(c) : t.createPolygon(); case "MULTIPOINT": var h = this.parseMultiPointText_(); if (!h || 0 === h.length) return t.createMultiPoint(); var f = h.map(e).map((function (e) { return t.createPoint(e) })); return t.createMultiPoint(f); case "MULTILINESTRING": var p = this.parseMultiLineStringText_().map((function (n) { return t.createLineString(n.map(e)) })); return t.createMultiLineString(p); case "MULTIPOLYGON": var y = this.parseMultiPolygonText_(); if (!y || 0 === y.length) return t.createMultiPolygon(); var v = y.map(n); return t.createMultiPolygon(v); default: throw new Error("Invalid geometry type: " + i) } } throw new Error(this.formatErrorMessage_()) } }]), e }(); function we(t) { if (t.isEmpty()) return ""; var e = t.getCoordinate(), n = [e.x, e.y]; return void 0 === e.z || Number.isNaN(e.z) || n.push(e.z), void 0 === e.m || Number.isNaN(e.m) || n.push(e.m), n.join(" ") } function ke(t) { for (var e = t.getCoordinates().map((function (t) { var e = [t.x, t.y]; return void 0 === t.z || Number.isNaN(t.z) || e.push(t.z), void 0 === t.m || Number.isNaN(t.m) || e.push(t.m), e })), n = [], r = 0, i = e.length; r < i; ++r)n.push(e[r].join(" ")); return n.join(", ") } function Se(t) { var e = []; e.push("(" + ke(t.getExteriorRing()) + ")"); for (var n = 0, r = t.getNumInteriorRing(); n < r; ++n)e.push("(" + ke(t.getInteriorRingN(n)) + ")"); return e.join(", ") } var Ie = { Point: we, LineString: ke, LinearRing: ke, Polygon: Se, MultiPoint: function (t) { for (var e = [], n = 0, r = t.getNumGeometries(); n < r; ++n)e.push("(" + we(t.getGeometryN(n)) + ")"); return e.join(", ") }, MultiLineString: function (t) { for (var e = [], n = 0, r = t.getNumGeometries(); n < r; ++n)e.push("(" + ke(t.getGeometryN(n)) + ")"); return e.join(", ") }, MultiPolygon: function (t) { for (var e = [], n = 0, r = t.getNumGeometries(); n < r; ++n)e.push("(" + Se(t.getGeometryN(n)) + ")"); return e.join(", ") }, GeometryCollection: function (t) { for (var e = [], n = 0, r = t.getNumGeometries(); n < r; ++n)e.push(Pe(t.getGeometryN(n))); return e.join(", ") } }; function Pe(t) { var e = t.getGeometryType(), n = Ie[e]; e = e.toUpperCase(); var r = function (t) { var e = ""; if (t.isEmpty()) return e; var n = t.getCoordinate(); return void 0 === n.z || Number.isNaN(n.z) || (e += "Z"), void 0 === n.m || Number.isNaN(n.m) || (e += "M"), e }(t); return r.length > 0 && (e += " " + r), t.isEmpty() ? e + " " + pe : e + " (" + n(t) + ")" } var Ne = function () { function e(n) { t(this, e), this.geometryFactory = n || new se, this.precisionModel = this.geometryFactory.getPrecisionModel() } return r(e, [{ key: "read", value: function (t) { var e = new xe(t); return new Ee(e, this.geometryFactory).parse() } }, { key: "write", value: function (t) { return Pe(t) } }]), e }(), Me = function () { function e(n) { t(this, e), this.parser = new Ne(n) } return r(e, [{ key: "write", value: function (t) { return this.parser.write(t) } }], [{ key: "toLineString", value: function (t, e) { if (2 !== arguments.length) throw new Error("Not implemented"); return "LINESTRING ( " + t.x + " " + t.y + ", " + e.x + " " + e.y + " )" } }]), e }(), Oe = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "getIndexAlongSegment", value: function (t, e) { return this.computeIntLineIndex(), this._intLineIndex[t][e] } }, { key: "getTopologySummary", value: function () { var t = new Qt; return this.isEndPoint() && t.append(" endpoint"), this._isProper && t.append(" proper"), this.isCollinear() && t.append(" collinear"), t.toString() } }, { key: "computeIntersection", value: function (t, e, n, r) { this._inputLines[0][0] = t, this._inputLines[0][1] = e, this._inputLines[1][0] = n, this._inputLines[1][1] = r, this._result = this.computeIntersect(t, e, n, r) } }, { key: "getIntersectionNum", value: function () { return this._result } }, { key: "computeIntLineIndex", value: function () { if (0 === arguments.length) null === this._intLineIndex && (this._intLineIndex = Array(2).fill().map((function () { return Array(2) })), this.computeIntLineIndex(0), this.computeIntLineIndex(1)); else if (1 === arguments.length) { var t = arguments[0]; this.getEdgeDistance(t, 0) > this.getEdgeDistance(t, 1) ? (this._intLineIndex[t][0] = 0, this._intLineIndex[t][1] = 1) : (this._intLineIndex[t][0] = 1, this._intLineIndex[t][1] = 0) } } }, { key: "isProper", value: function () { return this.hasIntersection() && this._isProper } }, { key: "setPrecisionModel", value: function (t) { this._precisionModel = t } }, { key: "isInteriorIntersection", value: function () { if (0 === arguments.length) return !!this.isInteriorIntersection(0) || !!this.isInteriorIntersection(1); if (1 === arguments.length) { for (var t = arguments[0], e = 0; e < this._result; e++)if (!this._intPt[e].equals2D(this._inputLines[t][0]) && !this._intPt[e].equals2D(this._inputLines[t][1])) return !0; return !1 } } }, { key: "getIntersection", value: function (t) { return this._intPt[t] } }, { key: "isEndPoint", value: function () { return this.hasIntersection() && !this._isProper } }, { key: "hasIntersection", value: function () { return this._result !== e.NO_INTERSECTION } }, { key: "getEdgeDistance", value: function (t, n) { return e.computeEdgeDistance(this._intPt[n], this._inputLines[t][0], this._inputLines[t][1]) } }, { key: "isCollinear", value: function () { return this._result === e.COLLINEAR_INTERSECTION } }, { key: "toString", value: function () { return Me.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + " - " + Me.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary() } }, { key: "getEndpoint", value: function (t, e) { return this._inputLines[t][e] } }, { key: "isIntersection", value: function (t) { for (var e = 0; e < this._result; e++)if (this._intPt[e].equals2D(t)) return !0; return !1 } }, { key: "getIntersectionAlongSegment", value: function (t, e) { return this.computeIntLineIndex(), this._intPt[this._intLineIndex[t][e]] } }], [{ key: "constructor_", value: function () { this._result = null, this._inputLines = Array(2).fill().map((function () { return Array(2) })), this._intPt = new Array(2).fill(null), this._intLineIndex = null, this._isProper = null, this._pa = null, this._pb = null, this._precisionModel = null, this._intPt[0] = new Y, this._intPt[1] = new Y, this._pa = this._intPt[0], this._pb = this._intPt[1], this._result = 0 } }, { key: "computeEdgeDistance", value: function (t, e, n) { var r = Math.abs(n.x - e.x), i = Math.abs(n.y - e.y), o = -1; if (t.equals(e)) o = 0; else if (t.equals(n)) o = r > i ? r : i; else { var a = Math.abs(t.x - e.x), s = Math.abs(t.y - e.y); 0 !== (o = r > i ? a : s) || t.equals(e) || (o = Math.max(a, s)) } return B.isTrue(!(0 === o && !t.equals(e)), "Bad distance calculation"), o } }, { key: "nonRobustComputeEdgeDistance", value: function (t, e, n) { var r = t.x - e.x, i = t.y - e.y, o = Math.sqrt(r * r + i * i); return B.isTrue(!(0 === o && !t.equals(e)), "Invalid distance calculation"), o } }]), e }(); Oe.DONT_INTERSECT = 0, Oe.DO_INTERSECT = 1, Oe.COLLINEAR = 2, Oe.NO_INTERSECTION = 0, Oe.POINT_INTERSECTION = 1, Oe.COLLINEAR_INTERSECTION = 2; var Le = function (e) { i(a, e); var n = f(a); function a() { return t(this, a), n.call(this) } return r(a, [{ key: "isInSegmentEnvelopes", value: function (t) { var e = new U(this._inputLines[0][0], this._inputLines[0][1]), n = new U(this._inputLines[1][0], this._inputLines[1][1]); return e.contains(t) && n.contains(t) } }, { key: "computeIntersection", value: function () { if (3 !== arguments.length) return p(o(a.prototype), "computeIntersection", this).apply(this, arguments); var t = arguments[0], e = arguments[1], n = arguments[2]; if (this._isProper = !1, U.intersects(e, n, t) && 0 === ft.index(e, n, t) && 0 === ft.index(n, e, t)) return this._isProper = !0, (t.equals(e) || t.equals(n)) && (this._isProper = !1), this._result = Oe.POINT_INTERSECTION, null; this._result = Oe.NO_INTERSECTION } }, { key: "intersection", value: function (t, e, n, r) { var i = this.intersectionSafe(t, e, n, r); return this.isInSegmentEnvelopes(i) || (i = new Y(a.nearestEndpoint(t, e, n, r))), null !== this._precisionModel && this._precisionModel.makePrecise(i), i } }, { key: "checkDD", value: function (t, e, n, r, i) { var o = ct.intersection(t, e, n, r), a = this.isInSegmentEnvelopes(o); bt.out.println("DD in env = " + a + "  --------------------- " + o), i.distance(o) > 1e-4 && bt.out.println("Distance = " + i.distance(o)) } }, { key: "intersectionSafe", value: function (t, e, n, r) { var i = _t.intersection(t, e, n, r); return null === i && (i = a.nearestEndpoint(t, e, n, r)), i } }, { key: "computeCollinearIntersection", value: function (t, e, n, r) { var i = U.intersects(t, e, n), o = U.intersects(t, e, r), a = U.intersects(n, r, t), s = U.intersects(n, r, e); return i && o ? (this._intPt[0] = n, this._intPt[1] = r, Oe.COLLINEAR_INTERSECTION) : a && s ? (this._intPt[0] = t, this._intPt[1] = e, Oe.COLLINEAR_INTERSECTION) : i && a ? (this._intPt[0] = n, this._intPt[1] = t, !n.equals(t) || o || s ? Oe.COLLINEAR_INTERSECTION : Oe.POINT_INTERSECTION) : i && s ? (this._intPt[0] = n, this._intPt[1] = e, !n.equals(e) || o || a ? Oe.COLLINEAR_INTERSECTION : Oe.POINT_INTERSECTION) : o && a ? (this._intPt[0] = r, this._intPt[1] = t, !r.equals(t) || i || s ? Oe.COLLINEAR_INTERSECTION : Oe.POINT_INTERSECTION) : o && s ? (this._intPt[0] = r, this._intPt[1] = e, !r.equals(e) || i || a ? Oe.COLLINEAR_INTERSECTION : Oe.POINT_INTERSECTION) : Oe.NO_INTERSECTION } }, { key: "computeIntersect", value: function (t, e, n, r) { if (this._isProper = !1, !U.intersects(t, e, n, r)) return Oe.NO_INTERSECTION; var i = ft.index(t, e, n), o = ft.index(t, e, r); if (i > 0 && o > 0 || i < 0 && o < 0) return Oe.NO_INTERSECTION; var a = ft.index(n, r, t), s = ft.index(n, r, e); return a > 0 && s > 0 || a < 0 && s < 0 ? Oe.NO_INTERSECTION : 0 === i && 0 === o && 0 === a && 0 === s ? this.computeCollinearIntersection(t, e, n, r) : (0 === i || 0 === o || 0 === a || 0 === s ? (this._isProper = !1, t.equals2D(n) || t.equals2D(r) ? this._intPt[0] = t : e.equals2D(n) || e.equals2D(r) ? this._intPt[0] = e : 0 === i ? this._intPt[0] = new Y(n) : 0 === o ? this._intPt[0] = new Y(r) : 0 === a ? this._intPt[0] = new Y(t) : 0 === s && (this._intPt[0] = new Y(e))) : (this._isProper = !0, this._intPt[0] = this.intersection(t, e, n, r)), Oe.POINT_INTERSECTION) } }], [{ key: "nearestEndpoint", value: function (t, e, n, r) { var i = t, o = Et.pointToSegment(t, n, r), a = Et.pointToSegment(e, n, r); return a < o && (o = a, i = e), (a = Et.pointToSegment(n, t, e)) < o && (o = a, i = n), (a = Et.pointToSegment(r, t, e)) < o && (o = a, i = r), i } }]), a }(Oe), Re = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "countSegment", value: function (t, e) { if (t.x < this._p.x && e.x < this._p.x) return null; if (this._p.x === e.x && this._p.y === e.y) return this._isPointOnSegment = !0, null; if (t.y === this._p.y && e.y === this._p.y) { var n = t.x, r = e.x; return n > r && (n = e.x, r = t.x), this._p.x >= n && this._p.x <= r && (this._isPointOnSegment = !0), null } if (t.y > this._p.y && e.y <= this._p.y || e.y > this._p.y && t.y <= this._p.y) { var i = ft.index(t, e, this._p); if (i === ft.COLLINEAR) return this._isPointOnSegment = !0, null; e.y < t.y && (i = -i), i === ft.LEFT && this._crossingCount++ } } }, { key: "isPointInPolygon", value: function () { return this.getLocation() !== W.EXTERIOR } }, { key: "getLocation", value: function () { return this._isPointOnSegment ? W.BOUNDARY : this._crossingCount % 2 == 1 ? W.INTERIOR : W.EXTERIOR } }, { key: "isOnSegment", value: function () { return this._isPointOnSegment } }], [{ key: "constructor_", value: function () { this._p = null, this._crossingCount = 0, this._isPointOnSegment = !1; var t = arguments[0]; this._p = t } }, { key: "locatePointInRing", value: function () { if (arguments[0] instanceof Y && ot(arguments[1], ht)) { for (var t = arguments[1], n = new e(arguments[0]), r = new Y, i = new Y, o = 1; o < t.size(); o++)if (t.getCoordinate(o, r), t.getCoordinate(o - 1, i), n.countSegment(r, i), n.isOnSegment()) return n.getLocation(); return n.getLocation() } if (arguments[0] instanceof Y && arguments[1] instanceof Array) { for (var a = arguments[1], s = new e(arguments[0]), u = 1; u < a.length; u++) { var l = a[u], c = a[u - 1]; if (s.countSegment(l, c), s.isOnSegment()) return s.getLocation() } return s.getLocation() } } }]), e }(), Ce = function () { function e() { t(this, e) } return r(e, null, [{ key: "isOnLine", value: function () { if (arguments[0] instanceof Y && ot(arguments[1], ht)) { for (var t = arguments[0], e = arguments[1], n = new Le, r = new Y, i = new Y, o = e.size(), a = 1; a < o; a++)if (e.getCoordinate(a - 1, r), e.getCoordinate(a, i), n.computeIntersection(t, r, i), n.hasIntersection()) return !0; return !1 } if (arguments[0] instanceof Y && arguments[1] instanceof Array) { for (var s = arguments[0], u = arguments[1], l = new Le, c = 1; c < u.length; c++) { var h = u[c - 1], f = u[c]; if (l.computeIntersection(s, h, f), l.hasIntersection()) return !0 } return !1 } } }, { key: "locateInRing", value: function (t, e) { return Re.locatePointInRing(t, e) } }, { key: "isInRing", value: function (t, n) { return e.locateInRing(t, n) !== W.EXTERIOR } }]), e }(), Te = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "setAllLocations", value: function (t) { for (var e = 0; e < this.location.length; e++)this.location[e] = t } }, { key: "isNull", value: function () { for (var t = 0; t < this.location.length; t++)if (this.location[t] !== W.NONE) return !1; return !0 } }, { key: "setAllLocationsIfNull", value: function (t) { for (var e = 0; e < this.location.length; e++)this.location[e] === W.NONE && (this.location[e] = t) } }, { key: "isLine", value: function () { return 1 === this.location.length } }, { key: "merge", value: function (t) { if (t.location.length > this.location.length) { var e = new Array(3).fill(null); e[tt.ON] = this.location[tt.ON], e[tt.LEFT] = W.NONE, e[tt.RIGHT] = W.NONE, this.location = e } for (var n = 0; n < this.location.length; n++)this.location[n] === W.NONE && n < t.location.length && (this.location[n] = t.location[n]) } }, { key: "getLocations", value: function () { return this.location } }, { key: "flip", value: function () { if (this.location.length <= 1) return null; var t = this.location[tt.LEFT]; this.location[tt.LEFT] = this.location[tt.RIGHT], this.location[tt.RIGHT] = t } }, { key: "toString", value: function () { var t = new at; return this.location.length > 1 && t.append(W.toLocationSymbol(this.location[tt.LEFT])), t.append(W.toLocationSymbol(this.location[tt.ON])), this.location.length > 1 && t.append(W.toLocationSymbol(this.location[tt.RIGHT])), t.toString() } }, { key: "setLocations", value: function (t, e, n) { this.location[tt.ON] = t, this.location[tt.LEFT] = e, this.location[tt.RIGHT] = n } }, { key: "get", value: function (t) { return t < this.location.length ? this.location[t] : W.NONE } }, { key: "isArea", value: function () { return this.location.length > 1 } }, { key: "isAnyNull", value: function () { for (var t = 0; t < this.location.length; t++)if (this.location[t] === W.NONE) return !0; return !1 } }, { key: "setLocation", value: function () { if (1 === arguments.length) { var t = arguments[0]; this.setLocation(tt.ON, t) } else if (2 === arguments.length) { var e = arguments[0], n = arguments[1]; this.location[e] = n } } }, { key: "init", value: function (t) { this.location = new Array(t).fill(null), this.setAllLocations(W.NONE) } }, { key: "isEqualOnSide", value: function (t, e) { return this.location[e] === t.location[e] } }, { key: "allPositionsEqual", value: function (t) { for (var e = 0; e < this.location.length; e++)if (this.location[e] !== t) return !1; return !0 } }], [{ key: "constructor_", value: function () { if (this.location = null, 1 === arguments.length) { if (arguments[0] instanceof Array) { var t = arguments[0]; this.init(t.length) } else if (Number.isInteger(arguments[0])) { var n = arguments[0]; this.init(1), this.location[tt.ON] = n } else if (arguments[0] instanceof e) { var r = arguments[0]; if (this.init(r.location.length), null !== r) for (var i = 0; i < this.location.length; i++)this.location[i] = r.location[i] } } else if (3 === arguments.length) { var o = arguments[0], a = arguments[1], s = arguments[2]; this.init(3), this.location[tt.ON] = o, this.location[tt.LEFT] = a, this.location[tt.RIGHT] = s } } }]), e }(), Ae = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "getGeometryCount", value: function () { var t = 0; return this.elt[0].isNull() || t++, this.elt[1].isNull() || t++, t } }, { key: "setAllLocations", value: function (t, e) { this.elt[t].setAllLocations(e) } }, { key: "isNull", value: function (t) { return this.elt[t].isNull() } }, { key: "setAllLocationsIfNull", value: function () { if (1 === arguments.length) { var t = arguments[0]; this.setAllLocationsIfNull(0, t), this.setAllLocationsIfNull(1, t) } else if (2 === arguments.length) { var e = arguments[0], n = arguments[1]; this.elt[e].setAllLocationsIfNull(n) } } }, { key: "isLine", value: function (t) { return this.elt[t].isLine() } }, { key: "merge", value: function (t) { for (var e = 0; e < 2; e++)null === this.elt[e] && null !== t.elt[e] ? this.elt[e] = new Te(t.elt[e]) : this.elt[e].merge(t.elt[e]) } }, { key: "flip", value: function () { this.elt[0].flip(), this.elt[1].flip() } }, { key: "getLocation", value: function () { if (1 === arguments.length) { var t = arguments[0]; return this.elt[t].get(tt.ON) } if (2 === arguments.length) { var e = arguments[0], n = arguments[1]; return this.elt[e].get(n) } } }, { key: "toString", value: function () { var t = new at; return null !== this.elt[0] && (t.append("A:"), t.append(this.elt[0].toString())), null !== this.elt[1] && (t.append(" B:"), t.append(this.elt[1].toString())), t.toString() } }, { key: "isArea", value: function () { if (0 === arguments.length) return this.elt[0].isArea() || this.elt[1].isArea(); if (1 === arguments.length) { var t = arguments[0]; return this.elt[t].isArea() } } }, { key: "isAnyNull", value: function (t) { return this.elt[t].isAnyNull() } }, { key: "setLocation", value: function () { if (2 === arguments.length) { var t = arguments[0], e = arguments[1]; this.elt[t].setLocation(tt.ON, e) } else if (3 === arguments.length) { var n = arguments[0], r = arguments[1], i = arguments[2]; this.elt[n].setLocation(r, i) } } }, { key: "isEqualOnSide", value: function (t, e) { return this.elt[0].isEqualOnSide(t.elt[0], e) && this.elt[1].isEqualOnSide(t.elt[1], e) } }, { key: "allPositionsEqual", value: function (t, e) { return this.elt[t].allPositionsEqual(e) } }, { key: "toLine", value: function (t) { this.elt[t].isArea() && (this.elt[t] = new Te(this.elt[t].location[0])) } }], [{ key: "constructor_", value: function () { if (this.elt = new Array(2).fill(null), 1 === arguments.length) { if (Number.isInteger(arguments[0])) { var t = arguments[0]; this.elt[0] = new Te(t), this.elt[1] = new Te(t) } else if (arguments[0] instanceof e) { var n = arguments[0]; this.elt[0] = new Te(n.elt[0]), this.elt[1] = new Te(n.elt[1]) } } else if (2 === arguments.length) { var r = arguments[0], i = arguments[1]; this.elt[0] = new Te(W.NONE), this.elt[1] = new Te(W.NONE), this.elt[r].setLocation(i) } else if (3 === arguments.length) { var o = arguments[0], a = arguments[1], s = arguments[2]; this.elt[0] = new Te(o, a, s), this.elt[1] = new Te(o, a, s) } else if (4 === arguments.length) { var u = arguments[0], l = arguments[1], c = arguments[2], h = arguments[3]; this.elt[0] = new Te(W.NONE, W.NONE, W.NONE), this.elt[1] = new Te(W.NONE, W.NONE, W.NONE), this.elt[u].setLocations(l, c, h) } } }, { key: "toLineLabel", value: function (t) { for (var n = new e(W.NONE), r = 0; r < 2; r++)n.setLocation(r, t.getLocation(r)); return n } }]), e }(), De = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "computeRing", value: function () { if (null !== this._ring) return null; for (var t = new Array(this._pts.size()).fill(null), e = 0; e < this._pts.size(); e++)t[e] = this._pts.get(e); this._ring = this._geometryFactory.createLinearRing(t), this._isHole = ft.isCCW(this._ring.getCoordinates()) } }, { key: "isIsolated", value: function () { return 1 === this._label.getGeometryCount() } }, { key: "computePoints", value: function (t) { this._startDe = t; var e = t, n = !0; do { if (null === e) throw new gt("Found null DirectedEdge"); if (e.getEdgeRing() === this) throw new gt("Directed Edge visited twice during ring-building at " + e.getCoordinate()); this._edges.add(e); var r = e.getLabel(); B.isTrue(r.isArea()), this.mergeLabel(r), this.addPoints(e.getEdge(), e.isForward(), n), n = !1, this.setEdgeRing(e, this), e = this.getNext(e) } while (e !== this._startDe) } }, { key: "getLinearRing", value: function () { return this._ring } }, { key: "getCoordinate", value: function (t) { return this._pts.get(t) } }, { key: "computeMaxNodeDegree", value: function () { this._maxNodeDegree = 0; var t = this._startDe; do { var e = t.getNode().getEdges().getOutgoingDegree(this); e > this._maxNodeDegree && (this._maxNodeDegree = e), t = this.getNext(t) } while (t !== this._startDe); this._maxNodeDegree *= 2 } }, { key: "addPoints", value: function (t, e, n) { var r = t.getCoordinates(); if (e) { var i = 1; n && (i = 0); for (var o = i; o < r.length; o++)this._pts.add(r[o]) } else { var a = r.length - 2; n && (a = r.length - 1); for (var s = a; s >= 0; s--)this._pts.add(r[s]) } } }, { key: "isHole", value: function () { return this._isHole } }, { key: "setInResult", value: function () { var t = this._startDe; do { t.getEdge().setInResult(!0), t = t.getNext() } while (t !== this._startDe) } }, { key: "containsPoint", value: function (t) { var e = this.getLinearRing(); if (!e.getEnvelopeInternal().contains(t)) return !1; if (!Ce.isInRing(t, e.getCoordinates())) return !1; for (var n = this._holes.iterator(); n.hasNext();)if (n.next().containsPoint(t)) return !1; return !0 } }, { key: "addHole", value: function (t) { this._holes.add(t) } }, { key: "isShell", value: function () { return null === this._shell } }, { key: "getLabel", value: function () { return this._label } }, { key: "getEdges", value: function () { return this._edges } }, { key: "getMaxNodeDegree", value: function () { return this._maxNodeDegree < 0 && this.computeMaxNodeDegree(), this._maxNodeDegree } }, { key: "getShell", value: function () { return this._shell } }, { key: "mergeLabel", value: function () { if (1 === arguments.length) { var t = arguments[0]; this.mergeLabel(t, 0), this.mergeLabel(t, 1) } else if (2 === arguments.length) { var e = arguments[1], n = arguments[0].getLocation(e, tt.RIGHT); if (n === W.NONE) return null; if (this._label.getLocation(e) === W.NONE) return this._label.setLocation(e, n), null } } }, { key: "setShell", value: function (t) { this._shell = t, null !== t && t.addHole(this) } }, { key: "toPolygon", value: function (t) { for (var e = new Array(this._holes.size()).fill(null), n = 0; n < this._holes.size(); n++)e[n] = this._holes.get(n).getLinearRing(); return t.createPolygon(this.getLinearRing(), e) } }], [{ key: "constructor_", value: function () { if (this._startDe = null, this._maxNodeDegree = -1, this._edges = new vt, this._pts = new vt, this._label = new Ae(W.NONE), this._ring = null, this._isHole = null, this._shell = null, this._holes = new vt, this._geometryFactory = null, 0 === arguments.length); else if (2 === arguments.length) { var t = arguments[0], e = arguments[1]; this._geometryFactory = e, this.computePoints(t), this.computeRing() } } }]), e }(), je = function (e) { i(o, e); var n = f(o); function o() { var e; return t(this, o), e = n.call(this), o.constructor_.apply(c(e), arguments), e } return r(o, [{ key: "setEdgeRing", value: function (t, e) { t.setMinEdgeRing(e) } }, { key: "getNext", value: function (t) { return t.getNextMin() } }], [{ key: "constructor_", value: function () { var t = arguments[0], e = arguments[1]; De.constructor_.call(this, t, e) } }]), o }(De), Fe = function (e) { i(o, e); var n = f(o); function o() { var e; return t(this, o), e = n.call(this), o.constructor_.apply(c(e), arguments), e } return r(o, [{ key: "buildMinimalRings", value: function () { var t = new vt, e = this._startDe; do { if (null === e.getMinEdgeRing()) { var n = new je(e, this._geometryFactory); t.add(n) } e = e.getNext() } while (e !== this._startDe); return t } }, { key: "setEdgeRing", value: function (t, e) { t.setEdgeRing(e) } }, { key: "linkDirectedEdgesForMinimalEdgeRings", value: function () { var t = this._startDe; do { t.getNode().getEdges().linkMinimalDirectedEdges(this), t = t.getNext() } while (t !== this._startDe) } }, { key: "getNext", value: function (t) { return t.getNext() } }], [{ key: "constructor_", value: function () { var t = arguments[0], e = arguments[1]; De.constructor_.call(this, t, e) } }]), o }(De), Be = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "setVisited", value: function (t) { this._isVisited = t } }, { key: "setInResult", value: function (t) { this._isInResult = t } }, { key: "isCovered", value: function () { return this._isCovered } }, { key: "isCoveredSet", value: function () { return this._isCoveredSet } }, { key: "setLabel", value: function (t) { this._label = t } }, { key: "getLabel", value: function () { return this._label } }, { key: "setCovered", value: function (t) { this._isCovered = t, this._isCoveredSet = !0 } }, { key: "updateIM", value: function (t) { B.isTrue(this._label.getGeometryCount() >= 2, "found partial label"), this.computeIM(t) } }, { key: "isInResult", value: function () { return this._isInResult } }, { key: "isVisited", value: function () { return this._isVisited } }], [{ key: "constructor_", value: function () { if (this._label = null, this._isInResult = !1, this._isCovered = !1, this._isCoveredSet = !1, this._isVisited = !1, 0 === arguments.length); else if (1 === arguments.length) { var t = arguments[0]; this._label = t } } }]), e }(), qe = function (e) { i(a, e); var n = f(a); function a() { var e; return t(this, a), e = n.call(this), a.constructor_.apply(c(e), arguments), e } return r(a, [{ key: "isIncidentEdgeInResult", value: function () { for (var t = this.getEdges().getEdges().iterator(); t.hasNext();)if (t.next().getEdge().isInResult()) return !0; return !1 } }, { key: "isIsolated", value: function () { return 1 === this._label.getGeometryCount() } }, { key: "getCoordinate", value: function () { return this._coord } }, { key: "print", value: function (t) { t.println("node " + this._coord + " lbl: " + this._label) } }, { key: "computeIM", value: function (t) { } }, { key: "computeMergedLocation", value: function (t, e) { var n = W.NONE; if (n = this._label.getLocation(e), !t.isNull(e)) { var r = t.getLocation(e); n !== W.BOUNDARY && (n = r) } return n } }, { key: "setLabel", value: function () { if (2 !== arguments.length || !Number.isInteger(arguments[1]) || !Number.isInteger(arguments[0])) return p(o(a.prototype), "setLabel", this).apply(this, arguments); var t = arguments[0], e = arguments[1]; null === this._label ? this._label = new Ae(t, e) : this._label.setLocation(t, e) } }, { key: "getEdges", value: function () { return this._edges } }, { key: "mergeLabel", value: function () { if (arguments[0] instanceof a) { var t = arguments[0]; this.mergeLabel(t._label) } else if (arguments[0] instanceof Ae) for (var e = arguments[0], n = 0; n < 2; n++) { var r = this.computeMergedLocation(e, n); this._label.getLocation(n) === W.NONE && this._label.setLocation(n, r) } } }, { key: "add", value: function (t) { this._edges.insert(t), t.setNode(this) } }, { key: "setLabelBoundary", value: function (t) { if (null === this._label) return null; var e = W.NONE; null !== this._label && (e = this._label.getLocation(t)); var n = null; switch (e) { case W.BOUNDARY: n = W.INTERIOR; break; case W.INTERIOR: default: n = W.BOUNDARY }this._label.setLocation(t, n) } }], [{ key: "constructor_", value: function () { this._coord = null, this._edges = null; var t = arguments[0], e = arguments[1]; this._coord = t, this._edges = e, this._label = new Ae(0, W.NONE) } }]), a }(Be), Ve = function (e) { i(r, e); var n = f(r); function r() { return t(this, r), n.apply(this, arguments) } return r }(ne); function Ge(t) { return null == t ? 0 : t.color } function Ye(t) { return null == t ? null : t.parent } function ze(t, e) { null !== t && (t.color = e) } function Ue(t) { return null == t ? null : t.left } function Xe(t) { return null == t ? null : t.right } var We = function (e) { i(o, e); var n = f(o); function o() { var e; return t(this, o), (e = n.call(this)).root_ = null, e.size_ = 0, e } return r(o, [{ key: "get", value: function (t) { for (var e = this.root_; null !== e;) { var n = t.compareTo(e.key); if (n < 0) e = e.left; else { if (!(n > 0)) return e.value; e = e.right } } return null } }, { key: "put", value: function (t, e) { if (null === this.root_) return this.root_ = { key: t, value: e, left: null, right: null, parent: null, color: 0, getValue: function () { return this.value }, getKey: function () { return this.key } }, this.size_ = 1, null; var n, r, i = this.root_; do { if (n = i, (r = t.compareTo(i.key)) < 0) i = i.left; else { if (!(r > 0)) { var o = i.value; return i.value = e, o } i = i.right } } while (null !== i); var a = { key: t, left: null, right: null, value: e, parent: n, color: 0, getValue: function () { return this.value }, getKey: function () { return this.key } }; return r < 0 ? n.left = a : n.right = a, this.fixAfterInsertion(a), this.size_++, null } }, { key: "fixAfterInsertion", value: function (t) { var e; for (t.color = 1; null != t && t !== this.root_ && 1 === t.parent.color;)Ye(t) === Ue(Ye(Ye(t))) ? 1 === Ge(e = Xe(Ye(Ye(t)))) ? (ze(Ye(t), 0), ze(e, 0), ze(Ye(Ye(t)), 1), t = Ye(Ye(t))) : (t === Xe(Ye(t)) && (t = Ye(t), this.rotateLeft(t)), ze(Ye(t), 0), ze(Ye(Ye(t)), 1), this.rotateRight(Ye(Ye(t)))) : 1 === Ge(e = Ue(Ye(Ye(t)))) ? (ze(Ye(t), 0), ze(e, 0), ze(Ye(Ye(t)), 1), t = Ye(Ye(t))) : (t === Ue(Ye(t)) && (t = Ye(t), this.rotateRight(t)), ze(Ye(t), 0), ze(Ye(Ye(t)), 1), this.rotateLeft(Ye(Ye(t)))); this.root_.color = 0 } }, { key: "values", value: function () { var t = new vt, e = this.getFirstEntry(); if (null !== e) for (t.add(e.value); null !== (e = o.successor(e));)t.add(e.value); return t } }, { key: "entrySet", value: function () { var t = new Q, e = this.getFirstEntry(); if (null !== e) for (t.add(e); null !== (e = o.successor(e));)t.add(e); return t } }, { key: "rotateLeft", value: function (t) { if (null != t) { var e = t.right; t.right = e.left, null != e.left && (e.left.parent = t), e.parent = t.parent, null == t.parent ? this.root_ = e : t.parent.left === t ? t.parent.left = e : t.parent.right = e, e.left = t, t.parent = e } } }, { key: "rotateRight", value: function (t) { if (null != t) { var e = t.left; t.left = e.right, null != e.right && (e.right.parent = t), e.parent = t.parent, null == t.parent ? this.root_ = e : t.parent.right === t ? t.parent.right = e : t.parent.left = e, e.right = t, t.parent = e } } }, { key: "getFirstEntry", value: function () { var t = this.root_; if (null != t) for (; null != t.left;)t = t.left; return t } }, { key: "size", value: function () { return this.size_ } }, { key: "containsKey", value: function (t) { for (var e = this.root_; null !== e;) { var n = t.compareTo(e.key); if (n < 0) e = e.left; else { if (!(n > 0)) return !0; e = e.right } } return !1 } }], [{ key: "successor", value: function (t) { var e; if (null === t) return null; if (null !== t.right) { for (e = t.right; null !== e.left;)e = e.left; return e } e = t.parent; for (var n = t; null !== e && n === e.right;)n = e, e = e.parent; return e } }]), o }(Ve), He = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "find", value: function (t) { return this.nodeMap.get(t) } }, { key: "addNode", value: function () { if (arguments[0] instanceof Y) { var t = arguments[0], e = this.nodeMap.get(t); return null === e && (e = this.nodeFact.createNode(t), this.nodeMap.put(t, e)), e } if (arguments[0] instanceof qe) { var n = arguments[0], r = this.nodeMap.get(n.getCoordinate()); return null === r ? (this.nodeMap.put(n.getCoordinate(), n), n) : (r.mergeLabel(n), r) } } }, { key: "print", value: function (t) { for (var e = this.iterator(); e.hasNext();)e.next().print(t) } }, { key: "iterator", value: function () { return this.nodeMap.values().iterator() } }, { key: "values", value: function () { return this.nodeMap.values() } }, { key: "getBoundaryNodes", value: function (t) { for (var e = new vt, n = this.iterator(); n.hasNext();) { var r = n.next(); r.getLabel().getLocation(t) === W.BOUNDARY && e.add(r) } return e } }, { key: "add", value: function (t) { var e = t.getCoordinate(); this.addNode(e).add(t) } }], [{ key: "constructor_", value: function () { this.nodeMap = new We, this.nodeFact = null; var t = arguments[0]; this.nodeFact = t } }]), e }(), Ze = function () { function e() { t(this, e) } return r(e, null, [{ key: "isNorthern", value: function (t) { return t === e.NE || t === e.NW } }, { key: "isOpposite", value: function (t, e) { return t !== e && 2 == (t - e + 4) % 4 } }, { key: "commonHalfPlane", value: function (t, e) { if (t === e) return t; if (2 == (t - e + 4) % 4) return -1; var n = t < e ? t : e; return 0 === n && 3 === (t > e ? t : e) ? 3 : n } }, { key: "isInHalfPlane", value: function (t, n) { return n === e.SE ? t === e.SE || t === e.SW : t === n || t === n + 1 } }, { key: "quadrant", value: function () { if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) { var t = arguments[0], n = arguments[1]; if (0 === t && 0 === n) throw new b("Cannot compute the quadrant for point ( " + t + ", " + n + " )"); return t >= 0 ? n >= 0 ? e.NE : e.SE : n >= 0 ? e.NW : e.SW } if (arguments[0] instanceof Y && arguments[1] instanceof Y) { var r = arguments[0], i = arguments[1]; if (i.x === r.x && i.y === r.y) throw new b("Cannot compute the quadrant for two identical points " + r); return i.x >= r.x ? i.y >= r.y ? e.NE : e.SE : i.y >= r.y ? e.NW : e.SW } } }]), e }(); Ze.NE = 0, Ze.NW = 1, Ze.SW = 2, Ze.SE = 3; var Je = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "compareDirection", value: function (t) { return this._dx === t._dx && this._dy === t._dy ? 0 : this._quadrant > t._quadrant ? 1 : this._quadrant < t._quadrant ? -1 : ft.index(t._p0, t._p1, this._p1) } }, { key: "getDy", value: function () { return this._dy } }, { key: "getCoordinate", value: function () { return this._p0 } }, { key: "setNode", value: function (t) { this._node = t } }, { key: "print", value: function (t) { var e = Math.atan2(this._dy, this._dx), n = this.getClass().getName(), r = n.lastIndexOf("."), i = n.substring(r + 1); t.print("  " + i + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + e + "   " + this._label) } }, { key: "compareTo", value: function (t) { var e = t; return this.compareDirection(e) } }, { key: "getDirectedCoordinate", value: function () { return this._p1 } }, { key: "getDx", value: function () { return this._dx } }, { key: "getLabel", value: function () { return this._label } }, { key: "getEdge", value: function () { return this._edge } }, { key: "getQuadrant", value: function () { return this._quadrant } }, { key: "getNode", value: function () { return this._node } }, { key: "toString", value: function () { var t = Math.atan2(this._dy, this._dx), e = this.getClass().getName(), n = e.lastIndexOf("."); return "  " + e.substring(n + 1) + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + t + "   " + this._label } }, { key: "computeLabel", value: function (t) { } }, { key: "init", value: function (t, e) { this._p0 = t, this._p1 = e, this._dx = e.x - t.x, this._dy = e.y - t.y, this._quadrant = Ze.quadrant(this._dx, this._dy), B.isTrue(!(0 === this._dx && 0 === this._dy), "EdgeEnd with identical endpoints found") } }, { key: "interfaces_", get: function () { return [E] } }], [{ key: "constructor_", value: function () { if (this._edge = null, this._label = null, this._node = null, this._p0 = null, this._p1 = null, this._dx = null, this._dy = null, this._quadrant = null, 1 === arguments.length) { var t = arguments[0]; this._edge = t } else if (3 === arguments.length) { var n = arguments[0], r = arguments[1], i = arguments[2]; e.constructor_.call(this, n, r, i, null) } else if (4 === arguments.length) { var o = arguments[0], a = arguments[1], s = arguments[2], u = arguments[3]; e.constructor_.call(this, o), this.init(a, s), this._label = u } } }]), e }(), $e = function (e) { i(a, e); var n = f(a); function a() { var e; return t(this, a), e = n.call(this), a.constructor_.apply(c(e), arguments), e } return r(a, [{ key: "getNextMin", value: function () { return this._nextMin } }, { key: "getDepth", value: function (t) { return this._depth[t] } }, { key: "setVisited", value: function (t) { this._isVisited = t } }, { key: "computeDirectedLabel", value: function () { this._label = new Ae(this._edge.getLabel()), this._isForward || this._label.flip() } }, { key: "getNext", value: function () { return this._next } }, { key: "setDepth", value: function (t, e) { if (-999 !== this._depth[t] && this._depth[t] !== e) throw new gt("assigned depths do not match", this.getCoordinate()); this._depth[t] = e } }, { key: "isInteriorAreaEdge", value: function () { for (var t = !0, e = 0; e < 2; e++)this._label.isArea(e) && this._label.getLocation(e, tt.LEFT) === W.INTERIOR && this._label.getLocation(e, tt.RIGHT) === W.INTERIOR || (t = !1); return t } }, { key: "setNextMin", value: function (t) { this._nextMin = t } }, { key: "print", value: function (t) { p(o(a.prototype), "print", this).call(this, t), t.print(" " + this._depth[tt.LEFT] + "/" + this._depth[tt.RIGHT]), t.print(" (" + this.getDepthDelta() + ")"), this._isInResult && t.print(" inResult") } }, { key: "setMinEdgeRing", value: function (t) { this._minEdgeRing = t } }, { key: "isLineEdge", value: function () { var t = this._label.isLine(0) || this._label.isLine(1), e = !this._label.isArea(0) || this._label.allPositionsEqual(0, W.EXTERIOR), n = !this._label.isArea(1) || this._label.allPositionsEqual(1, W.EXTERIOR); return t && e && n } }, { key: "setEdgeRing", value: function (t) { this._edgeRing = t } }, { key: "getMinEdgeRing", value: function () { return this._minEdgeRing } }, { key: "getDepthDelta", value: function () { var t = this._edge.getDepthDelta(); return this._isForward || (t = -t), t } }, { key: "setInResult", value: function (t) { this._isInResult = t } }, { key: "getSym", value: function () { return this._sym } }, { key: "isForward", value: function () { return this._isForward } }, { key: "getEdge", value: function () { return this._edge } }, { key: "printEdge", value: function (t) { this.print(t), t.print(" "), this._isForward ? this._edge.print(t) : this._edge.printReverse(t) } }, { key: "setSym", value: function (t) { this._sym = t } }, { key: "setVisitedEdge", value: function (t) { this.setVisited(t), this._sym.setVisited(t) } }, { key: "setEdgeDepths", value: function (t, e) { var n = this.getEdge().getDepthDelta(); this._isForward || (n = -n); var r = 1; t === tt.LEFT && (r = -1); var i = tt.opposite(t), o = e + n * r; this.setDepth(t, e), this.setDepth(i, o) } }, { key: "getEdgeRing", value: function () { return this._edgeRing } }, { key: "isInResult", value: function () { return this._isInResult } }, { key: "setNext", value: function (t) { this._next = t } }, { key: "isVisited", value: function () { return this._isVisited } }], [{ key: "constructor_", value: function () { this._isForward = null, this._isInResult = !1, this._isVisited = !1, this._sym = null, this._next = null, this._nextMin = null, this._edgeRing = null, this._minEdgeRing = null, this._depth = [0, -999, -999]; var t = arguments[0], e = arguments[1]; if (Je.constructor_.call(this, t), this._isForward = e, e) this.init(t.getCoordinate(0), t.getCoordinate(1)); else { var n = t.getNumPoints() - 1; this.init(t.getCoordinate(n), t.getCoordinate(n - 1)) } this.computeDirectedLabel() } }, { key: "depthFactor", value: function (t, e) { return t === W.EXTERIOR && e === W.INTERIOR ? 1 : t === W.INTERIOR && e === W.EXTERIOR ? -1 : 0 } }]), a }(Je), Qe = function () { function e() { t(this, e) } return r(e, [{ key: "createNode", value: function (t) { return new qe(t, null) } }]), e }(), Ke = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "printEdges", value: function (t) { t.println("Edges:"); for (var e = 0; e < this._edges.size(); e++) { t.println("edge " + e + ":"); var n = this._edges.get(e); n.print(t), n.eiList.print(t) } } }, { key: "find", value: function (t) { return this._nodes.find(t) } }, { key: "addNode", value: function () { if (arguments[0] instanceof qe) { var t = arguments[0]; return this._nodes.addNode(t) } if (arguments[0] instanceof Y) { var e = arguments[0]; return this._nodes.addNode(e) } } }, { key: "getNodeIterator", value: function () { return this._nodes.iterator() } }, { key: "linkResultDirectedEdges", value: function () { for (var t = this._nodes.iterator(); t.hasNext();)t.next().getEdges().linkResultDirectedEdges() } }, { key: "debugPrintln", value: function (t) { bt.out.println(t) } }, { key: "isBoundaryNode", value: function (t, e) { var n = this._nodes.find(e); if (null === n) return !1; var r = n.getLabel(); return null !== r && r.getLocation(t) === W.BOUNDARY } }, { key: "linkAllDirectedEdges", value: function () { for (var t = this._nodes.iterator(); t.hasNext();)t.next().getEdges().linkAllDirectedEdges() } }, { key: "matchInSameDirection", value: function (t, e, n, r) { return !!t.equals(n) && ft.index(t, e, r) === ft.COLLINEAR && Ze.quadrant(t, e) === Ze.quadrant(n, r) } }, { key: "getEdgeEnds", value: function () { return this._edgeEndList } }, { key: "debugPrint", value: function (t) { bt.out.print(t) } }, { key: "getEdgeIterator", value: function () { return this._edges.iterator() } }, { key: "findEdgeInSameDirection", value: function (t, e) { for (var n = 0; n < this._edges.size(); n++) { var r = this._edges.get(n), i = r.getCoordinates(); if (this.matchInSameDirection(t, e, i[0], i[1])) return r; if (this.matchInSameDirection(t, e, i[i.length - 1], i[i.length - 2])) return r } return null } }, { key: "insertEdge", value: function (t) { this._edges.add(t) } }, { key: "findEdgeEnd", value: function (t) { for (var e = this.getEdgeEnds().iterator(); e.hasNext();) { var n = e.next(); if (n.getEdge() === t) return n } return null } }, { key: "addEdges", value: function (t) { for (var e = t.iterator(); e.hasNext();) { var n = e.next(); this._edges.add(n); var r = new $e(n, !0), i = new $e(n, !1); r.setSym(i), i.setSym(r), this.add(r), this.add(i) } } }, { key: "add", value: function (t) { this._nodes.add(t), this._edgeEndList.add(t) } }, { key: "getNodes", value: function () { return this._nodes.values() } }, { key: "findEdge", value: function (t, e) { for (var n = 0; n < this._edges.size(); n++) { var r = this._edges.get(n), i = r.getCoordinates(); if (t.equals(i[0]) && e.equals(i[1])) return r } return null } }], [{ key: "constructor_", value: function () { if (this._edges = new vt, this._nodes = null, this._edgeEndList = new vt, 0 === arguments.length) this._nodes = new He(new Qe); else if (1 === arguments.length) { var t = arguments[0]; this._nodes = new He(t) } } }, { key: "linkResultDirectedEdges", value: function (t) { for (var e = t.iterator(); e.hasNext();)e.next().getEdges().linkResultDirectedEdges() } }]), e }(), tn = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "sortShellsAndHoles", value: function (t, e, n) { for (var r = t.iterator(); r.hasNext();) { var i = r.next(); i.isHole() ? n.add(i) : e.add(i) } } }, { key: "computePolygons", value: function (t) { for (var e = new vt, n = t.iterator(); n.hasNext();) { var r = n.next().toPolygon(this._geometryFactory); e.add(r) } return e } }, { key: "placeFreeHoles", value: function (t, n) { for (var r = n.iterator(); r.hasNext();) { var i = r.next(); if (null === i.getShell()) { var o = e.findEdgeRingContaining(i, t); if (null === o) throw new gt("unable to assign hole to a shell", i.getCoordinate(0)); i.setShell(o) } } } }, { key: "buildMinimalEdgeRings", value: function (t, e, n) { for (var r = new vt, i = t.iterator(); i.hasNext();) { var o = i.next(); if (o.getMaxNodeDegree() > 2) { o.linkDirectedEdgesForMinimalEdgeRings(); var a = o.buildMinimalRings(), s = this.findShell(a); null !== s ? (this.placePolygonHoles(s, a), e.add(s)) : n.addAll(a) } else r.add(o) } return r } }, { key: "buildMaximalEdgeRings", value: function (t) { for (var e = new vt, n = t.iterator(); n.hasNext();) { var r = n.next(); if (r.isInResult() && r.getLabel().isArea() && null === r.getEdgeRing()) { var i = new Fe(r, this._geometryFactory); e.add(i), i.setInResult() } } return e } }, { key: "placePolygonHoles", value: function (t, e) { for (var n = e.iterator(); n.hasNext();) { var r = n.next(); r.isHole() && r.setShell(t) } } }, { key: "getPolygons", value: function () { return this.computePolygons(this._shellList) } }, { key: "findShell", value: function (t) { for (var e = 0, n = null, r = t.iterator(); r.hasNext();) { var i = r.next(); i.isHole() || (n = i, e++) } return B.isTrue(e <= 1, "found two shells in MinimalEdgeRing list"), n } }, { key: "add", value: function () { if (1 === arguments.length) { var t = arguments[0]; this.add(t.getEdgeEnds(), t.getNodes()) } else if (2 === arguments.length) { var e = arguments[0], n = arguments[1]; Ke.linkResultDirectedEdges(n); var r = this.buildMaximalEdgeRings(e), i = new vt, o = this.buildMinimalEdgeRings(r, this._shellList, i); this.sortShellsAndHoles(o, this._shellList, i), this.placeFreeHoles(this._shellList, i) } } }], [{ key: "constructor_", value: function () { this._geometryFactory = null, this._shellList = new vt; var t = arguments[0]; this._geometryFactory = t } }, { key: "findEdgeRingContaining", value: function (t, e) { for (var n = t.getLinearRing(), r = n.getEnvelopeInternal(), i = n.getCoordinateN(0), o = null, a = null, s = e.iterator(); s.hasNext();) { var u = s.next(), l = u.getLinearRing(), c = l.getEnvelopeInternal(); if (!c.equals(r) && c.contains(r)) { i = Zt.ptNotInList(n.getCoordinates(), l.getCoordinates()); var h = !1; Ce.isInRing(i, l.getCoordinates()) && (h = !0), h && (null === o || a.contains(c)) && (a = (o = u).getLinearRing().getEnvelopeInternal()) } } return o } }]), e }(), en = function () { function e() { t(this, e) } return r(e, [{ key: "getBounds", value: function () { } }]), e }(), nn = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "getItem", value: function () { return this._item } }, { key: "getBounds", value: function () { return this._bounds } }, { key: "interfaces_", get: function () { return [en, k] } }], [{ key: "constructor_", value: function () { this._bounds = null, this._item = null; var t = arguments[0], e = arguments[1]; this._bounds = t, this._item = e } }]), e }(), rn = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "poll", value: function () { if (this.isEmpty()) return null; var t = this._items.get(1); return this._items.set(1, this._items.get(this._size)), this._size -= 1, this.reorder(1), t } }, { key: "size", value: function () { return this._size } }, { key: "reorder", value: function (t) { for (var e = null, n = this._items.get(t); 2 * t <= this._size && ((e = 2 * t) !== this._size && this._items.get(e + 1).compareTo(this._items.get(e)) < 0 && e++, this._items.get(e).compareTo(n) < 0); t = e)this._items.set(t, this._items.get(e)); this._items.set(t, n) } }, { key: "clear", value: function () { this._size = 0, this._items.clear() } }, { key: "peek", value: function () { return this.isEmpty() ? null : this._items.get(1) } }, { key: "isEmpty", value: function () { return 0 === this._size } }, { key: "add", value: function (t) { this._items.add(null), this._size += 1; var e = this._size; for (this._items.set(0, t); t.compareTo(this._items.get(Math.trunc(e / 2))) < 0; e /= 2)this._items.set(e, this._items.get(Math.trunc(e / 2))); this._items.set(e, t) } }], [{ key: "constructor_", value: function () { this._size = null, this._items = null, this._size = 0, this._items = new vt, this._items.add(null) } }]), e }(), on = function () { function e() { t(this, e) } return r(e, [{ key: "insert", value: function (t, e) { } }, { key: "remove", value: function (t, e) { } }, { key: "query", value: function () { } }]), e }(), an = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "getLevel", value: function () { return this._level } }, { key: "size", value: function () { return this._childBoundables.size() } }, { key: "getChildBoundables", value: function () { return this._childBoundables } }, { key: "addChildBoundable", value: function (t) { B.isTrue(null === this._bounds), this._childBoundables.add(t) } }, { key: "isEmpty", value: function () { return this._childBoundables.isEmpty() } }, { key: "getBounds", value: function () { return null === this._bounds && (this._bounds = this.computeBounds()), this._bounds } }, { key: "interfaces_", get: function () { return [en, k] } }], [{ key: "constructor_", value: function () { if (this._childBoundables = new vt, this._bounds = null, this._level = null, 0 === arguments.length); else if (1 === arguments.length) { var t = arguments[0]; this._level = t } } }]), e }(), sn = { reverseOrder: function () { return { compare: function (t, e) { return e.compareTo(t) } } }, min: function (t) { return sn.sort(t), t.get(0) }, sort: function (t, e) { var n = t.toArray(); e ? At.sort(n, e) : At.sort(n); for (var r = t.iterator(), i = 0, o = n.length; i < o; i++)r.next(), r.set(n[i]) }, singletonList: function (t) { var e = new vt; return e.add(t), e } }, un = function () { function e() { t(this, e) } return r(e, null, [{ key: "maxDistance", value: function (t, n, r, i, o, a, s, u) { var l = e.distance(t, n, o, a); return l = Math.max(l, e.distance(t, n, s, u)), l = Math.max(l, e.distance(r, i, o, a)), Math.max(l, e.distance(r, i, s, u)) } }, { key: "distance", value: function (t, e, n, r) { var i = n - t, o = r - e; return Math.sqrt(i * i + o * o) } }, { key: "maximumDistance", value: function (t, n) { var r = Math.min(t.getMinX(), n.getMinX()), i = Math.min(t.getMinY(), n.getMinY()), o = Math.max(t.getMaxX(), n.getMaxX()), a = Math.max(t.getMaxY(), n.getMaxY()); return e.distance(r, i, o, a) } }, { key: "minMaxDistance", value: function (t, n) { var r = t.getMinX(), i = t.getMinY(), o = t.getMaxX(), a = t.getMaxY(), s = n.getMinX(), u = n.getMinY(), l = n.getMaxX(), c = n.getMaxY(), h = e.maxDistance(r, i, r, a, s, u, s, c); return h = Math.min(h, e.maxDistance(r, i, r, a, s, u, l, u)), h = Math.min(h, e.maxDistance(r, i, r, a, l, c, s, c)), h = Math.min(h, e.maxDistance(r, i, r, a, l, c, l, u)), h = Math.min(h, e.maxDistance(r, i, o, i, s, u, s, c)), h = Math.min(h, e.maxDistance(r, i, o, i, s, u, l, u)), h = Math.min(h, e.maxDistance(r, i, o, i, l, c, s, c)), h = Math.min(h, e.maxDistance(r, i, o, i, l, c, l, u)), h = Math.min(h, e.maxDistance(o, a, r, a, s, u, s, c)), h = Math.min(h, e.maxDistance(o, a, r, a, s, u, l, u)), h = Math.min(h, e.maxDistance(o, a, r, a, l, c, s, c)), h = Math.min(h, e.maxDistance(o, a, r, a, l, c, l, u)), h = Math.min(h, e.maxDistance(o, a, o, i, s, u, s, c)), h = Math.min(h, e.maxDistance(o, a, o, i, s, u, l, u)), h = Math.min(h, e.maxDistance(o, a, o, i, l, c, s, c)), Math.min(h, e.maxDistance(o, a, o, i, l, c, l, u)) } }]), e }(), ln = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "maximumDistance", value: function () { return un.maximumDistance(this._boundable1.getBounds(), this._boundable2.getBounds()) } }, { key: "expandToQueue", value: function (t, n) { var r = e.isComposite(this._boundable1), i = e.isComposite(this._boundable2); if (r && i) return e.area(this._boundable1) > e.area(this._boundable2) ? (this.expand(this._boundable1, this._boundable2, !1, t, n), null) : (this.expand(this._boundable2, this._boundable1, !0, t, n), null); if (r) return this.expand(this._boundable1, this._boundable2, !1, t, n), null; if (i) return this.expand(this._boundable2, this._boundable1, !0, t, n), null; throw new b("neither boundable is composite") } }, { key: "isLeaves", value: function () { return !(e.isComposite(this._boundable1) || e.isComposite(this._boundable2)) } }, { key: "compareTo", value: function (t) { var e = t; return this._distance < e._distance ? -1 : this._distance > e._distance ? 1 : 0 } }, { key: "expand", value: function (t, n, r, i, o) { for (var a = t.getChildBoundables().iterator(); a.hasNext();) { var s = a.next(), u = null; (u = r ? new e(n, s, this._itemDistance) : new e(s, n, this._itemDistance)).getDistance() < o && i.add(u) } } }, { key: "getBoundable", value: function (t) { return 0 === t ? this._boundable1 : this._boundable2 } }, { key: "getDistance", value: function () { return this._distance } }, { key: "distance", value: function () { return this.isLeaves() ? this._itemDistance.distance(this._boundable1, this._boundable2) : this._boundable1.getBounds().distance(this._boundable2.getBounds()) } }, { key: "interfaces_", get: function () { return [E] } }], [{ key: "constructor_", value: function () { this._boundable1 = null, this._boundable2 = null, this._distance = null, this._itemDistance = null; var t = arguments[0], e = arguments[1], n = arguments[2]; this._boundable1 = t, this._boundable2 = e, this._itemDistance = n, this._distance = this.distance() } }, { key: "area", value: function (t) { return t.getBounds().getArea() } }, { key: "isComposite", value: function (t) { return t instanceof an } }]), e }(), cn = function () { function e() { t(this, e) } return r(e, [{ key: "visitItem", value: function (t) { } }]), e }(), hn = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "queryInternal", value: function () { if (ot(arguments[2], cn) && arguments[0] instanceof Object && arguments[1] instanceof an) for (var t = arguments[0], e = arguments[2], n = arguments[1].getChildBoundables(), r = 0; r < n.size(); r++) { var i = n.get(r); this.getIntersectsOp().intersects(i.getBounds(), t) && (i instanceof an ? this.queryInternal(t, i, e) : i instanceof nn ? e.visitItem(i.getItem()) : B.shouldNeverReachHere()) } else if (ot(arguments[2], rt) && arguments[0] instanceof Object && arguments[1] instanceof an) for (var o = arguments[0], a = arguments[2], s = arguments[1].getChildBoundables(), u = 0; u < s.size(); u++) { var l = s.get(u); this.getIntersectsOp().intersects(l.getBounds(), o) && (l instanceof an ? this.queryInternal(o, l, a) : l instanceof nn ? a.add(l.getItem()) : B.shouldNeverReachHere()) } } }, { key: "getNodeCapacity", value: function () { return this._nodeCapacity } }, { key: "lastNode", value: function (t) { return t.get(t.size() - 1) } }, { key: "size", value: function () { if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.size(this._root)); if (1 === arguments.length) { for (var t = 0, e = arguments[0].getChildBoundables().iterator(); e.hasNext();) { var n = e.next(); n instanceof an ? t += this.size(n) : n instanceof nn && (t += 1) } return t } } }, { key: "removeItem", value: function (t, e) { for (var n = null, r = t.getChildBoundables().iterator(); r.hasNext();) { var i = r.next(); i instanceof nn && i.getItem() === e && (n = i) } return null !== n && (t.getChildBoundables().remove(n), !0) } }, { key: "itemsTree", value: function () { if (0 === arguments.length) { this.build(); var t = this.itemsTree(this._root); return null === t ? new vt : t } if (1 === arguments.length) { for (var e = arguments[0], n = new vt, r = e.getChildBoundables().iterator(); r.hasNext();) { var i = r.next(); if (i instanceof an) { var o = this.itemsTree(i); null !== o && n.add(o) } else i instanceof nn ? n.add(i.getItem()) : B.shouldNeverReachHere() } return n.size() <= 0 ? null : n } } }, { key: "insert", value: function (t, e) { B.isTrue(!this._built, "Cannot insert items into an STR packed R-tree after it has been built."), this._itemBoundables.add(new nn(t, e)) } }, { key: "boundablesAtLevel", value: function () { if (1 === arguments.length) { var t = arguments[0], e = new vt; return this.boundablesAtLevel(t, this._root, e), e } if (3 === arguments.length) { var n = arguments[0], r = arguments[1], i = arguments[2]; if (B.isTrue(n > -2), r.getLevel() === n) return i.add(r), null; for (var o = r.getChildBoundables().iterator(); o.hasNext();) { var a = o.next(); a instanceof an ? this.boundablesAtLevel(n, a, i) : (B.isTrue(a instanceof nn), -1 === n && i.add(a)) } return null } } }, { key: "query", value: function () { if (1 === arguments.length) { var t = arguments[0]; this.build(); var e = new vt; return this.isEmpty() || this.getIntersectsOp().intersects(this._root.getBounds(), t) && this.queryInternal(t, this._root, e), e } if (2 === arguments.length) { var n = arguments[0], r = arguments[1]; if (this.build(), this.isEmpty()) return null; this.getIntersectsOp().intersects(this._root.getBounds(), n) && this.queryInternal(n, this._root, r) } } }, { key: "build", value: function () { if (this._built) return null; this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1), this._itemBoundables = null, this._built = !0 } }, { key: "getRoot", value: function () { return this.build(), this._root } }, { key: "remove", value: function () { if (2 === arguments.length) { var t = arguments[0], e = arguments[1]; return this.build(), !!this.getIntersectsOp().intersects(this._root.getBounds(), t) && this.remove(t, this._root, e) } if (3 === arguments.length) { var n = arguments[0], r = arguments[1], i = arguments[2], o = this.removeItem(r, i); if (o) return !0; for (var a = null, s = r.getChildBoundables().iterator(); s.hasNext();) { var u = s.next(); if (this.getIntersectsOp().intersects(u.getBounds(), n) && u instanceof an && (o = this.remove(n, u, i))) { a = u; break } } return null !== a && a.getChildBoundables().isEmpty() && r.getChildBoundables().remove(a), o } } }, { key: "createHigherLevels", value: function (t, e) { B.isTrue(!t.isEmpty()); var n = this.createParentBoundables(t, e + 1); return 1 === n.size() ? n.get(0) : this.createHigherLevels(n, e + 1) } }, { key: "depth", value: function () { if (0 === arguments.length) return this.isEmpty() ? 0 : (this.build(), this.depth(this._root)); if (1 === arguments.length) { for (var t = 0, e = arguments[0].getChildBoundables().iterator(); e.hasNext();) { var n = e.next(); if (n instanceof an) { var r = this.depth(n); r > t && (t = r) } } return t + 1 } } }, { key: "createParentBoundables", value: function (t, e) { B.isTrue(!t.isEmpty()); var n = new vt; n.add(this.createNode(e)); var r = new vt(t); sn.sort(r, this.getComparator()); for (var i = r.iterator(); i.hasNext();) { var o = i.next(); this.lastNode(n).getChildBoundables().size() === this.getNodeCapacity() && n.add(this.createNode(e)), this.lastNode(n).addChildBoundable(o) } return n } }, { key: "isEmpty", value: function () { return this._built ? this._root.isEmpty() : this._itemBoundables.isEmpty() } }, { key: "interfaces_", get: function () { return [k] } }], [{ key: "constructor_", value: function () { if (this._root = null, this._built = !1, this._itemBoundables = new vt, this._nodeCapacity = null, 0 === arguments.length) e.constructor_.call(this, e.DEFAULT_NODE_CAPACITY); else if (1 === arguments.length) { var t = arguments[0]; B.isTrue(t > 1, "Node capacity must be greater than 1"), this._nodeCapacity = t } } }, { key: "compareDoubles", value: function (t, e) { return t > e ? 1 : t < e ? -1 : 0 } }]), e }(); hn.IntersectsOp = function () { }, hn.DEFAULT_NODE_CAPACITY = 10; var fn = function () { function e() { t(this, e) } return r(e, [{ key: "distance", value: function (t, e) { } }]), e }(), pn = function (e) { i(a, e); var n = f(a); function a() { var e; return t(this, a), e = n.call(this), a.constructor_.apply(c(e), arguments), e } return r(a, [{ key: "createParentBoundablesFromVerticalSlices", value: function (t, e) { B.isTrue(t.length > 0); for (var n = new vt, r = 0; r < t.length; r++)n.addAll(this.createParentBoundablesFromVerticalSlice(t[r], e)); return n } }, { key: "nearestNeighbourK", value: function () { if (2 === arguments.length) { var t = arguments[0], e = arguments[1]; return this.nearestNeighbourK(t, A.POSITIVE_INFINITY, e) } if (3 === arguments.length) { var n = arguments[0], r = arguments[2], i = arguments[1], o = new rn; o.add(n); for (var s = new rn; !o.isEmpty() && i >= 0;) { var u = o.poll(), l = u.getDistance(); if (l >= i) break; u.isLeaves() ? s.size() < r ? s.add(u) : (s.peek().getDistance() > l && (s.poll(), s.add(u)), i = s.peek().getDistance()) : u.expandToQueue(o, i) } return a.getItems(s) } } }, { key: "createNode", value: function (t) { return new gn(t) } }, { key: "size", value: function () { return 0 === arguments.length ? p(o(a.prototype), "size", this).call(this) : p(o(a.prototype), "size", this).apply(this, arguments) } }, { key: "insert", value: function () { if (!(2 === arguments.length && arguments[1] instanceof Object && arguments[0] instanceof U)) return p(o(a.prototype), "insert", this).apply(this, arguments); var t = arguments[0], e = arguments[1]; if (t.isNull()) return null; p(o(a.prototype), "insert", this).call(this, t, e) } }, { key: "getIntersectsOp", value: function () { return a.intersectsOp } }, { key: "verticalSlices", value: function (t, e) { for (var n = Math.trunc(Math.ceil(t.size() / e)), r = new Array(e).fill(null), i = t.iterator(), o = 0; o < e; o++) { r[o] = new vt; for (var a = 0; i.hasNext() && a < n;) { var s = i.next(); r[o].add(s), a++ } } return r } }, { key: "query", value: function () { if (1 === arguments.length) { var t = arguments[0]; return p(o(a.prototype), "query", this).call(this, t) } if (2 === arguments.length) { var e = arguments[0], n = arguments[1]; p(o(a.prototype), "query", this).call(this, e, n) } } }, { key: "getComparator", value: function () { return a.yComparator } }, { key: "createParentBoundablesFromVerticalSlice", value: function (t, e) { return p(o(a.prototype), "createParentBoundables", this).call(this, t, e) } }, { key: "remove", value: function () { if (2 === arguments.length && arguments[1] instanceof Object && arguments[0] instanceof U) { var t = arguments[0], e = arguments[1]; return p(o(a.prototype), "remove", this).call(this, t, e) } return p(o(a.prototype), "remove", this).apply(this, arguments) } }, { key: "depth", value: function () { return 0 === arguments.length ? p(o(a.prototype), "depth", this).call(this) : p(o(a.prototype), "depth", this).apply(this, arguments) } }, { key: "createParentBoundables", value: function (t, e) { B.isTrue(!t.isEmpty()); var n = Math.trunc(Math.ceil(t.size() / this.getNodeCapacity())), r = new vt(t); sn.sort(r, a.xComparator); var i = this.verticalSlices(r, Math.trunc(Math.ceil(Math.sqrt(n)))); return this.createParentBoundablesFromVerticalSlices(i, e) } }, { key: "nearestNeighbour", value: function () { if (1 === arguments.length) { if (ot(arguments[0], fn)) { var t = arguments[0]; if (this.isEmpty()) return null; var e = new ln(this.getRoot(), this.getRoot(), t); return this.nearestNeighbour(e) } if (arguments[0] instanceof ln) { var n = arguments[0], r = A.POSITIVE_INFINITY, i = null, o = new rn; for (o.add(n); !o.isEmpty() && r > 0;) { var a = o.poll(), s = a.getDistance(); if (s >= r) break; a.isLeaves() ? (r = s, i = a) : a.expandToQueue(o, r) } return null === i ? null : [i.getBoundable(0).getItem(), i.getBoundable(1).getItem()] } } else { if (2 === arguments.length) { var u = arguments[0], l = arguments[1]; if (this.isEmpty() || u.isEmpty()) return null; var c = new ln(this.getRoot(), u.getRoot(), l); return this.nearestNeighbour(c) } if (3 === arguments.length) { var h = arguments[2], f = new nn(arguments[0], arguments[1]), p = new ln(this.getRoot(), f, h); return this.nearestNeighbour(p)[0] } if (4 === arguments.length) { var g = arguments[2], y = arguments[3], v = new nn(arguments[0], arguments[1]), d = new ln(this.getRoot(), v, g); return this.nearestNeighbourK(d, y) } } } }, { key: "isWithinDistance", value: function () { if (2 === arguments.length) { var t = arguments[0], e = arguments[1], n = A.POSITIVE_INFINITY, r = new rn; for (r.add(t); !r.isEmpty();) { var i = r.poll(), o = i.getDistance(); if (o > e) return !1; if (i.maximumDistance() <= e) return !0; if (i.isLeaves()) { if ((n = o) <= e) return !0 } else i.expandToQueue(r, n) } return !1 } if (3 === arguments.length) { var a = arguments[0], s = arguments[1], u = arguments[2], l = new ln(this.getRoot(), a.getRoot(), s); return this.isWithinDistance(l, u) } } }, { key: "interfaces_", get: function () { return [on, k] } }], [{ key: "constructor_", value: function () { if (0 === arguments.length) a.constructor_.call(this, a.DEFAULT_NODE_CAPACITY); else if (1 === arguments.length) { var t = arguments[0]; hn.constructor_.call(this, t) } } }, { key: "centreX", value: function (t) { return a.avg(t.getMinX(), t.getMaxX()) } }, { key: "avg", value: function (t, e) { return (t + e) / 2 } }, { key: "getItems", value: function (t) { for (var e = new Array(t.size()).fill(null), n = 0; !t.isEmpty();) { var r = t.poll(); e[n] = r.getBoundable(0).getItem(), n++ } return e } }, { key: "centreY", value: function (t) { return a.avg(t.getMinY(), t.getMaxY()) } }]), a }(hn), gn = function (e) { i(o, e); var n = f(o); function o() { var e; return t(this, o), e = n.call(this), o.constructor_.apply(c(e), arguments), e } return r(o, [{ key: "computeBounds", value: function () { for (var t = null, e = this.getChildBoundables().iterator(); e.hasNext();) { var n = e.next(); null === t ? t = new U(n.getBounds()) : t.expandToInclude(n.getBounds()) } return t } }], [{ key: "constructor_", value: function () { var t = arguments[0]; an.constructor_.call(this, t) } }]), o }(an); pn.STRtreeNode = gn, pn.xComparator = new (function () { function e() { t(this, e) } return r(e, [{ key: "interfaces_", get: function () { return [D] } }, { key: "compare", value: function (t, e) { return hn.compareDoubles(pn.centreX(t.getBounds()), pn.centreX(e.getBounds())) } }]), e }()), pn.yComparator = new (function () { function e() { t(this, e) } return r(e, [{ key: "interfaces_", get: function () { return [D] } }, { key: "compare", value: function (t, e) { return hn.compareDoubles(pn.centreY(t.getBounds()), pn.centreY(e.getBounds())) } }]), e }()), pn.intersectsOp = new (function () { function e() { t(this, e) } return r(e, [{ key: "interfaces_", get: function () { return [IntersectsOp] } }, { key: "intersects", value: function (t, e) { return t.intersects(e) } }]), e }()), pn.DEFAULT_NODE_CAPACITY = 10; var yn = function () { function e() { t(this, e) } return r(e, null, [{ key: "relativeSign", value: function (t, e) { return t < e ? -1 : t > e ? 1 : 0 } }, { key: "compare", value: function (t, n, r) { if (n.equals2D(r)) return 0; var i = e.relativeSign(n.x, r.x), o = e.relativeSign(n.y, r.y); switch (t) { case 0: return e.compareValue(i, o); case 1: return e.compareValue(o, i); case 2: return e.compareValue(o, -i); case 3: return e.compareValue(-i, o); case 4: return e.compareValue(-i, -o); case 5: return e.compareValue(-o, -i); case 6: return e.compareValue(-o, i); case 7: return e.compareValue(i, -o) }return B.shouldNeverReachHere("invalid octant value"), 0 } }, { key: "compareValue", value: function (t, e) { return t < 0 ? -1 : t > 0 ? 1 : e < 0 ? -1 : e > 0 ? 1 : 0 } }]), e }(), vn = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "getCoordinate", value: function () { return this.coord } }, { key: "print", value: function (t) { t.print(this.coord), t.print(" seg # = " + this.segmentIndex) } }, { key: "compareTo", value: function (t) { var e = t; return this.segmentIndex < e.segmentIndex ? -1 : this.segmentIndex > e.segmentIndex ? 1 : this.coord.equals2D(e.coord) ? 0 : this._isInterior ? e._isInterior ? yn.compare(this._segmentOctant, this.coord, e.coord) : 1 : -1 } }, { key: "isEndPoint", value: function (t) { return 0 === this.segmentIndex && !this._isInterior || this.segmentIndex === t } }, { key: "toString", value: function () { return this.segmentIndex + ":" + this.coord.toString() } }, { key: "isInterior", value: function () { return this._isInterior } }, { key: "interfaces_", get: function () { return [E] } }], [{ key: "constructor_", value: function () { this._segString = null, this.coord = null, this.segmentIndex = null, this._segmentOctant = null, this._isInterior = null; var t = arguments[0], e = arguments[1], n = arguments[2], r = arguments[3]; this._segString = t, this.coord = new Y(e), this.segmentIndex = n, this._segmentOctant = r, this._isInterior = !e.equals2D(t.getCoordinate(n)) } }]), e }(), dn = function () { function e() { t(this, e) } return r(e, [{ key: "hasNext", value: function () { } }, { key: "next", value: function () { } }, { key: "remove", value: function () { } }]), e }(), mn = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "getSplitCoordinates", value: function () { var t = new Ht; this.addEndpoints(); for (var e = this.iterator(), n = e.next(); e.hasNext();) { var r = e.next(); this.addEdgeCoordinates(n, r, t), n = r } return t.toCoordinateArray() } }, { key: "addCollapsedNodes", value: function () { var t = new vt; this.findCollapsesFromInsertedNodes(t), this.findCollapsesFromExistingVertices(t); for (var e = t.iterator(); e.hasNext();) { var n = e.next().intValue(); this.add(this._edge.getCoordinate(n), n) } } }, { key: "createSplitEdgePts", value: function (t, e) { var n = e.segmentIndex - t.segmentIndex + 2; if (2 === n) return [new Y(t.coord), new Y(e.coord)]; var r = this._edge.getCoordinate(e.segmentIndex), i = e.isInterior() || !e.coord.equals2D(r); i || n--; var o = new Array(n).fill(null), a = 0; o[a++] = new Y(t.coord); for (var s = t.segmentIndex + 1; s <= e.segmentIndex; s++)o[a++] = this._edge.getCoordinate(s); return i && (o[a] = new Y(e.coord)), o } }, { key: "print", value: function (t) { t.println("Intersections:"); for (var e = this.iterator(); e.hasNext();)e.next().print(t) } }, { key: "findCollapsesFromExistingVertices", value: function (t) { for (var e = 0; e < this._edge.size() - 2; e++) { var n = this._edge.getCoordinate(e); this._edge.getCoordinate(e + 1); var r = this._edge.getCoordinate(e + 2); n.equals2D(r) && t.add(st.valueOf(e + 1)) } } }, { key: "addEdgeCoordinates", value: function (t, e, n) { var r = this.createSplitEdgePts(t, e); n.add(r, !1) } }, { key: "iterator", value: function () { return this._nodeMap.values().iterator() } }, { key: "addSplitEdges", value: function (t) { this.addEndpoints(), this.addCollapsedNodes(); for (var e = this.iterator(), n = e.next(); e.hasNext();) { var r = e.next(), i = this.createSplitEdge(n, r); t.add(i), n = r } } }, { key: "findCollapseIndex", value: function (t, e, n) { if (!t.coord.equals2D(e.coord)) return !1; var r = e.segmentIndex - t.segmentIndex; return e.isInterior() || r--, 1 === r && (n[0] = t.segmentIndex + 1, !0) } }, { key: "findCollapsesFromInsertedNodes", value: function (t) { for (var e = new Array(1).fill(null), n = this.iterator(), r = n.next(); n.hasNext();) { var i = n.next(); this.findCollapseIndex(r, i, e) && t.add(st.valueOf(e[0])), r = i } } }, { key: "getEdge", value: function () { return this._edge } }, { key: "addEndpoints", value: function () { var t = this._edge.size() - 1; this.add(this._edge.getCoordinate(0), 0), this.add(this._edge.getCoordinate(t), t) } }, { key: "createSplitEdge", value: function (t, e) { var n = this.createSplitEdgePts(t, e); return new En(n, this._edge.getData()) } }, { key: "add", value: function (t, e) { var n = new vn(this._edge, t, e, this._edge.getSegmentOctant(e)), r = this._nodeMap.get(n); return null !== r ? (B.isTrue(r.coord.equals2D(t), "Found equal nodes with different coordinates"), r) : (this._nodeMap.put(n, n), n) } }, { key: "checkSplitEdgesCorrectness", value: function (t) { var e = this._edge.getCoordinates(), n = t.get(0).getCoordinate(0); if (!n.equals2D(e[0])) throw new j("bad split edge start point at " + n); var r = t.get(t.size() - 1).getCoordinates(), i = r[r.length - 1]; if (!i.equals2D(e[e.length - 1])) throw new j("bad split edge end point at " + i) } }], [{ key: "constructor_", value: function () { this._nodeMap = new We, this._edge = null; var t = arguments[0]; this._edge = t } }]), e }(), _n = function () { function e() { t(this, e) } return r(e, null, [{ key: "octant", value: function () { if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) { var t = arguments[0], n = arguments[1]; if (0 === t && 0 === n) throw new b("Cannot compute the octant for point ( " + t + ", " + n + " )"); var r = Math.abs(t), i = Math.abs(n); return t >= 0 ? n >= 0 ? r >= i ? 0 : 1 : r >= i ? 7 : 6 : n >= 0 ? r >= i ? 3 : 2 : r >= i ? 4 : 5 } if (arguments[0] instanceof Y && arguments[1] instanceof Y) { var o = arguments[0], a = arguments[1], s = a.x - o.x, u = a.y - o.y; if (0 === s && 0 === u) throw new b("Cannot compute the octant for two identical points " + o); return e.octant(s, u) } } }]), e }(), bn = function () { function e() { t(this, e) } return r(e, [{ key: "getCoordinates", value: function () { } }, { key: "size", value: function () { } }, { key: "getCoordinate", value: function (t) { } }, { key: "isClosed", value: function () { } }, { key: "setData", value: function (t) { } }, { key: "getData", value: function () { } }]), e }(), xn = function () { function e() { t(this, e) } return r(e, [{ key: "addIntersection", value: function (t, e) { } }, { key: "interfaces_", get: function () { return [bn] } }]), e }(), En = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "getCoordinates", value: function () { return this._pts } }, { key: "size", value: function () { return this._pts.length } }, { key: "getCoordinate", value: function (t) { return this._pts[t] } }, { key: "isClosed", value: function () { return this._pts[0].equals(this._pts[this._pts.length - 1]) } }, { key: "getSegmentOctant", value: function (t) { return t === this._pts.length - 1 ? -1 : this.safeOctant(this.getCoordinate(t), this.getCoordinate(t + 1)) } }, { key: "setData", value: function (t) { this._data = t } }, { key: "safeOctant", value: function (t, e) { return t.equals2D(e) ? 0 : _n.octant(t, e) } }, { key: "getData", value: function () { return this._data } }, { key: "addIntersection", value: function () { if (2 === arguments.length) { var t = arguments[0], e = arguments[1]; this.addIntersectionNode(t, e) } else if (4 === arguments.length) { var n = arguments[1], r = arguments[3], i = new Y(arguments[0].getIntersection(r)); this.addIntersection(i, n) } } }, { key: "toString", value: function () { return Me.toLineString(new Kt(this._pts)) } }, { key: "getNodeList", value: function () { return this._nodeList } }, { key: "addIntersectionNode", value: function (t, e) { var n = e, r = n + 1; if (r < this._pts.length) { var i = this._pts[r]; t.equals2D(i) && (n = r) } return this._nodeList.add(t, n) } }, { key: "addIntersections", value: function (t, e, n) { for (var r = 0; r < t.getIntersectionNum(); r++)this.addIntersection(t, e, n, r) } }, { key: "interfaces_", get: function () { return [xn] } }], [{ key: "constructor_", value: function () { this._nodeList = new mn(this), this._pts = null, this._data = null; var t = arguments[0], e = arguments[1]; this._pts = t, this._data = e } }, { key: "getNodedSubstrings", value: function () { if (1 === arguments.length) { var t = arguments[0], n = new vt; return e.getNodedSubstrings(t, n), n } if (2 === arguments.length) for (var r = arguments[1], i = arguments[0].iterator(); i.hasNext();)i.next().getNodeList().addSplitEdges(r) } }]), e }(), wn = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "minX", value: function () { return Math.min(this.p0.x, this.p1.x) } }, { key: "orientationIndex", value: function () { if (arguments[0] instanceof e) { var t = arguments[0], n = ft.index(this.p0, this.p1, t.p0), r = ft.index(this.p0, this.p1, t.p1); return n >= 0 && r >= 0 || n <= 0 && r <= 0 ? Math.max(n, r) : 0 } if (arguments[0] instanceof Y) { var i = arguments[0]; return ft.index(this.p0, this.p1, i) } } }, { key: "toGeometry", value: function (t) { return t.createLineString([this.p0, this.p1]) } }, { key: "isVertical", value: function () { return this.p0.x === this.p1.x } }, { key: "equals", value: function (t) { if (!(t instanceof e)) return !1; var n = t; return this.p0.equals(n.p0) && this.p1.equals(n.p1) } }, { key: "intersection", value: function (t) { var e = new Le; return e.computeIntersection(this.p0, this.p1, t.p0, t.p1), e.hasIntersection() ? e.getIntersection(0) : null } }, { key: "project", value: function () { if (arguments[0] instanceof Y) { var t = arguments[0]; if (t.equals(this.p0) || t.equals(this.p1)) return new Y(t); var n = this.projectionFactor(t), r = new Y; return r.x = this.p0.x + n * (this.p1.x - this.p0.x), r.y = this.p0.y + n * (this.p1.y - this.p0.y), r } if (arguments[0] instanceof e) { var i = arguments[0], o = this.projectionFactor(i.p0), a = this.projectionFactor(i.p1); if (o >= 1 && a >= 1) return null; if (o <= 0 && a <= 0) return null; var s = this.project(i.p0); o < 0 && (s = this.p0), o > 1 && (s = this.p1); var u = this.project(i.p1); return a < 0 && (u = this.p0), a > 1 && (u = this.p1), new e(s, u) } } }, { key: "normalize", value: function () { this.p1.compareTo(this.p0) < 0 && this.reverse() } }, { key: "angle", value: function () { return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x) } }, { key: "getCoordinate", value: function (t) { return 0 === t ? this.p0 : this.p1 } }, { key: "distancePerpendicular", value: function (t) { return Et.pointToLinePerpendicular(t, this.p0, this.p1) } }, { key: "minY", value: function () { return Math.min(this.p0.y, this.p1.y) } }, { key: "midPoint", value: function () { return e.midPoint(this.p0, this.p1) } }, { key: "projectionFactor", value: function (t) { if (t.equals(this.p0)) return 0; if (t.equals(this.p1)) return 1; var e = this.p1.x - this.p0.x, n = this.p1.y - this.p0.y, r = e * e + n * n; return r <= 0 ? A.NaN : ((t.x - this.p0.x) * e + (t.y - this.p0.y) * n) / r } }, { key: "closestPoints", value: function (t) { var e = this.intersection(t); if (null !== e) return [e, e]; var n = new Array(2).fill(null), r = A.MAX_VALUE, i = null, o = this.closestPoint(t.p0); r = o.distance(t.p0), n[0] = o, n[1] = t.p0; var a = this.closestPoint(t.p1); (i = a.distance(t.p1)) < r && (r = i, n[0] = a, n[1] = t.p1); var s = t.closestPoint(this.p0); (i = s.distance(this.p0)) < r && (r = i, n[0] = this.p0, n[1] = s); var u = t.closestPoint(this.p1); return (i = u.distance(this.p1)) < r && (r = i, n[0] = this.p1, n[1] = u), n } }, { key: "closestPoint", value: function (t) { var e = this.projectionFactor(t); return e > 0 && e < 1 ? this.project(t) : this.p0.distance(t) < this.p1.distance(t) ? this.p0 : this.p1 } }, { key: "maxX", value: function () { return Math.max(this.p0.x, this.p1.x) } }, { key: "getLength", value: function () { return this.p0.distance(this.p1) } }, { key: "compareTo", value: function (t) { var e = t, n = this.p0.compareTo(e.p0); return 0 !== n ? n : this.p1.compareTo(e.p1) } }, { key: "reverse", value: function () { var t = this.p0; this.p0 = this.p1, this.p1 = t } }, { key: "equalsTopo", value: function (t) { return this.p0.equals(t.p0) && this.p1.equals(t.p1) || this.p0.equals(t.p1) && this.p1.equals(t.p0) } }, { key: "lineIntersection", value: function (t) { return _t.intersection(this.p0, this.p1, t.p0, t.p1) } }, { key: "maxY", value: function () { return Math.max(this.p0.y, this.p1.y) } }, { key: "pointAlongOffset", value: function (t, e) { var n = this.p0.x + t * (this.p1.x - this.p0.x), r = this.p0.y + t * (this.p1.y - this.p0.y), i = this.p1.x - this.p0.x, o = this.p1.y - this.p0.y, a = Math.sqrt(i * i + o * o), s = 0, u = 0; if (0 !== e) { if (a <= 0) throw new IllegalStateException("Cannot compute offset from zero-length line segment"); s = e * i / a, u = e * o / a } return new Y(n - u, r + s) } }, { key: "setCoordinates", value: function () { if (1 === arguments.length) { var t = arguments[0]; this.setCoordinates(t.p0, t.p1) } else if (2 === arguments.length) { var e = arguments[0], n = arguments[1]; this.p0.x = e.x, this.p0.y = e.y, this.p1.x = n.x, this.p1.y = n.y } } }, { key: "segmentFraction", value: function (t) { var e = this.projectionFactor(t); return e < 0 ? e = 0 : (e > 1 || A.isNaN(e)) && (e = 1), e } }, { key: "toString", value: function () { return "LINESTRING( " + this.p0.x + " " + this.p0.y + ", " + this.p1.x + " " + this.p1.y + ")" } }, { key: "isHorizontal", value: function () { return this.p0.y === this.p1.y } }, { key: "reflect", value: function (t) { var e = this.p1.getY() - this.p0.getY(), n = this.p0.getX() - this.p1.getX(), r = this.p0.getY() * (this.p1.getX() - this.p0.getX()) - this.p0.getX() * (this.p1.getY() - this.p0.getY()), i = e * e + n * n, o = e * e - n * n, a = t.getX(), s = t.getY(); return new Y((-o * a - 2 * e * n * s - 2 * e * r) / i, (o * s - 2 * e * n * a - 2 * n * r) / i) } }, { key: "distance", value: function () { if (arguments[0] instanceof e) { var t = arguments[0]; return Et.segmentToSegment(this.p0, this.p1, t.p0, t.p1) } if (arguments[0] instanceof Y) { var n = arguments[0]; return Et.pointToSegment(n, this.p0, this.p1) } } }, { key: "pointAlong", value: function (t) { var e = new Y; return e.x = this.p0.x + t * (this.p1.x - this.p0.x), e.y = this.p0.y + t * (this.p1.y - this.p0.y), e } }, { key: "hashCode", value: function () { var t = A.doubleToLongBits(this.p0.x); t ^= 31 * A.doubleToLongBits(this.p0.y); var e = Math.trunc(t) ^ Math.trunc(t >> 32), n = A.doubleToLongBits(this.p1.x); return n ^= 31 * A.doubleToLongBits(this.p1.y), e ^ Math.trunc(n) ^ Math.trunc(n >> 32) } }, { key: "interfaces_", get: function () { return [E, k] } }], [{ key: "constructor_", value: function () { if (this.p0 = null, this.p1 = null, 0 === arguments.length) e.constructor_.call(this, new Y, new Y); else if (1 === arguments.length) { var t = arguments[0]; e.constructor_.call(this, t.p0, t.p1) } else if (2 === arguments.length) { var n = arguments[0], r = arguments[1]; this.p0 = n, this.p1 = r } else if (4 === arguments.length) { var i = arguments[0], o = arguments[1], a = arguments[2], s = arguments[3]; e.constructor_.call(this, new Y(i, o), new Y(a, s)) } } }, { key: "midPoint", value: function (t, e) { return new Y((t.x + e.x) / 2, (t.y + e.y) / 2) } }]), e }(), kn = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "overlap", value: function () { if (2 === arguments.length); else if (4 === arguments.length) { var t = arguments[1], e = arguments[2], n = arguments[3]; arguments[0].getLineSegment(t, this._overlapSeg1), e.getLineSegment(n, this._overlapSeg2), this.overlap(this._overlapSeg1, this._overlapSeg2) } } }], [{ key: "constructor_", value: function () { this._overlapSeg1 = new wn, this._overlapSeg2 = new wn } }]), e }(), Sn = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "getLineSegment", value: function (t, e) { e.p0 = this._pts[t], e.p1 = this._pts[t + 1] } }, { key: "computeSelect", value: function (t, e, n, r) { var i = this._pts[e], o = this._pts[n]; if (n - e == 1) return r.select(this, e), null; if (!t.intersects(i, o)) return null; var a = Math.trunc((e + n) / 2); e < a && this.computeSelect(t, e, a, r), a < n && this.computeSelect(t, a, n, r) } }, { key: "getCoordinates", value: function () { for (var t = new Array(this._end - this._start + 1).fill(null), e = 0, n = this._start; n <= this._end; n++)t[e++] = this._pts[n]; return t } }, { key: "computeOverlaps", value: function () { if (2 === arguments.length) { var t = arguments[0], e = arguments[1]; this.computeOverlaps(this._start, this._end, t, t._start, t._end, e) } else if (6 === arguments.length) { var n = arguments[0], r = arguments[1], i = arguments[2], o = arguments[3], a = arguments[4], s = arguments[5]; if (r - n == 1 && a - o == 1) return s.overlap(this, n, i, o), null; if (!this.overlaps(n, r, i, o, a)) return null; var u = Math.trunc((n + r) / 2), l = Math.trunc((o + a) / 2); n < u && (o < l && this.computeOverlaps(n, u, i, o, l, s), l < a && this.computeOverlaps(n, u, i, l, a, s)), u < r && (o < l && this.computeOverlaps(u, r, i, o, l, s), l < a && this.computeOverlaps(u, r, i, l, a, s)) } } }, { key: "setId", value: function (t) { this._id = t } }, { key: "select", value: function (t, e) { this.computeSelect(t, this._start, this._end, e) } }, { key: "getEnvelope", value: function () { if (null === this._env) { var t = this._pts[this._start], e = this._pts[this._end]; this._env = new U(t, e) } return this._env } }, { key: "overlaps", value: function (t, e, n, r, i) { return U.intersects(this._pts[t], this._pts[e], n._pts[r], n._pts[i]) } }, { key: "getEndIndex", value: function () { return this._end } }, { key: "getStartIndex", value: function () { return this._start } }, { key: "getContext", value: function () { return this._context } }, { key: "getId", value: function () { return this._id } }], [{ key: "constructor_", value: function () { this._pts = null, this._start = null, this._end = null, this._env = null, this._context = null, this._id = null; var t = arguments[0], e = arguments[1], n = arguments[2], r = arguments[3]; this._pts = t, this._start = e, this._end = n, this._context = r } }]), e }(), In = function () { function e() { t(this, e) } return r(e, null, [{ key: "findChainEnd", value: function (t, e) { for (var n = e; n < t.length - 1 && t[n].equals2D(t[n + 1]);)n++; if (n >= t.length - 1) return t.length - 1; for (var r = Ze.quadrant(t[n], t[n + 1]), i = e + 1; i < t.length && (t[i - 1].equals2D(t[i]) || Ze.quadrant(t[i - 1], t[i]) === r);)i++; return i - 1 } }, { key: "getChains", value: function () { if (1 === arguments.length) { var t = arguments[0]; return e.getChains(t, null) } if (2 === arguments.length) { var n = arguments[0], r = arguments[1], i = new vt, o = 0; do { var a = e.findChainEnd(n, o), s = new Sn(n, o, a, r); i.add(s), o = a } while (o < n.length - 1); return i } } }]), e }(), Pn = function () { function e() { t(this, e) } return r(e, [{ key: "computeNodes", value: function (t) { } }, { key: "getNodedSubstrings", value: function () { } }]), e }(), Nn = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "setSegmentIntersector", value: function (t) { this._segInt = t } }, { key: "interfaces_", get: function () { return [Pn] } }], [{ key: "constructor_", value: function () { if (this._segInt = null, 0 === arguments.length); else if (1 === arguments.length) { var t = arguments[0]; this.setSegmentIntersector(t) } } }]), e }(), Mn = function (e) { i(o, e); var n = f(o); function o() { var e; return t(this, o), e = n.call(this), o.constructor_.apply(c(e), arguments), e } return r(o, [{ key: "getMonotoneChains", value: function () { return this._monoChains } }, { key: "getNodedSubstrings", value: function () { return En.getNodedSubstrings(this._nodedSegStrings) } }, { key: "getIndex", value: function () { return this._index } }, { key: "add", value: function (t) { for (var e = In.getChains(t.getCoordinates(), t).iterator(); e.hasNext();) { var n = e.next(); n.setId(this._idCounter++), this._index.insert(n.getEnvelope(), n), this._monoChains.add(n) } } }, { key: "computeNodes", value: function (t) { this._nodedSegStrings = t; for (var e = t.iterator(); e.hasNext();)this.add(e.next()); this.intersectChains() } }, { key: "intersectChains", value: function () { for (var t = new On(this._segInt), e = this._monoChains.iterator(); e.hasNext();)for (var n = e.next(), r = this._index.query(n.getEnvelope()).iterator(); r.hasNext();) { var i = r.next(); if (i.getId() > n.getId() && (n.computeOverlaps(i, t), this._nOverlaps++), this._segInt.isDone()) return null } } }], [{ key: "constructor_", value: function () { if (this._monoChains = new vt, this._index = new pn, this._idCounter = 0, this._nodedSegStrings = null, this._nOverlaps = 0, 0 === arguments.length); else if (1 === arguments.length) { var t = arguments[0]; Nn.constructor_.call(this, t) } } }]), o }(Nn), On = function (e) { i(a, e); var n = f(a); function a() { var e; return t(this, a), e = n.call(this), a.constructor_.apply(c(e), arguments), e } return r(a, [{ key: "overlap", value: function () { if (4 !== arguments.length) return p(o(a.prototype), "overlap", this).apply(this, arguments); var t = arguments[1], e = arguments[2], n = arguments[3], r = arguments[0].getContext(), i = e.getContext(); this._si.processIntersections(r, t, i, n) } }], [{ key: "constructor_", value: function () { this._si = null; var t = arguments[0]; this._si = t } }]), a }(kn); Mn.SegmentOverlapAction = On; var Ln = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "isDeletable", value: function (t, e, n, r) { var i = this._inputLine[t], o = this._inputLine[e], a = this._inputLine[n]; return !!this.isConcave(i, o, a) && !!this.isShallow(i, o, a, r) && this.isShallowSampled(i, o, t, n, r) } }, { key: "deleteShallowConcavities", value: function () { for (var t = 1, n = this.findNextNonDeletedIndex(t), r = this.findNextNonDeletedIndex(n), i = !1; r < this._inputLine.length;) { var o = !1; this.isDeletable(t, n, r, this._distanceTol) && (this._isDeleted[n] = e.DELETE, o = !0, i = !0), t = o ? r : n, n = this.findNextNonDeletedIndex(t), r = this.findNextNonDeletedIndex(n) } return i } }, { key: "isShallowConcavity", value: function (t, e, n, r) { return ft.index(t, e, n) === this._angleOrientation && Et.pointToSegment(e, t, n) < r } }, { key: "isShallowSampled", value: function (t, n, r, i, o) { var a = Math.trunc((i - r) / e.NUM_PTS_TO_CHECK); a <= 0 && (a = 1); for (var s = r; s < i; s += a)if (!this.isShallow(t, n, this._inputLine[s], o)) return !1; return !0 } }, { key: "isConcave", value: function (t, e, n) { return ft.index(t, e, n) === this._angleOrientation } }, { key: "simplify", value: function (t) { this._distanceTol = Math.abs(t), t < 0 && (this._angleOrientation = ft.CLOCKWISE), this._isDeleted = new Array(this._inputLine.length).fill(null); var e = !1; do { e = this.deleteShallowConcavities() } while (e); return this.collapseLine() } }, { key: "findNextNonDeletedIndex", value: function (t) { for (var n = t + 1; n < this._inputLine.length && this._isDeleted[n] === e.DELETE;)n++; return n } }, { key: "isShallow", value: function (t, e, n, r) { return Et.pointToSegment(e, t, n) < r } }, { key: "collapseLine", value: function () { for (var t = new Ht, n = 0; n < this._inputLine.length; n++)this._isDeleted[n] !== e.DELETE && t.add(this._inputLine[n]); return t.toCoordinateArray() } }], [{ key: "constructor_", value: function () { this._inputLine = null, this._distanceTol = null, this._isDeleted = null, this._angleOrientation = ft.COUNTERCLOCKWISE; var t = arguments[0]; this._inputLine = t } }, { key: "simplify", value: function (t, n) { return new e(t).simplify(n) } }]), e }(); Ln.INIT = 0, Ln.DELETE = 1, Ln.KEEP = 1, Ln.NUM_PTS_TO_CHECK = 10; var Rn = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "getCoordinates", value: function () { return this._ptList.toArray(e.COORDINATE_ARRAY_TYPE) } }, { key: "setPrecisionModel", value: function (t) { this._precisionModel = t } }, { key: "addPt", value: function (t) { var e = new Y(t); if (this._precisionModel.makePrecise(e), this.isRedundant(e)) return null; this._ptList.add(e) } }, { key: "reverse", value: function () { } }, { key: "addPts", value: function (t, e) { if (e) for (var n = 0; n < t.length; n++)this.addPt(t[n]); else for (var r = t.length - 1; r >= 0; r--)this.addPt(t[r]) } }, { key: "isRedundant", value: function (t) { if (this._ptList.size() < 1) return !1; var e = this._ptList.get(this._ptList.size() - 1); return t.distance(e) < this._minimimVertexDistance } }, { key: "toString", value: function () { return (new se).createLineString(this.getCoordinates()).toString() } }, { key: "closeRing", value: function () { if (this._ptList.size() < 1) return null; var t = new Y(this._ptList.get(0)), e = this._ptList.get(this._ptList.size() - 1); if (t.equals(e)) return null; this._ptList.add(t) } }, { key: "setMinimumVertexDistance", value: function (t) { this._minimimVertexDistance = t } }], [{ key: "constructor_", value: function () { this._ptList = null, this._precisionModel = null, this._minimimVertexDistance = 0, this._ptList = new vt } }]), e }(); Rn.COORDINATE_ARRAY_TYPE = new Array(0).fill(null); var Cn = function () { function e() { t(this, e) } return r(e, null, [{ key: "toDegrees", value: function (t) { return 180 * t / Math.PI } }, { key: "normalize", value: function (t) { for (; t > Math.PI;)t -= e.PI_TIMES_2; for (; t <= -Math.PI;)t += e.PI_TIMES_2; return t } }, { key: "angle", value: function () { if (1 === arguments.length) { var t = arguments[0]; return Math.atan2(t.y, t.x) } if (2 === arguments.length) { var e = arguments[0], n = arguments[1], r = n.x - e.x, i = n.y - e.y; return Math.atan2(i, r) } } }, { key: "isAcute", value: function (t, e, n) { var r = t.x - e.x, i = t.y - e.y; return r * (n.x - e.x) + i * (n.y - e.y) > 0 } }, { key: "isObtuse", value: function (t, e, n) { var r = t.x - e.x, i = t.y - e.y; return r * (n.x - e.x) + i * (n.y - e.y) < 0 } }, { key: "interiorAngle", value: function (t, n, r) { var i = e.angle(n, t), o = e.angle(n, r); return Math.abs(o - i) } }, { key: "normalizePositive", value: function (t) { if (t < 0) { for (; t < 0;)t += e.PI_TIMES_2; t >= e.PI_TIMES_2 && (t = 0) } else { for (; t >= e.PI_TIMES_2;)t -= e.PI_TIMES_2; t < 0 && (t = 0) } return t } }, { key: "angleBetween", value: function (t, n, r) { var i = e.angle(n, t), o = e.angle(n, r); return e.diff(i, o) } }, { key: "diff", value: function (t, e) { var n = null; return (n = t < e ? e - t : t - e) > Math.PI && (n = 2 * Math.PI - n), n } }, { key: "toRadians", value: function (t) { return t * Math.PI / 180 } }, { key: "getTurn", value: function (t, n) { var r = Math.sin(n - t); return r > 0 ? e.COUNTERCLOCKWISE : r < 0 ? e.CLOCKWISE : e.NONE } }, { key: "angleBetweenOriented", value: function (t, n, r) { var i = e.angle(n, t), o = e.angle(n, r) - i; return o <= -Math.PI ? o + e.PI_TIMES_2 : o > Math.PI ? o - e.PI_TIMES_2 : o } }]), e }(); Cn.PI_TIMES_2 = 2 * Math.PI, Cn.PI_OVER_2 = Math.PI / 2, Cn.PI_OVER_4 = Math.PI / 4, Cn.COUNTERCLOCKWISE = ft.COUNTERCLOCKWISE, Cn.CLOCKWISE = ft.CLOCKWISE, Cn.NONE = ft.COLLINEAR; var Tn = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "addNextSegment", value: function (t, e) { if (this._s0 = this._s1, this._s1 = this._s2, this._s2 = t, this._seg0.setCoordinates(this._s0, this._s1), this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0), this._seg1.setCoordinates(this._s1, this._s2), this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1), this._s1.equals(this._s2)) return null; var n = ft.index(this._s0, this._s1, this._s2), r = n === ft.CLOCKWISE && this._side === tt.LEFT || n === ft.COUNTERCLOCKWISE && this._side === tt.RIGHT; 0 === n ? this.addCollinear(e) : r ? this.addOutsideTurn(n, e) : this.addInsideTurn(n, e) } }, { key: "addLineEndCap", value: function (t, e) { var n = new wn(t, e), r = new wn; this.computeOffsetSegment(n, tt.LEFT, this._distance, r); var i = new wn; this.computeOffsetSegment(n, tt.RIGHT, this._distance, i); var o = e.x - t.x, a = e.y - t.y, s = Math.atan2(a, o); switch (this._bufParams.getEndCapStyle()) { case m.CAP_ROUND: this._segList.addPt(r.p1), this.addDirectedFillet(e, s + Math.PI / 2, s - Math.PI / 2, ft.CLOCKWISE, this._distance), this._segList.addPt(i.p1); break; case m.CAP_FLAT: this._segList.addPt(r.p1), this._segList.addPt(i.p1); break; case m.CAP_SQUARE: var u = new Y; u.x = Math.abs(this._distance) * Math.cos(s), u.y = Math.abs(this._distance) * Math.sin(s); var l = new Y(r.p1.x + u.x, r.p1.y + u.y), c = new Y(i.p1.x + u.x, i.p1.y + u.y); this._segList.addPt(l), this._segList.addPt(c) } } }, { key: "getCoordinates", value: function () { return this._segList.getCoordinates() } }, { key: "addMitreJoin", value: function (t, e, n, r) { var i = _t.intersection(e.p0, e.p1, n.p0, n.p1); if (null !== i && (r <= 0 ? 1 : i.distance(t) / Math.abs(r)) <= this._bufParams.getMitreLimit()) return this._segList.addPt(i), null; this.addLimitedMitreJoin(e, n, r, this._bufParams.getMitreLimit()) } }, { key: "addOutsideTurn", value: function (t, n) { if (this._offset0.p1.distance(this._offset1.p0) < this._distance * e.OFFSET_SEGMENT_SEPARATION_FACTOR) return this._segList.addPt(this._offset0.p1), null; this._bufParams.getJoinStyle() === m.JOIN_MITRE ? this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance) : this._bufParams.getJoinStyle() === m.JOIN_BEVEL ? this.addBevelJoin(this._offset0, this._offset1) : (n && this._segList.addPt(this._offset0.p1), this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, t, this._distance), this._segList.addPt(this._offset1.p0)) } }, { key: "createSquare", value: function (t) { this._segList.addPt(new Y(t.x + this._distance, t.y + this._distance)), this._segList.addPt(new Y(t.x + this._distance, t.y - this._distance)), this._segList.addPt(new Y(t.x - this._distance, t.y - this._distance)), this._segList.addPt(new Y(t.x - this._distance, t.y + this._distance)), this._segList.closeRing() } }, { key: "addSegments", value: function (t, e) { this._segList.addPts(t, e) } }, { key: "addFirstSegment", value: function () { this._segList.addPt(this._offset1.p0) } }, { key: "addCornerFillet", value: function (t, e, n, r, i) { var o = e.x - t.x, a = e.y - t.y, s = Math.atan2(a, o), u = n.x - t.x, l = n.y - t.y, c = Math.atan2(l, u); r === ft.CLOCKWISE ? s <= c && (s += 2 * Math.PI) : s >= c && (s -= 2 * Math.PI), this._segList.addPt(e), this.addDirectedFillet(t, s, c, r, i), this._segList.addPt(n) } }, { key: "addLastSegment", value: function () { this._segList.addPt(this._offset1.p1) } }, { key: "initSideSegments", value: function (t, e, n) { this._s1 = t, this._s2 = e, this._side = n, this._seg1.setCoordinates(t, e), this.computeOffsetSegment(this._seg1, n, this._distance, this._offset1) } }, { key: "addLimitedMitreJoin", value: function (t, e, n, r) { var i = this._seg0.p1, o = Cn.angle(i, this._seg0.p0), a = Cn.angleBetweenOriented(this._seg0.p0, i, this._seg1.p1) / 2, s = Cn.normalize(o + a), u = Cn.normalize(s + Math.PI), l = r * n, c = n - l * Math.abs(Math.sin(a)), h = i.x + l * Math.cos(u), f = i.y + l * Math.sin(u), p = new Y(h, f), g = new wn(i, p), y = g.pointAlongOffset(1, c), v = g.pointAlongOffset(1, -c); this._side === tt.LEFT ? (this._segList.addPt(y), this._segList.addPt(v)) : (this._segList.addPt(v), this._segList.addPt(y)) } }, { key: "addDirectedFillet", value: function (t, e, n, r, i) { var o = r === ft.CLOCKWISE ? -1 : 1, a = Math.abs(e - n), s = Math.trunc(a / this._filletAngleQuantum + .5); if (s < 1) return null; for (var u = a / s, l = new Y, c = 0; c < s; c++) { var h = e + o * c * u; l.x = t.x + i * Math.cos(h), l.y = t.y + i * Math.sin(h), this._segList.addPt(l) } } }, { key: "computeOffsetSegment", value: function (t, e, n, r) { var i = e === tt.LEFT ? 1 : -1, o = t.p1.x - t.p0.x, a = t.p1.y - t.p0.y, s = Math.sqrt(o * o + a * a), u = i * n * o / s, l = i * n * a / s; r.p0.x = t.p0.x - l, r.p0.y = t.p0.y + u, r.p1.x = t.p1.x - l, r.p1.y = t.p1.y + u } }, { key: "addInsideTurn", value: function (t, n) { if (this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1), this._li.hasIntersection()) this._segList.addPt(this._li.getIntersection(0)); else if (this._hasNarrowConcaveAngle = !0, this._offset0.p1.distance(this._offset1.p0) < this._distance * e.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) this._segList.addPt(this._offset0.p1); else { if (this._segList.addPt(this._offset0.p1), this._closingSegLengthFactor > 0) { var r = new Y((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1)); this._segList.addPt(r); var i = new Y((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1)); this._segList.addPt(i) } else this._segList.addPt(this._s1); this._segList.addPt(this._offset1.p0) } } }, { key: "createCircle", value: function (t) { var e = new Y(t.x + this._distance, t.y); this._segList.addPt(e), this.addDirectedFillet(t, 0, 2 * Math.PI, -1, this._distance), this._segList.closeRing() } }, { key: "addBevelJoin", value: function (t, e) { this._segList.addPt(t.p1), this._segList.addPt(e.p0) } }, { key: "init", value: function (t) { this._distance = t, this._maxCurveSegmentError = t * (1 - Math.cos(this._filletAngleQuantum / 2)), this._segList = new Rn, this._segList.setPrecisionModel(this._precisionModel), this._segList.setMinimumVertexDistance(t * e.CURVE_VERTEX_SNAP_DISTANCE_FACTOR) } }, { key: "addCollinear", value: function (t) { this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2), this._li.getIntersectionNum() >= 2 && (this._bufParams.getJoinStyle() === m.JOIN_BEVEL || this._bufParams.getJoinStyle() === m.JOIN_MITRE ? (t && this._segList.addPt(this._offset0.p1), this._segList.addPt(this._offset1.p0)) : this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, ft.CLOCKWISE, this._distance)) } }, { key: "closeRing", value: function () { this._segList.closeRing() } }, { key: "hasNarrowConcaveAngle", value: function () { return this._hasNarrowConcaveAngle } }], [{ key: "constructor_", value: function () { this._maxCurveSegmentError = 0, this._filletAngleQuantum = null, this._closingSegLengthFactor = 1, this._segList = null, this._distance = 0, this._precisionModel = null, this._bufParams = null, this._li = null, this._s0 = null, this._s1 = null, this._s2 = null, this._seg0 = new wn, this._seg1 = new wn, this._offset0 = new wn, this._offset1 = new wn, this._side = 0, this._hasNarrowConcaveAngle = !1; var t = arguments[0], n = arguments[1], r = arguments[2]; this._precisionModel = t, this._bufParams = n, this._li = new Le, this._filletAngleQuantum = Math.PI / 2 / n.getQuadrantSegments(), n.getQuadrantSegments() >= 8 && n.getJoinStyle() === m.JOIN_ROUND && (this._closingSegLengthFactor = e.MAX_CLOSING_SEG_LEN_FACTOR), this.init(r) } }]), e }(); Tn.OFFSET_SEGMENT_SEPARATION_FACTOR = .001, Tn.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = .001, Tn.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1e-6, Tn.MAX_CLOSING_SEG_LEN_FACTOR = 80; var An = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "getOffsetCurve", value: function (t, e) { if (this._distance = e, 0 === e) return null; var n = e < 0, r = Math.abs(e), i = this.getSegGen(r); t.length <= 1 ? this.computePointCurve(t[0], i) : this.computeOffsetCurve(t, n, i); var o = i.getCoordinates(); return n && Zt.reverse(o), o } }, { key: "computeSingleSidedBufferCurve", value: function (t, e, n) { var r = this.simplifyTolerance(this._distance); if (e) { n.addSegments(t, !0); var i = Ln.simplify(t, -r), o = i.length - 1; n.initSideSegments(i[o], i[o - 1], tt.LEFT), n.addFirstSegment(); for (var a = o - 2; a >= 0; a--)n.addNextSegment(i[a], !0) } else { n.addSegments(t, !1); var s = Ln.simplify(t, r), u = s.length - 1; n.initSideSegments(s[0], s[1], tt.LEFT), n.addFirstSegment(); for (var l = 2; l <= u; l++)n.addNextSegment(s[l], !0) } n.addLastSegment(), n.closeRing() } }, { key: "computeRingBufferCurve", value: function (t, e, n) { var r = this.simplifyTolerance(this._distance); e === tt.RIGHT && (r = -r); var i = Ln.simplify(t, r), o = i.length - 1; n.initSideSegments(i[o - 1], i[0], e); for (var a = 1; a <= o; a++) { var s = 1 !== a; n.addNextSegment(i[a], s) } n.closeRing() } }, { key: "computeLineBufferCurve", value: function (t, e) { var n = this.simplifyTolerance(this._distance), r = Ln.simplify(t, n), i = r.length - 1; e.initSideSegments(r[0], r[1], tt.LEFT); for (var o = 2; o <= i; o++)e.addNextSegment(r[o], !0); e.addLastSegment(), e.addLineEndCap(r[i - 1], r[i]); var a = Ln.simplify(t, -n), s = a.length - 1; e.initSideSegments(a[s], a[s - 1], tt.LEFT); for (var u = s - 2; u >= 0; u--)e.addNextSegment(a[u], !0); e.addLastSegment(), e.addLineEndCap(a[1], a[0]), e.closeRing() } }, { key: "computePointCurve", value: function (t, e) { switch (this._bufParams.getEndCapStyle()) { case m.CAP_ROUND: e.createCircle(t); break; case m.CAP_SQUARE: e.createSquare(t) } } }, { key: "getLineCurve", value: function (t, e) { if (this._distance = e, this.isLineOffsetEmpty(e)) return null; var n = Math.abs(e), r = this.getSegGen(n); if (t.length <= 1) this.computePointCurve(t[0], r); else if (this._bufParams.isSingleSided()) { var i = e < 0; this.computeSingleSidedBufferCurve(t, i, r) } else this.computeLineBufferCurve(t, r); return r.getCoordinates() } }, { key: "getBufferParameters", value: function () { return this._bufParams } }, { key: "simplifyTolerance", value: function (t) { return t * this._bufParams.getSimplifyFactor() } }, { key: "getRingCurve", value: function (t, n, r) { if (this._distance = r, t.length <= 2) return this.getLineCurve(t, r); if (0 === r) return e.copyCoordinates(t); var i = this.getSegGen(r); return this.computeRingBufferCurve(t, n, i), i.getCoordinates() } }, { key: "computeOffsetCurve", value: function (t, e, n) { var r = this.simplifyTolerance(this._distance); if (e) { var i = Ln.simplify(t, -r), o = i.length - 1; n.initSideSegments(i[o], i[o - 1], tt.LEFT), n.addFirstSegment(); for (var a = o - 2; a >= 0; a--)n.addNextSegment(i[a], !0) } else { var s = Ln.simplify(t, r), u = s.length - 1; n.initSideSegments(s[0], s[1], tt.LEFT), n.addFirstSegment(); for (var l = 2; l <= u; l++)n.addNextSegment(s[l], !0) } n.addLastSegment() } }, { key: "isLineOffsetEmpty", value: function (t) { return 0 === t || t < 0 && !this._bufParams.isSingleSided() } }, { key: "getSegGen", value: function (t) { return new Tn(this._precisionModel, this._bufParams, t) } }], [{ key: "constructor_", value: function () { this._distance = 0, this._precisionModel = null, this._bufParams = null; var t = arguments[0], e = arguments[1]; this._precisionModel = t, this._bufParams = e } }, { key: "copyCoordinates", value: function (t) { for (var e = new Array(t.length).fill(null), n = 0; n < e.length; n++)e[n] = new Y(t[n]); return e } }]), e }(), Dn = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "findStabbedSegments", value: function () { if (1 === arguments.length) { for (var t = arguments[0], e = new vt, n = this._subgraphs.iterator(); n.hasNext();) { var r = n.next(), i = r.getEnvelope(); t.y < i.getMinY() || t.y > i.getMaxY() || this.findStabbedSegments(t, r.getDirectedEdges(), e) } return e } if (3 === arguments.length) if (ot(arguments[2], rt) && arguments[0] instanceof Y && arguments[1] instanceof $e) { for (var o = arguments[0], a = arguments[1], s = arguments[2], u = a.getEdge().getCoordinates(), l = 0; l < u.length - 1; l++)if (this._seg.p0 = u[l], this._seg.p1 = u[l + 1], this._seg.p0.y > this._seg.p1.y && this._seg.reverse(), !(Math.max(this._seg.p0.x, this._seg.p1.x) < o.x || this._seg.isHorizontal() || o.y < this._seg.p0.y || o.y > this._seg.p1.y || ft.index(this._seg.p0, this._seg.p1, o) === ft.RIGHT)) { var c = a.getDepth(tt.LEFT); this._seg.p0.equals(u[l]) || (c = a.getDepth(tt.RIGHT)); var h = new jn(this._seg, c); s.add(h) } } else if (ot(arguments[2], rt) && arguments[0] instanceof Y && ot(arguments[1], rt)) for (var f = arguments[0], p = arguments[2], g = arguments[1].iterator(); g.hasNext();) { var y = g.next(); y.isForward() && this.findStabbedSegments(f, y, p) } } }, { key: "getDepth", value: function (t) { var e = this.findStabbedSegments(t); return 0 === e.size() ? 0 : sn.min(e)._leftDepth } }], [{ key: "constructor_", value: function () { this._subgraphs = null, this._seg = new wn; var t = arguments[0]; this._subgraphs = t } }]), e }(), jn = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "compareTo", value: function (t) { var e = t; if (this._upwardSeg.minX() >= e._upwardSeg.maxX()) return 1; if (this._upwardSeg.maxX() <= e._upwardSeg.minX()) return -1; var n = this._upwardSeg.orientationIndex(e._upwardSeg); return 0 !== n || 0 != (n = -1 * e._upwardSeg.orientationIndex(this._upwardSeg)) ? n : this._upwardSeg.compareTo(e._upwardSeg) } }, { key: "compareX", value: function (t, e) { var n = t.p0.compareTo(e.p0); return 0 !== n ? n : t.p1.compareTo(e.p1) } }, { key: "toString", value: function () { return this._upwardSeg.toString() } }, { key: "interfaces_", get: function () { return [E] } }], [{ key: "constructor_", value: function () { this._upwardSeg = null, this._leftDepth = null; var t = arguments[0], e = arguments[1]; this._upwardSeg = new wn(t), this._leftDepth = e } }]), e }(); Dn.DepthSegment = jn; var Fn = function (e) { i(o, e); var n = f(o); function o() { var e; return t(this, o), e = n.call(this), o.constructor_.apply(c(e), arguments), e } return r(o, null, [{ key: "constructor_", value: function () { _.constructor_.call(this, "Projective point not representable on the Cartesian plane.") } }]), o }(_), Bn = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "getY", value: function () { var t = this.y / this.w; if (A.isNaN(t) || A.isInfinite(t)) throw new Fn; return t } }, { key: "getX", value: function () { var t = this.x / this.w; if (A.isNaN(t) || A.isInfinite(t)) throw new Fn; return t } }, { key: "getCoordinate", value: function () { var t = new Y; return t.x = this.getX(), t.y = this.getY(), t } }], [{ key: "constructor_", value: function () { if (this.x = null, this.y = null, this.w = null, 0 === arguments.length) this.x = 0, this.y = 0, this.w = 1; else if (1 === arguments.length) { var t = arguments[0]; this.x = t.x, this.y = t.y, this.w = 1 } else if (2 === arguments.length) { if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) { var n = arguments[0], r = arguments[1]; this.x = n, this.y = r, this.w = 1 } else if (arguments[0] instanceof e && arguments[1] instanceof e) { var i = arguments[0], o = arguments[1]; this.x = i.y * o.w - o.y * i.w, this.y = o.x * i.w - i.x * o.w, this.w = i.x * o.y - o.x * i.y } else if (arguments[0] instanceof Y && arguments[1] instanceof Y) { var a = arguments[0], s = arguments[1]; this.x = a.y - s.y, this.y = s.x - a.x, this.w = a.x * s.y - s.x * a.y } } else if (3 === arguments.length) { var u = arguments[0], l = arguments[1], c = arguments[2]; this.x = u, this.y = l, this.w = c } else if (4 === arguments.length) { var h = arguments[0], f = arguments[1], p = arguments[2], g = arguments[3], y = h.y - f.y, v = f.x - h.x, d = h.x * f.y - f.x * h.y, m = p.y - g.y, _ = g.x - p.x, b = p.x * g.y - g.x * p.y; this.x = v * b - _ * d, this.y = m * d - y * b, this.w = y * _ - m * v } } }]), e }(), qn = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "area", value: function () { return e.area(this.p0, this.p1, this.p2) } }, { key: "signedArea", value: function () { return e.signedArea(this.p0, this.p1, this.p2) } }, { key: "interpolateZ", value: function (t) { if (null === t) throw new b("Supplied point is null."); return e.interpolateZ(t, this.p0, this.p1, this.p2) } }, { key: "longestSideLength", value: function () { return e.longestSideLength(this.p0, this.p1, this.p2) } }, { key: "isAcute", value: function () { return e.isAcute(this.p0, this.p1, this.p2) } }, { key: "circumcentre", value: function () { return e.circumcentre(this.p0, this.p1, this.p2) } }, { key: "area3D", value: function () { return e.area3D(this.p0, this.p1, this.p2) } }, { key: "centroid", value: function () { return e.centroid(this.p0, this.p1, this.p2) } }, { key: "inCentre", value: function () { return e.inCentre(this.p0, this.p1, this.p2) } }], [{ key: "constructor_", value: function () { this.p0 = null, this.p1 = null, this.p2 = null; var t = arguments[0], e = arguments[1], n = arguments[2]; this.p0 = t, this.p1 = e, this.p2 = n } }, { key: "area", value: function (t, e, n) { return Math.abs(((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2) } }, { key: "signedArea", value: function (t, e, n) { return ((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2 } }, { key: "det", value: function (t, e, n, r) { return t * r - e * n } }, { key: "interpolateZ", value: function (t, e, n, r) { var i = e.x, o = e.y, a = n.x - i, s = r.x - i, u = n.y - o, l = r.y - o, c = a * l - s * u, h = t.x - i, f = t.y - o, p = (l * h - s * f) / c, g = (-u * h + a * f) / c; return e.getZ() + p * (n.getZ() - e.getZ()) + g * (r.getZ() - e.getZ()) } }, { key: "longestSideLength", value: function (t, e, n) { var r = t.distance(e), i = e.distance(n), o = n.distance(t), a = r; return i > a && (a = i), o > a && (a = o), a } }, { key: "circumcentreDD", value: function (t, e, n) { var r = lt.valueOf(t.x).subtract(n.x), i = lt.valueOf(t.y).subtract(n.y), o = lt.valueOf(e.x).subtract(n.x), a = lt.valueOf(e.y).subtract(n.y), s = lt.determinant(r, i, o, a).multiply(2), u = r.sqr().add(i.sqr()), l = o.sqr().add(a.sqr()), c = lt.determinant(i, u, a, l), h = lt.determinant(r, u, o, l), f = lt.valueOf(n.x).subtract(c.divide(s)).doubleValue(), p = lt.valueOf(n.y).add(h.divide(s)).doubleValue(); return new Y(f, p) } }, { key: "isAcute", value: function (t, e, n) { return !!Cn.isAcute(t, e, n) && !!Cn.isAcute(e, n, t) && !!Cn.isAcute(n, t, e) } }, { key: "circumcentre", value: function (t, n, r) { var i = r.x, o = r.y, a = t.x - i, s = t.y - o, u = n.x - i, l = n.y - o, c = 2 * e.det(a, s, u, l), h = e.det(s, a * a + s * s, l, u * u + l * l), f = e.det(a, a * a + s * s, u, u * u + l * l); return new Y(i - h / c, o + f / c) } }, { key: "perpendicularBisector", value: function (t, e) { var n = e.x - t.x, r = e.y - t.y, i = new Bn(t.x + n / 2, t.y + r / 2, 1), o = new Bn(t.x - r + n / 2, t.y + n + r / 2, 1); return new Bn(i, o) } }, { key: "angleBisector", value: function (t, e, n) { var r = e.distance(t), i = r / (r + e.distance(n)), o = n.x - t.x, a = n.y - t.y; return new Y(t.x + i * o, t.y + i * a) } }, { key: "area3D", value: function (t, e, n) { var r = e.x - t.x, i = e.y - t.y, o = e.getZ() - t.getZ(), a = n.x - t.x, s = n.y - t.y, u = n.getZ() - t.getZ(), l = i * u - o * s, c = o * a - r * u, h = r * s - i * a, f = l * l + c * c + h * h; return Math.sqrt(f) / 2 } }, { key: "centroid", value: function (t, e, n) { var r = (t.x + e.x + n.x) / 3, i = (t.y + e.y + n.y) / 3; return new Y(r, i) } }, { key: "inCentre", value: function (t, e, n) { var r = e.distance(n), i = t.distance(n), o = t.distance(e), a = r + i + o, s = (r * t.x + i * e.x + o * n.x) / a, u = (r * t.y + i * e.y + o * n.y) / a; return new Y(s, u) } }]), e }(), Vn = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "addRingSide", value: function (t, e, n, r, i) { if (0 === e && t.length < Yt.MINIMUM_VALID_SIZE) return null; var o = r, a = i; t.length >= Yt.MINIMUM_VALID_SIZE && ft.isCCW(t) && (o = i, a = r, n = tt.opposite(n)); var s = this._curveBuilder.getRingCurve(t, n, e); this.addCurve(s, o, a) } }, { key: "addRingBothSides", value: function (t, e) { this.addRingSide(t, e, tt.LEFT, W.EXTERIOR, W.INTERIOR), this.addRingSide(t, e, tt.RIGHT, W.INTERIOR, W.EXTERIOR) } }, { key: "addPoint", value: function (t) { if (this._distance <= 0) return null; var e = t.getCoordinates(), n = this._curveBuilder.getLineCurve(e, this._distance); this.addCurve(n, W.EXTERIOR, W.INTERIOR) } }, { key: "addPolygon", value: function (t) { var e = this._distance, n = tt.LEFT; this._distance < 0 && (e = -this._distance, n = tt.RIGHT); var r = t.getExteriorRing(), i = Zt.removeRepeatedPoints(r.getCoordinates()); if (this._distance < 0 && this.isErodedCompletely(r, this._distance)) return null; if (this._distance <= 0 && i.length < 3) return null; this.addRingSide(i, e, n, W.EXTERIOR, W.INTERIOR); for (var o = 0; o < t.getNumInteriorRing(); o++) { var a = t.getInteriorRingN(o), s = Zt.removeRepeatedPoints(a.getCoordinates()); this._distance > 0 && this.isErodedCompletely(a, -this._distance) || this.addRingSide(s, e, tt.opposite(n), W.INTERIOR, W.EXTERIOR) } } }, { key: "isTriangleErodedCompletely", value: function (t, e) { var n = new qn(t[0], t[1], t[2]), r = n.inCentre(); return Et.pointToSegment(r, n.p0, n.p1) < Math.abs(e) } }, { key: "addLineString", value: function (t) { if (this._curveBuilder.isLineOffsetEmpty(this._distance)) return null; var e = Zt.removeRepeatedPoints(t.getCoordinates()); if (Zt.isRing(e) && !this._curveBuilder.getBufferParameters().isSingleSided()) this.addRingBothSides(e, this._distance); else { var n = this._curveBuilder.getLineCurve(e, this._distance); this.addCurve(n, W.EXTERIOR, W.INTERIOR) } } }, { key: "addCurve", value: function (t, e, n) { if (null === t || t.length < 2) return null; var r = new En(t, new Ae(0, W.BOUNDARY, e, n)); this._curveList.add(r) } }, { key: "getCurves", value: function () { return this.add(this._inputGeom), this._curveList } }, { key: "add", value: function (t) { if (t.isEmpty()) return null; if (t instanceof jt) this.addPolygon(t); else if (t instanceof Lt) this.addLineString(t); else if (t instanceof Ct) this.addPoint(t); else if (t instanceof Gt) this.addCollection(t); else if (t instanceof ae) this.addCollection(t); else if (t instanceof ee) this.addCollection(t); else { if (!(t instanceof Vt)) throw new J(t.getGeometryType()); this.addCollection(t) } } }, { key: "isErodedCompletely", value: function (t, e) { var n = t.getCoordinates(); if (n.length < 4) return e < 0; if (4 === n.length) return this.isTriangleErodedCompletely(n, e); var r = t.getEnvelopeInternal(), i = Math.min(r.getHeight(), r.getWidth()); return e < 0 && 2 * Math.abs(e) > i } }, { key: "addCollection", value: function (t) { for (var e = 0; e < t.getNumGeometries(); e++) { var n = t.getGeometryN(e); this.add(n) } } }], [{ key: "constructor_", value: function () { this._inputGeom = null, this._distance = null, this._curveBuilder = null, this._curveList = new vt; var t = arguments[0], e = arguments[1], n = arguments[2]; this._inputGeom = t, this._distance = e, this._curveBuilder = n } }]), e }(), Gn = function () { function e() { t(this, e) } return r(e, [{ key: "locate", value: function (t) { } }]), e }(), Yn = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "next", value: function () { if (this._atStart) return this._atStart = !1, e.isAtomic(this._parent) && this._index++, this._parent; if (null !== this._subcollectionIterator) { if (this._subcollectionIterator.hasNext()) return this._subcollectionIterator.next(); this._subcollectionIterator = null } if (this._index >= this._max) throw new Z; var t = this._parent.getGeometryN(this._index++); return t instanceof Vt ? (this._subcollectionIterator = new e(t), this._subcollectionIterator.next()) : t } }, { key: "remove", value: function () { throw new J(this.getClass().getName()) } }, { key: "hasNext", value: function () { if (this._atStart) return !0; if (null !== this._subcollectionIterator) { if (this._subcollectionIterator.hasNext()) return !0; this._subcollectionIterator = null } return !(this._index >= this._max) } }, { key: "interfaces_", get: function () { return [dn] } }], [{ key: "constructor_", value: function () { this._parent = null, this._atStart = null, this._max = null, this._index = null, this._subcollectionIterator = null; var t = arguments[0]; this._parent = t, this._atStart = !0, this._index = 0, this._max = t.getNumGeometries() } }, { key: "isAtomic", value: function (t) { return !(t instanceof Vt) } }]), e }(), zn = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "locate", value: function (t) { return e.locate(t, this._geom) } }, { key: "interfaces_", get: function () { return [Gn] } }], [{ key: "constructor_", value: function () { this._geom = null; var t = arguments[0]; this._geom = t } }, { key: "locatePointInPolygon", value: function (t, n) { if (n.isEmpty()) return W.EXTERIOR; var r = n.getExteriorRing(), i = e.locatePointInRing(t, r); if (i !== W.INTERIOR) return i; for (var o = 0; o < n.getNumInteriorRing(); o++) { var a = n.getInteriorRingN(o), s = e.locatePointInRing(t, a); if (s === W.BOUNDARY) return W.BOUNDARY; if (s === W.INTERIOR) return W.EXTERIOR } return W.INTERIOR } }, { key: "locatePointInRing", value: function (t, e) { return e.getEnvelopeInternal().intersects(t) ? Ce.locateInRing(t, e.getCoordinates()) : W.EXTERIOR } }, { key: "containsPointInPolygon", value: function (t, n) { return W.EXTERIOR !== e.locatePointInPolygon(t, n) } }, { key: "locateInGeometry", value: function (t, n) { if (n instanceof jt) return e.locatePointInPolygon(t, n); if (n instanceof Vt) for (var r = new Yn(n); r.hasNext();) { var i = r.next(); if (i !== n) { var o = e.locateInGeometry(t, i); if (o !== W.EXTERIOR) return o } } return W.EXTERIOR } }, { key: "isContained", value: function (t, n) { return W.EXTERIOR !== e.locate(t, n) } }, { key: "locate", value: function (t, n) { return n.isEmpty() ? W.EXTERIOR : n.getEnvelopeInternal().intersects(t) ? e.locateInGeometry(t, n) : W.EXTERIOR } }]), e }(), Un = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "getNextCW", value: function (t) { this.getEdges(); var e = this._edgeList.indexOf(t), n = e - 1; return 0 === e && (n = this._edgeList.size() - 1), this._edgeList.get(n) } }, { key: "propagateSideLabels", value: function (t) { for (var e = W.NONE, n = this.iterator(); n.hasNext();) { var r = n.next().getLabel(); r.isArea(t) && r.getLocation(t, tt.LEFT) !== W.NONE && (e = r.getLocation(t, tt.LEFT)) } if (e === W.NONE) return null; for (var i = e, o = this.iterator(); o.hasNext();) { var a = o.next(), s = a.getLabel(); if (s.getLocation(t, tt.ON) === W.NONE && s.setLocation(t, tt.ON, i), s.isArea(t)) { var u = s.getLocation(t, tt.LEFT), l = s.getLocation(t, tt.RIGHT); if (l !== W.NONE) { if (l !== i) throw new gt("side location conflict", a.getCoordinate()); u === W.NONE && B.shouldNeverReachHere("found single null side (at " + a.getCoordinate() + ")"), i = u } else B.isTrue(s.getLocation(t, tt.LEFT) === W.NONE, "found single null side"), s.setLocation(t, tt.RIGHT, i), s.setLocation(t, tt.LEFT, i) } } } }, { key: "getCoordinate", value: function () { var t = this.iterator(); return t.hasNext() ? t.next().getCoordinate() : null } }, { key: "print", value: function (t) { bt.out.println("EdgeEndStar:   " + this.getCoordinate()); for (var e = this.iterator(); e.hasNext();)e.next().print(t) } }, { key: "isAreaLabelsConsistent", value: function (t) { return this.computeEdgeEndLabels(t.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0) } }, { key: "checkAreaLabelsConsistent", value: function (t) { var e = this.getEdges(); if (e.size() <= 0) return !0; var n = e.size() - 1, r = e.get(n).getLabel().getLocation(t, tt.LEFT); B.isTrue(r !== W.NONE, "Found unlabelled area edge"); for (var i = r, o = this.iterator(); o.hasNext();) { var a = o.next().getLabel(); B.isTrue(a.isArea(t), "Found non-area edge"); var s = a.getLocation(t, tt.LEFT), u = a.getLocation(t, tt.RIGHT); if (s === u) return !1; if (u !== i) return !1; i = s } return !0 } }, { key: "findIndex", value: function (t) { this.iterator(); for (var e = 0; e < this._edgeList.size(); e++)if (this._edgeList.get(e) === t) return e; return -1 } }, { key: "iterator", value: function () { return this.getEdges().iterator() } }, { key: "getEdges", value: function () { return null === this._edgeList && (this._edgeList = new vt(this._edgeMap.values())), this._edgeList } }, { key: "getLocation", value: function (t, e, n) { return this._ptInAreaLocation[t] === W.NONE && (this._ptInAreaLocation[t] = zn.locate(e, n[t].getGeometry())), this._ptInAreaLocation[t] } }, { key: "toString", value: function () { var t = new at; t.append("EdgeEndStar:   " + this.getCoordinate()), t.append("\n"); for (var e = this.iterator(); e.hasNext();) { var n = e.next(); t.append(n), t.append("\n") } return t.toString() } }, { key: "computeEdgeEndLabels", value: function (t) { for (var e = this.iterator(); e.hasNext();)e.next().computeLabel(t) } }, { key: "computeLabelling", value: function (t) { this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()), this.propagateSideLabels(0), this.propagateSideLabels(1); for (var e = [!1, !1], n = this.iterator(); n.hasNext();)for (var r = n.next().getLabel(), i = 0; i < 2; i++)r.isLine(i) && r.getLocation(i) === W.BOUNDARY && (e[i] = !0); for (var o = this.iterator(); o.hasNext();)for (var a = o.next(), s = a.getLabel(), u = 0; u < 2; u++)if (s.isAnyNull(u)) { var l = W.NONE; if (e[u]) l = W.EXTERIOR; else { var c = a.getCoordinate(); l = this.getLocation(u, c, t) } s.setAllLocationsIfNull(u, l) } } }, { key: "getDegree", value: function () { return this._edgeMap.size() } }, { key: "insertEdgeEnd", value: function (t, e) { this._edgeMap.put(t, e), this._edgeList = null } }], [{ key: "constructor_", value: function () { this._edgeMap = new We, this._edgeList = null, this._ptInAreaLocation = [W.NONE, W.NONE] } }]), e }(), Xn = function (e) { i(a, e); var n = f(a); function a() { var e; return t(this, a), e = n.call(this), a.constructor_.apply(c(e), arguments), e } return r(a, [{ key: "linkResultDirectedEdges", value: function () { this.getResultAreaEdges(); for (var t = null, e = null, n = this._SCANNING_FOR_INCOMING, r = 0; r < this._resultAreaEdgeList.size(); r++) { var i = this._resultAreaEdgeList.get(r), o = i.getSym(); if (i.getLabel().isArea()) switch (null === t && i.isInResult() && (t = i), n) { case this._SCANNING_FOR_INCOMING: if (!o.isInResult()) continue; e = o, n = this._LINKING_TO_OUTGOING; break; case this._LINKING_TO_OUTGOING: if (!i.isInResult()) continue; e.setNext(i), n = this._SCANNING_FOR_INCOMING } } if (n === this._LINKING_TO_OUTGOING) { if (null === t) throw new gt("no outgoing dirEdge found", this.getCoordinate()); B.isTrue(t.isInResult(), "unable to link last incoming dirEdge"), e.setNext(t) } } }, { key: "insert", value: function (t) { var e = t; this.insertEdgeEnd(e, e) } }, { key: "getRightmostEdge", value: function () { var t = this.getEdges(), e = t.size(); if (e < 1) return null; var n = t.get(0); if (1 === e) return n; var r = t.get(e - 1), i = n.getQuadrant(), o = r.getQuadrant(); return Ze.isNorthern(i) && Ze.isNorthern(o) ? n : Ze.isNorthern(i) || Ze.isNorthern(o) ? 0 !== n.getDy() ? n : 0 !== r.getDy() ? r : (B.shouldNeverReachHere("found two horizontal edges incident on node"), null) : r } }, { key: "print", value: function (t) { bt.out.println("DirectedEdgeStar: " + this.getCoordinate()); for (var e = this.iterator(); e.hasNext();) { var n = e.next(); t.print("out "), n.print(t), t.println(), t.print("in "), n.getSym().print(t), t.println() } } }, { key: "getResultAreaEdges", value: function () { if (null !== this._resultAreaEdgeList) return this._resultAreaEdgeList; this._resultAreaEdgeList = new vt; for (var t = this.iterator(); t.hasNext();) { var e = t.next(); (e.isInResult() || e.getSym().isInResult()) && this._resultAreaEdgeList.add(e) } return this._resultAreaEdgeList } }, { key: "updateLabelling", value: function (t) { for (var e = this.iterator(); e.hasNext();) { var n = e.next().getLabel(); n.setAllLocationsIfNull(0, t.getLocation(0)), n.setAllLocationsIfNull(1, t.getLocation(1)) } } }, { key: "linkAllDirectedEdges", value: function () { this.getEdges(); for (var t = null, e = null, n = this._edgeList.size() - 1; n >= 0; n--) { var r = this._edgeList.get(n), i = r.getSym(); null === e && (e = i), null !== t && i.setNext(t), t = r } e.setNext(t) } }, { key: "computeDepths", value: function () { if (1 === arguments.length) { var t = arguments[0], e = this.findIndex(t), n = t.getDepth(tt.LEFT), r = t.getDepth(tt.RIGHT), i = this.computeDepths(e + 1, this._edgeList.size(), n); if (this.computeDepths(0, e, i) !== r) throw new gt("depth mismatch at " + t.getCoordinate()) } else if (3 === arguments.length) { for (var o = arguments[1], a = arguments[2], s = arguments[0]; s < o; s++) { var u = this._edgeList.get(s); u.setEdgeDepths(tt.RIGHT, a), a = u.getDepth(tt.LEFT) } return a } } }, { key: "mergeSymLabels", value: function () { for (var t = this.iterator(); t.hasNext();) { var e = t.next(); e.getLabel().merge(e.getSym().getLabel()) } } }, { key: "linkMinimalDirectedEdges", value: function (t) { for (var e = null, n = null, r = this._SCANNING_FOR_INCOMING, i = this._resultAreaEdgeList.size() - 1; i >= 0; i--) { var o = this._resultAreaEdgeList.get(i), a = o.getSym(); switch (null === e && o.getEdgeRing() === t && (e = o), r) { case this._SCANNING_FOR_INCOMING: if (a.getEdgeRing() !== t) continue; n = a, r = this._LINKING_TO_OUTGOING; break; case this._LINKING_TO_OUTGOING: if (o.getEdgeRing() !== t) continue; n.setNextMin(o), r = this._SCANNING_FOR_INCOMING } } r === this._LINKING_TO_OUTGOING && (B.isTrue(null !== e, "found null for first outgoing dirEdge"), B.isTrue(e.getEdgeRing() === t, "unable to link last incoming dirEdge"), n.setNextMin(e)) } }, { key: "getOutgoingDegree", value: function () { if (0 === arguments.length) { for (var t = 0, e = this.iterator(); e.hasNext();)e.next().isInResult() && t++; return t } if (1 === arguments.length) { for (var n = arguments[0], r = 0, i = this.iterator(); i.hasNext();)i.next().getEdgeRing() === n && r++; return r } } }, { key: "getLabel", value: function () { return this._label } }, { key: "findCoveredLineEdges", value: function () { for (var t = W.NONE, e = this.iterator(); e.hasNext();) { var n = e.next(), r = n.getSym(); if (!n.isLineEdge()) { if (n.isInResult()) { t = W.INTERIOR; break } if (r.isInResult()) { t = W.EXTERIOR; break } } } if (t === W.NONE) return null; for (var i = t, o = this.iterator(); o.hasNext();) { var a = o.next(), s = a.getSym(); a.isLineEdge() ? a.getEdge().setCovered(i === W.INTERIOR) : (a.isInResult() && (i = W.EXTERIOR), s.isInResult() && (i = W.INTERIOR)) } } }, { key: "computeLabelling", value: function (t) { p(o(a.prototype), "computeLabelling", this).call(this, t), this._label = new Ae(W.NONE); for (var e = this.iterator(); e.hasNext();)for (var n = e.next().getEdge().getLabel(), r = 0; r < 2; r++) { var i = n.getLocation(r); i !== W.INTERIOR && i !== W.BOUNDARY || this._label.setLocation(r, W.INTERIOR) } } }], [{ key: "constructor_", value: function () { this._resultAreaEdgeList = null, this._label = null, this._SCANNING_FOR_INCOMING = 1, this._LINKING_TO_OUTGOING = 2 } }]), a }(Un), Wn = function (e) { i(o, e); var n = f(o); function o() { return t(this, o), n.call(this) } return r(o, [{ key: "createNode", value: function (t) { return new qe(t, new Xn) } }]), o }(Qe), Hn = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "compareTo", value: function (t) { var n = t; return e.compareOriented(this._pts, this._orientation, n._pts, n._orientation) } }, { key: "interfaces_", get: function () { return [E] } }], [{ key: "constructor_", value: function () { this._pts = null, this._orientation = null; var t = arguments[0]; this._pts = t, this._orientation = e.orientation(t) } }, { key: "orientation", value: function (t) { return 1 === Zt.increasingDirection(t) } }, { key: "compareOriented", value: function (t, e, n, r) { for (var i = e ? 1 : -1, o = r ? 1 : -1, a = e ? t.length : -1, s = r ? n.length : -1, u = e ? 0 : t.length - 1, l = r ? 0 : n.length - 1; ;) { var c = t[u].compareTo(n[l]); if (0 !== c) return c; var h = (u += i) === a, f = (l += o) === s; if (h && !f) return -1; if (!h && f) return 1; if (h && f) return 0 } } }]), e }(), Zn = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "print", value: function (t) { t.print("MULTILINESTRING ( "); for (var e = 0; e < this._edges.size(); e++) { var n = this._edges.get(e); e > 0 && t.print(","), t.print("("); for (var r = n.getCoordinates(), i = 0; i < r.length; i++)i > 0 && t.print(","), t.print(r[i].x + " " + r[i].y); t.println(")") } t.print(")  ") } }, { key: "addAll", value: function (t) { for (var e = t.iterator(); e.hasNext();)this.add(e.next()) } }, { key: "findEdgeIndex", value: function (t) { for (var e = 0; e < this._edges.size(); e++)if (this._edges.get(e).equals(t)) return e; return -1 } }, { key: "iterator", value: function () { return this._edges.iterator() } }, { key: "getEdges", value: function () { return this._edges } }, { key: "get", value: function (t) { return this._edges.get(t) } }, { key: "findEqualEdge", value: function (t) { var e = new Hn(t.getCoordinates()); return this._ocaMap.get(e) } }, { key: "add", value: function (t) { this._edges.add(t); var e = new Hn(t.getCoordinates()); this._ocaMap.put(e, t) } }], [{ key: "constructor_", value: function () { this._edges = new vt, this._ocaMap = new We } }]), e }(), Jn = function () { function e() { t(this, e) } return r(e, [{ key: "processIntersections", value: function (t, e, n, r) { } }, { key: "isDone", value: function () { } }]), e }(), $n = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "isTrivialIntersection", value: function (t, n, r, i) { if (t === r && 1 === this._li.getIntersectionNum()) { if (e.isAdjacentSegments(n, i)) return !0; if (t.isClosed()) { var o = t.size() - 1; if (0 === n && i === o || 0 === i && n === o) return !0 } } return !1 } }, { key: "getProperIntersectionPoint", value: function () { return this._properIntersectionPoint } }, { key: "hasProperInteriorIntersection", value: function () { return this._hasProperInterior } }, { key: "getLineIntersector", value: function () { return this._li } }, { key: "hasProperIntersection", value: function () { return this._hasProper } }, { key: "processIntersections", value: function (t, e, n, r) { if (t === n && e === r) return null; this.numTests++; var i = t.getCoordinates()[e], o = t.getCoordinates()[e + 1], a = n.getCoordinates()[r], s = n.getCoordinates()[r + 1]; this._li.computeIntersection(i, o, a, s), this._li.hasIntersection() && (this.numIntersections++, this._li.isInteriorIntersection() && (this.numInteriorIntersections++, this._hasInterior = !0), this.isTrivialIntersection(t, e, n, r) || (this._hasIntersection = !0, t.addIntersections(this._li, e, 0), n.addIntersections(this._li, r, 1), this._li.isProper() && (this.numProperIntersections++, this._hasProper = !0, this._hasProperInterior = !0))) } }, { key: "hasIntersection", value: function () { return this._hasIntersection } }, { key: "isDone", value: function () { return !1 } }, { key: "hasInteriorIntersection", value: function () { return this._hasInterior } }, { key: "interfaces_", get: function () { return [Jn] } }], [{ key: "constructor_", value: function () { this._hasIntersection = !1, this._hasProper = !1, this._hasProperInterior = !1, this._hasInterior = !1, this._properIntersectionPoint = null, this._li = null, this._isSelfIntersection = null, this.numIntersections = 0, this.numInteriorIntersections = 0, this.numProperIntersections = 0, this.numTests = 0; var t = arguments[0]; this._li = t } }, { key: "isAdjacentSegments", value: function (t, e) { return 1 === Math.abs(t - e) } }]), e }(), Qn = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "getSegmentIndex", value: function () { return this.segmentIndex } }, { key: "getCoordinate", value: function () { return this.coord } }, { key: "print", value: function (t) { t.print(this.coord), t.print(" seg # = " + this.segmentIndex), t.println(" dist = " + this.dist) } }, { key: "compareTo", value: function (t) { var e = t; return this.compare(e.segmentIndex, e.dist) } }, { key: "isEndPoint", value: function (t) { return 0 === this.segmentIndex && 0 === this.dist || this.segmentIndex === t } }, { key: "toString", value: function () { return this.coord + " seg # = " + this.segmentIndex + " dist = " + this.dist } }, { key: "getDistance", value: function () { return this.dist } }, { key: "compare", value: function (t, e) { return this.segmentIndex < t ? -1 : this.segmentIndex > t ? 1 : this.dist < e ? -1 : this.dist > e ? 1 : 0 } }, { key: "interfaces_", get: function () { return [E] } }], [{ key: "constructor_", value: function () { this.coord = null, this.segmentIndex = null, this.dist = null; var t = arguments[0], e = arguments[1], n = arguments[2]; this.coord = new Y(t), this.segmentIndex = e, this.dist = n } }]), e }(), Kn = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "print", value: function (t) { t.println("Intersections:"); for (var e = this.iterator(); e.hasNext();)e.next().print(t) } }, { key: "iterator", value: function () { return this._nodeMap.values().iterator() } }, { key: "addSplitEdges", value: function (t) { this.addEndpoints(); for (var e = this.iterator(), n = e.next(); e.hasNext();) { var r = e.next(), i = this.createSplitEdge(n, r); t.add(i), n = r } } }, { key: "addEndpoints", value: function () { var t = this.edge.pts.length - 1; this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[t], t, 0) } }, { key: "createSplitEdge", value: function (t, e) { var n = e.segmentIndex - t.segmentIndex + 2, r = this.edge.pts[e.segmentIndex], i = e.dist > 0 || !e.coord.equals2D(r); i || n--; var o = new Array(n).fill(null), a = 0; o[a++] = new Y(t.coord); for (var s = t.segmentIndex + 1; s <= e.segmentIndex; s++)o[a++] = this.edge.pts[s]; return i && (o[a] = e.coord), new or(o, new Ae(this.edge._label)) } }, { key: "add", value: function (t, e, n) { var r = new Qn(t, e, n), i = this._nodeMap.get(r); return null !== i ? i : (this._nodeMap.put(r, r), r) } }, { key: "isIntersection", value: function (t) { for (var e = this.iterator(); e.hasNext();)if (e.next().coord.equals(t)) return !0; return !1 } }], [{ key: "constructor_", value: function () { this._nodeMap = new We, this.edge = null; var t = arguments[0]; this.edge = t } }]), e }(), tr = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "isIntersects", value: function () { return !this.isDisjoint() } }, { key: "isCovers", value: function () { return (e.isTrue(this._matrix[W.INTERIOR][W.INTERIOR]) || e.isTrue(this._matrix[W.INTERIOR][W.BOUNDARY]) || e.isTrue(this._matrix[W.BOUNDARY][W.INTERIOR]) || e.isTrue(this._matrix[W.BOUNDARY][W.BOUNDARY])) && this._matrix[W.EXTERIOR][W.INTERIOR] === Nt.FALSE && this._matrix[W.EXTERIOR][W.BOUNDARY] === Nt.FALSE } }, { key: "isCoveredBy", value: function () { return (e.isTrue(this._matrix[W.INTERIOR][W.INTERIOR]) || e.isTrue(this._matrix[W.INTERIOR][W.BOUNDARY]) || e.isTrue(this._matrix[W.BOUNDARY][W.INTERIOR]) || e.isTrue(this._matrix[W.BOUNDARY][W.BOUNDARY])) && this._matrix[W.INTERIOR][W.EXTERIOR] === Nt.FALSE && this._matrix[W.BOUNDARY][W.EXTERIOR] === Nt.FALSE } }, { key: "set", value: function () { if (1 === arguments.length) for (var t = arguments[0], e = 0; e < t.length; e++) { var n = Math.trunc(e / 3), r = e % 3; this._matrix[n][r] = Nt.toDimensionValue(t.charAt(e)) } else if (3 === arguments.length) { var i = arguments[0], o = arguments[1], a = arguments[2]; this._matrix[i][o] = a } } }, { key: "isContains", value: function () { return e.isTrue(this._matrix[W.INTERIOR][W.INTERIOR]) && this._matrix[W.EXTERIOR][W.INTERIOR] === Nt.FALSE && this._matrix[W.EXTERIOR][W.BOUNDARY] === Nt.FALSE } }, { key: "setAtLeast", value: function () { if (1 === arguments.length) for (var t = arguments[0], e = 0; e < t.length; e++) { var n = Math.trunc(e / 3), r = e % 3; this.setAtLeast(n, r, Nt.toDimensionValue(t.charAt(e))) } else if (3 === arguments.length) { var i = arguments[0], o = arguments[1], a = arguments[2]; this._matrix[i][o] < a && (this._matrix[i][o] = a) } } }, { key: "setAtLeastIfValid", value: function (t, e, n) { t >= 0 && e >= 0 && this.setAtLeast(t, e, n) } }, { key: "isWithin", value: function () { return e.isTrue(this._matrix[W.INTERIOR][W.INTERIOR]) && this._matrix[W.INTERIOR][W.EXTERIOR] === Nt.FALSE && this._matrix[W.BOUNDARY][W.EXTERIOR] === Nt.FALSE } }, { key: "isTouches", value: function (t, n) { return t > n ? this.isTouches(n, t) : (t === Nt.A && n === Nt.A || t === Nt.L && n === Nt.L || t === Nt.L && n === Nt.A || t === Nt.P && n === Nt.A || t === Nt.P && n === Nt.L) && this._matrix[W.INTERIOR][W.INTERIOR] === Nt.FALSE && (e.isTrue(this._matrix[W.INTERIOR][W.BOUNDARY]) || e.isTrue(this._matrix[W.BOUNDARY][W.INTERIOR]) || e.isTrue(this._matrix[W.BOUNDARY][W.BOUNDARY])) } }, { key: "isOverlaps", value: function (t, n) { return t === Nt.P && n === Nt.P || t === Nt.A && n === Nt.A ? e.isTrue(this._matrix[W.INTERIOR][W.INTERIOR]) && e.isTrue(this._matrix[W.INTERIOR][W.EXTERIOR]) && e.isTrue(this._matrix[W.EXTERIOR][W.INTERIOR]) : t === Nt.L && n === Nt.L && 1 === this._matrix[W.INTERIOR][W.INTERIOR] && e.isTrue(this._matrix[W.INTERIOR][W.EXTERIOR]) && e.isTrue(this._matrix[W.EXTERIOR][W.INTERIOR]) } }, { key: "isEquals", value: function (t, n) { return t === n && e.isTrue(this._matrix[W.INTERIOR][W.INTERIOR]) && this._matrix[W.INTERIOR][W.EXTERIOR] === Nt.FALSE && this._matrix[W.BOUNDARY][W.EXTERIOR] === Nt.FALSE && this._matrix[W.EXTERIOR][W.INTERIOR] === Nt.FALSE && this._matrix[W.EXTERIOR][W.BOUNDARY] === Nt.FALSE } }, { key: "toString", value: function () { for (var t = new Qt("123456789"), e = 0; e < 3; e++)for (var n = 0; n < 3; n++)t.setCharAt(3 * e + n, Nt.toDimensionSymbol(this._matrix[e][n])); return t.toString() } }, { key: "setAll", value: function (t) { for (var e = 0; e < 3; e++)for (var n = 0; n < 3; n++)this._matrix[e][n] = t } }, { key: "get", value: function (t, e) { return this._matrix[t][e] } }, { key: "transpose", value: function () { var t = this._matrix[1][0]; return this._matrix[1][0] = this._matrix[0][1], this._matrix[0][1] = t, t = this._matrix[2][0], this._matrix[2][0] = this._matrix[0][2], this._matrix[0][2] = t, t = this._matrix[2][1], this._matrix[2][1] = this._matrix[1][2], this._matrix[1][2] = t, this } }, { key: "matches", value: function (t) { if (9 !== t.length) throw new b("Should be length 9: " + t); for (var n = 0; n < 3; n++)for (var r = 0; r < 3; r++)if (!e.matches(this._matrix[n][r], t.charAt(3 * n + r))) return !1; return !0 } }, { key: "add", value: function (t) { for (var e = 0; e < 3; e++)for (var n = 0; n < 3; n++)this.setAtLeast(e, n, t.get(e, n)) } }, { key: "isDisjoint", value: function () { return this._matrix[W.INTERIOR][W.INTERIOR] === Nt.FALSE && this._matrix[W.INTERIOR][W.BOUNDARY] === Nt.FALSE && this._matrix[W.BOUNDARY][W.INTERIOR] === Nt.FALSE && this._matrix[W.BOUNDARY][W.BOUNDARY] === Nt.FALSE } }, { key: "isCrosses", value: function (t, n) { return t === Nt.P && n === Nt.L || t === Nt.P && n === Nt.A || t === Nt.L && n === Nt.A ? e.isTrue(this._matrix[W.INTERIOR][W.INTERIOR]) && e.isTrue(this._matrix[W.INTERIOR][W.EXTERIOR]) : t === Nt.L && n === Nt.P || t === Nt.A && n === Nt.P || t === Nt.A && n === Nt.L ? e.isTrue(this._matrix[W.INTERIOR][W.INTERIOR]) && e.isTrue(this._matrix[W.EXTERIOR][W.INTERIOR]) : t === Nt.L && n === Nt.L && 0 === this._matrix[W.INTERIOR][W.INTERIOR] } }, { key: "interfaces_", get: function () { return [w] } }], [{ key: "constructor_", value: function () { if (this._matrix = null, 0 === arguments.length) this._matrix = Array(3).fill().map((function () { return Array(3) })), this.setAll(Nt.FALSE); else if (1 === arguments.length) if ("string" == typeof arguments[0]) { var t = arguments[0]; e.constructor_.call(this), this.set(t) } else if (arguments[0] instanceof e) { var n = arguments[0]; e.constructor_.call(this), this._matrix[W.INTERIOR][W.INTERIOR] = n._matrix[W.INTERIOR][W.INTERIOR], this._matrix[W.INTERIOR][W.BOUNDARY] = n._matrix[W.INTERIOR][W.BOUNDARY], this._matrix[W.INTERIOR][W.EXTERIOR] = n._matrix[W.INTERIOR][W.EXTERIOR], this._matrix[W.BOUNDARY][W.INTERIOR] = n._matrix[W.BOUNDARY][W.INTERIOR], this._matrix[W.BOUNDARY][W.BOUNDARY] = n._matrix[W.BOUNDARY][W.BOUNDARY], this._matrix[W.BOUNDARY][W.EXTERIOR] = n._matrix[W.BOUNDARY][W.EXTERIOR], this._matrix[W.EXTERIOR][W.INTERIOR] = n._matrix[W.EXTERIOR][W.INTERIOR], this._matrix[W.EXTERIOR][W.BOUNDARY] = n._matrix[W.EXTERIOR][W.BOUNDARY], this._matrix[W.EXTERIOR][W.EXTERIOR] = n._matrix[W.EXTERIOR][W.EXTERIOR] } } }, { key: "matches", value: function () { if (Number.isInteger(arguments[0]) && "string" == typeof arguments[1]) { var t = arguments[0], n = arguments[1]; return n === Nt.SYM_DONTCARE || n === Nt.SYM_TRUE && (t >= 0 || t === Nt.TRUE) || n === Nt.SYM_FALSE && t === Nt.FALSE || n === Nt.SYM_P && t === Nt.P || n === Nt.SYM_L && t === Nt.L || n === Nt.SYM_A && t === Nt.A } if ("string" == typeof arguments[0] && "string" == typeof arguments[1]) { var r = arguments[1]; return new e(arguments[0]).matches(r) } } }, { key: "isTrue", value: function (t) { return t >= 0 || t === Nt.TRUE } }]), e }(), er = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "size", value: function () { return this._size } }, { key: "addAll", value: function (t) { return null === t || 0 === t.length ? null : (this.ensureCapacity(this._size + t.length), bt.arraycopy(t, 0, this._data, this._size, t.length), void (this._size += t.length)) } }, { key: "ensureCapacity", value: function (t) { if (t <= this._data.length) return null; var e = Math.max(t, 2 * this._data.length); this._data = At.copyOf(this._data, e) } }, { key: "toArray", value: function () { var t = new Array(this._size).fill(null); return bt.arraycopy(this._data, 0, t, 0, this._size), t } }, { key: "add", value: function (t) { this.ensureCapacity(this._size + 1), this._data[this._size] = t, ++this._size } }], [{ key: "constructor_", value: function () { if (this._data = null, this._size = 0, 0 === arguments.length) e.constructor_.call(this, 10); else if (1 === arguments.length) { var t = arguments[0]; this._data = new Array(t).fill(null) } } }]), e }(), nr = function () { function e() { t(this, e) } return r(e, [{ key: "getChainStartIndices", value: function (t) { var e = 0, n = new er(Math.trunc(t.length / 2)); n.add(e); do { var r = this.findChainEnd(t, e); n.add(r), e = r } while (e < t.length - 1); return n.toArray() } }, { key: "findChainEnd", value: function (t, e) { for (var n = Ze.quadrant(t[e], t[e + 1]), r = e + 1; r < t.length && Ze.quadrant(t[r - 1], t[r]) === n;)r++; return r - 1 } }, { key: "OLDgetChainStartIndices", value: function (t) { var n = 0, r = new vt; r.add(n); do { var i = this.findChainEnd(t, n); r.add(i), n = i } while (n < t.length - 1); return e.toIntArray(r) } }], [{ key: "toIntArray", value: function (t) { for (var e = new Array(t.size()).fill(null), n = 0; n < e.length; n++)e[n] = t.get(n).intValue(); return e } }]), e }(), rr = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "getCoordinates", value: function () { return this.pts } }, { key: "getMaxX", value: function (t) { var e = this.pts[this.startIndex[t]].x, n = this.pts[this.startIndex[t + 1]].x; return e > n ? e : n } }, { key: "getMinX", value: function (t) { var e = this.pts[this.startIndex[t]].x, n = this.pts[this.startIndex[t + 1]].x; return e < n ? e : n } }, { key: "computeIntersectsForChain", value: function () { if (4 === arguments.length) { var t = arguments[0], e = arguments[1], n = arguments[2], r = arguments[3]; this.computeIntersectsForChain(this.startIndex[t], this.startIndex[t + 1], e, e.startIndex[n], e.startIndex[n + 1], r) } else if (6 === arguments.length) { var i = arguments[0], o = arguments[1], a = arguments[2], s = arguments[3], u = arguments[4], l = arguments[5]; if (o - i == 1 && u - s == 1) return l.addIntersections(this.e, i, a.e, s), null; if (!this.overlaps(i, o, a, s, u)) return null; var c = Math.trunc((i + o) / 2), h = Math.trunc((s + u) / 2); i < c && (s < h && this.computeIntersectsForChain(i, c, a, s, h, l), h < u && this.computeIntersectsForChain(i, c, a, h, u, l)), c < o && (s < h && this.computeIntersectsForChain(c, o, a, s, h, l), h < u && this.computeIntersectsForChain(c, o, a, h, u, l)) } } }, { key: "overlaps", value: function (t, e, n, r, i) { return U.intersects(this.pts[t], this.pts[e], n.pts[r], n.pts[i]) } }, { key: "getStartIndexes", value: function () { return this.startIndex } }, { key: "computeIntersects", value: function (t, e) { for (var n = 0; n < this.startIndex.length - 1; n++)for (var r = 0; r < t.startIndex.length - 1; r++)this.computeIntersectsForChain(n, t, r, e) } }], [{ key: "constructor_", value: function () { this.e = null, this.pts = null, this.startIndex = null; var t = arguments[0]; this.e = t, this.pts = t.getCoordinates(); var e = new nr; this.startIndex = e.getChainStartIndices(this.pts) } }]), e }(), ir = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "getDepth", value: function (t, e) { return this._depth[t][e] } }, { key: "setDepth", value: function (t, e, n) { this._depth[t][e] = n } }, { key: "isNull", value: function () { if (0 === arguments.length) { for (var t = 0; t < 2; t++)for (var n = 0; n < 3; n++)if (this._depth[t][n] !== e.NULL_VALUE) return !1; return !0 } if (1 === arguments.length) { var r = arguments[0]; return this._depth[r][1] === e.NULL_VALUE } if (2 === arguments.length) { var i = arguments[0], o = arguments[1]; return this._depth[i][o] === e.NULL_VALUE } } }, { key: "normalize", value: function () { for (var t = 0; t < 2; t++)if (!this.isNull(t)) { var e = this._depth[t][1]; this._depth[t][2] < e && (e = this._depth[t][2]), e < 0 && (e = 0); for (var n = 1; n < 3; n++) { var r = 0; this._depth[t][n] > e && (r = 1), this._depth[t][n] = r } } } }, { key: "getDelta", value: function (t) { return this._depth[t][tt.RIGHT] - this._depth[t][tt.LEFT] } }, { key: "getLocation", value: function (t, e) { return this._depth[t][e] <= 0 ? W.EXTERIOR : W.INTERIOR } }, { key: "toString", value: function () { return "A: " + this._depth[0][1] + "," + this._depth[0][2] + " B: " + this._depth[1][1] + "," + this._depth[1][2] } }, { key: "add", value: function () { if (1 === arguments.length) for (var t = arguments[0], n = 0; n < 2; n++)for (var r = 1; r < 3; r++) { var i = t.getLocation(n, r); i !== W.EXTERIOR && i !== W.INTERIOR || (this.isNull(n, r) ? this._depth[n][r] = e.depthAtLocation(i) : this._depth[n][r] += e.depthAtLocation(i)) } else if (3 === arguments.length) { var o = arguments[0], a = arguments[1]; arguments[2] === W.INTERIOR && this._depth[o][a]++ } } }], [{ key: "constructor_", value: function () { this._depth = Array(2).fill().map((function () { return Array(3) })); for (var t = 0; t < 2; t++)for (var n = 0; n < 3; n++)this._depth[t][n] = e.NULL_VALUE } }, { key: "depthAtLocation", value: function (t) { return t === W.EXTERIOR ? 0 : t === W.INTERIOR ? 1 : e.NULL_VALUE } }]), e }(); ir.NULL_VALUE = -1; var or = function (e) { i(a, e); var n = f(a); function a() { var e; return t(this, a), e = n.call(this), a.constructor_.apply(c(e), arguments), e } return r(a, [{ key: "getDepth", value: function () { return this._depth } }, { key: "getCollapsedEdge", value: function () { var t = new Array(2).fill(null); return t[0] = this.pts[0], t[1] = this.pts[1], new a(t, Ae.toLineLabel(this._label)) } }, { key: "isIsolated", value: function () { return this._isIsolated } }, { key: "getCoordinates", value: function () { return this.pts } }, { key: "setIsolated", value: function (t) { this._isIsolated = t } }, { key: "setName", value: function (t) { this._name = t } }, { key: "equals", value: function (t) { if (!(t instanceof a)) return !1; var e = t; if (this.pts.length !== e.pts.length) return !1; for (var n = !0, r = !0, i = this.pts.length, o = 0; o < this.pts.length; o++)if (this.pts[o].equals2D(e.pts[o]) || (n = !1), this.pts[o].equals2D(e.pts[--i]) || (r = !1), !n && !r) return !1; return !0 } }, { key: "getCoordinate", value: function () { if (0 === arguments.length) return this.pts.length > 0 ? this.pts[0] : null; if (1 === arguments.length) { var t = arguments[0]; return this.pts[t] } } }, { key: "print", value: function (t) { t.print("edge " + this._name + ": "), t.print("LINESTRING ("); for (var e = 0; e < this.pts.length; e++)e > 0 && t.print(","), t.print(this.pts[e].x + " " + this.pts[e].y); t.print(")  " + this._label + " " + this._depthDelta) } }, { key: "computeIM", value: function (t) { a.updateIM(this._label, t) } }, { key: "isCollapsed", value: function () { return !!this._label.isArea() && 3 === this.pts.length && !!this.pts[0].equals(this.pts[2]) } }, { key: "isClosed", value: function () { return this.pts[0].equals(this.pts[this.pts.length - 1]) } }, { key: "getMaximumSegmentIndex", value: function () { return this.pts.length - 1 } }, { key: "getDepthDelta", value: function () { return this._depthDelta } }, { key: "getNumPoints", value: function () { return this.pts.length } }, { key: "printReverse", value: function (t) { t.print("edge " + this._name + ": "); for (var e = this.pts.length - 1; e >= 0; e--)t.print(this.pts[e] + " "); t.println("") } }, { key: "getMonotoneChainEdge", value: function () { return null === this._mce && (this._mce = new rr(this)), this._mce } }, { key: "getEnvelope", value: function () { if (null === this._env) { this._env = new U; for (var t = 0; t < this.pts.length; t++)this._env.expandToInclude(this.pts[t]) } return this._env } }, { key: "addIntersection", value: function (t, e, n, r) { var i = new Y(t.getIntersection(r)), o = e, a = t.getEdgeDistance(n, r), s = o + 1; if (s < this.pts.length) { var u = this.pts[s]; i.equals2D(u) && (o = s, a = 0) } this.eiList.add(i, o, a) } }, { key: "toString", value: function () { var t = new Qt; t.append("edge " + this._name + ": "), t.append("LINESTRING ("); for (var e = 0; e < this.pts.length; e++)e > 0 && t.append(","), t.append(this.pts[e].x + " " + this.pts[e].y); return t.append(")  " + this._label + " " + this._depthDelta), t.toString() } }, { key: "isPointwiseEqual", value: function (t) { if (this.pts.length !== t.pts.length) return !1; for (var e = 0; e < this.pts.length; e++)if (!this.pts[e].equals2D(t.pts[e])) return !1; return !0 } }, { key: "setDepthDelta", value: function (t) { this._depthDelta = t } }, { key: "getEdgeIntersectionList", value: function () { return this.eiList } }, { key: "addIntersections", value: function (t, e, n) { for (var r = 0; r < t.getIntersectionNum(); r++)this.addIntersection(t, e, n, r) } }], [{ key: "constructor_", value: function () { if (this.pts = null, this._env = null, this.eiList = new Kn(this), this._name = null, this._mce = null, this._isIsolated = !0, this._depth = new ir, this._depthDelta = 0, 1 === arguments.length) { var t = arguments[0]; a.constructor_.call(this, t, null) } else if (2 === arguments.length) { var e = arguments[0], n = arguments[1]; this.pts = e, this._label = n } } }, { key: "updateIM", value: function () { if (!(2 === arguments.length && arguments[1] instanceof tr && arguments[0] instanceof Ae)) return p(o(a), "updateIM", this).apply(this, arguments); var t = arguments[0], e = arguments[1]; e.setAtLeastIfValid(t.getLocation(0, tt.ON), t.getLocation(1, tt.ON), 1), t.isArea() && (e.setAtLeastIfValid(t.getLocation(0, tt.LEFT), t.getLocation(1, tt.LEFT), 2), e.setAtLeastIfValid(t.getLocation(0, tt.RIGHT), t.getLocation(1, tt.RIGHT), 2)) } }]), a }(Be), ar = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "setWorkingPrecisionModel", value: function (t) { this._workingPrecisionModel = t } }, { key: "insertUniqueEdge", value: function (t) { var n = this._edgeList.findEqualEdge(t); if (null !== n) { var r = n.getLabel(), i = t.getLabel(); n.isPointwiseEqual(t) || (i = new Ae(t.getLabel())).flip(), r.merge(i); var o = e.depthDelta(i), a = n.getDepthDelta() + o; n.setDepthDelta(a) } else this._edgeList.add(t), t.setDepthDelta(e.depthDelta(t.getLabel())) } }, { key: "buildSubgraphs", value: function (t, e) { for (var n = new vt, r = t.iterator(); r.hasNext();) { var i = r.next(), o = i.getRightmostCoordinate(), a = new Dn(n).getDepth(o); i.computeDepth(a), i.findResultEdges(), n.add(i), e.add(i.getDirectedEdges(), i.getNodes()) } } }, { key: "createSubgraphs", value: function (t) { for (var e = new vt, n = t.getNodes().iterator(); n.hasNext();) { var r = n.next(); if (!r.isVisited()) { var i = new mt; i.create(r), e.add(i) } } return sn.sort(e, sn.reverseOrder()), e } }, { key: "createEmptyResultGeometry", value: function () { return this._geomFact.createPolygon() } }, { key: "getNoder", value: function (t) { if (null !== this._workingNoder) return this._workingNoder; var e = new Mn, n = new Le; return n.setPrecisionModel(t), e.setSegmentIntersector(new $n(n)), e } }, { key: "buffer", value: function (t, e) { var n = this._workingPrecisionModel; null === n && (n = t.getPrecisionModel()), this._geomFact = t.getFactory(); var r = new An(n, this._bufParams), i = new Vn(t, e, r).getCurves(); if (i.size() <= 0) return this.createEmptyResultGeometry(); this.computeNodedEdges(i, n), this._graph = new Ke(new Wn), this._graph.addEdges(this._edgeList.getEdges()); var o = this.createSubgraphs(this._graph), a = new tn(this._geomFact); this.buildSubgraphs(o, a); var s = a.getPolygons(); return s.size() <= 0 ? this.createEmptyResultGeometry() : this._geomFact.buildGeometry(s) } }, { key: "computeNodedEdges", value: function (t, e) { var n = this.getNoder(e); n.computeNodes(t); for (var r = n.getNodedSubstrings().iterator(); r.hasNext();) { var i = r.next(), o = i.getCoordinates(); if (2 !== o.length || !o[0].equals2D(o[1])) { var a = i.getData(), s = new or(i.getCoordinates(), new Ae(a)); this.insertUniqueEdge(s) } } } }, { key: "setNoder", value: function (t) { this._workingNoder = t } }], [{ key: "constructor_", value: function () { this._bufParams = null, this._workingPrecisionModel = null, this._workingNoder = null, this._geomFact = null, this._graph = null, this._edgeList = new Zn; var t = arguments[0]; this._bufParams = t } }, { key: "depthDelta", value: function (t) { var e = t.getLocation(0, tt.LEFT), n = t.getLocation(0, tt.RIGHT); return e === W.INTERIOR && n === W.EXTERIOR ? 1 : e === W.EXTERIOR && n === W.INTERIOR ? -1 : 0 } }, { key: "convertSegStrings", value: function (t) { for (var e = new se, n = new vt; t.hasNext();) { var r = t.next(), i = e.createLineString(r.getCoordinates()); n.add(i) } return e.buildGeometry(n) } }]), e }(), sr = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "rescale", value: function () { if (ot(arguments[0], H)) for (var t = arguments[0].iterator(); t.hasNext();) { var e = t.next(); this.rescale(e.getCoordinates()) } else if (arguments[0] instanceof Array) { for (var n = arguments[0], r = 0; r < n.length; r++)n[r].x = n[r].x / this._scaleFactor + this._offsetX, n[r].y = n[r].y / this._scaleFactor + this._offsetY; 2 === n.length && n[0].equals2D(n[1]) && bt.out.println(n) } } }, { key: "scale", value: function () { if (ot(arguments[0], H)) { for (var t = arguments[0], e = new vt(t.size()), n = t.iterator(); n.hasNext();) { var r = n.next(); e.add(new En(this.scale(r.getCoordinates()), r.getData())) } return e } if (arguments[0] instanceof Array) { for (var i = arguments[0], o = new Array(i.length).fill(null), a = 0; a < i.length; a++)o[a] = new Y(Math.round((i[a].x - this._offsetX) * this._scaleFactor), Math.round((i[a].y - this._offsetY) * this._scaleFactor), i[a].getZ()); return Zt.removeRepeatedPoints(o) } } }, { key: "isIntegerPrecision", value: function () { return 1 === this._scaleFactor } }, { key: "getNodedSubstrings", value: function () { var t = this._noder.getNodedSubstrings(); return this._isScaled && this.rescale(t), t } }, { key: "computeNodes", value: function (t) { var e = t; this._isScaled && (e = this.scale(t)), this._noder.computeNodes(e) } }, { key: "interfaces_", get: function () { return [Pn] } }], [{ key: "constructor_", value: function () { if (this._noder = null, this._scaleFactor = null, this._offsetX = null, this._offsetY = null, this._isScaled = !1, 2 === arguments.length) { var t = arguments[0], n = arguments[1]; e.constructor_.call(this, t, n, 0, 0) } else if (4 === arguments.length) { var r = arguments[0], i = arguments[1]; this._noder = r, this._scaleFactor = i, this._isScaled = !this.isIntegerPrecision() } } }]), e }(), ur = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "checkEndPtVertexIntersections", value: function () { if (0 === arguments.length) for (var t = this._segStrings.iterator(); t.hasNext();) { var e = t.next().getCoordinates(); this.checkEndPtVertexIntersections(e[0], this._segStrings), this.checkEndPtVertexIntersections(e[e.length - 1], this._segStrings) } else if (2 === arguments.length) for (var n = arguments[0], r = arguments[1].iterator(); r.hasNext();)for (var i = r.next().getCoordinates(), o = 1; o < i.length - 1; o++)if (i[o].equals(n)) throw new j("found endpt/interior pt intersection at index " + o + " :pt " + n) } }, { key: "checkInteriorIntersections", value: function () { if (0 === arguments.length) for (var t = this._segStrings.iterator(); t.hasNext();)for (var e = t.next(), n = this._segStrings.iterator(); n.hasNext();) { var r = n.next(); this.checkInteriorIntersections(e, r) } else if (2 === arguments.length) for (var i = arguments[0], o = arguments[1], a = i.getCoordinates(), s = o.getCoordinates(), u = 0; u < a.length - 1; u++)for (var l = 0; l < s.length - 1; l++)this.checkInteriorIntersections(i, u, o, l); else if (4 === arguments.length) { var c = arguments[0], h = arguments[1], f = arguments[2], p = arguments[3]; if (c === f && h === p) return null; var g = c.getCoordinates()[h], y = c.getCoordinates()[h + 1], v = f.getCoordinates()[p], d = f.getCoordinates()[p + 1]; if (this._li.computeIntersection(g, y, v, d), this._li.hasIntersection() && (this._li.isProper() || this.hasInteriorIntersection(this._li, g, y) || this.hasInteriorIntersection(this._li, v, d))) throw new j("found non-noded intersection at " + g + "-" + y + " and " + v + "-" + d) } } }, { key: "checkValid", value: function () { this.checkEndPtVertexIntersections(), this.checkInteriorIntersections(), this.checkCollapses() } }, { key: "checkCollapses", value: function () { if (0 === arguments.length) for (var t = this._segStrings.iterator(); t.hasNext();) { var e = t.next(); this.checkCollapses(e) } else if (1 === arguments.length) for (var n = arguments[0].getCoordinates(), r = 0; r < n.length - 2; r++)this.checkCollapse(n[r], n[r + 1], n[r + 2]) } }, { key: "hasInteriorIntersection", value: function (t, e, n) { for (var r = 0; r < t.getIntersectionNum(); r++) { var i = t.getIntersection(r); if (!i.equals(e) && !i.equals(n)) return !0 } return !1 } }, { key: "checkCollapse", value: function (t, n, r) { if (t.equals(r)) throw new j("found non-noded collapse at " + e.fact.createLineString([t, n, r])) } }], [{ key: "constructor_", value: function () { this._li = new Le, this._segStrings = null; var t = arguments[0]; this._segStrings = t } }]), e }(); ur.fact = new se; var lr = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "intersectsScaled", value: function (t, e) { var n = Math.min(t.x, e.x), r = Math.max(t.x, e.x), i = Math.min(t.y, e.y), o = Math.max(t.y, e.y), a = this._maxx < n || this._minx > r || this._maxy < i || this._miny > o; if (a) return !1; var s = this.intersectsToleranceSquare(t, e); return B.isTrue(!(a && s), "Found bad envelope test"), s } }, { key: "initCorners", value: function (t) { var e = .5; this._minx = t.x - e, this._maxx = t.x + e, this._miny = t.y - e, this._maxy = t.y + e, this._corner[0] = new Y(this._maxx, this._maxy), this._corner[1] = new Y(this._minx, this._maxy), this._corner[2] = new Y(this._minx, this._miny), this._corner[3] = new Y(this._maxx, this._miny) } }, { key: "intersects", value: function (t, e) { return 1 === this._scaleFactor ? this.intersectsScaled(t, e) : (this.copyScaled(t, this._p0Scaled), this.copyScaled(e, this._p1Scaled), this.intersectsScaled(this._p0Scaled, this._p1Scaled)) } }, { key: "scale", value: function (t) { return Math.round(t * this._scaleFactor) } }, { key: "getCoordinate", value: function () { return this._originalPt } }, { key: "copyScaled", value: function (t, e) { e.x = this.scale(t.x), e.y = this.scale(t.y) } }, { key: "getSafeEnvelope", value: function () { if (null === this._safeEnv) { var t = e.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor; this._safeEnv = new U(this._originalPt.x - t, this._originalPt.x + t, this._originalPt.y - t, this._originalPt.y + t) } return this._safeEnv } }, { key: "intersectsPixelClosure", value: function (t, e) { return this._li.computeIntersection(t, e, this._corner[0], this._corner[1]), !!(this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[1], this._corner[2]), this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[2], this._corner[3]), this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[3], this._corner[0]), this._li.hasIntersection())))) } }, { key: "intersectsToleranceSquare", value: function (t, e) { var n = !1, r = !1; return this._li.computeIntersection(t, e, this._corner[0], this._corner[1]), !!(this._li.isProper() || (this._li.computeIntersection(t, e, this._corner[1], this._corner[2]), this._li.isProper() || (this._li.hasIntersection() && (n = !0), this._li.computeIntersection(t, e, this._corner[2], this._corner[3]), this._li.isProper() || (this._li.hasIntersection() && (r = !0), this._li.computeIntersection(t, e, this._corner[3], this._corner[0]), this._li.isProper() || n && r || t.equals(this._pt) || e.equals(this._pt))))) } }, { key: "addSnappedNode", value: function (t, e) { var n = t.getCoordinate(e), r = t.getCoordinate(e + 1); return !!this.intersects(n, r) && (t.addIntersection(this.getCoordinate(), e), !0) } }], [{ key: "constructor_", value: function () { this._li = null, this._pt = null, this._originalPt = null, this._ptScaled = null, this._p0Scaled = null, this._p1Scaled = null, this._scaleFactor = null, this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, this._corner = new Array(4).fill(null), this._safeEnv = null; var t = arguments[0], e = arguments[1], n = arguments[2]; if (this._originalPt = t, this._pt = t, this._scaleFactor = e, this._li = n, e <= 0) throw new b("Scale factor must be non-zero"); 1 !== e && (this._pt = new Y(this.scale(t.x), this.scale(t.y)), this._p0Scaled = new Y, this._p1Scaled = new Y), this.initCorners(this._pt) } }]), e }(); lr.SAFE_ENV_EXPANSION_FACTOR = .75; var cr = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "select", value: function () { if (1 === arguments.length); else if (2 === arguments.length) { var t = arguments[1]; arguments[0].getLineSegment(t, this.selectedSegment), this.select(this.selectedSegment) } } }], [{ key: "constructor_", value: function () { this.selectedSegment = new wn } }]), e }(), hr = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "snap", value: function () { if (1 === arguments.length) { var e = arguments[0]; return this.snap(e, null, -1) } if (3 === arguments.length) { var n = arguments[0], i = arguments[1], o = arguments[2], a = n.getSafeEnvelope(), s = new fr(n, i, o); return this._index.query(a, new (function () { function e() { t(this, e) } return r(e, [{ key: "interfaces_", get: function () { return [cn] } }, { key: "visitItem", value: function (t) { t.select(a, s) } }]), e }())), s.isNodeAdded() } } }], [{ key: "constructor_", value: function () { this._index = null; var t = arguments[0]; this._index = t } }]), e }(), fr = function (e) { i(a, e); var n = f(a); function a() { var e; return t(this, a), e = n.call(this), a.constructor_.apply(c(e), arguments), e } return r(a, [{ key: "isNodeAdded", value: function () { return this._isNodeAdded } }, { key: "select", value: function () { if (!(2 === arguments.length && Number.isInteger(arguments[1]) && arguments[0] instanceof Sn)) return p(o(a.prototype), "select", this).apply(this, arguments); var t = arguments[1], e = arguments[0].getContext(); if (this._parentEdge === e && (t === this._hotPixelVertexIndex || t + 1 === this._hotPixelVertexIndex)) return null; this._isNodeAdded |= this._hotPixel.addSnappedNode(e, t) } }], [{ key: "constructor_", value: function () { this._hotPixel = null, this._parentEdge = null, this._hotPixelVertexIndex = null, this._isNodeAdded = !1; var t = arguments[0], e = arguments[1], n = arguments[2]; this._hotPixel = t, this._parentEdge = e, this._hotPixelVertexIndex = n } }]), a }(cr); hr.HotPixelSnapAction = fr; var pr = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "processIntersections", value: function (t, e, n, r) { if (t === n && e === r) return null; var i = t.getCoordinates()[e], o = t.getCoordinates()[e + 1], a = n.getCoordinates()[r], s = n.getCoordinates()[r + 1]; if (this._li.computeIntersection(i, o, a, s), this._li.hasIntersection() && this._li.isInteriorIntersection()) { for (var u = 0; u < this._li.getIntersectionNum(); u++)this._interiorIntersections.add(this._li.getIntersection(u)); t.addIntersections(this._li, e, 0), n.addIntersections(this._li, r, 1) } } }, { key: "isDone", value: function () { return !1 } }, { key: "getInteriorIntersections", value: function () { return this._interiorIntersections } }, { key: "interfaces_", get: function () { return [Jn] } }], [{ key: "constructor_", value: function () { this._li = null, this._interiorIntersections = null; var t = arguments[0]; this._li = t, this._interiorIntersections = new vt } }]), e }(), gr = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "checkCorrectness", value: function (t) { var e = En.getNodedSubstrings(t), n = new ur(e); try { n.checkValid() } catch (t) { if (!(t instanceof _)) throw t; t.printStackTrace() } } }, { key: "getNodedSubstrings", value: function () { return En.getNodedSubstrings(this._nodedSegStrings) } }, { key: "snapRound", value: function (t, e) { var n = this.findInteriorIntersections(t, e); this.computeIntersectionSnaps(n), this.computeVertexSnaps(t) } }, { key: "findInteriorIntersections", value: function (t, e) { var n = new pr(e); return this._noder.setSegmentIntersector(n), this._noder.computeNodes(t), n.getInteriorIntersections() } }, { key: "computeVertexSnaps", value: function () { if (ot(arguments[0], H)) for (var t = arguments[0].iterator(); t.hasNext();) { var e = t.next(); this.computeVertexSnaps(e) } else if (arguments[0] instanceof En) for (var n = arguments[0], r = n.getCoordinates(), i = 0; i < r.length; i++) { var o = new lr(r[i], this._scaleFactor, this._li); this._pointSnapper.snap(o, n, i) && n.addIntersection(r[i], i) } } }, { key: "computeNodes", value: function (t) { this._nodedSegStrings = t, this._noder = new Mn, this._pointSnapper = new hr(this._noder.getIndex()), this.snapRound(t, this._li) } }, { key: "computeIntersectionSnaps", value: function (t) { for (var e = t.iterator(); e.hasNext();) { var n = e.next(), r = new lr(n, this._scaleFactor, this._li); this._pointSnapper.snap(r) } } }, { key: "interfaces_", get: function () { return [Pn] } }], [{ key: "constructor_", value: function () { this._pm = null, this._li = null, this._scaleFactor = null, this._noder = null, this._pointSnapper = null, this._nodedSegStrings = null; var t = arguments[0]; this._pm = t, this._li = new Le, this._li.setPrecisionModel(t), this._scaleFactor = t.getScale() } }]), e }(), yr = function () { function e() { t(this, e), e.constructor_.apply(this, arguments) } return r(e, [{ key: "bufferFixedPrecision", value: function (t) { var e = new sr(new gr(new ie(1)), t.getScale()), n = new ar(this._bufParams); n.setWorkingPrecisionModel(t), n.setNoder(e), this._resultGeometry = n.buffer(this._argGeom, this._distance) } }, { key: "bufferReducedPrecision", value: function () { if (0 === arguments.length) { for (var t = e.MAX_PRECISION_DIGITS; t >= 0; t--) { try { this.bufferReducedPrecision(t) } catch (t) { if (!(t instanceof gt)) throw t; this._saveException = t } if (null !== this._resultGeometry) return null } throw this._saveException } if (1 === arguments.length) { var n = arguments[0], r = e.precisionScaleFactor(this._argGeom, this._distance, n), i = new ie(r); this.bufferFixedPrecision(i) } } }, { key: "computeGeometry", value: function () { if (this.bufferOriginalPrecision(), null !== this._resultGeometry) return null; var t = this._argGeom.getFactory().getPrecisionModel(); t.getType() === ie.FIXED ? this.bufferFixedPrecision(t) : this.bufferReducedPrecision() } }, { key: "setQuadrantSegments", value: function (t) { this._bufParams.setQuadrantSegments(t) } }, { key: "bufferOriginalPrecision", value: function () { try { var t = new ar(this._bufParams); this._resultGeometry = t.buffer(this._argGeom, this._distance) } catch (t) { if (!(t instanceof j)) throw t; this._saveException = t } } }, { key: "getResultGeometry", value: function (t) { return this._distance = t, this.computeGeometry(), this._resultGeometry } }, { key: "setEndCapStyle", value: function (t) { this._bufParams.setEndCapStyle(t) } }], [{ key: "constructor_", value: function () { if (this._argGeom = null, this._distance = null, this._bufParams = new m, this._resultGeometry = null, this._saveException = null, 1 === arguments.length) { var t = arguments[0]; this._argGeom = t } else if (2 === arguments.length) { var e = arguments[0], n = arguments[1]; this._argGeom = e, this._bufParams = n } } }, { key: "bufferOp", value: function () { if (2 === arguments.length) { var t = arguments[1]; return new e(arguments[0]).getResultGeometry(t) } if (3 === arguments.length) { if (Number.isInteger(arguments[2]) && arguments[0] instanceof X && "number" == typeof arguments[1]) { var n = arguments[1], r = arguments[2], i = new e(arguments[0]); return i.setQuadrantSegments(r), i.getResultGeometry(n) } if (arguments[2] instanceof m && arguments[0] instanceof X && "number" == typeof arguments[1]) { var o = arguments[1]; return new e(arguments[0], arguments[2]).getResultGeometry(o) } } else if (4 === arguments.length) { var a = arguments[1], s = arguments[2], u = arguments[3], l = new e(arguments[0]); return l.setQuadrantSegments(s), l.setEndCapStyle(u), l.getResultGeometry(a) } } }, { key: "precisionScaleFactor", value: function (t, e, n) { var r = t.getEnvelopeInternal(), i = xt.max(Math.abs(r.getMaxX()), Math.abs(r.getMaxY()), Math.abs(r.getMinX()), Math.abs(r.getMinY())) + 2 * (e > 0 ? e : 0), o = n - Math.trunc(Math.log(i) / Math.log(10) + 1); return Math.pow(10, o) } }]), e }(); yr.CAP_ROUND = m.CAP_ROUND, yr.CAP_BUTT = m.CAP_FLAT, yr.CAP_FLAT = m.CAP_FLAT, yr.CAP_SQUARE = m.CAP_SQUARE, yr.MAX_PRECISION_DIGITS = 12; var vr = ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"], dr = function () { function e(n) { t(this, e), this.geometryFactory = n || new se } return r(e, [{ key: "read", value: function (t) { var e, n = (e = "string" == typeof t ? JSON.parse(t) : t).type; if (!mr[n]) throw new Error("Unknown GeoJSON type: " + e.type); return -1 !== vr.indexOf(n) ? mr[n].call(this, e.coordinates) : "GeometryCollection" === n ? mr[n].call(this, e.geometries) : mr[n].call(this, e) } }, { key: "write", value: function (t) { var e = t.getGeometryType(); if (!_r[e]) throw new Error("Geometry is not supported"); return _r[e].call(this, t) } }]), e }(), mr = { Feature: function (t) { var e = {}; for (var n in t) e[n] = t[n]; if (t.geometry) { var r = t.geometry.type; if (!mr[r]) throw new Error("Unknown GeoJSON type: " + t.type); e.geometry = this.read(t.geometry) } return t.bbox && (e.bbox = mr.bbox.call(this, t.bbox)), e }, FeatureCollection: function (t) { var e = {}; if (t.features) { e.features = []; for (var n = 0; n < t.features.length; ++n)e.features.push(this.read(t.features[n])) } return t.bbox && (e.bbox = this.parse.bbox.call(this, t.bbox)), e }, coordinates: function (t) { for (var e = [], n = 0; n < t.length; ++n) { var r = t[n]; e.push(u(Y, g(r))) } return e }, bbox: function (t) { return this.geometryFactory.createLinearRing([new Y(t[0], t[1]), new Y(t[2], t[1]), new Y(t[2], t[3]), new Y(t[0], t[3]), new Y(t[0], t[1])]) }, Point: function (t) { var e = u(Y, g(t)); return this.geometryFactory.createPoint(e) }, MultiPoint: function (t) { for (var e = [], n = 0; n < t.length; ++n)e.push(mr.Point.call(this, t[n])); return this.geometryFactory.createMultiPoint(e) }, LineString: function (t) { var e = mr.coordinates.call(this, t); return this.geometryFactory.createLineString(e) }, MultiLineString: function (t) { for (var e = [], n = 0; n < t.length; ++n)e.push(mr.LineString.call(this, t[n])); return this.geometryFactory.createMultiLineString(e) }, Polygon: function (t) { for (var e = mr.coordinates.call(this, t[0]), n = this.geometryFactory.createLinearRing(e), r = [], i = 1; i < t.length; ++i) { var o = t[i], a = mr.coordinates.call(this, o), s = this.geometryFactory.createLinearRing(a); r.push(s) } return this.geometryFactory.createPolygon(n, r) }, MultiPolygon: function (t) { for (var e = [], n = 0; n < t.length; ++n) { var r = t[n]; e.push(mr.Polygon.call(this, r)) } return this.geometryFactory.createMultiPolygon(e) }, GeometryCollection: function (t) { for (var e = [], n = 0; n < t.length; ++n) { var r = t[n]; e.push(this.read(r)) } return this.geometryFactory.createGeometryCollection(e) } }, _r = { coordinate: function (t) { var e = [t.x, t.y]; return t.z && e.push(t.z), t.m && e.push(t.m), e }, Point: function (t) { return { type: "Point", coordinates: _r.coordinate.call(this, t.getCoordinate()) } }, MultiPoint: function (t) { for (var e = [], n = 0; n < t._geometries.length; ++n) { var r = t._geometries[n], i = _r.Point.call(this, r); e.push(i.coordinates) } return { type: "MultiPoint", coordinates: e } }, LineString: function (t) { for (var e = [], n = t.getCoordinates(), r = 0; r < n.length; ++r) { var i = n[r]; e.push(_r.coordinate.call(this, i)) } return { type: "LineString", coordinates: e } }, MultiLineString: function (t) { for (var e = [], n = 0; n < t._geometries.length; ++n) { var r = t._geometries[n], i = _r.LineString.call(this, r); e.push(i.coordinates) } return { type: "MultiLineString", coordinates: e } }, Polygon: function (t) { var e = [], n = _r.LineString.call(this, t._shell); e.push(n.coordinates); for (var r = 0; r < t._holes.length; ++r) { var i = t._holes[r], o = _r.LineString.call(this, i); e.push(o.coordinates) } return { type: "Polygon", coordinates: e } }, MultiPolygon: function (t) { for (var e = [], n = 0; n < t._geometries.length; ++n) { var r = t._geometries[n], i = _r.Polygon.call(this, r); e.push(i.coordinates) } return { type: "MultiPolygon", coordinates: e } }, GeometryCollection: function (t) { for (var e = [], n = 0; n < t._geometries.length; ++n) { var r = t._geometries[n], i = r.getGeometryType(); e.push(_r[i].call(this, r)) } return { type: "GeometryCollection", geometries: e } } }; return { BufferOp: yr, GeoJSONReader: function () { function e(n) { t(this, e), this.parser = new dr(n || new se) } return r(e, [{ key: "read", value: function (t) { return this.parser.read(t) } }]), e }(), GeoJSONWriter: function () { function e() { t(this, e), this.parser = new dr(this.geometryFactory) } return r(e, [{ key: "write", value: function (t) { return this.parser.write(t) } }]), e }() } }() }(lp); var cp = p(lp.exports); function hp() { return new fp } function fp() { this.reset() } fp.prototype = { constructor: fp, reset: function () { this.s = this.t = 0 }, add: function (t) { gp(pp, t, this.t), gp(this, pp.s, this.s), this.s ? this.t += pp.t : this.s = pp.t }, valueOf: function () { return this.s } }; var pp = new fp; function gp(t, e, n) { var r = t.s = e + n, i = r - e, o = r - i; t.t = e - o + (n - i) } var yp = 1e-6, vp = Math.PI, dp = vp / 2, mp = vp / 4, _p = 2 * vp, bp = 180 / vp, xp = vp / 180, Ep = Math.abs, wp = Math.atan, kp = Math.atan2, Sp = Math.cos, Ip = Math.sin, Pp = Math.sqrt; function Np(t) { return t > 1 ? 0 : t < -1 ? vp : Math.acos(t) } function Mp(t) { return t > 1 ? dp : t < -1 ? -dp : Math.asin(t) } function Op() { } function Lp(t, e) { t && Ap.hasOwnProperty(t.type) && Ap[t.type](t, e) } var Rp, Cp, Tp = { Feature: function (t, e) { Lp(t.geometry, e) }, FeatureCollection: function (t, e) { for (var n = t.features, r = -1, i = n.length; ++r < i;)Lp(n[r].geometry, e) } }, Ap = { Sphere: function (t, e) { e.sphere() }, Point: function (t, e) { t = t.coordinates, e.point(t[0], t[1], t[2]) }, MultiPoint: function (t, e) { for (var n = t.coordinates, r = -1, i = n.length; ++r < i;)t = n[r], e.point(t[0], t[1], t[2]) }, LineString: function (t, e) { Dp(t.coordinates, e, 0) }, MultiLineString: function (t, e) { for (var n = t.coordinates, r = -1, i = n.length; ++r < i;)Dp(n[r], e, 0) }, Polygon: function (t, e) { jp(t.coordinates, e) }, MultiPolygon: function (t, e) { for (var n = t.coordinates, r = -1, i = n.length; ++r < i;)jp(n[r], e) }, GeometryCollection: function (t, e) { for (var n = t.geometries, r = -1, i = n.length; ++r < i;)Lp(n[r], e) } }; function Dp(t, e, n) { var r, i = -1, o = t.length - n; for (e.lineStart(); ++i < o;)r = t[i], e.point(r[0], r[1], r[2]); e.lineEnd() } function jp(t, e) { var n = -1, r = t.length; for (e.polygonStart(); ++n < r;)Dp(t[n], e, 1); e.polygonEnd() } function Fp(t) { return [kp(t[1], t[0]), Mp(t[2])] } function Bp(t) { var e = t[0], n = t[1], r = Sp(n); return [r * Sp(e), r * Ip(e), Ip(n)] } function qp(t, e) { return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] } function Vp(t, e) { return [t[1] * e[2] - t[2] * e[1], t[2] * e[0] - t[0] * e[2], t[0] * e[1] - t[1] * e[0]] } function Gp(t, e) { t[0] += e[0], t[1] += e[1], t[2] += e[2] } function Yp(t, e) { return [t[0] * e, t[1] * e, t[2] * e] } function zp(t) { var e = Pp(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]); t[0] /= e, t[1] /= e, t[2] /= e } function Up(t, e) { function n(n, r) { return n = t(n, r), e(n[0], n[1]) } return t.invert && e.invert && (n.invert = function (n, r) { return (n = e.invert(n, r)) && t.invert(n[0], n[1]) }), n } function Xp(t, e) { return [t > vp ? t - _p : t < -vp ? t + _p : t, e] } function Wp(t) { return function (e, n) { return [(e += t) > vp ? e - _p : e < -vp ? e + _p : e, n] } } function Hp(t) { var e = Wp(t); return e.invert = Wp(-t), e } function Zp(t, e) { var n = Sp(t), r = Ip(t), i = Sp(e), o = Ip(e); function a(t, e) { var a = Sp(e), s = Sp(t) * a, u = Ip(t) * a, l = Ip(e), c = l * n + s * r; return [kp(u * i - c * o, s * n - l * r), Mp(c * i + u * o)] } return a.invert = function (t, e) { var a = Sp(e), s = Sp(t) * a, u = Ip(t) * a, l = Ip(e), c = l * i - u * o; return [kp(u * i + l * o, s * n + c * r), Mp(c * n - s * r)] }, a } function Jp(t, e) { (e = Bp(e))[0] -= t, zp(e); var n = Np(-e[1]); return ((-e[2] < 0 ? -n : n) + _p - yp) % _p } function $p() { var t, e = []; return { point: function (e, n) { t.push([e, n]) }, lineStart: function () { e.push(t = []) }, lineEnd: Op, rejoin: function () { e.length > 1 && e.push(e.pop().concat(e.shift())) }, result: function () { var n = e; return e = [], t = null, n } } } function Qp(t, e) { return Ep(t[0] - e[0]) < yp && Ep(t[1] - e[1]) < yp } function Kp(t, e, n, r) { this.x = t, this.z = e, this.o = n, this.e = r, this.v = !1, this.n = this.p = null } function tg(t, e, n, r, i) { var o, a, s = [], u = []; if (t.forEach((function (t) { if (!((e = t.length - 1) <= 0)) { var e, n, r = t[0], a = t[e]; if (Qp(r, a)) { for (i.lineStart(), o = 0; o < e; ++o)i.point((r = t[o])[0], r[1]); i.lineEnd() } else s.push(n = new Kp(r, t, null, !0)), u.push(n.o = new Kp(r, null, n, !1)), s.push(n = new Kp(a, t, null, !1)), u.push(n.o = new Kp(a, null, n, !0)) } })), s.length) { for (u.sort(e), eg(s), eg(u), o = 0, a = u.length; o < a; ++o)u[o].e = n = !n; for (var l, c, h = s[0]; ;) { for (var f = h, p = !0; f.v;)if ((f = f.n) === h) return; l = f.z, i.lineStart(); do { if (f.v = f.o.v = !0, f.e) { if (p) for (o = 0, a = l.length; o < a; ++o)i.point((c = l[o])[0], c[1]); else r(f.x, f.n.x, 1, i); f = f.n } else { if (p) for (l = f.p.z, o = l.length - 1; o >= 0; --o)i.point((c = l[o])[0], c[1]); else r(f.x, f.p.x, -1, i); f = f.p } l = (f = f.o).z, p = !p } while (!f.v); i.lineEnd() } } } function eg(t) { if (e = t.length) { for (var e, n, r = 0, i = t[0]; ++r < e;)i.n = n = t[r], n.p = i, i = n; i.n = n = t[0], n.p = i } } function ng(t, e) { return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN } function rg(t) { for (var e, n, r, i = t.length, o = -1, a = 0; ++o < i;)a += t[o].length; for (n = new Array(a); --i >= 0;)for (e = (r = t[i]).length; --e >= 0;)n[--a] = r[e]; return n } hp(), hp(), hp(), Xp.invert = Xp, 1 === (Rp = ng).length && (Cp = Rp, Rp = function (t, e) { return ng(Cp(t), e) }); var ig = 1e9, og = -ig; function ag(t, e, n, r) { function i(i, o) { return t <= i && i <= n && e <= o && o <= r } function o(i, o, s, l) { var c = 0, h = 0; if (null == i || (c = a(i, s)) !== (h = a(o, s)) || u(i, o) < 0 ^ s > 0) do { l.point(0 === c || 3 === c ? t : n, c > 1 ? r : e) } while ((c = (c + s + 4) % 4) !== h); else l.point(o[0], o[1]) } function a(r, i) { return Ep(r[0] - t) < yp ? i > 0 ? 0 : 3 : Ep(r[0] - n) < yp ? i > 0 ? 2 : 1 : Ep(r[1] - e) < yp ? i > 0 ? 1 : 0 : i > 0 ? 3 : 2 } function s(t, e) { return u(t.x, e.x) } function u(t, e) { var n = a(t, 1), r = a(e, 1); return n !== r ? n - r : 0 === n ? e[1] - t[1] : 1 === n ? t[0] - e[0] : 2 === n ? t[1] - e[1] : e[0] - t[0] } return function (a) { var u, l, c, h, f, p, g, y, v, d, m, _ = a, b = $p(), x = { point: E, lineStart: function () { x.point = w, l && l.push(c = []); d = !0, v = !1, g = y = NaN }, lineEnd: function () { u && (w(h, f), p && v && b.rejoin(), u.push(b.result())); x.point = E, v && _.lineEnd() }, polygonStart: function () { _ = b, u = [], l = [], m = !0 }, polygonEnd: function () { var e = function () { for (var e = 0, n = 0, i = l.length; n < i; ++n)for (var o, a, s = l[n], u = 1, c = s.length, h = s[0], f = h[0], p = h[1]; u < c; ++u)o = f, a = p, f = (h = s[u])[0], p = h[1], a <= r ? p > r && (f - o) * (r - a) > (p - a) * (t - o) && ++e : p <= r && (f - o) * (r - a) < (p - a) * (t - o) && --e; return e }(), n = m && e, i = (u = rg(u)).length; (n || i) && (a.polygonStart(), n && (a.lineStart(), o(null, null, 1, a), a.lineEnd()), i && tg(u, s, e, o, a), a.polygonEnd()); _ = a, u = l = c = null } }; function E(t, e) { i(t, e) && _.point(t, e) } function w(o, a) { var s = i(o, a); if (l && c.push([o, a]), d) h = o, f = a, p = s, d = !1, s && (_.lineStart(), _.point(o, a)); else if (s && v) _.point(o, a); else { var u = [g = Math.max(og, Math.min(ig, g)), y = Math.max(og, Math.min(ig, y))], b = [o = Math.max(og, Math.min(ig, o)), a = Math.max(og, Math.min(ig, a))]; !function (t, e, n, r, i, o) { var a, s = t[0], u = t[1], l = 0, c = 1, h = e[0] - s, f = e[1] - u; if (a = n - s, h || !(a > 0)) { if (a /= h, h < 0) { if (a < l) return; a < c && (c = a) } else if (h > 0) { if (a > c) return; a > l && (l = a) } if (a = i - s, h || !(a < 0)) { if (a /= h, h < 0) { if (a > c) return; a > l && (l = a) } else if (h > 0) { if (a < l) return; a < c && (c = a) } if (a = r - u, f || !(a > 0)) { if (a /= f, f < 0) { if (a < l) return; a < c && (c = a) } else if (f > 0) { if (a > c) return; a > l && (l = a) } if (a = o - u, f || !(a < 0)) { if (a /= f, f < 0) { if (a > c) return; a > l && (l = a) } else if (f > 0) { if (a < l) return; a < c && (c = a) } return l > 0 && (t[0] = s + l * h, t[1] = u + l * f), c < 1 && (e[0] = s + c * h, e[1] = u + c * f), !0 } } } } }(u, b, t, e, n, r) ? s && (_.lineStart(), _.point(o, a), m = !1) : (v || (_.lineStart(), _.point(u[0], u[1])), _.point(b[0], b[1]), s || _.lineEnd(), m = !1) } g = o, y = a, v = s } return x } } var sg = hp(); function ug(t) { return t } hp(), hp(), hp(); var lg = 1 / 0, cg = lg, hg = -lg, fg = hg, pg = { point: function (t, e) { t < lg && (lg = t); t > hg && (hg = t); e < cg && (cg = e); e > fg && (fg = e) }, lineStart: Op, lineEnd: Op, polygonStart: Op, polygonEnd: Op, result: function () { var t = [[lg, cg], [hg, fg]]; return hg = fg = -(cg = lg = 1 / 0), t } }; function gg(t, e, n, r) { return function (i, o) { var a, s, u, l = e(o), c = i.invert(r[0], r[1]), h = $p(), f = e(h), p = !1, g = { point: y, lineStart: d, lineEnd: m, polygonStart: function () { g.point = _, g.lineStart = b, g.lineEnd = x, s = [], a = [] }, polygonEnd: function () { g.point = y, g.lineStart = d, g.lineEnd = m, s = rg(s); var t = function (t, e) { var n = e[0], r = e[1], i = [Ip(n), -Sp(n), 0], o = 0, a = 0; sg.reset(); for (var s = 0, u = t.length; s < u; ++s)if (c = (l = t[s]).length) for (var l, c, h = l[c - 1], f = h[0], p = h[1] / 2 + mp, g = Ip(p), y = Sp(p), v = 0; v < c; ++v, f = m, g = b, y = x, h = d) { var d = l[v], m = d[0], _ = d[1] / 2 + mp, b = Ip(_), x = Sp(_), E = m - f, w = E >= 0 ? 1 : -1, k = w * E, S = k > vp, I = g * b; if (sg.add(kp(I * w * Ip(k), y * x + I * Sp(k))), o += S ? E + w * _p : E, S ^ f >= n ^ m >= n) { var P = Vp(Bp(h), Bp(d)); zp(P); var N = Vp(i, P); zp(N); var M = (S ^ E >= 0 ? -1 : 1) * Mp(N[2]); (r > M || r === M && (P[0] || P[1])) && (a += S ^ E >= 0 ? 1 : -1) } } return (o < -yp || o < yp && sg < -yp) ^ 1 & a }(a, c); s.length ? (p || (o.polygonStart(), p = !0), tg(s, vg, t, n, o)) : t && (p || (o.polygonStart(), p = !0), o.lineStart(), n(null, null, 1, o), o.lineEnd()), p && (o.polygonEnd(), p = !1), s = a = null }, sphere: function () { o.polygonStart(), o.lineStart(), n(null, null, 1, o), o.lineEnd(), o.polygonEnd() } }; function y(e, n) { var r = i(e, n); t(e = r[0], n = r[1]) && o.point(e, n) } function v(t, e) { var n = i(t, e); l.point(n[0], n[1]) } function d() { g.point = v, l.lineStart() } function m() { g.point = y, l.lineEnd() } function _(t, e) { u.push([t, e]); var n = i(t, e); f.point(n[0], n[1]) } function b() { f.lineStart(), u = [] } function x() { _(u[0][0], u[0][1]), f.lineEnd(); var t, e, n, r, i = f.clean(), l = h.result(), c = l.length; if (u.pop(), a.push(u), u = null, c) if (1 & i) { if ((e = (n = l[0]).length - 1) > 0) { for (p || (o.polygonStart(), p = !0), o.lineStart(), t = 0; t < e; ++t)o.point((r = n[t])[0], r[1]); o.lineEnd() } } else c > 1 && 2 & i && l.push(l.pop().concat(l.shift())), s.push(l.filter(yg)) } return g } } function yg(t) { return t.length > 1 } function vg(t, e) { return ((t = t.x)[0] < 0 ? t[1] - dp - yp : dp - t[1]) - ((e = e.x)[0] < 0 ? e[1] - dp - yp : dp - e[1]) } hp(); var dg = gg((function () { return !0 }), (function (t) { var e, n = NaN, r = NaN, i = NaN; return { lineStart: function () { t.lineStart(), e = 1 }, point: function (o, a) { var s = o > 0 ? vp : -vp, u = Ep(o - n); Ep(u - vp) < yp ? (t.point(n, r = (r + a) / 2 > 0 ? dp : -dp), t.point(i, r), t.lineEnd(), t.lineStart(), t.point(s, r), t.point(o, r), e = 0) : i !== s && u >= vp && (Ep(n - i) < yp && (n -= i * yp), Ep(o - s) < yp && (o -= s * yp), r = function (t, e, n, r) { var i, o, a = Ip(t - n); return Ep(a) > yp ? wp((Ip(e) * (o = Sp(r)) * Ip(n) - Ip(r) * (i = Sp(e)) * Ip(t)) / (i * o * a)) : (e + r) / 2 }(n, r, o, a), t.point(i, r), t.lineEnd(), t.lineStart(), t.point(s, r), e = 0), t.point(n = o, r = a), i = s }, lineEnd: function () { t.lineEnd(), n = r = NaN }, clean: function () { return 2 - e } } }), (function (t, e, n, r) { var i; if (null == t) i = n * dp, r.point(-vp, i), r.point(0, i), r.point(vp, i), r.point(vp, 0), r.point(vp, -i), r.point(0, -i), r.point(-vp, -i), r.point(-vp, 0), r.point(-vp, i); else if (Ep(t[0] - e[0]) > yp) { var o = t[0] < e[0] ? vp : -vp; i = n * o / 2, r.point(-o, i), r.point(0, i), r.point(o, i) } else r.point(e[0], e[1]) }), [-vp, -dp]); function mg(t, e) { var n = Sp(t), r = n > 0, i = Ep(n) > yp; function o(t, e) { return Sp(t) * Sp(e) > n } function a(t, e, r) { var i = [1, 0, 0], o = Vp(Bp(t), Bp(e)), a = qp(o, o), s = o[0], u = a - s * s; if (!u) return !r && t; var l = n * a / u, c = -n * s / u, h = Vp(i, o), f = Yp(i, l); Gp(f, Yp(o, c)); var p = h, g = qp(f, p), y = qp(p, p), v = g * g - y * (qp(f, f) - 1); if (!(v < 0)) { var d = Pp(v), m = Yp(p, (-g - d) / y); if (Gp(m, f), m = Fp(m), !r) return m; var _, b = t[0], x = e[0], E = t[1], w = e[1]; x < b && (_ = b, b = x, x = _); var k = x - b, S = Ep(k - vp) < yp; if (!S && w < E && (_ = E, E = w, w = _), S || k < yp ? S ? E + w > 0 ^ m[1] < (Ep(m[0] - b) < yp ? E : w) : E <= m[1] && m[1] <= w : k > vp ^ (b <= m[0] && m[0] <= x)) { var I = Yp(p, (-g + d) / y); return Gp(I, f), [m, Fp(I)] } } } function s(e, n) { var i = r ? t : vp - t, o = 0; return e < -i ? o |= 1 : e > i && (o |= 2), n < -i ? o |= 4 : n > i && (o |= 8), o } return gg(o, (function (t) { var e, n, u, l, c; return { lineStart: function () { l = u = !1, c = 1 }, point: function (h, f) { var p, g = [h, f], y = o(h, f), v = r ? y ? 0 : s(h, f) : y ? s(h + (h < 0 ? vp : -vp), f) : 0; if (!e && (l = u = y) && t.lineStart(), y !== u && (!(p = a(e, g)) || Qp(e, p) || Qp(g, p)) && (g[0] += yp, g[1] += yp, y = o(g[0], g[1])), y !== u) c = 0, y ? (t.lineStart(), p = a(g, e), t.point(p[0], p[1])) : (p = a(e, g), t.point(p[0], p[1]), t.lineEnd()), e = p; else if (i && e && r ^ y) { var d; v & n || !(d = a(g, e, !0)) || (c = 0, r ? (t.lineStart(), t.point(d[0][0], d[0][1]), t.point(d[1][0], d[1][1]), t.lineEnd()) : (t.point(d[1][0], d[1][1]), t.lineEnd(), t.lineStart(), t.point(d[0][0], d[0][1]))) } !y || e && Qp(e, g) || t.point(g[0], g[1]), e = g, u = y, n = v }, lineEnd: function () { u && t.lineEnd(), e = null }, clean: function () { return c | (l && u) << 1 } } }), (function (n, r, i, o) { !function (t, e, n, r, i, o) { if (n) { var a = Sp(e), s = Ip(e), u = r * n; null == i ? (i = e + r * _p, o = e - u / 2) : (i = Jp(a, i), o = Jp(a, o), (r > 0 ? i < o : i > o) && (i += r * _p)); for (var l, c = i; r > 0 ? c > o : c < o; c -= u)l = Fp([a, -s * Sp(c), -s * Ip(c)]), t.point(l[0], l[1]) } }(o, t, e, i, n, r) }), r ? [0, -t] : [-vp, t - vp]) } function _g(t) { return function (e) { var n = new bg; for (var r in t) n[r] = t[r]; return n.stream = e, n } } function bg() { } function xg(t, e, n) { var r = e[1][0] - e[0][0], i = e[1][1] - e[0][1], o = t.clipExtent && t.clipExtent(); t.scale(150).translate([0, 0]), null != o && t.clipExtent(null), function (t, e) { t && Tp.hasOwnProperty(t.type) ? Tp[t.type](t, e) : Lp(t, e) }(n, t.stream(pg)); var a = pg.result(), s = Math.min(r / (a[1][0] - a[0][0]), i / (a[1][1] - a[0][1])), u = +e[0][0] + (r - s * (a[1][0] + a[0][0])) / 2, l = +e[0][1] + (i - s * (a[1][1] + a[0][1])) / 2; return null != o && t.clipExtent(o), t.scale(150 * s).translate([u, l]) } bg.prototype = { constructor: bg, point: function (t, e) { this.stream.point(t, e) }, sphere: function () { this.stream.sphere() }, lineStart: function () { this.stream.lineStart() }, lineEnd: function () { this.stream.lineEnd() }, polygonStart: function () { this.stream.polygonStart() }, polygonEnd: function () { this.stream.polygonEnd() } }; var Eg = 16, wg = Sp(30 * xp); function kg(t, e) { return +e ? function (t, e) { function n(r, i, o, a, s, u, l, c, h, f, p, g, y, v) { var d = l - r, m = c - i, _ = d * d + m * m; if (_ > 4 * e && y--) { var b = a + f, x = s + p, E = u + g, w = Pp(b * b + x * x + E * E), k = Mp(E /= w), S = Ep(Ep(E) - 1) < yp || Ep(o - h) < yp ? (o + h) / 2 : kp(x, b), I = t(S, k), P = I[0], N = I[1], M = P - r, O = N - i, L = m * M - d * O; (L * L / _ > e || Ep((d * M + m * O) / _ - .5) > .3 || a * f + s * p + u * g < wg) && (n(r, i, o, a, s, u, P, N, S, b /= w, x /= w, E, y, v), v.point(P, N), n(P, N, S, b, x, E, l, c, h, f, p, g, y, v)) } } return function (e) { var r, i, o, a, s, u, l, c, h, f, p, g, y = { point: v, lineStart: d, lineEnd: _, polygonStart: function () { e.polygonStart(), y.lineStart = b }, polygonEnd: function () { e.polygonEnd(), y.lineStart = d } }; function v(n, r) { n = t(n, r), e.point(n[0], n[1]) } function d() { c = NaN, y.point = m, e.lineStart() } function m(r, i) { var o = Bp([r, i]), a = t(r, i); n(c, h, l, f, p, g, c = a[0], h = a[1], l = r, f = o[0], p = o[1], g = o[2], Eg, e), e.point(c, h) } function _() { y.point = v, e.lineEnd() } function b() { d(), y.point = x, y.lineEnd = E } function x(t, e) { m(r = t, e), i = c, o = h, a = f, s = p, u = g, y.point = m } function E() { n(c, h, l, f, p, g, i, o, r, a, s, u, Eg, e), y.lineEnd = _, _() } return y } }(t, e) : function (t) { return _g({ point: function (e, n) { e = t(e, n), this.stream.point(e[0], e[1]) } }) }(t) } var Sg = _g({ point: function (t, e) { this.stream.point(t * xp, e * xp) } }); function Ig(t) { return function (t) { var e, n, r, i, o, a, s, u, l, c, h = 150, f = 480, p = 250, g = 0, y = 0, v = 0, d = 0, m = 0, _ = null, b = dg, x = null, E = ug, w = .5, k = kg(P, w); function S(t) { return [(t = o(t[0] * xp, t[1] * xp))[0] * h + n, r - t[1] * h] } function I(t) { return (t = o.invert((t[0] - n) / h, (r - t[1]) / h)) && [t[0] * bp, t[1] * bp] } function P(t, i) { return [(t = e(t, i))[0] * h + n, r - t[1] * h] } function N() { o = Up(i = function (t, e, n) { return (t %= _p) ? e || n ? Up(Hp(t), Zp(e, n)) : Hp(t) : e || n ? Zp(e, n) : Xp }(v, d, m), e); var t = e(g, y); return n = f - t[0] * h, r = p + t[1] * h, M() } function M() { return l = c = null, S } return S.stream = function (t) { return l && c === t ? l : l = Sg(b(i, k(E(c = t)))) }, S.clipAngle = function (t) { return arguments.length ? (b = +t ? mg(_ = t * xp, 6 * xp) : (_ = null, dg), M()) : _ * bp }, S.clipExtent = function (t) { return arguments.length ? (E = null == t ? (x = a = s = u = null, ug) : ag(x = +t[0][0], a = +t[0][1], s = +t[1][0], u = +t[1][1]), M()) : null == x ? null : [[x, a], [s, u]] }, S.scale = function (t) { return arguments.length ? (h = +t, N()) : h }, S.translate = function (t) { return arguments.length ? (f = +t[0], p = +t[1], N()) : [f, p] }, S.center = function (t) { return arguments.length ? (g = t[0] % 360 * xp, y = t[1] % 360 * xp, N()) : [g * bp, y * bp] }, S.rotate = function (t) { return arguments.length ? (v = t[0] % 360 * xp, d = t[1] % 360 * xp, m = t.length > 2 ? t[2] % 360 * xp : 0, N()) : [v * bp, d * bp, m * bp] }, S.precision = function (t) { return arguments.length ? (k = kg(P, w = t * t), M()) : Pp(w) }, S.fitExtent = function (t, e) { return xg(S, t, e) }, S.fitSize = function (t, e) { return function (t, e, n) { return xg(t, [[0, 0], e], n) }(S, t, e) }, function () { return e = t.apply(this, arguments), S.invert = e.invert && I, N() } }((function () { return t }))() } function Pg(t) { return function (e, n) { var r = Sp(e), i = Sp(n), o = t(r * i); return [o * i * Ip(e), o * Ip(n)] } } function Ng(t) { return function (e, n) { var r = Pp(e * e + n * n), i = t(r), o = Ip(i), a = Sp(i); return [kp(e * o, r * a), Mp(r && n * o / r)] } } Pg((function (t) { return Pp(2 / (1 + t)) })).invert = Ng((function (t) { return 2 * Mp(t / 2) })); var Mg = Pg((function (t) { return (t = Np(t)) && t / Ip(t) })); function Og(t, e) { return [t, e] } Mg.invert = Ng((function (t) { return t })), Og.invert = Og; var Lg = Object.defineProperty, Rg = function (t, e) { return Lg(t, "name", { value: e, configurable: !0 }) }, Cg = cp.BufferOp, Tg = cp.GeoJSONReader, Ag = cp.GeoJSONWriter; function Dg(t, n, r) { var i = (r = r || {}).units || "kilometers", o = r.steps || 8; if (!t) throw new Error("geojson is required"); if ("object" !== e(r)) throw new Error("options must be an object"); if ("number" != typeof o) throw new Error("steps must be an number"); if (void 0 === n) throw new Error("radius is required"); if (o <= 0) throw new Error("steps must be greater than 0"); var a = []; switch (t.type) { case "GeometryCollection": return jl(t, (function (t) { var e = jg(t, n, i, o); e && a.push(e) })), ju(a); case "FeatureCollection": return Tl(t, (function (t) { var e = jg(t, n, i, o); e && Tl(e, (function (t) { t && a.push(t) })) })), ju(a) }return jg(t, n, i, o) } function jg(t, e, n, r) { var i = t.properties || {}, o = "Feature" === t.type ? t.geometry : t; if ("GeometryCollection" === o.type) { var a = []; return jl(t, (function (t) { var i = jg(t, e, n, r); i && a.push(i) })), ju(a) } var s = Vg(o), u = { type: o.type, coordinates: Bg(o.coordinates, s) }, l = (new Tg).read(u), c = Yu(zu(e, n), "meters"), h = Cg.bufferOp(l, c, r); if (!Fg((h = (new Ag).write(h)).coordinates)) return Mu({ type: h.type, coordinates: qg(h.coordinates, s) }, i) } function Fg(t) { return Array.isArray(t[0]) ? Fg(t[0]) : isNaN(t[0]) } function Bg(t, n) { return "object" !== e(t[0]) ? n(t) : t.map((function (t) { return Bg(t, n) })) } function qg(t, n) { return "object" !== e(t[0]) ? n.invert(t) : t.map((function (t) { return qg(t, n) })) } function Vg(t) { var e = up(t).geometry.coordinates, n = [-e[0], -e[1]]; return Ig(Mg).scale(79.4188).clipAngle(179.999).rotate(n).scale(Iu) } Rg(Dg, "buffer"), Rg(jg, "bufferFeature"), Rg(Fg, "coordsIsNaN"), Rg(Bg, "projectCoords"), Rg(qg, "unprojectCoords"), Rg(Vg, "defineProjection"); var Gg = Object.defineProperty; function Yg(t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = 0, r = 0, i = 0; return jl(t, (function (t, o, a) { var s = e.weight ? null == a ? void 0 : a[e.weight] : void 0; if (!$u(s = null == s ? 1 : s)) throw new Error("weight value must be a number for feature index " + o); (s = Number(s)) > 0 && Ol(t, (function (t) { n += t[0] * s, r += t[1] * s, i += s })) })), Lu([n / i, r / i], e.properties, e) } !function (t, e) { Gg(t, "name", { value: e, configurable: !0 }) }(Yg, "centerMean"); var zg = Object.defineProperty; function Ug(t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = 0, r = 0, i = 0; return Ol(t, (function (t) { n += t[0], r += t[1], i++ }), !0), Lu([n / i, r / i], e.properties) } !function (t, e) { zg(t, "name", { value: e, configurable: !0 }) }(Ug, "centroid"); var Xg = Object.defineProperty, Wg = function (t, e) { return Xg(t, "name", { value: e, configurable: !0 }) }; function Hg(t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (!Qu(e = e || {})) throw new Error("options is invalid"); var n = e.counter || 10; if (!$u(n)) throw new Error("counter must be a number"); var r = e.weight, i = Yg(t, { weight: e.weight }), o = ju([]); Tl(t, (function (t) { var e; o.features.push(Ug(t, { properties: { weight: null == (e = t.properties) ? void 0 : e[r] } })) })); var a = { tolerance: e.tolerance, medianCandidates: [] }; return Zg(i.geometry.coordinates, [0, 0], o, a, n) } function Zg(t, e, n, r, i) { var o = r.tolerance || .001, a = 0, s = 0, u = 0, l = 0; if (Tl(n, (function (e) { var n, r = null == (n = e.properties) ? void 0 : n.weight, i = null == r ? 1 : r; if (!$u(i = Number(i))) throw new Error("weight value must be a number"); if (i > 0) { l += 1; var o = i * _l(e, t); 0 === o && (o = 1); var c = i / o; a += e.geometry.coordinates[0] * c, s += e.geometry.coordinates[1] * c, u += c } })), l < 1) throw new Error("no features to measure"); var c = a / u, h = s / u; return 1 === l || 0 === i || Math.abs(c - e[0]) < o && Math.abs(h - e[1]) < o ? Lu([c, h], { medianCandidates: r.medianCandidates }) : (r.medianCandidates.push([c, h]), Zg([c, h], t, n, r, i - 1)) } Wg(Hg, "centerMedian"), Wg(Zg, "findMedian"); var Jg = { exports: {} }, $g = g(sf), Qg = function () { function t() { var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Kg; if (n(this, t), this.data = e, this.length = this.data.length, this.compare = r, this.length > 0) for (var i = (this.length >> 1) - 1; i >= 0; i--)this._down(i) } return i(t, [{ key: "push", value: function (t) { this.data.push(t), this.length++, this._up(this.length - 1) } }, { key: "pop", value: function () { if (0 !== this.length) { var t = this.data[0], e = this.data.pop(); return this.length--, this.length > 0 && (this.data[0] = e, this._down(0)), t } } }, { key: "peek", value: function () { return this.data[0] } }, { key: "_up", value: function (t) { for (var e = this.data, n = this.compare, r = e[t]; t > 0;) { var i = t - 1 >> 1, o = e[i]; if (n(r, o) >= 0) break; e[t] = o, t = i } e[t] = r } }, { key: "_down", value: function (t) { for (var e = this.data, n = this.compare, r = this.length >> 1, i = e[t]; t < r;) { var o = 1 + (t << 1), a = e[o], s = o + 1; if (s < this.length && n(e[s], a) < 0 && (o = s, a = e[s]), n(a, i) >= 0) break; e[t] = a, t = o } e[t] = i } }]), t }(); function Kg(t, e) { return t < e ? -1 : t > e ? 1 : 0 } var ty = g(Object.freeze({ __proto__: null, default: Qg })), ey = { exports: {} }, ny = function (t, e, n, r) { var i = t[0], o = t[1], a = !1; void 0 === n && (n = 0), void 0 === r && (r = e.length); for (var s = (r - n) / 2, u = 0, l = s - 1; u < s; l = u++) { var c = e[n + 2 * u + 0], h = e[n + 2 * u + 1], f = e[n + 2 * l + 0], p = e[n + 2 * l + 1]; h > o != p > o && i < (f - c) * (o - h) / (p - h) + c && (a = !a) } return a }, ry = function (t, e, n, r) { var i = t[0], o = t[1], a = !1; void 0 === n && (n = 0), void 0 === r && (r = e.length); for (var s = r - n, u = 0, l = s - 1; u < s; l = u++) { var c = e[u + n][0], h = e[u + n][1], f = e[l + n][0], p = e[l + n][1]; h > o != p > o && i < (f - c) * (o - h) / (p - h) + c && (a = !a) } return a }; ey.exports = function (t, e, n, r) { return e.length > 0 && Array.isArray(e[0]) ? ry(t, e, n, r) : ny(t, e, n, r) }, ey.exports.nested = ry, ey.exports.flat = ny; var iy = ey.exports, oy = { exports: {} }; !function (t, e) { !function (t) { var e = 134217729, n = 33306690738754706e-32; function r(t, e, n, r, i) { var o, a, s, u, l = e[0], c = r[0], h = 0, f = 0; c > l == c > -l ? (o = l, l = e[++h]) : (o = c, c = r[++f]); var p = 0; if (h < t && f < n) for (c > l == c > -l ? (s = o - ((a = l + o) - l), l = e[++h]) : (s = o - ((a = c + o) - c), c = r[++f]), o = a, 0 !== s && (i[p++] = s); h < t && f < n;)c > l == c > -l ? (s = o - ((a = o + l) - (u = a - o)) + (l - u), l = e[++h]) : (s = o - ((a = o + c) - (u = a - o)) + (c - u), c = r[++f]), o = a, 0 !== s && (i[p++] = s); for (; h < t;)s = o - ((a = o + l) - (u = a - o)) + (l - u), l = e[++h], o = a, 0 !== s && (i[p++] = s); for (; f < n;)s = o - ((a = o + c) - (u = a - o)) + (c - u), c = r[++f], o = a, 0 !== s && (i[p++] = s); return 0 === o && 0 !== p || (i[p++] = o), p } function i(t) { return new Float64Array(t) } var o = 33306690738754716e-32, a = 22204460492503146e-32, s = 11093356479670487e-47, u = i(4), l = i(8), c = i(12), h = i(16), f = i(4); t.orient2d = function (t, i, p, g, y, v) { var d = (i - v) * (p - y), m = (t - y) * (g - v), _ = d - m; if (0 === d || 0 === m || d > 0 != m > 0) return _; var b = Math.abs(d + m); return Math.abs(_) >= o * b ? _ : -function (t, i, o, p, g, y, v) { var d, m, _, b, x, E, w, k, S, I, P, N, M, O, L, R, C, T, A = t - g, D = o - g, j = i - y, F = p - y; x = (L = (k = A - (w = (E = e * A) - (E - A))) * (I = F - (S = (E = e * F) - (E - F))) - ((O = A * F) - w * S - k * S - w * I)) - (P = L - (C = (k = j - (w = (E = e * j) - (E - j))) * (I = D - (S = (E = e * D) - (E - D))) - ((R = j * D) - w * S - k * S - w * I))), u[0] = L - (P + x) + (x - C), x = (M = O - ((N = O + P) - (x = N - O)) + (P - x)) - (P = M - R), u[1] = M - (P + x) + (x - R), x = (T = N + P) - N, u[2] = N - (T - x) + (P - x), u[3] = T; var B = function (t, e) { for (var n = e[0], r = 1; r < t; r++)n += e[r]; return n }(4, u), q = a * v; if (B >= q || -B >= q) return B; if (d = t - (A + (x = t - A)) + (x - g), _ = o - (D + (x = o - D)) + (x - g), m = i - (j + (x = i - j)) + (x - y), b = p - (F + (x = p - F)) + (x - y), 0 === d && 0 === m && 0 === _ && 0 === b) return B; if (q = s * v + n * Math.abs(B), (B += A * b + F * d - (j * _ + D * m)) >= q || -B >= q) return B; x = (L = (k = d - (w = (E = e * d) - (E - d))) * (I = F - (S = (E = e * F) - (E - F))) - ((O = d * F) - w * S - k * S - w * I)) - (P = L - (C = (k = m - (w = (E = e * m) - (E - m))) * (I = D - (S = (E = e * D) - (E - D))) - ((R = m * D) - w * S - k * S - w * I))), f[0] = L - (P + x) + (x - C), x = (M = O - ((N = O + P) - (x = N - O)) + (P - x)) - (P = M - R), f[1] = M - (P + x) + (x - R), x = (T = N + P) - N, f[2] = N - (T - x) + (P - x), f[3] = T; var V = r(4, u, 4, f, l); x = (L = (k = A - (w = (E = e * A) - (E - A))) * (I = b - (S = (E = e * b) - (E - b))) - ((O = A * b) - w * S - k * S - w * I)) - (P = L - (C = (k = j - (w = (E = e * j) - (E - j))) * (I = _ - (S = (E = e * _) - (E - _))) - ((R = j * _) - w * S - k * S - w * I))), f[0] = L - (P + x) + (x - C), x = (M = O - ((N = O + P) - (x = N - O)) + (P - x)) - (P = M - R), f[1] = M - (P + x) + (x - R), x = (T = N + P) - N, f[2] = N - (T - x) + (P - x), f[3] = T; var G = r(V, l, 4, f, c); x = (L = (k = d - (w = (E = e * d) - (E - d))) * (I = b - (S = (E = e * b) - (E - b))) - ((O = d * b) - w * S - k * S - w * I)) - (P = L - (C = (k = m - (w = (E = e * m) - (E - m))) * (I = _ - (S = (E = e * _) - (E - _))) - ((R = m * _) - w * S - k * S - w * I))), f[0] = L - (P + x) + (x - C), x = (M = O - ((N = O + P) - (x = N - O)) + (P - x)) - (P = M - R), f[1] = M - (P + x) + (x - R), x = (T = N + P) - N, f[2] = N - (T - x) + (P - x), f[3] = T; var Y = r(G, c, 4, f, h); return h[Y - 1] }(t, i, p, g, y, v, b) }, t.orient2dfast = function (t, e, n, r, i, o) { return (e - o) * (n - i) - (t - i) * (r - o) }, Object.defineProperty(t, "__esModule", { value: !0 }) }(e) }(0, oy.exports); var ay = $g, sy = ty, uy = iy, ly = oy.exports.orient2d; function cy(t, e, n) { e = Math.max(0, void 0 === e ? 2 : e), n = n || 0; var r = function (t) { for (var e = t[0], n = t[0], r = t[0], i = t[0], o = 0; o < t.length; o++) { var a = t[o]; a[0] < e[0] && (e = a), a[0] > r[0] && (r = a), a[1] < n[1] && (n = a), a[1] > i[1] && (i = a) } var s = [e, n, r, i], u = s.slice(); for (o = 0; o < t.length; o++)uy(t[o], s) || u.push(t[o]); return function (t) { t.sort(Ey); for (var e = [], n = 0; n < t.length; n++) { for (; e.length >= 2 && vy(e[e.length - 2], e[e.length - 1], t[n]) <= 0;)e.pop(); e.push(t[n]) } for (var r = [], i = t.length - 1; i >= 0; i--) { for (; r.length >= 2 && vy(r[r.length - 2], r[r.length - 1], t[i]) <= 0;)r.pop(); r.push(t[i]) } return r.pop(), e.pop(), e.concat(r) }(u) }(t), i = new ay(16); i.toBBox = function (t) { return { minX: t[0], minY: t[1], maxX: t[0], maxY: t[1] } }, i.compareMinX = function (t, e) { return t[0] - e[0] }, i.compareMinY = function (t, e) { return t[1] - e[1] }, i.load(t); for (var o, a = [], s = 0; s < r.length; s++) { var u = r[s]; i.remove(u), o = my(u, o), a.push(o) } var l = new ay(16); for (s = 0; s < a.length; s++)l.insert(dy(a[s])); for (var c = e * e, h = n * n; a.length;) { var f = a.shift(), p = f.p, g = f.next.p, y = _y(p, g); if (!(y < h)) { var v = y / c; (u = hy(i, f.prev.p, p, g, f.next.next.p, v, l)) && Math.min(_y(u, p), _y(u, g)) <= v && (a.push(f), a.push(my(u, f)), i.remove(u), l.remove(f), l.insert(dy(f)), l.insert(dy(f.next))) } } f = o; var d = []; do { d.push(f.p), f = f.next } while (f !== o); return d.push(f.p), d } function hy(t, e, n, r, i, o, a) { for (var s = new sy([], fy), u = t.data; u;) { for (var l = 0; l < u.children.length; l++) { var c = u.children[l], h = u.leaf ? by(c, n, r) : py(n, r, c); h > o || s.push({ node: c, dist: h }) } for (; s.length && !s.peek().node.children;) { var f = s.pop(), p = f.node, g = by(p, e, n), y = by(p, r, i); if (f.dist < g && f.dist < y && yy(n, p, a) && yy(r, p, a)) return p } (u = s.pop()) && (u = u.node) } return null } function fy(t, e) { return t.dist - e.dist } function py(t, e, n) { if (gy(t, n) || gy(e, n)) return 0; var r = xy(t[0], t[1], e[0], e[1], n.minX, n.minY, n.maxX, n.minY); if (0 === r) return 0; var i = xy(t[0], t[1], e[0], e[1], n.minX, n.minY, n.minX, n.maxY); if (0 === i) return 0; var o = xy(t[0], t[1], e[0], e[1], n.maxX, n.minY, n.maxX, n.maxY); if (0 === o) return 0; var a = xy(t[0], t[1], e[0], e[1], n.minX, n.maxY, n.maxX, n.maxY); return 0 === a ? 0 : Math.min(r, i, o, a) } function gy(t, e) { return t[0] >= e.minX && t[0] <= e.maxX && t[1] >= e.minY && t[1] <= e.maxY } function yy(t, e, n) { for (var r, i, o, a, s = Math.min(t[0], e[0]), u = Math.min(t[1], e[1]), l = Math.max(t[0], e[0]), c = Math.max(t[1], e[1]), h = n.search({ minX: s, minY: u, maxX: l, maxY: c }), f = 0; f < h.length; f++)if (r = h[f].p, i = h[f].next.p, o = t, r !== (a = e) && i !== o && vy(r, i, o) > 0 != vy(r, i, a) > 0 && vy(o, a, r) > 0 != vy(o, a, i) > 0) return !1; return !0 } function vy(t, e, n) { return ly(t[0], t[1], e[0], e[1], n[0], n[1]) } function dy(t) { var e = t.p, n = t.next.p; return t.minX = Math.min(e[0], n[0]), t.minY = Math.min(e[1], n[1]), t.maxX = Math.max(e[0], n[0]), t.maxY = Math.max(e[1], n[1]), t } function my(t, e) { var n = { p: t, prev: null, next: null, minX: 0, minY: 0, maxX: 0, maxY: 0 }; return e ? (n.next = e.next, n.prev = e, e.next.prev = n, e.next = n) : (n.prev = n, n.next = n), n } function _y(t, e) { var n = t[0] - e[0], r = t[1] - e[1]; return n * n + r * r } function by(t, e, n) { var r = e[0], i = e[1], o = n[0] - r, a = n[1] - i; if (0 !== o || 0 !== a) { var s = ((t[0] - r) * o + (t[1] - i) * a) / (o * o + a * a); s > 1 ? (r = n[0], i = n[1]) : s > 0 && (r += o * s, i += a * s) } return (o = t[0] - r) * o + (a = t[1] - i) * a } function xy(t, e, n, r, i, o, a, s) { var u, l, c, h, f = n - t, p = r - e, g = a - i, y = s - o, v = t - i, d = e - o, m = f * f + p * p, _ = f * g + p * y, b = g * g + y * y, x = f * v + p * d, E = g * v + y * d, w = m * b - _ * _, k = w, S = w; 0 === w ? (l = 0, k = 1, h = E, S = b) : (h = m * E - _ * x, (l = _ * E - b * x) < 0 ? (l = 0, h = E, S = b) : l > k && (l = k, h = E + _, S = b)), h < 0 ? (h = 0, -x < 0 ? l = 0 : -x > m ? l = k : (l = -x, k = m)) : h > S && (h = S, -x + _ < 0 ? l = 0 : -x + _ > m ? l = k : (l = -x + _, k = m)); var I = (1 - (c = 0 === h ? 0 : h / S)) * i + c * a - ((1 - (u = 0 === l ? 0 : l / k)) * t + u * n), P = (1 - c) * o + c * s - ((1 - u) * e + u * r); return I * I + P * P } function Ey(t, e) { return t[0] === e[0] ? t[1] - e[1] : t[0] - e[0] } sy.default && (sy = sy.default), Jg.exports = cy, Jg.exports.default = cy; var wy = p(Jg.exports), ky = Object.defineProperty; function Sy(t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; e.concavity = e.concavity || 1 / 0; var n = []; if (Ol(t, (function (t) { n.push([t[0], t[1]]) })), !n.length) return null; var r = wy(n, e.concavity); return r.length > 3 ? Cu([r]) : null } !function (t, e) { ky(t, "name", { value: e, configurable: !0 }) }(Sy, "convex"); var Iy = Object.defineProperty; function Py(t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; switch (hl(t)) { case "Point": return Lu(il(t), e.properties); case "Polygon": var n = []; Ol(t, (function (t) { n.push(t) })); var r, i, o, a, s, u, l, c, h = Ug(t, { properties: e.properties }), f = h.geometry.coordinates, p = 0, g = 0, y = 0, v = n.map((function (t) { return [t[0] - f[0], t[1] - f[1]] })); for (r = 0; r < n.length - 1; r++)a = (i = v[r])[0], u = i[1], s = (o = v[r + 1])[0], y += c = a * (l = o[1]) - s * u, p += (a + s) * c, g += (u + l) * c; if (0 === y) return h; var d = 1 / (6 * (.5 * y)); return Lu([f[0] + d * p, f[1] + d * g], e.properties); default: var m = Sy(t); return m ? Py(m, { properties: e.properties }) : Ug(t, { properties: e.properties }) } } !function (t, e) { Iy(t, "name", { value: e, configurable: !0 }) }(Py, "centerOfMass"); var Ny = Object.defineProperty; function My(t, e) { for (var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r = n.steps || 64, i = n.properties ? n.properties : !Array.isArray(t) && "Feature" === t.type && t.properties ? t.properties : {}, o = [], a = 0; a < r; a++)o.push(dl(t, e, -360 * a / r, n).geometry.coordinates); return o.push(o[0]), Cu([o], i) } !function (t, e) { Ny(t, "name", { value: e, configurable: !0 }) }(My, "circle"); var Oy = Object.defineProperty, Ly = function (t, e) { return Oy(t, "name", { value: e, configurable: !0 }) }; function Ry(t) { if (!t) throw new Error("geojson is required"); switch (t.type) { case "Feature": return Cy(t); case "FeatureCollection": return Ay(t); case "Point": case "LineString": case "Polygon": case "MultiPoint": case "MultiLineString": case "MultiPolygon": case "GeometryCollection": return Dy(t); default: throw new Error("unknown GeoJSON type") } } function Cy(t) { var e = { type: "Feature" }; return Object.keys(t).forEach((function (n) { switch (n) { case "type": case "properties": case "geometry": return; default: e[n] = t[n] } })), e.properties = Ty(t.properties), null == t.geometry ? e.geometry = null : e.geometry = Dy(t.geometry), e } function Ty(t) { var n = {}; return t ? (Object.keys(t).forEach((function (r) { var i = t[r]; "object" === e(i) ? null === i ? n[r] = null : Array.isArray(i) ? n[r] = i.map((function (t) { return t })) : n[r] = Ty(i) : n[r] = i })), n) : n } function Ay(t) { var e = { type: "FeatureCollection" }; return Object.keys(t).forEach((function (n) { switch (n) { case "type": case "features": return; default: e[n] = t[n] } })), e.features = t.features.map((function (t) { return Cy(t) })), e } function Dy(t) { var e = { type: t.type }; return t.bbox && (e.bbox = t.bbox), "GeometryCollection" === t.type ? (e.geometries = t.geometries.map((function (t) { return Dy(t) })), e) : (e.coordinates = jy(t.coordinates), e) } function jy(t) { var n = t; return "object" !== e(n[0]) ? n.slice() : n.map((function (t) { return jy(t) })) } Ly(Ry, "clone"), Ly(Cy, "cloneFeature"), Ly(Ty, "cloneProperties"), Ly(Ay, "cloneFeatureCollection"), Ly(Dy, "cloneGeometry"), Ly(jy, "deepSlice"); var Fy = Object.defineProperty, By = function (t, e) { return Fy(t, "name", { value: e, configurable: !0 }) }; function qy(t, e) { if (!t) throw new Error("geojson is required"); if ("FeatureCollection" !== t.type) throw new Error("geojson must be a FeatureCollection"); if (null == e) throw new Error("filter is required"); var n = []; return Tl(t, (function (t) { zy(t.properties, e) && n.push(t) })), ju(n) } function Vy(t, e, n) { if (!t) throw new Error("geojson is required"); if ("FeatureCollection" !== t.type) throw new Error("geojson must be a FeatureCollection"); if (null == e) throw new Error("property is required"); for (var r = Yy(t, e), i = Object.keys(r), o = 0; o < i.length; o++) { for (var a = i[o], s = r[a], u = [], l = 0; l < s.length; l++)u.push(t.features[s[l]]); n(ju(u), a, o) } } function Gy(t, e, n, r) { var i = r; return Vy(t, e, (function (t, e, o) { i = 0 === o && void 0 === r ? t : n(i, t, e, o) })), i } function Yy(t, e) { var n = {}; return Tl(t, (function (t, r) { var i = t.properties || {}; if (Object.prototype.hasOwnProperty.call(i, String(e))) { var o = i[e]; Object.prototype.hasOwnProperty.call(n, o) ? n[o].push(r) : n[o] = [r] } })), n } function zy(t, n) { if (void 0 === t) return !1; var r = e(n); if ("number" === r || "string" === r) return Object.prototype.hasOwnProperty.call(t, n); if (Array.isArray(n)) { for (var i = 0; i < n.length; i++)if (!zy(t, n[i])) return !1; return !0 } return Uy(t, n) } function Uy(t, e) { for (var n = Object.keys(e), r = 0; r < n.length; r++) { var i = n[r]; if (t[i] !== e[i]) return !1 } return !0 } function Xy(t, e) { if (!e) return {}; if (!e.length) return {}; for (var n = {}, r = 0; r < e.length; r++) { var i = e[r]; Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]) } return n } By(qy, "getCluster"), By(Vy, "clusterEach"), By(Gy, "clusterReduce"), By(Yy, "createBins"), By(zy, "applyFilter"), By(Uy, "propertiesContainsFilter"), By(Xy, "filterProperties"); var Wy = Object.freeze({ __proto__: null, applyFilter: zy, clusterEach: Vy, clusterReduce: Gy, createBins: Yy, filterProperties: Xy, getCluster: qy, propertiesContainsFilter: Uy }), Hy = Object.defineProperty, Zy = function (t, e) { return Hy(t, "name", { value: e, configurable: !0 }) }, Jy = Wh; function $y(t, e) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; !0 !== n.mutate && (t = Ry(t)); var r = n.minPoints || 3, i = Uu(e, n.units), o = new Jy(t.features.length), u = t.features.map((function (t) { return !1 })), l = t.features.map((function (t) { return !1 })), c = t.features.map((function (t) { return !1 })), h = t.features.map((function (t) { return -1 })); o.load(t.features.map((function (t, e) { var n = a(t.geometry.coordinates, 2), r = n[0], i = n[1]; return { minX: r, minY: i, maxX: r, maxY: i, index: e } }))); var f = Zy((function (n) { var r = t.features[n], s = a(r.geometry.coordinates, 2), u = s[0], l = s[1], c = Math.max(l - i, -90), h = Math.min(l + i, 90), f = c < 0 && h > 0 ? i : Math.abs(c) < Math.abs(h) ? i / Math.cos(Hu(h)) : i / Math.cos(Hu(c)), p = Math.max(u - f, -360), g = Math.min(u + f, 360), y = { minX: p, minY: c, maxX: g, maxY: h }; return o.search(y).filter((function (n) { var i = n.index, o = t.features[i]; return _l(r, o, { units: "kilometers" }) <= e })) }), "regionQuery"), p = Zy((function (t, e) { for (var n = 0; n < e.length; n++) { var i = e[n].index; if (!u[i]) { u[i] = !0; var o = f(i); o.length >= r && e.push.apply(e, s(o)) } l[i] || (l[i] = !0, h[i] = t) } }), "expandCluster"), g = 0; return t.features.forEach((function (t, e) { if (!u[e]) { var n = f(e); if (n.length >= r) { var i = g; g++, u[e] = !0, p(i, n) } else c[e] = !0 } })), t.features.forEach((function (e, n) { var r = t.features[n]; r.properties || (r.properties = {}), h[n] >= 0 ? (r.properties.dbscan = c[n] ? "edge" : "core", r.properties.cluster = h[n]) : r.properties.dbscan = "noise" })), t } Zy($y, "clustersDbscan"); var Qy = { eudist: function (t, e, n) { for (var r = t.length, i = 0, o = 0; o < r; o++) { var a = (t[o] || 0) - (e[o] || 0); i += a * a } return n ? Math.sqrt(i) : i }, mandist: function (t, e, n) { for (var r = t.length, i = 0, o = 0; o < r; o++)i += Math.abs((t[o] || 0) - (e[o] || 0)); return n ? Math.sqrt(i) : i }, dist: function (t, e, n) { var r = Math.abs(t - e); return n ? r : r * r } }, Ky = Qy.eudist, tv = Qy.dist, ev = { kmrand: function (t, e) { for (var n = {}, r = [], i = e << 2, o = t.length, a = t[0].length > 0; r.length < e && i-- > 0;) { var s = t[Math.floor(Math.random() * o)], u = a ? s.join("_") : "" + s; n[u] || (n[u] = !0, r.push(s)) } if (r.length < e) throw new Error("Error initializating clusters"); return r }, kmpp: function (t, e) { var n = t[0].length ? Ky : tv, r = [], i = t.length, o = t[0].length > 0, a = t[Math.floor(Math.random() * i)]; for (o && a.join("_"), r.push(a); r.length < e;) { for (var s = [], u = r.length, l = 0, c = [], h = 0; h < i; h++) { for (var f = 1 / 0, p = 0; p < u; p++) { var g = n(t[h], r[p]); g <= f && (f = g) } s[h] = f } for (var y = 0; y < i; y++)l += s[y]; for (var v = 0; v < i; v++)c[v] = { i: v, v: t[v], pr: s[v] / l, cs: 0 }; c.sort((function (t, e) { return t.pr - e.pr })), c[0].cs = c[0].pr; for (var d = 1; d < i; d++)c[d].cs = c[d - 1].cs + c[d].pr; for (var m = Math.random(), _ = 0; _ < i - 1 && c[_++].cs < m;); r.push(c[_ - 1].v) } return r } }, nv = Qy, rv = nv.eudist, iv = ev.kmrand, ov = ev.kmpp; function av(t, e, n) { n = n || []; for (var r = 0; r < t; r++)n[r] = e; return n } var sv = function (t, e, n, r) { var i = [], o = [], a = [], s = [], u = !1, l = r || 1e4, c = t.length, h = t[0].length, f = h > 0, p = []; if (n) i = "kmrand" == n ? iv(t, e) : "kmpp" == n ? ov(t, e) : n; else for (var g = {}; i.length < e;) { var y = Math.floor(Math.random() * c); g[y] || (g[y] = !0, i.push(t[y])) } do { av(e, 0, p); for (var v = 0; v < c; v++) { for (var d = 1 / 0, m = 0, _ = 0; _ < e; _++) { (s = f ? rv(t[v], i[_]) : Math.abs(t[v] - i[_])) <= d && (d = s, m = _) } a[v] = m, p[m]++ } for (var b = [], x = (o = [], 0); x < e; x++)b[x] = f ? av(h, 0, b[x]) : 0, o[x] = i[x]; if (f) { for (var E = 0; E < e; E++)i[E] = []; for (var w = 0; w < c; w++)for (var k = b[a[w]], S = t[w], I = 0; I < h; I++)k[I] += S[I]; u = !0; for (var P = 0; P < e; P++) { for (var N = i[P], M = b[P], O = o[P], L = p[P], R = 0; R < h; R++)N[R] = M[R] / L || 0; if (u) for (var C = 0; C < h; C++)if (O[C] != N[C]) { u = !1; break } } } else { for (var T = 0; T < c; T++) { b[a[T]] += t[T] } for (var A = 0; A < e; A++)i[A] = b[A] / p[A] || 0; u = !0; for (var D = 0; D < e; D++)if (o[D] != i[D]) { u = !1; break } } u = u || --l <= 0 } while (!u); return { it: 1e4 - l, k: e, idxs: a, centroids: i } }, uv = p(sv), lv = Object.defineProperty; function cv(t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = t.features.length; e.numberOfClusters = e.numberOfClusters || Math.round(Math.sqrt(n / 2)), e.numberOfClusters > n && (e.numberOfClusters = n), !0 !== e.mutate && (t = Ry(t)); var r = Dl(t), i = r.slice(0, e.numberOfClusters), o = uv(r, e.numberOfClusters, i), a = {}; return o.centroids.forEach((function (t, e) { a[e] = t })), Tl(t, (function (t, e) { var n = o.idxs[e]; t.properties.cluster = n, t.properties.centroid = a[n] })), t } !function (t, e) { lv(t, "name", { value: e, configurable: !0 }) }(cv, "clustersKmeans"); var hv = Object.defineProperty, fv = Wh; function pv(t, e, n, r) { var i = new fv(6), o = e.features.map((function (t) { var e; return { minX: t.geometry.coordinates[0], minY: t.geometry.coordinates[1], maxX: t.geometry.coordinates[0], maxY: t.geometry.coordinates[1], property: null == (e = t.properties) ? void 0 : e[n] } })); return i.load(o), t.features.forEach((function (t) { t.properties || (t.properties = {}); var e = rc(t), n = i.search({ minX: e[0], minY: e[1], maxX: e[2], maxY: e[3] }), o = []; n.forEach((function (e) { Nc([e.minX, e.minY], t) && o.push(e.property) })), t.properties[r] = o })), t } !function (t, e) { hv(t, "name", { value: e, configurable: !0 }) }(pv, "collect"); var gv = Object.defineProperty; function yv(t) { var e = { MultiPoint: { coordinates: [], properties: [] }, MultiLineString: { coordinates: [], properties: [] }, MultiPolygon: { coordinates: [], properties: [] } }; return Tl(t, (function (t) { var n, r, i, o; switch (null == (o = t.geometry) ? void 0 : o.type) { case "Point": e.MultiPoint.coordinates.push(t.geometry.coordinates), e.MultiPoint.properties.push(t.properties); break; case "MultiPoint": (n = e.MultiPoint.coordinates).push.apply(n, s(t.geometry.coordinates)), e.MultiPoint.properties.push(t.properties); break; case "LineString": e.MultiLineString.coordinates.push(t.geometry.coordinates), e.MultiLineString.properties.push(t.properties); break; case "MultiLineString": (r = e.MultiLineString.coordinates).push.apply(r, s(t.geometry.coordinates)), e.MultiLineString.properties.push(t.properties); break; case "Polygon": e.MultiPolygon.coordinates.push(t.geometry.coordinates), e.MultiPolygon.properties.push(t.properties); break; case "MultiPolygon": (i = e.MultiPolygon.coordinates).push.apply(i, s(t.geometry.coordinates)), e.MultiPolygon.properties.push(t.properties) } })), ju(Object.keys(e).filter((function (t) { return e[t].coordinates.length })).sort().map((function (t) { return Mu({ type: t, coordinates: e[t].coordinates }, { collectedProperties: e[t].properties }) }))) } !function (t, e) { gv(t, "name", { value: e, configurable: !0 }) }(yv, "combine"); var vv = Object.defineProperty, dv = function (t, e) { return vv(t, "name", { value: e, configurable: !0 }) }; function mv(t, e) { var n = !1; return ju(wv(t.features.map((function (t) { var r = { x: t.geometry.coordinates[0], y: t.geometry.coordinates[1] }; return e ? r.z = t.properties[e] : 3 === t.geometry.coordinates.length && (n = !0, r.z = t.geometry.coordinates[2]), r }))).map((function (t) { var e = [t.a.x, t.a.y], r = [t.b.x, t.b.y], i = [t.c.x, t.c.y], o = {}; return n ? (e.push(t.a.z), r.push(t.b.z), i.push(t.c.z)) : o = { a: t.a.z, b: t.b.z, c: t.c.z }, Cu([[e, r, i, e]], o) }))) } dv(mv, "tin"); var _v = i((function t(e, r, i) { n(this, t), this.a = e, this.b = r, this.c = i; var o, a, s = r.x - e.x, u = r.y - e.y, l = i.x - e.x, c = i.y - e.y, h = s * (e.x + r.x) + u * (e.y + r.y), f = l * (e.x + i.x) + c * (e.y + i.y), p = 2 * (s * (i.y - r.y) - u * (i.x - r.x)); this.x = (c * h - u * f) / p, this.y = (s * f - l * h) / p, o = this.x - e.x, a = this.y - e.y, this.r = o * o + a * a })); dv(_v, "Triangle"); var bv = _v; function xv(t, e) { return e.x - t.x } function Ev(t) { var e, n, r, i, o, a = t.length; t: for (; a;)for (n = t[--a], e = t[--a], r = a; r;)if (o = t[--r], e === (i = t[--r]) && n === o || e === o && n === i) { t.splice(a, 2), t.splice(r, 2), a -= 2; continue t } } function wv(t) { if (t.length < 3) return []; t.sort(xv); for (var e, n, r, i, o, a, s = t.length - 1, u = t[s].x, l = t[0].x, c = t[s].y, h = c; s--;)t[s].y < c && (c = t[s].y), t[s].y > h && (h = t[s].y); var f, p = l - u, g = h - c, y = p > g ? p : g, v = .5 * (l + u), d = .5 * (h + c), m = [new bv({ __sentinel: !0, x: v - 20 * y, y: d - y }, { __sentinel: !0, x: v, y: d + 20 * y }, { __sentinel: !0, x: v + 20 * y, y: d - y })], _ = [], b = []; for (s = t.length; s--;) { for (b.length = 0, f = m.length; f--;)(p = t[s].x - m[f].x) > 0 && p * p > m[f].r ? (_.push(m[f]), m.splice(f, 1)) : p * p + (g = t[s].y - m[f].y) * g > m[f].r || (b.push(m[f].a, m[f].b, m[f].b, m[f].c, m[f].c, m[f].a), m.splice(f, 1)); for (Ev(b), f = b.length; f;)n = b[--f], e = b[--f], r = t[s], i = n.x - e.x, o = n.y - e.y, a = 2 * (i * (r.y - n.y) - o * (r.x - n.x)), Math.abs(a) > 1e-12 && m.push(new bv(e, n, r)) } for (Array.prototype.push.apply(_, m), s = _.length; s--;)(_[s].a.__sentinel || _[s].b.__sentinel || _[s].c.__sentinel) && _.splice(s, 1); return _ } function kv(t) { return t } function Sv(t, e) { var n = function (t) { if (null == t) return kv; var e, n, r = t.scale[0], i = t.scale[1], o = t.translate[0], a = t.translate[1]; return function (t, s) { s || (e = n = 0); var u = 2, l = t.length, c = new Array(l); for (c[0] = (e += t[0]) * r + o, c[1] = (n += t[1]) * i + a; u < l;)c[u] = t[u], ++u; return c } }(t.transform), r = t.arcs; function i(t, e) { e.length && e.pop(); for (var i = r[t < 0 ? ~t : t], o = 0, a = i.length; o < a; ++o)e.push(n(i[o], o)); t < 0 && function (t, e) { for (var n, r = t.length, i = r - e; i < --r;)n = t[i], t[i++] = t[r], t[r] = n }(e, a) } function o(t) { return n(t) } function a(t) { for (var e = [], n = 0, r = t.length; n < r; ++n)i(t[n], e); return e.length < 2 && e.push(e[0]), e } function s(t) { for (var e = a(t); e.length < 4;)e.push(e[0]); return e } function u(t) { return t.map(s) } return function t(e) { var n, r = e.type; switch (r) { case "GeometryCollection": return { type: r, geometries: e.geometries.map(t) }; case "Point": n = o(e.coordinates); break; case "MultiPoint": n = e.coordinates.map(o); break; case "LineString": n = a(e.arcs); break; case "MultiLineString": n = e.arcs.map(a); break; case "Polygon": n = u(e.arcs); break; case "MultiPolygon": n = e.arcs.map(u); break; default: return null }return { type: r, coordinates: n } }(e) } function Iv(t, e) { var n = {}, r = {}, i = {}, o = [], a = -1; function s(t, e) { for (var r in t) { var i = t[r]; delete e[i.start], delete i.start, delete i.end, i.forEach((function (t) { n[t < 0 ? ~t : t] = 1 })), o.push(i) } } return e.forEach((function (n, r) { var i, o = t.arcs[n < 0 ? ~n : n]; o.length < 3 && !o[1][0] && !o[1][1] && (i = e[++a], e[a] = n, e[r] = i) })), e.forEach((function (e) { var n, o, a = function (e) { var n, r = t.arcs[e < 0 ? ~e : e], i = r[0]; t.transform ? (n = [0, 0], r.forEach((function (t) { n[0] += t[0], n[1] += t[1] }))) : n = r[r.length - 1]; return e < 0 ? [n, i] : [i, n] }(e), s = a[0], u = a[1]; if (n = i[s]) if (delete i[n.end], n.push(e), n.end = u, o = r[u]) { delete r[o.start]; var l = o === n ? n : n.concat(o); r[l.start = n.start] = i[l.end = o.end] = l } else r[n.start] = i[n.end] = n; else if (n = r[u]) if (delete r[n.start], n.unshift(e), n.start = s, o = i[s]) { delete i[o.end]; var c = o === n ? n : o.concat(n); r[c.start = o.start] = i[c.end = n.end] = c } else r[n.start] = i[n.end] = n; else r[(n = [e]).start = s] = i[n.end = u] = n })), s(i, r), s(r, i), e.forEach((function (t) { n[t < 0 ? ~t : t] || o.push([t]) })), o } function Pv(t) { return Sv(t, Nv.apply(this, arguments)) } function Nv(t, e) { var n = {}, r = [], i = []; function o(t) { t.forEach((function (e) { e.forEach((function (e) { (n[e = e < 0 ? ~e : e] || (n[e] = [])).push(t) })) })), r.push(t) } function a(e) { return function (t) { for (var e, n = -1, r = t.length, i = t[r - 1], o = 0; ++n < r;)e = i, i = t[n], o += e[0] * i[1] - e[1] * i[0]; return Math.abs(o) }(Sv(t, { type: "Polygon", arcs: [e] }).coordinates[0]) } return e.forEach((function t(e) { switch (e.type) { case "GeometryCollection": e.geometries.forEach(t); break; case "Polygon": o(e.arcs); break; case "MultiPolygon": e.arcs.forEach(o) } })), r.forEach((function (t) { if (!t._) { var e = [], r = [t]; for (t._ = 1, i.push(e); t = r.pop();)e.push(t), t.forEach((function (t) { t.forEach((function (t) { n[t < 0 ? ~t : t].forEach((function (t) { t._ || (t._ = 1, r.push(t)) })) })) })) } })), r.forEach((function (t) { delete t._ })), { type: "MultiPolygon", arcs: i.map((function (e) { var r, i = []; if (e.forEach((function (t) { t.forEach((function (t) { t.forEach((function (t) { n[t < 0 ? ~t : t].length < 2 && i.push(t) })) })) })), (r = (i = Iv(t, i)).length) > 1) for (var o, s, u = 1, l = a(i[0]); u < r; ++u)(o = a(i[u])) > l && (s = i[0], i[0] = i[u], i[u] = s, l = o); return i })).filter((function (t) { return t.length > 0 })) } } dv(xv, "byX"), dv(Ev, "dedup"), dv(wv, "triangulate"); var Mv = Object.prototype.hasOwnProperty; function Ov(t, e, n, r, i, o) { 3 === arguments.length && (r = o = Array, i = null); for (var a = new r(t = 1 << Math.max(4, Math.ceil(Math.log(t) / Math.LN2))), s = new o(t), u = t - 1, l = 0; l < t; ++l)a[l] = i; return { set: function (r, o) { for (var l = e(r) & u, c = a[l], h = 0; c != i;) { if (n(c, r)) return s[l] = o; if (++h >= t) throw new Error("full hashmap"); c = a[l = l + 1 & u] } return a[l] = r, s[l] = o, o }, maybeSet: function (r, o) { for (var l = e(r) & u, c = a[l], h = 0; c != i;) { if (n(c, r)) return s[l]; if (++h >= t) throw new Error("full hashmap"); c = a[l = l + 1 & u] } return a[l] = r, s[l] = o, o }, get: function (r, o) { for (var l = e(r) & u, c = a[l], h = 0; c != i;) { if (n(c, r)) return s[l]; if (++h >= t) break; c = a[l = l + 1 & u] } return o }, keys: function () { for (var t = [], e = 0, n = a.length; e < n; ++e) { var r = a[e]; r != i && t.push(r) } return t } } } function Lv(t, e) { return t[0] === e[0] && t[1] === e[1] } var Rv = new ArrayBuffer(16), Cv = new Float64Array(Rv), Tv = new Uint32Array(Rv); function Av(t) { Cv[0] = t[0], Cv[1] = t[1]; var e = Tv[0] ^ Tv[1]; return 2147483647 & (e = e << 5 ^ e >> 7 ^ Tv[2] ^ Tv[3]) } function Dv(t) { var e, n, r, i, o = t.coordinates, a = t.lines, s = t.rings, u = function () { for (var t = Ov(1.4 * o.length, x, E, Int32Array, -1, Int32Array), e = new Int32Array(o.length), n = 0, r = o.length; n < r; ++n)e[n] = t.maybeSet(n, n); return e }(), l = new Int32Array(o.length), c = new Int32Array(o.length), h = new Int32Array(o.length), f = new Int8Array(o.length), p = 0; for (e = 0, n = o.length; e < n; ++e)l[e] = c[e] = h[e] = -1; for (e = 0, n = a.length; e < n; ++e) { var g = a[e], y = g[0], v = g[1]; for (r = u[y], i = u[++y], ++p, f[r] = 1; ++y <= v;)b(e, r, r = i, i = u[y]); ++p, f[i] = 1 } for (e = 0, n = o.length; e < n; ++e)l[e] = -1; for (e = 0, n = s.length; e < n; ++e) { var d = s[e], m = d[0] + 1, _ = d[1]; for (b(e, u[_ - 1], r = u[m - 1], i = u[m]); ++m <= _;)b(e, r, r = i, i = u[m]) } function b(t, e, n, r) { if (l[n] !== t) { l[n] = t; var i = c[n]; if (i >= 0) { var o = h[n]; i === e && o === r || i === r && o === e || (++p, f[n] = 1) } else c[n] = e, h[n] = r } } function x(t) { return Av(o[t]) } function E(t, e) { return Lv(o[t], o[e]) } l = c = h = null; var w, k = function (t, e, n, r, i) { 3 === arguments.length && (r = Array, i = null); for (var o = new r(t = 1 << Math.max(4, Math.ceil(Math.log(t) / Math.LN2))), a = t - 1, s = 0; s < t; ++s)o[s] = i; return { add: function (r) { for (var s = e(r) & a, u = o[s], l = 0; u != i;) { if (n(u, r)) return !0; if (++l >= t) throw new Error("full hashset"); u = o[s = s + 1 & a] } return o[s] = r, !0 }, has: function (r) { for (var s = e(r) & a, u = o[s], l = 0; u != i;) { if (n(u, r)) return !0; if (++l >= t) break; u = o[s = s + 1 & a] } return !1 }, values: function () { for (var t = [], e = 0, n = o.length; e < n; ++e) { var r = o[e]; r != i && t.push(r) } return t } } }(1.4 * p, Av, Lv); for (e = 0, n = o.length; e < n; ++e)f[w = u[e]] && k.add(o[w]); return k } function jv(t, e, n, r) { Fv(t, e, n), Fv(t, e, e + r), Fv(t, e + r, n) } function Fv(t, e, n) { for (var r, i = e + (n-- - e >> 1); e < i; ++e, --n)r = t[e], t[e] = t[n], t[n] = r } function Bv(t) { var e, n, r = {}; for (e in t) r[e] = null == (n = t[e]) ? { type: null } : ("FeatureCollection" === n.type ? qv : "Feature" === n.type ? Vv : Gv)(n); return r } function qv(t) { var e = { type: "GeometryCollection", geometries: t.features.map(Vv) }; return null != t.bbox && (e.bbox = t.bbox), e } function Vv(t) { var e, n = Gv(t.geometry); for (e in null != t.id && (n.id = t.id), null != t.bbox && (n.bbox = t.bbox), t.properties) { n.properties = t.properties; break } return n } function Gv(t) { if (null == t) return { type: null }; var e = "GeometryCollection" === t.type ? { type: "GeometryCollection", geometries: t.geometries.map(Gv) } : "Point" === t.type || "MultiPoint" === t.type ? { type: t.type, coordinates: t.coordinates } : { type: t.type, arcs: t.coordinates }; return null != t.bbox && (e.bbox = t.bbox), e } function Yv(t, e) { var n = function (t) { var e = 1 / 0, n = 1 / 0, r = -1 / 0, i = -1 / 0; function o(t) { null != t && Mv.call(a, t.type) && a[t.type](t) } var a = { GeometryCollection: function (t) { t.geometries.forEach(o) }, Point: function (t) { s(t.coordinates) }, MultiPoint: function (t) { t.coordinates.forEach(s) }, LineString: function (t) { u(t.arcs) }, MultiLineString: function (t) { t.arcs.forEach(u) }, Polygon: function (t) { t.arcs.forEach(u) }, MultiPolygon: function (t) { t.arcs.forEach(l) } }; function s(t) { var o = t[0], a = t[1]; o < e && (e = o), o > r && (r = o), a < n && (n = a), a > i && (i = a) } function u(t) { t.forEach(s) } function l(t) { t.forEach(u) } for (var c in t) o(t[c]); return r >= e && i >= n ? [e, n, r, i] : void 0 }(t = Bv(t)), r = e > 0 && n && function (t, e, n) { var r = e[0], i = e[1], o = e[2], a = e[3], s = o - r ? (n - 1) / (o - r) : 1, u = a - i ? (n - 1) / (a - i) : 1; function l(t) { return [Math.round((t[0] - r) * s), Math.round((t[1] - i) * u)] } function c(t, e) { for (var n, o, a, l, c, h = -1, f = 0, p = t.length, g = new Array(p); ++h < p;)n = t[h], l = Math.round((n[0] - r) * s), c = Math.round((n[1] - i) * u), l === o && c === a || (g[f++] = [o = l, a = c]); for (g.length = f; f < e;)f = g.push([g[0][0], g[0][1]]); return g } function h(t) { return c(t, 2) } function f(t) { return c(t, 4) } function p(t) { return t.map(f) } function g(t) { null != t && Mv.call(y, t.type) && y[t.type](t) } var y = { GeometryCollection: function (t) { t.geometries.forEach(g) }, Point: function (t) { t.coordinates = l(t.coordinates) }, MultiPoint: function (t) { t.coordinates = t.coordinates.map(l) }, LineString: function (t) { t.arcs = h(t.arcs) }, MultiLineString: function (t) { t.arcs = t.arcs.map(h) }, Polygon: function (t) { t.arcs = p(t.arcs) }, MultiPolygon: function (t) { t.arcs = t.arcs.map(p) } }; for (var v in t) g(t[v]); return { scale: [1 / s, 1 / u], translate: [r, i] } }(t, n, e), i = function (t) { var e, n, r, i, o = t.coordinates, a = t.lines, s = t.rings, u = a.length + s.length; for (delete t.lines, delete t.rings, r = 0, i = a.length; r < i; ++r)for (e = a[r]; e = e.next;)++u; for (r = 0, i = s.length; r < i; ++r)for (n = s[r]; n = n.next;)++u; var l = Ov(2 * u * 1.4, Av, Lv), c = t.arcs = []; for (r = 0, i = a.length; r < i; ++r) { e = a[r]; do { h(e) } while (e = e.next) } for (r = 0, i = s.length; r < i; ++r)if ((n = s[r]).next) do { h(n) } while (n = n.next); else f(n); function h(t) { var e, n, r, i, a, s, u, h; if (r = l.get(e = o[t[0]])) for (u = 0, h = r.length; u < h; ++u)if (p(i = r[u], t)) return t[0] = i[0], void (t[1] = i[1]); if (a = l.get(n = o[t[1]])) for (u = 0, h = a.length; u < h; ++u)if (g(s = a[u], t)) return t[1] = s[0], void (t[0] = s[1]); r ? r.push(t) : l.set(e, [t]), a ? a.push(t) : l.set(n, [t]), c.push(t) } function f(t) { var e, n, r, i, a; if (n = l.get(o[t[0]])) for (i = 0, a = n.length; i < a; ++i) { if (y(r = n[i], t)) return t[0] = r[0], void (t[1] = r[1]); if (v(r, t)) return t[0] = r[1], void (t[1] = r[0]) } if (n = l.get(e = o[t[0] + d(t)])) for (i = 0, a = n.length; i < a; ++i) { if (y(r = n[i], t)) return t[0] = r[0], void (t[1] = r[1]); if (v(r, t)) return t[0] = r[1], void (t[1] = r[0]) } n ? n.push(t) : l.set(e, [t]), c.push(t) } function p(t, e) { var n = t[0], r = e[0], i = t[1]; if (n - i != r - e[1]) return !1; for (; n <= i; ++n, ++r)if (!Lv(o[n], o[r])) return !1; return !0 } function g(t, e) { var n = t[0], r = e[0], i = t[1], a = e[1]; if (n - i != r - a) return !1; for (; n <= i; ++n, --a)if (!Lv(o[n], o[a])) return !1; return !0 } function y(t, e) { var n = t[0], r = e[0], i = t[1] - n; if (i !== e[1] - r) return !1; for (var a = d(t), s = d(e), u = 0; u < i; ++u)if (!Lv(o[n + (u + a) % i], o[r + (u + s) % i])) return !1; return !0 } function v(t, e) { var n = t[0], r = e[0], i = t[1], a = e[1], s = i - n; if (s !== a - r) return !1; for (var u = d(t), l = s - d(e), c = 0; c < s; ++c)if (!Lv(o[n + (c + u) % s], o[a - (c + l) % s])) return !1; return !0 } function d(t) { for (var e = t[0], n = t[1], r = e, i = r, a = o[r]; ++r < n;) { var s = o[r]; (s[0] < a[0] || s[0] === a[0] && s[1] < a[1]) && (i = r, a = s) } return i - e } return t }(function (t) { var e, n, r, i = Dv(t), o = t.coordinates, a = t.lines, s = t.rings; for (n = 0, r = a.length; n < r; ++n)for (var u = a[n], l = u[0], c = u[1]; ++l < c;)i.has(o[l]) && (e = { 0: l, 1: u[1] }, u[1] = l, u = u.next = e); for (n = 0, r = s.length; n < r; ++n)for (var h = s[n], f = h[0], p = f, g = h[1], y = i.has(o[f]); ++p < g;)i.has(o[p]) && (y ? (e = { 0: p, 1: h[1] }, h[1] = p, h = h.next = e) : (jv(o, f, g, g - p), o[g] = o[f], y = !0, p = f)); return t }(function (t) { var e = -1, n = [], r = [], i = []; function o(t) { t && Mv.call(a, t.type) && a[t.type](t) } var a = { GeometryCollection: function (t) { t.geometries.forEach(o) }, LineString: function (t) { t.arcs = s(t.arcs) }, MultiLineString: function (t) { t.arcs = t.arcs.map(s) }, Polygon: function (t) { t.arcs = t.arcs.map(u) }, MultiPolygon: function (t) { t.arcs = t.arcs.map(l) } }; function s(t) { for (var r = 0, o = t.length; r < o; ++r)i[++e] = t[r]; var a = { 0: e - o + 1, 1: e }; return n.push(a), a } function u(t) { for (var n = 0, o = t.length; n < o; ++n)i[++e] = t[n]; var a = { 0: e - o + 1, 1: e }; return r.push(a), a } function l(t) { return t.map(u) } for (var c in t) o(t[c]); return { type: "Topology", coordinates: i, lines: n, rings: r, objects: t } }(t))), o = i.coordinates, a = Ov(1.4 * i.arcs.length, zv, Uv); function s(t) { t && Mv.call(u, t.type) && u[t.type](t) } t = i.objects, i.bbox = n, i.arcs = i.arcs.map((function (t, e) { return a.set(t, e), o.slice(t[0], t[1] + 1) })), delete i.coordinates, o = null; var u = { GeometryCollection: function (t) { t.geometries.forEach(s) }, LineString: function (t) { t.arcs = l(t.arcs) }, MultiLineString: function (t) { t.arcs = t.arcs.map(l) }, Polygon: function (t) { t.arcs = t.arcs.map(l) }, MultiPolygon: function (t) { t.arcs = t.arcs.map(c) } }; function l(t) { var e = []; do { var n = a.get(t); e.push(t[0] < t[1] ? n : ~n) } while (t = t.next); return e } function c(t) { return t.map(l) } for (var h in t) s(t[h]); return r && (i.transform = r, i.arcs = function (t) { for (var e = -1, n = t.length; ++e < n;) { for (var r, i, o = t[e], a = 0, s = 1, u = o.length, l = o[0], c = l[0], h = l[1]; ++a < u;)r = (l = o[a])[0], i = l[1], r === c && i === h || (o[s++] = [r - c, i - h], c = r, h = i); 1 === s && (o[s++] = [0, 0]), o.length = s } return t }(i.arcs)), i } function zv(t) { var e, n = t[0], r = t[1]; return r < n && (e = n, n = r, r = e), n + 31 * r } function Uv(t, e) { var n, r = t[0], i = t[1], o = e[0], a = e[1]; return i < r && (n = r, r = i, i = n), a < o && (n = o, o = a, a = n), r === o && i === a } var Xv = Object.defineProperty, Wv = function (t, e) { return Xv(t, "name", { value: e, configurable: !0 }) }; function Hv(t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (!Qu(e = e || {})) throw new Error("options is invalid"); var n = e.mutate; if ("FeatureCollection" !== hl(t)) throw new Error("geojson must be a FeatureCollection"); if (!t.features.length) throw new Error("geojson is empty"); !1 !== n && void 0 !== n || (t = Ry(t)); var r = [], i = zl(t, (function (t, e) { var n = Jv(t, e); return n || (r.push(t), e) })); return i && r.push(i), r.length ? 1 === r.length ? r[0] : Fu(r.map((function (t) { return t.coordinates }))) : null } function Zv(t) { return t[0].toString() + "," + t[1].toString() } function Jv(t, e) { var n, r = t.geometry.coordinates, i = e.geometry.coordinates, o = Zv(r[0]), a = Zv(r[r.length - 1]), s = Zv(i[0]), u = Zv(i[i.length - 1]); if (o === u) n = i.concat(r.slice(1)); else if (s === a) n = r.concat(i.slice(1)); else if (o === s) n = r.slice(1).reverse().concat(i); else { if (a !== u) return null; n = r.concat(i.reverse().slice(1)) } return Au(n) } function $v(t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if ("FeatureCollection" !== hl(t)) throw new Error("geojson must be a FeatureCollection"); if (!t.features.length) throw new Error("geojson is empty"); !1 !== e.mutate && void 0 !== e.mutate || (t = Ry(t)); var n = []; Bl(t, (function (t) { n.push(t.geometry) })); var r = Yv({ geoms: Vu(n).geometry }); return Pv(r, r.objects.geoms.geometries) } function Qv(t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (!Qu(e = e || {})) throw new Error("options is invalid"); var n = e.mutate; if ("FeatureCollection" !== hl(t)) throw new Error("geojson must be a FeatureCollection"); if (!t.features.length) throw new Error("geojson is empty"); !1 !== n && void 0 !== n || (t = Ry(t)); var r = Kv(t); if (!r) throw new Error("geojson must be homogenous"); var i = t; switch (r) { case "LineString": return Hv(i, e); case "Polygon": return $v(i, e); default: throw new Error(r + " is not supported") } } function Kv(t) { var e = {}; Bl(t, (function (t) { e[t.geometry.type] = !0 })); var n = Object.keys(e); return 1 === n.length ? n[0] : null } function td(t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = e.maxEdge || 1 / 0, r = mv(ed(t)); if (r.features = r.features.filter((function (t) { var r = t.geometry.coordinates[0][0], i = t.geometry.coordinates[0][1], o = t.geometry.coordinates[0][2], a = _l(r, i, e), s = _l(i, o, e), u = _l(r, o, e); return a <= n && s <= n && u <= n })), r.features.length < 1) return null; var i = Qv(r); return 1 === i.coordinates.length && (i.coordinates = i.coordinates[0], i.type = "Polygon"), Mu(i) } function ed(t) { var e = [], n = {}; return Tl(t, (function (t) { if (t.geometry) { var r = t.geometry.coordinates.join("-"); Object.prototype.hasOwnProperty.call(n, r) || (e.push(t), n[r] = !0) } })), ju(e) }
            /**
            * splaytree v3.1.2
            * Fast Splay tree for Node and browser
            *
            * @author Alexander Milevski <info@w8r.name>
            * @license MIT
            * @preserve
            */
            /*! *****************************************************************************
            Copyright (c) Microsoft Corporation. All rights reserved.
            Licensed under the Apache License, Version 2.0 (the "License"); you may not use
            this file except in compliance with the License. You may obtain a copy of the
            License at http://www.apache.org/licenses/LICENSE-2.0
        
            THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
            KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
            WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
            MERCHANTABLITY OR NON-INFRINGEMENT.
        
            See the Apache Version 2.0 License for specific language governing permissions
            and limitations under the License.
            ***************************************************************************** */
            function nd(t, e) { var n, r, i, o, a = { label: 0, sent: function () { if (1 & i[0]) throw i[1]; return i[1] }, trys: [], ops: [] }; return o = { next: s(0), throw: s(1), return: s(2) }, "function" == typeof Symbol && (o[Symbol.iterator] = function () { return this }), o; function s(o) { return function (s) { return function (o) { if (n) throw new TypeError("Generator is already executing."); for (; a;)try { if (n = 1, r && (i = 2 & o[0] ? r.return : o[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, o[1])).done) return i; switch (r = 0, i && (o = [2 & o[0], i.value]), o[0]) { case 0: case 1: i = o; break; case 4: return a.label++, { value: o[1], done: !1 }; case 5: a.label++, r = o[1], o = [0]; continue; case 7: o = a.ops.pop(), a.trys.pop(); continue; default: if (!(i = a.trys, (i = i.length > 0 && i[i.length - 1]) || 6 !== o[0] && 2 !== o[0])) { a = 0; continue } if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) { a.label = o[1]; break } if (6 === o[0] && a.label < i[1]) { a.label = i[1], i = o; break } if (i && a.label < i[2]) { a.label = i[2], a.ops.push(o); break } i[2] && a.ops.pop(), a.trys.pop(); continue }o = e.call(t, a) } catch (t) { o = [6, t], r = 0 } finally { n = i = 0 } if (5 & o[0]) throw o[1]; return { value: o[0] ? o[1] : void 0, done: !0 } }([o, s]) } } } Wv(Hv, "lineDissolve"), Wv(Zv, "coordId"), Wv(Jv, "mergeLineStrings"), Wv($v, "polygonDissolve"), Wv(Qv, "dissolve"), Wv(Kv, "getHomogenousType"), Wv(td, "concave"), Wv(ed, "removeDuplicates"); var rd = function (t, e) { this.next = null, this.key = t, this.data = e, this.left = null, this.right = null }; function id(t, e) { return t > e ? 1 : t < e ? -1 : 0 } function od(t, e, n) { for (var r = new rd(null, null), i = r, o = r; ;) { var a = n(t, e.key); if (a < 0) { if (null === e.left) break; if (n(t, e.left.key) < 0) { var s = e.left; if (e.left = s.right, s.right = e, null === (e = s).left) break } o.left = e, o = e, e = e.left } else { if (!(a > 0)) break; if (null === e.right) break; if (n(t, e.right.key) > 0) { s = e.right; if (e.right = s.left, s.left = e, null === (e = s).right) break } i.right = e, i = e, e = e.right } } return i.right = e.left, o.left = e.right, e.left = r.right, e.right = r.left, e } function ad(t, e, n, r) { var i = new rd(t, e); if (null === n) return i.left = i.right = null, i; var o = r(t, (n = od(t, n, r)).key); return o < 0 ? (i.left = n.left, i.right = n, n.left = null) : o >= 0 && (i.right = n.right, i.left = n, n.right = null), i } function sd(t, e, n) { var r = null, i = null; if (e) { var o = n((e = od(t, e, n)).key, t); 0 === o ? (r = e.left, i = e.right) : o < 0 ? (i = e.right, e.right = null, r = e) : (r = e.left, e.left = null, i = e) } return { left: r, right: i } } function ud(t, e, n, r, i) { if (t) { r(e + (n ? "└── " : "├── ") + i(t) + "\n"); var o = e + (n ? "    " : "│   "); t.left && ud(t.left, o, !1, r, i), t.right && ud(t.right, o, !0, r, i) } } var ld = function () { function t(t) { void 0 === t && (t = id), this._root = null, this._size = 0, this._comparator = t } return t.prototype.insert = function (t, e) { return this._size++, this._root = ad(t, e, this._root, this._comparator) }, t.prototype.add = function (t, e) { var n = new rd(t, e); null === this._root && (n.left = n.right = null, this._size++, this._root = n); var r = this._comparator, i = od(t, this._root, r), o = r(t, i.key); return 0 === o ? this._root = i : (o < 0 ? (n.left = i.left, n.right = i, i.left = null) : o > 0 && (n.right = i.right, n.left = i, i.right = null), this._size++, this._root = n), this._root }, t.prototype.remove = function (t) { this._root = this._remove(t, this._root, this._comparator) }, t.prototype._remove = function (t, e, n) { var r; return null === e ? null : 0 === n(t, (e = od(t, e, n)).key) ? (null === e.left ? r = e.right : (r = od(t, e.left, n)).right = e.right, this._size--, r) : e }, t.prototype.pop = function () { var t = this._root; if (t) { for (; t.left;)t = t.left; return this._root = od(t.key, this._root, this._comparator), this._root = this._remove(t.key, this._root, this._comparator), { key: t.key, data: t.data } } return null }, t.prototype.findStatic = function (t) { for (var e = this._root, n = this._comparator; e;) { var r = n(t, e.key); if (0 === r) return e; e = r < 0 ? e.left : e.right } return null }, t.prototype.find = function (t) { return this._root && (this._root = od(t, this._root, this._comparator), 0 !== this._comparator(t, this._root.key)) ? null : this._root }, t.prototype.contains = function (t) { for (var e = this._root, n = this._comparator; e;) { var r = n(t, e.key); if (0 === r) return !0; e = r < 0 ? e.left : e.right } return !1 }, t.prototype.forEach = function (t, e) { for (var n = this._root, r = [], i = !1; !i;)null !== n ? (r.push(n), n = n.left) : 0 !== r.length ? (n = r.pop(), t.call(e, n), n = n.right) : i = !0; return this }, t.prototype.range = function (t, e, n, r) { for (var i = [], o = this._comparator, a = this._root; 0 !== i.length || a;)if (a) i.push(a), a = a.left; else { if (o((a = i.pop()).key, e) > 0) break; if (o(a.key, t) >= 0 && n.call(r, a)) return this; a = a.right } return this }, t.prototype.keys = function () { var t = []; return this.forEach((function (e) { var n = e.key; return t.push(n) })), t }, t.prototype.values = function () { var t = []; return this.forEach((function (e) { var n = e.data; return t.push(n) })), t }, t.prototype.min = function () { return this._root ? this.minNode(this._root).key : null }, t.prototype.max = function () { return this._root ? this.maxNode(this._root).key : null }, t.prototype.minNode = function (t) { if (void 0 === t && (t = this._root), t) for (; t.left;)t = t.left; return t }, t.prototype.maxNode = function (t) { if (void 0 === t && (t = this._root), t) for (; t.right;)t = t.right; return t }, t.prototype.at = function (t) { for (var e = this._root, n = !1, r = 0, i = []; !n;)if (e) i.push(e), e = e.left; else if (i.length > 0) { if (e = i.pop(), r === t) return e; r++, e = e.right } else n = !0; return null }, t.prototype.next = function (t) { var e = this._root, n = null; if (t.right) { for (n = t.right; n.left;)n = n.left; return n } for (var r = this._comparator; e;) { var i = r(t.key, e.key); if (0 === i) break; i < 0 ? (n = e, e = e.left) : e = e.right } return n }, t.prototype.prev = function (t) { var e = this._root, n = null; if (null !== t.left) { for (n = t.left; n.right;)n = n.right; return n } for (var r = this._comparator; e;) { var i = r(t.key, e.key); if (0 === i) break; i < 0 ? e = e.left : (n = e, e = e.right) } return n }, t.prototype.clear = function () { return this._root = null, this._size = 0, this }, t.prototype.toList = function () { return function (t) { var e = t, n = [], r = !1, i = new rd(null, null), o = i; for (; !r;)e ? (n.push(e), e = e.left) : n.length > 0 ? e = (e = o = o.next = n.pop()).right : r = !0; return o.next = null, i.next }(this._root) }, t.prototype.load = function (t, e, n) { void 0 === e && (e = []), void 0 === n && (n = !1); var r = t.length, i = this._comparator; if (n && fd(t, e, 0, r - 1, i), null === this._root) this._root = cd(t, e, 0, r), this._size = r; else { var o = function (t, e, n) { var r = new rd(null, null), i = r, o = t, a = e; for (; null !== o && null !== a;)n(o.key, a.key) < 0 ? (i.next = o, o = o.next) : (i.next = a, a = a.next), i = i.next; null !== o ? i.next = o : null !== a && (i.next = a); return r.next }(this.toList(), function (t, e) { for (var n = new rd(null, null), r = n, i = 0; i < t.length; i++)r = r.next = new rd(t[i], e[i]); return r.next = null, n.next }(t, e), i); r = this._size + r, this._root = hd({ head: o }, 0, r) } return this }, t.prototype.isEmpty = function () { return null === this._root }, Object.defineProperty(t.prototype, "size", { get: function () { return this._size }, enumerable: !0, configurable: !0 }), Object.defineProperty(t.prototype, "root", { get: function () { return this._root }, enumerable: !0, configurable: !0 }), t.prototype.toString = function (t) { void 0 === t && (t = function (t) { return String(t.key) }); var e = []; return ud(this._root, "", !0, (function (t) { return e.push(t) }), t), e.join("") }, t.prototype.update = function (t, e, n) { var r = this._comparator, i = sd(t, this._root, r), o = i.left, a = i.right; r(t, e) < 0 ? a = ad(e, n, a, r) : o = ad(e, n, o, r), this._root = function (t, e, n) { return null === e ? t : (null === t || ((e = od(t.key, e, n)).left = t), e) }(o, a, r) }, t.prototype.split = function (t) { return sd(t, this._root, this._comparator) }, t.prototype[Symbol.iterator] = function () { var t, e, n; return nd(this, (function (r) { switch (r.label) { case 0: t = this._root, e = [], n = !1, r.label = 1; case 1: return n ? [3, 6] : null === t ? [3, 2] : (e.push(t), t = t.left, [3, 5]); case 2: return 0 === e.length ? [3, 4] : [4, t = e.pop()]; case 3: return r.sent(), t = t.right, [3, 5]; case 4: n = !0, r.label = 5; case 5: return [3, 1]; case 6: return [2] } })) }, t }(); function cd(t, e, n, r) { var i = r - n; if (i > 0) { var o = n + Math.floor(i / 2), a = t[o], s = e[o], u = new rd(a, s); return u.left = cd(t, e, n, o), u.right = cd(t, e, o + 1, r), u } return null } function hd(t, e, n) { var r = n - e; if (r > 0) { var i = e + Math.floor(r / 2), o = hd(t, e, i), a = t.head; return a.left = o, t.head = t.head.next, a.right = hd(t, i + 1, n), a } return null } function fd(t, e, n, r, i) { if (!(n >= r)) { for (var o = t[n + r >> 1], a = n - 1, s = r + 1; ;) { do { a++ } while (i(t[a], o) < 0); do { s-- } while (i(t[s], o) > 0); if (a >= s) break; var u = t[a]; t[a] = t[s], t[s] = u, u = e[a], e[a] = e[s], e[s] = u } fd(t, e, n, s, i), fd(t, e, s + 1, r, i) } } function pd(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function gd(t, e) { for (var n = 0; n < e.length; n++) { var r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r) } } function yd(t, e, n) { return e && gd(t.prototype, e), n && gd(t, n), t } var vd = function (t, e) { return t.ll.x <= e.x && e.x <= t.ur.x && t.ll.y <= e.y && e.y <= t.ur.y }, dd = function (t, e) { if (e.ur.x < t.ll.x || t.ur.x < e.ll.x || e.ur.y < t.ll.y || t.ur.y < e.ll.y) return null; var n = t.ll.x < e.ll.x ? e.ll.x : t.ll.x, r = t.ur.x < e.ur.x ? t.ur.x : e.ur.x; return { ll: { x: n, y: t.ll.y < e.ll.y ? e.ll.y : t.ll.y }, ur: { x: r, y: t.ur.y < e.ur.y ? t.ur.y : e.ur.y } } }, md = Number.EPSILON; void 0 === md && (md = Math.pow(2, -52)); var _d = md * md, bd = function (t, e) { if (-md < t && t < md && -md < e && e < md) return 0; var n = t - e; return n * n < _d * t * e ? 0 : t < e ? -1 : 1 }, xd = function () { function t() { pd(this, t), this.reset() } return yd(t, [{ key: "reset", value: function () { this.xRounder = new Ed, this.yRounder = new Ed } }, { key: "round", value: function (t, e) { return { x: this.xRounder.round(t), y: this.yRounder.round(e) } } }]), t }(), Ed = function () { function t() { pd(this, t), this.tree = new ld, this.round(0) } return yd(t, [{ key: "round", value: function (t) { var e = this.tree.add(t), n = this.tree.prev(e); if (null !== n && 0 === bd(e.key, n.key)) return this.tree.remove(t), n.key; var r = this.tree.next(e); return null !== r && 0 === bd(e.key, r.key) ? (this.tree.remove(t), r.key) : t } }]), t }(), wd = new xd, kd = function (t, e) { return t.x * e.y - t.y * e.x }, Sd = function (t, e) { return t.x * e.x + t.y * e.y }, Id = function (t, e, n) { var r = { x: e.x - t.x, y: e.y - t.y }, i = { x: n.x - t.x, y: n.y - t.y }, o = kd(r, i); return bd(o, 0) }, Pd = function (t) { return Math.sqrt(Sd(t, t)) }, Nd = function (t, e, n) { var r = { x: e.x - t.x, y: e.y - t.y }, i = { x: n.x - t.x, y: n.y - t.y }; return Sd(i, r) / Pd(i) / Pd(r) }, Md = function (t, e, n) { return 0 === e.y ? null : { x: t.x + e.x / e.y * (n - t.y), y: n } }, Od = function (t, e, n) { return 0 === e.x ? null : { x: n, y: t.y + e.y / e.x * (n - t.x) } }, Ld = function () { function t(e, n) { pd(this, t), void 0 === e.events ? e.events = [this] : e.events.push(this), this.point = e, this.isLeft = n } return yd(t, null, [{ key: "compare", value: function (e, n) { var r = t.comparePoints(e.point, n.point); return 0 !== r ? r : (e.point !== n.point && e.link(n), e.isLeft !== n.isLeft ? e.isLeft ? 1 : -1 : Cd.compare(e.segment, n.segment)) } }, { key: "comparePoints", value: function (t, e) { return t.x < e.x ? -1 : t.x > e.x ? 1 : t.y < e.y ? -1 : t.y > e.y ? 1 : 0 } }]), yd(t, [{ key: "link", value: function (t) { if (t.point === this.point) throw new Error("Tried to link already linked events"); for (var e = t.point.events, n = 0, r = e.length; n < r; n++) { var i = e[n]; this.point.events.push(i), i.point = this.point } this.checkForConsuming() } }, { key: "checkForConsuming", value: function () { for (var t = this.point.events.length, e = 0; e < t; e++) { var n = this.point.events[e]; if (void 0 === n.segment.consumedBy) for (var r = e + 1; r < t; r++) { var i = this.point.events[r]; void 0 === i.consumedBy && (n.otherSE.point.events === i.otherSE.point.events && n.segment.consume(i.segment)) } } } }, { key: "getAvailableLinkedEvents", value: function () { for (var t = [], e = 0, n = this.point.events.length; e < n; e++) { var r = this.point.events[e]; r !== this && !r.segment.ringOut && r.segment.isInResult() && t.push(r) } return t } }, { key: "getLeftmostComparator", value: function (t) { var e = this, n = new Map, r = function (r) { var i, o, a, s, u, l = r.otherSE; n.set(r, { sine: (i = e.point, o = t.point, a = l.point, s = { x: o.x - i.x, y: o.y - i.y }, u = { x: a.x - i.x, y: a.y - i.y }, kd(u, s) / Pd(u) / Pd(s)), cosine: Nd(e.point, t.point, l.point) }) }; return function (t, e) { n.has(t) || r(t), n.has(e) || r(e); var i = n.get(t), o = i.sine, a = i.cosine, s = n.get(e), u = s.sine, l = s.cosine; return o >= 0 && u >= 0 ? a < l ? 1 : a > l ? -1 : 0 : o < 0 && u < 0 ? a < l ? -1 : a > l ? 1 : 0 : u < o ? -1 : u > o ? 1 : 0 } } }]), t }(), Rd = 0, Cd = function () { function t(e, n, r, i) { pd(this, t), this.id = ++Rd, this.leftSE = e, e.segment = this, e.otherSE = n, this.rightSE = n, n.segment = this, n.otherSE = e, this.rings = r, this.windings = i } return yd(t, null, [{ key: "compare", value: function (t, e) { var n = t.leftSE.point.x, r = e.leftSE.point.x, i = t.rightSE.point.x, o = e.rightSE.point.x; if (o < n) return 1; if (i < r) return -1; var a = t.leftSE.point.y, s = e.leftSE.point.y, u = t.rightSE.point.y, l = e.rightSE.point.y; if (n < r) { if (s < a && s < u) return 1; if (s > a && s > u) return -1; var c = t.comparePoint(e.leftSE.point); if (c < 0) return 1; if (c > 0) return -1; var h = e.comparePoint(t.rightSE.point); return 0 !== h ? h : -1 } if (n > r) { if (a < s && a < l) return -1; if (a > s && a > l) return 1; var f = e.comparePoint(t.leftSE.point); if (0 !== f) return f; var p = t.comparePoint(e.rightSE.point); return p < 0 ? 1 : p > 0 ? -1 : 1 } if (a < s) return -1; if (a > s) return 1; if (i < o) { var g = e.comparePoint(t.rightSE.point); if (0 !== g) return g } if (i > o) { var y = t.comparePoint(e.rightSE.point); if (y < 0) return 1; if (y > 0) return -1 } if (i !== o) { var v = u - a, d = i - n, m = l - s, _ = o - r; if (v > d && m < _) return 1; if (v < d && m > _) return -1 } return i > o ? 1 : i < o || u < l ? -1 : u > l ? 1 : t.id < e.id ? -1 : t.id > e.id ? 1 : 0 } }]), yd(t, [{ key: "replaceRightSE", value: function (t) { this.rightSE = t, this.rightSE.segment = this, this.rightSE.otherSE = this.leftSE, this.leftSE.otherSE = this.rightSE } }, { key: "bbox", value: function () { var t = this.leftSE.point.y, e = this.rightSE.point.y; return { ll: { x: this.leftSE.point.x, y: t < e ? t : e }, ur: { x: this.rightSE.point.x, y: t > e ? t : e } } } }, { key: "vector", value: function () { return { x: this.rightSE.point.x - this.leftSE.point.x, y: this.rightSE.point.y - this.leftSE.point.y } } }, { key: "isAnEndpoint", value: function (t) { return t.x === this.leftSE.point.x && t.y === this.leftSE.point.y || t.x === this.rightSE.point.x && t.y === this.rightSE.point.y } }, { key: "comparePoint", value: function (t) { if (this.isAnEndpoint(t)) return 0; var e = this.leftSE.point, n = this.rightSE.point, r = this.vector(); if (e.x === n.x) return t.x === e.x ? 0 : t.x < e.x ? 1 : -1; var i = (t.y - e.y) / r.y, o = e.x + i * r.x; if (t.x === o) return 0; var a = (t.x - e.x) / r.x, s = e.y + a * r.y; return t.y === s ? 0 : t.y < s ? -1 : 1 } }, { key: "getIntersection", value: function (t) { var e = this.bbox(), n = t.bbox(), r = dd(e, n); if (null === r) return null; var i = this.leftSE.point, o = this.rightSE.point, a = t.leftSE.point, s = t.rightSE.point, u = vd(e, a) && 0 === this.comparePoint(a), l = vd(n, i) && 0 === t.comparePoint(i), c = vd(e, s) && 0 === this.comparePoint(s), h = vd(n, o) && 0 === t.comparePoint(o); if (l && u) return h && !c ? o : !h && c ? s : null; if (l) return c && i.x === s.x && i.y === s.y ? null : i; if (u) return h && o.x === a.x && o.y === a.y ? null : a; if (h && c) return null; if (h) return o; if (c) return s; var f = function (t, e, n, r) { if (0 === e.x) return Od(n, r, t.x); if (0 === r.x) return Od(t, e, n.x); if (0 === e.y) return Md(n, r, t.y); if (0 === r.y) return Md(t, e, n.y); var i = kd(e, r); if (0 == i) return null; var o = { x: n.x - t.x, y: n.y - t.y }, a = kd(o, e) / i, s = kd(o, r) / i; return { x: (t.x + s * e.x + (n.x + a * r.x)) / 2, y: (t.y + s * e.y + (n.y + a * r.y)) / 2 } }(i, this.vector(), a, t.vector()); return null === f ? null : vd(r, f) ? wd.round(f.x, f.y) : null } }, { key: "split", value: function (e) { var n = [], r = void 0 !== e.events, i = new Ld(e, !0), o = new Ld(e, !1), a = this.rightSE; this.replaceRightSE(o), n.push(o), n.push(i); var s = new t(i, a, this.rings.slice(), this.windings.slice()); return Ld.comparePoints(s.leftSE.point, s.rightSE.point) > 0 && s.swapEvents(), Ld.comparePoints(this.leftSE.point, this.rightSE.point) > 0 && this.swapEvents(), r && (i.checkForConsuming(), o.checkForConsuming()), n } }, { key: "swapEvents", value: function () { var t = this.rightSE; this.rightSE = this.leftSE, this.leftSE = t, this.leftSE.isLeft = !0, this.rightSE.isLeft = !1; for (var e = 0, n = this.windings.length; e < n; e++)this.windings[e] *= -1 } }, { key: "consume", value: function (e) { for (var n = this, r = e; n.consumedBy;)n = n.consumedBy; for (; r.consumedBy;)r = r.consumedBy; var i = t.compare(n, r); if (0 !== i) { if (i > 0) { var o = n; n = r, r = o } if (n.prev === r) { var a = n; n = r, r = a } for (var s = 0, u = r.rings.length; s < u; s++) { var l = r.rings[s], c = r.windings[s], h = n.rings.indexOf(l); -1 === h ? (n.rings.push(l), n.windings.push(c)) : n.windings[h] += c } r.rings = null, r.windings = null, r.consumedBy = n, r.leftSE.consumedBy = n.leftSE, r.rightSE.consumedBy = n.rightSE } } }, { key: "prevInResult", value: function () { return void 0 !== this._prevInResult || (this.prev ? this.prev.isInResult() ? this._prevInResult = this.prev : this._prevInResult = this.prev.prevInResult() : this._prevInResult = null), this._prevInResult } }, { key: "beforeState", value: function () { if (void 0 !== this._beforeState) return this._beforeState; if (this.prev) { var t = this.prev.consumedBy || this.prev; this._beforeState = t.afterState() } else this._beforeState = { rings: [], windings: [], multiPolys: [] }; return this._beforeState } }, { key: "afterState", value: function () { if (void 0 !== this._afterState) return this._afterState; var t = this.beforeState(); this._afterState = { rings: t.rings.slice(0), windings: t.windings.slice(0), multiPolys: [] }; for (var e = this._afterState.rings, n = this._afterState.windings, r = this._afterState.multiPolys, i = 0, o = this.rings.length; i < o; i++) { var a = this.rings[i], s = this.windings[i], u = e.indexOf(a); -1 === u ? (e.push(a), n.push(s)) : n[u] += s } for (var l = [], c = [], h = 0, f = e.length; h < f; h++)if (0 !== n[h]) { var p = e[h], g = p.poly; if (-1 === c.indexOf(g)) if (p.isExterior) l.push(g); else { -1 === c.indexOf(g) && c.push(g); var y = l.indexOf(p.poly); -1 !== y && l.splice(y, 1) } } for (var v = 0, d = l.length; v < d; v++) { var m = l[v].multiPoly; -1 === r.indexOf(m) && r.push(m) } return this._afterState } }, { key: "isInResult", value: function () { if (this.consumedBy) return !1; if (void 0 !== this._isInResult) return this._isInResult; var t = this.beforeState().multiPolys, e = this.afterState().multiPolys; switch (zd.type) { case "union": var n = 0 === t.length, r = 0 === e.length; this._isInResult = n !== r; break; case "intersection": var i, o; t.length < e.length ? (i = t.length, o = e.length) : (i = e.length, o = t.length), this._isInResult = o === zd.numMultiPolys && i < o; break; case "xor": var a = Math.abs(t.length - e.length); this._isInResult = a % 2 == 1; break; case "difference": var s = function (t) { return 1 === t.length && t[0].isSubject }; this._isInResult = s(t) !== s(e); break; default: throw new Error("Unrecognized operation type found ".concat(zd.type)) }return this._isInResult } }], [{ key: "fromRing", value: function (e, n, r) { var i, o, a, s = Ld.comparePoints(e, n); if (s < 0) i = e, o = n, a = 1; else { if (!(s > 0)) throw new Error("Tried to create degenerate segment at [".concat(e.x, ", ").concat(e.y, "]")); i = n, o = e, a = -1 } return new t(new Ld(i, !0), new Ld(o, !1), [r], [a]) } }]), t }(), Td = function () { function t(e, n, r) { if (pd(this, t), !Array.isArray(e) || 0 === e.length) throw new Error("Input geometry is not a valid Polygon or MultiPolygon"); if (this.poly = n, this.isExterior = r, this.segments = [], "number" != typeof e[0][0] || "number" != typeof e[0][1]) throw new Error("Input geometry is not a valid Polygon or MultiPolygon"); var i = wd.round(e[0][0], e[0][1]); this.bbox = { ll: { x: i.x, y: i.y }, ur: { x: i.x, y: i.y } }; for (var o = i, a = 1, s = e.length; a < s; a++) { if ("number" != typeof e[a][0] || "number" != typeof e[a][1]) throw new Error("Input geometry is not a valid Polygon or MultiPolygon"); var u = wd.round(e[a][0], e[a][1]); u.x === o.x && u.y === o.y || (this.segments.push(Cd.fromRing(o, u, this)), u.x < this.bbox.ll.x && (this.bbox.ll.x = u.x), u.y < this.bbox.ll.y && (this.bbox.ll.y = u.y), u.x > this.bbox.ur.x && (this.bbox.ur.x = u.x), u.y > this.bbox.ur.y && (this.bbox.ur.y = u.y), o = u) } i.x === o.x && i.y === o.y || this.segments.push(Cd.fromRing(o, i, this)) } return yd(t, [{ key: "getSweepEvents", value: function () { for (var t = [], e = 0, n = this.segments.length; e < n; e++) { var r = this.segments[e]; t.push(r.leftSE), t.push(r.rightSE) } return t } }]), t }(), Ad = function () { function t(e, n) { if (pd(this, t), !Array.isArray(e)) throw new Error("Input geometry is not a valid Polygon or MultiPolygon"); this.exteriorRing = new Td(e[0], this, !0), this.bbox = { ll: { x: this.exteriorRing.bbox.ll.x, y: this.exteriorRing.bbox.ll.y }, ur: { x: this.exteriorRing.bbox.ur.x, y: this.exteriorRing.bbox.ur.y } }, this.interiorRings = []; for (var r = 1, i = e.length; r < i; r++) { var o = new Td(e[r], this, !1); o.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = o.bbox.ll.x), o.bbox.ll.y < this.bbox.ll.y && (this.bbox.ll.y = o.bbox.ll.y), o.bbox.ur.x > this.bbox.ur.x && (this.bbox.ur.x = o.bbox.ur.x), o.bbox.ur.y > this.bbox.ur.y && (this.bbox.ur.y = o.bbox.ur.y), this.interiorRings.push(o) } this.multiPoly = n } return yd(t, [{ key: "getSweepEvents", value: function () { for (var t = this.exteriorRing.getSweepEvents(), e = 0, n = this.interiorRings.length; e < n; e++)for (var r = this.interiorRings[e].getSweepEvents(), i = 0, o = r.length; i < o; i++)t.push(r[i]); return t } }]), t }(), Dd = function () { function t(e, n) { if (pd(this, t), !Array.isArray(e)) throw new Error("Input geometry is not a valid Polygon or MultiPolygon"); try { "number" == typeof e[0][0][0] && (e = [e]) } catch (t) { } this.polys = [], this.bbox = { ll: { x: Number.POSITIVE_INFINITY, y: Number.POSITIVE_INFINITY }, ur: { x: Number.NEGATIVE_INFINITY, y: Number.NEGATIVE_INFINITY } }; for (var r = 0, i = e.length; r < i; r++) { var o = new Ad(e[r], this); o.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = o.bbox.ll.x), o.bbox.ll.y < this.bbox.ll.y && (this.bbox.ll.y = o.bbox.ll.y), o.bbox.ur.x > this.bbox.ur.x && (this.bbox.ur.x = o.bbox.ur.x), o.bbox.ur.y > this.bbox.ur.y && (this.bbox.ur.y = o.bbox.ur.y), this.polys.push(o) } this.isSubject = n } return yd(t, [{ key: "getSweepEvents", value: function () { for (var t = [], e = 0, n = this.polys.length; e < n; e++)for (var r = this.polys[e].getSweepEvents(), i = 0, o = r.length; i < o; i++)t.push(r[i]); return t } }]), t }(), jd = function () { function t(e) { pd(this, t), this.events = e; for (var n = 0, r = e.length; n < r; n++)e[n].segment.ringOut = this; this.poly = null } return yd(t, null, [{ key: "factory", value: function (e) { for (var n = [], r = 0, i = e.length; r < i; r++) { var o = e[r]; if (o.isInResult() && !o.ringOut) { for (var a = null, s = o.leftSE, u = o.rightSE, l = [s], c = s.point, h = []; a = s, s = u, l.push(s), s.point !== c;)for (; ;) { var f = s.getAvailableLinkedEvents(); if (0 === f.length) { var p = l[0].point, g = l[l.length - 1].point; throw new Error("Unable to complete output ring starting at [".concat(p.x, ",") + " ".concat(p.y, "]. Last matching segment found ends at") + " [".concat(g.x, ", ").concat(g.y, "].")) } if (1 === f.length) { u = f[0].otherSE; break } for (var y = null, v = 0, d = h.length; v < d; v++)if (h[v].point === s.point) { y = v; break } if (null === y) { h.push({ index: l.length, point: s.point }); var m = s.getLeftmostComparator(a); u = f.sort(m)[0].otherSE; break } var _ = h.splice(y)[0], b = l.splice(_.index); b.unshift(b[0].otherSE), n.push(new t(b.reverse())) } n.push(new t(l)) } } return n } }]), yd(t, [{ key: "getGeom", value: function () { for (var t = this.events[0].point, e = [t], n = 1, r = this.events.length - 1; n < r; n++) { var i = this.events[n].point, o = this.events[n + 1].point; 0 !== Id(i, t, o) && (e.push(i), t = i) } if (1 === e.length) return null; var a = e[0], s = e[1]; 0 === Id(a, t, s) && e.shift(), e.push(e[0]); for (var u = this.isExteriorRing() ? 1 : -1, l = this.isExteriorRing() ? 0 : e.length - 1, c = this.isExteriorRing() ? e.length : -1, h = [], f = l; f != c; f += u)h.push([e[f].x, e[f].y]); return h } }, { key: "isExteriorRing", value: function () { if (void 0 === this._isExteriorRing) { var t = this.enclosingRing(); this._isExteriorRing = !t || !t.isExteriorRing() } return this._isExteriorRing } }, { key: "enclosingRing", value: function () { return void 0 === this._enclosingRing && (this._enclosingRing = this._calcEnclosingRing()), this._enclosingRing } }, { key: "_calcEnclosingRing", value: function () { for (var t = this.events[0], e = 1, n = this.events.length; e < n; e++) { var r = this.events[e]; Ld.compare(t, r) > 0 && (t = r) } for (var i = t.segment.prevInResult(), o = i ? i.prevInResult() : null; ;) { if (!i) return null; if (!o) return i.ringOut; if (o.ringOut !== i.ringOut) return o.ringOut.enclosingRing() !== i.ringOut ? i.ringOut : i.ringOut.enclosingRing(); i = o.prevInResult(), o = i ? i.prevInResult() : null } } }]), t }(), Fd = function () { function t(e) { pd(this, t), this.exteriorRing = e, e.poly = this, this.interiorRings = [] } return yd(t, [{ key: "addInterior", value: function (t) { this.interiorRings.push(t), t.poly = this } }, { key: "getGeom", value: function () { var t = [this.exteriorRing.getGeom()]; if (null === t[0]) return null; for (var e = 0, n = this.interiorRings.length; e < n; e++) { var r = this.interiorRings[e].getGeom(); null !== r && t.push(r) } return t } }]), t }(), Bd = function () { function t(e) { pd(this, t), this.rings = e, this.polys = this._composePolys(e) } return yd(t, [{ key: "getGeom", value: function () { for (var t = [], e = 0, n = this.polys.length; e < n; e++) { var r = this.polys[e].getGeom(); null !== r && t.push(r) } return t } }, { key: "_composePolys", value: function (t) { for (var e = [], n = 0, r = t.length; n < r; n++) { var i = t[n]; if (!i.poly) if (i.isExteriorRing()) e.push(new Fd(i)); else { var o = i.enclosingRing(); o.poly || e.push(new Fd(o)), o.poly.addInterior(i) } } return e } }]), t }(), qd = function () { function t(e) { var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Cd.compare; pd(this, t), this.queue = e, this.tree = new ld(n), this.segments = [] } return yd(t, [{ key: "process", value: function (t) { var e = t.segment, n = []; if (t.consumedBy) return t.isLeft ? this.queue.remove(t.otherSE) : this.tree.remove(e), n; var r = t.isLeft ? this.tree.insert(e) : this.tree.find(e); if (!r) throw new Error("Unable to find segment #".concat(e.id, " ") + "[".concat(e.leftSE.point.x, ", ").concat(e.leftSE.point.y, "] -> ") + "[".concat(e.rightSE.point.x, ", ").concat(e.rightSE.point.y, "] ") + "in SweepLine tree. Please submit a bug report."); for (var i = r, o = r, a = void 0, s = void 0; void 0 === a;)null === (i = this.tree.prev(i)) ? a = null : void 0 === i.key.consumedBy && (a = i.key); for (; void 0 === s;)null === (o = this.tree.next(o)) ? s = null : void 0 === o.key.consumedBy && (s = o.key); if (t.isLeft) { var u = null; if (a) { var l = a.getIntersection(e); if (null !== l && (e.isAnEndpoint(l) || (u = l), !a.isAnEndpoint(l))) for (var c = this._splitSafely(a, l), h = 0, f = c.length; h < f; h++)n.push(c[h]) } var p = null; if (s) { var g = s.getIntersection(e); if (null !== g && (e.isAnEndpoint(g) || (p = g), !s.isAnEndpoint(g))) for (var y = this._splitSafely(s, g), v = 0, d = y.length; v < d; v++)n.push(y[v]) } if (null !== u || null !== p) { var m = null; if (null === u) m = p; else if (null === p) m = u; else { m = Ld.comparePoints(u, p) <= 0 ? u : p } this.queue.remove(e.rightSE), n.push(e.rightSE); for (var _ = e.split(m), b = 0, x = _.length; b < x; b++)n.push(_[b]) } n.length > 0 ? (this.tree.remove(e), n.push(t)) : (this.segments.push(e), e.prev = a) } else { if (a && s) { var E = a.getIntersection(s); if (null !== E) { if (!a.isAnEndpoint(E)) for (var w = this._splitSafely(a, E), k = 0, S = w.length; k < S; k++)n.push(w[k]); if (!s.isAnEndpoint(E)) for (var I = this._splitSafely(s, E), P = 0, N = I.length; P < N; P++)n.push(I[P]) } } this.tree.remove(e) } return n } }, { key: "_splitSafely", value: function (t, e) { this.tree.remove(t); var n = t.rightSE; this.queue.remove(n); var r = t.split(e); return r.push(n), void 0 === t.consumedBy && this.tree.insert(t), r } }]), t }(), Vd = "undefined" != typeof process && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1e6, Gd = "undefined" != typeof process && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1e6, Yd = function () { function t() { pd(this, t) } return yd(t, [{ key: "run", value: function (t, e, n) { zd.type = t, wd.reset(); for (var r = [new Dd(e, !0)], i = 0, o = n.length; i < o; i++)r.push(new Dd(n[i], !1)); if (zd.numMultiPolys = r.length, "difference" === zd.type) for (var a = r[0], s = 1; s < r.length;)null !== dd(r[s].bbox, a.bbox) ? s++ : r.splice(s, 1); if ("intersection" === zd.type) for (var u = 0, l = r.length; u < l; u++)for (var c = r[u], h = u + 1, f = r.length; h < f; h++)if (null === dd(c.bbox, r[h].bbox)) return []; for (var p = new ld(Ld.compare), g = 0, y = r.length; g < y; g++)for (var v = r[g].getSweepEvents(), d = 0, m = v.length; d < m; d++)if (p.insert(v[d]), p.size > Vd) throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big). Please file a bug report."); for (var _ = new qd(p), b = p.size, x = p.pop(); x;) { var E = x.key; if (p.size === b) { var w = E.segment; throw new Error("Unable to pop() ".concat(E.isLeft ? "left" : "right", " SweepEvent ") + "[".concat(E.point.x, ", ").concat(E.point.y, "] from segment #").concat(w.id, " ") + "[".concat(w.leftSE.point.x, ", ").concat(w.leftSE.point.y, "] -> ") + "[".concat(w.rightSE.point.x, ", ").concat(w.rightSE.point.y, "] from queue. ") + "Please file a bug report.") } if (p.size > Vd) throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big). Please file a bug report."); if (_.segments.length > Gd) throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments). Please file a bug report."); for (var k = _.process(E), S = 0, I = k.length; S < I; S++) { var P = k[S]; void 0 === P.consumedBy && p.insert(P) } b = p.size, x = p.pop() } wd.reset(); var N = jd.factory(_.segments); return new Bd(N).getGeom() } }]), t }(), zd = new Yd, Ud = { union: function (t) { for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)n[r - 1] = arguments[r]; return zd.run("union", t, n) }, intersection: function (t) { for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)n[r - 1] = arguments[r]; return zd.run("intersection", t, n) }, xor: function (t) { for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)n[r - 1] = arguments[r]; return zd.run("xor", t, n) }, difference: function (t) { for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)n[r - 1] = arguments[r]; return zd.run("difference", t, n) } }, Xd = Object.defineProperty; function Wd(t) { var e = []; if (jl(t, (function (t) { e.push(t.coordinates) })), e.length < 2) throw new Error("Must have at least two features"); var n = t.features[0].properties || {}, r = Ud.difference.apply(Ud, [e[0]].concat(s(e.slice(1)))); return 0 === r.length ? null : 1 === r.length ? Cu(r[0], n) : qu(r, n) } !function (t, e) { Xd(t, "name", { value: e, configurable: !0 }) }(Wd, "difference"); var Hd = Object.defineProperty; function Zd(t) { if (!t) throw new Error("geojson is required"); var e = []; return Bl(t, (function (t) { e.push(t) })), ju(e) } !function (t, e) { Hd(t, "name", { value: e, configurable: !0 }) }(Zd, "flatten"); var Jd = Object.defineProperty; function $d(t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (!Qu(e = e || {})) throw new Error("options is invalid"); var n = e.propertyName; ll(t, "Polygon", "dissolve"); var r = []; if (!n) return Zd(qu(Ud.union.apply(null, t.features.map((function (t) { return t.geometry.coordinates }))))); var i = {}; Tl(t, (function (t) { t.properties && (Object.prototype.hasOwnProperty.call(i, t.properties[n]) || (i[t.properties[n]] = []), i[t.properties[n]].push(t)) })); for (var o = Object.keys(i), a = 0; a < o.length; a++) { var s = qu(Ud.union.apply(null, i[o[a]].map((function (t) { return t.geometry.coordinates })))); s && s.properties && (s.properties[n] = o[a], r.push(s)) } return Zd(ju(r)) } !function (t, e) { Jd(t, "name", { value: e, configurable: !0 }) }($d, "dissolve"); var Qd = Object.defineProperty, Kd = function (t, e) { return Qd(t, "name", { value: e, configurable: !0 }) }; function tm(t, e) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 2, r = il(t), i = il(e), o = r[0] - i[0], a = r[1] - i[1]; return 1 === n ? Math.abs(o) + Math.abs(a) : Math.pow(Math.pow(o, n) + Math.pow(a, n), 1 / n) } function em(t, e) { var n, r, i = (e = e || {}).threshold || 1e4, o = e.p || 2, a = null != (n = e.binary) && n, s = e.alpha || -1, u = null != (r = e.standardization) && r, l = []; Tl(t, (function (t) { l.push(Ug(t)) })); for (var c = [], h = 0; h < l.length; h++)c[h] = []; for (var f = 0; f < l.length; f++)for (var p = f; p < l.length; p++) { f === p && (c[f][p] = 0); var g = tm(l[f], l[p], o); c[f][p] = g, c[p][f] = g } for (var y = 0; y < l.length; y++)for (var v = 0; v < l.length; v++) { var d = c[y][v]; 0 !== d && (c[y][v] = a ? d <= i ? 1 : 0 : d <= i ? Math.pow(d, s) : 0) } if (u) for (var m = 0; m < l.length; m++)for (var _ = c[m].reduce((function (t, e) { return t + e }), 0), b = 0; b < l.length; b++)c[m][b] = c[m][b] / _; return c } Kd(tm, "pNormDistance"), Kd(em, "distanceWeight"); var nm = Object.defineProperty, rm = function (t, e) { return nm(t, "name", { value: e, configurable: !0 }) }; function im(t, e, n) { var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, i = e < 0, o = Zu(Math.abs(e), r.units, "meters"); i && (o = -Math.abs(o)); var a = il(t), s = om(a, o, n); return s[0] += s[0] - a[0] > 180 ? -360 : a[0] - s[0] > 180 ? 360 : 0, Lu(s, r.properties) } function om(t, e, n, r) { var i = e / (r = void 0 === r ? Iu : Number(r)), o = t[0] * Math.PI / 180, a = Hu(t[1]), s = Hu(n), u = i * Math.cos(s), l = a + u; Math.abs(l) > Math.PI / 2 && (l = l > 0 ? Math.PI - l : -Math.PI - l); var c = Math.log(Math.tan(l / 2 + Math.PI / 4) / Math.tan(a / 2 + Math.PI / 4)), h = Math.abs(c) > 1e-11 ? u / c : Math.cos(a); return [(180 * (o + i * Math.sin(s) / h) / Math.PI + 540) % 360 - 180, 180 * l / Math.PI] } rm(im, "rhumbDestination"), rm(om, "calculateRhumbDestination"); var am = Object.defineProperty, sm = function (t, e) { return am(t, "name", { value: e, configurable: !0 }) }; function um(t, e) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r = il(t), i = il(e); return i[0] += i[0] - r[0] > 180 ? -360 : r[0] - i[0] > 180 ? 360 : 0, Zu(lm(r, i), "meters", n.units) } function lm(t, e, n) { var r = n = void 0 === n ? Iu : Number(n), i = t[1] * Math.PI / 180, o = e[1] * Math.PI / 180, a = o - i, s = Math.abs(e[0] - t[0]) * Math.PI / 180; s > Math.PI && (s -= 2 * Math.PI); var u = Math.log(Math.tan(o / 2 + Math.PI / 4) / Math.tan(i / 2 + Math.PI / 4)), l = Math.abs(u) > 1e-11 ? a / u : Math.cos(i); return Math.sqrt(a * a + l * l * s * s) * r } sm(um, "rhumbDistance"), sm(lm, "calculateRhumbDistance"); var cm = Object.defineProperty; function hm(t, e, n) { if (!Qu(n = n || {})) throw new Error("options is invalid"); var r = n.pivot, i = n.mutate; if (!t) throw new Error("geojson is required"); if (null == e || isNaN(e)) throw new Error("angle is required"); return 0 === e || (r || (r = Ug(t)), !1 !== i && void 0 !== i || (t = Ry(t)), Ol(t, (function (t) { var n = kl(r, t) + e, i = um(r, t), o = ol(im(r, i, n)); t[0] = o[0], t[1] = o[1] }))), t } !function (t, e) { cm(t, "name", { value: e, configurable: !0 }) }(hm, "transformRotate"); var fm = Object.defineProperty, pm = function (t, e) { return fm(t, "name", { value: e, configurable: !0 }) }; function gm(t, e, n, r) { var i = (r = r || {}).steps || 64, o = r.units || "kilometers", a = r.angle || 0, s = r.pivot || t, u = r.properties || {}; if (!t) throw new Error("center is required"); if (!e) throw new Error("xSemiAxis is required"); if (!n) throw new Error("ySemiAxis is required"); if (!Qu(r)) throw new Error("options must be an object"); if (!$u(i)) throw new Error("steps must be a number"); if (!$u(a)) throw new Error("angle must be a number"); var l = il(t); if ("degrees" !== o) { var c = im(t, e, 90, { units: o }), h = im(t, n, 0, { units: o }); e = il(c)[0] - l[0], n = il(h)[1] - l[1] } for (var f = [], p = 0; p < i; p += 1) { var g = -360 * p / i, y = e * n / Math.sqrt(Math.pow(n, 2) + Math.pow(e, 2) * Math.pow(ym(g), 2)), v = e * n / Math.sqrt(Math.pow(e, 2) + Math.pow(n, 2) / Math.pow(ym(g), 2)); if (g < -90 && g >= -270 && (y = -y), g < -180 && g >= -360 && (v = -v), "degrees" === o) { var d = Hu(a), m = y * Math.cos(d) + v * Math.sin(d), _ = v * Math.cos(d) - y * Math.sin(d); y = m, v = _ } f.push([y + l[0], v + l[1]]) } return f.push(f[0]), "degrees" === o ? Cu([f], u) : hm(Cu([f], u), a, { pivot: s }) } function ym(t) { var e = t * Math.PI / 180; return Math.tan(e) } pm(gm, "ellipse"), pm(ym, "getTanDeg"); var vm = Object.defineProperty; function dm(t) { return pc(rc(t)) } !function (t, e) { vm(t, "name", { value: e, configurable: !0 }) }(dm, "envelope"); var mm = Object.defineProperty; function _m(t) { var e = []; return "FeatureCollection" === t.type ? Tl(t, (function (t) { Ol(t, (function (n) { e.push(Lu(n, t.properties)) })) })) : "Feature" === t.type ? Ol(t, (function (n) { e.push(Lu(n, t.properties)) })) : Ol(t, (function (t) { e.push(Lu(t)) })), ju(e) } !function (t, e) { mm(t, "name", { value: e, configurable: !0 }) }(_m, "explode"); var bm = Object.defineProperty; function xm(t, e) { var n; if (!Qu(e = e || {})) throw new Error("options is invalid"); var r = null != (n = e.mutate) && n; if (!t) throw new Error("geojson is required"); return !1 !== r && void 0 !== r || (t = Ry(t)), Ol(t, (function (t) { var e = t[0], n = t[1]; t[0] = n, t[1] = e })), t } !function (t, e) { bm(t, "name", { value: e, configurable: !0 }) }(xm, "flip"); var Em = Object.defineProperty, wm = function (t, e) { return Em(t, "name", { value: e, configurable: !0 }) }, km = Math.PI / 180, Sm = 180 / Math.PI, Im = wm((function (t, e) { this.lon = t, this.lat = e, this.x = km * t, this.y = km * e }), "Coord"); Im.prototype.view = function () { return String(this.lon).slice(0, 4) + "," + String(this.lat).slice(0, 4) }, Im.prototype.antipode = function () { var t = -1 * this.lat, e = this.lon < 0 ? 180 + this.lon : -1 * (180 - this.lon); return new Im(e, t) }; var Pm = wm((function () { this.coords = [], this.length = 0 }), "LineString"); Pm.prototype.move_to = function (t) { this.length++, this.coords.push(t) }; var Nm = wm((function (t) { this.properties = t || {}, this.geometries = [] }), "Arc"); Nm.prototype.json = function () { if (this.geometries.length <= 0) return { geometry: { type: "LineString", coordinates: null }, type: "Feature", properties: this.properties }; if (1 === this.geometries.length) return { geometry: { type: "LineString", coordinates: this.geometries[0].coords }, type: "Feature", properties: this.properties }; for (var t = [], e = 0; e < this.geometries.length; e++)t.push(this.geometries[e].coords); return { geometry: { type: "MultiLineString", coordinates: t }, type: "Feature", properties: this.properties } }, Nm.prototype.wkt = function () { for (var t = "", e = "LINESTRING(", n = wm((function (t) { e += t[0] + " " + t[1] + "," }), "collect"), r = 0; r < this.geometries.length; r++) { if (0 === this.geometries[r].coords.length) return "LINESTRING(empty)"; this.geometries[r].coords.forEach(n), t += e.substring(0, e.length - 1) + ")" } return t }; var Mm = wm((function (t, e, n) { if (!t || void 0 === t.x || void 0 === t.y) throw new Error("GreatCircle constructor expects two args: start and end objects with x and y properties"); if (!e || void 0 === e.x || void 0 === e.y) throw new Error("GreatCircle constructor expects two args: start and end objects with x and y properties"); this.start = new Im(t.x, t.y), this.end = new Im(e.x, e.y), this.properties = n || {}; var r = this.start.x - this.end.x, i = this.start.y - this.end.y, o = Math.pow(Math.sin(i / 2), 2) + Math.cos(this.start.y) * Math.cos(this.end.y) * Math.pow(Math.sin(r / 2), 2); if (this.g = 2 * Math.asin(Math.sqrt(o)), this.g === Math.PI) throw new Error("it appears " + t.view() + " and " + e.view() + " are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite"); if (isNaN(this.g)) throw new Error("could not calculate great circle between " + t + " and " + e) }), "GreatCircle"); function Om(t, n, r) { if ("object" !== e(r = r || {})) throw new Error("options is invalid"); var i = r.properties, o = r.npoints, a = r.offset; return t = il(t), n = il(n), i = i || {}, o = o || 100, a = a || 10, new Mm({ x: t[0], y: t[1] }, { x: n[0], y: n[1] }, i).Arc(o, { offset: a }).json() } Mm.prototype.interpolate = function (t) { var e = Math.sin((1 - t) * this.g) / Math.sin(this.g), n = Math.sin(t * this.g) / Math.sin(this.g), r = e * Math.cos(this.start.y) * Math.cos(this.start.x) + n * Math.cos(this.end.y) * Math.cos(this.end.x), i = e * Math.cos(this.start.y) * Math.sin(this.start.x) + n * Math.cos(this.end.y) * Math.sin(this.end.x), o = e * Math.sin(this.start.y) + n * Math.sin(this.end.y), a = Sm * Math.atan2(o, Math.sqrt(Math.pow(r, 2) + Math.pow(i, 2))); return [Sm * Math.atan2(i, r), a] }, Mm.prototype.Arc = function (t, e) { var n = []; if (!t || t <= 2) n.push([this.start.lon, this.start.lat]), n.push([this.end.lon, this.end.lat]); else for (var r = 1 / (t - 1), i = 0; i < t; ++i) { var o = r * i, a = this.interpolate(o); n.push(a) } for (var s = !1, u = 0, l = e && e.offset ? e.offset : 10, c = 180 - l, h = -180 + l, f = 360 - l, p = 1; p < n.length; ++p) { var g = n[p - 1][0], y = n[p][0], v = Math.abs(y - g); v > f && (y > c && g < h || g > c && y < h) ? s = !0 : v > u && (u = v) } var d = []; if (s && u < l) { var m = []; d.push(m); for (var _ = 0; _ < n.length; ++_) { var b = parseFloat(n[_][0]); if (_ > 0 && Math.abs(b - n[_ - 1][0]) > f) { var x = parseFloat(n[_ - 1][0]), E = parseFloat(n[_ - 1][1]), w = parseFloat(n[_][0]), k = parseFloat(n[_][1]); if (x > -180 && x < h && 180 === w && _ + 1 < n.length && n[_ - 1][0] > -180 && n[_ - 1][0] < h) { m.push([-180, n[_][1]]), _++, m.push([n[_][0], n[_][1]]); continue } if (x > c && x < 180 && -180 === w && _ + 1 < n.length && n[_ - 1][0] > c && n[_ - 1][0] < 180) { m.push([180, n[_][1]]), _++, m.push([n[_][0], n[_][1]]); continue } if (x < h && w > c) { var S = x; x = w, w = S; var I = E; E = k, k = I } if (x > c && w < h && (w += 360), x <= 180 && w >= 180 && x < w) { var P = (180 - x) / (w - x), N = P * k + (1 - P) * E; m.push([n[_ - 1][0] > c ? 180 : -180, N]), (m = []).push([n[_ - 1][0] > c ? -180 : 180, N]), d.push(m) } else m = [], d.push(m); m.push([b, n[_][1]]) } else m.push([n[_][0], n[_][1]]) } } else { var M = []; d.push(M); for (var O = 0; O < n.length; ++O)M.push([n[O][0], n[O][1]]) } for (var L = new Nm(this.properties), R = 0; R < d.length; ++R) { var C = new Pm; L.geometries.push(C); for (var T = d[R], A = 0; A < T.length; ++A)C.move_to(T[A]) } return L }, wm(Om, "greatCircle");
            /*!
            * Copyright (c) 2019, Dane Springmeyer
            *
            * Redistribution and use in source and binary forms, with or without
            * modification, are permitted provided that the following conditions are
            * met:
            *
            *     * Redistributions of source code must retain the above copyright
            *       notice, this list of conditions and the following disclaimer.
            *     * Redistributions in binary form must reproduce the above copyright
            *       notice, this list of conditions and the following disclaimer in
            *       the documentation and/or other materials provided with the
            *       distribution.
            *
            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
            * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
            * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
            * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
            * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
            * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
            * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
            * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
            * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
            * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
            * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
            */
            var Lm = Object.defineProperty; function Rm(t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = []; if (jl(t, (function (t) { n.push(t.coordinates) })), n.length < 2) throw new Error("Must specify at least 2 geometries"); var r = Ud.intersection.apply(Ud, [n[0]].concat(s(n.slice(1)))); return 0 === r.length ? null : 1 === r.length ? Cu(r[0], e.properties) : qu(r, e.properties) } !function (t, e) { Lm(t, "name", { value: e, configurable: !0 }) }(Rm, "intersect"); var Cm = Object.defineProperty, Tm = function (t, e) { return Cm(t, "name", { value: e, configurable: !0 }) }; function Am(t, e) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r = JSON.stringify(n.properties || {}), i = a(t, 4), o = i[0], s = i[1], u = i[2], l = i[3], c = (s + l) / 2, h = (o + u) / 2, f = 2 * e / _l([o, c], [u, c], n) * (u - o), p = 2 * e / _l([h, s], [h, l], n) * (l - s), g = f / 2, y = 2 * g, v = Math.sqrt(3) / 2 * p, d = u - o, m = l - s, _ = 3 / 4 * y, b = v, x = (d - y) / (y - g / 2), E = Math.floor(x), w = (E * _ - g / 2 - d) / 2 - g / 2 + _ / 2, k = Math.floor((m - v) / v), S = (m - k * v) / 2, I = k * v - m > v / 2; I && (S -= v / 4); for (var P = [], N = [], M = 0; M < 6; M++) { var O = 2 * Math.PI / 6 * M; P.push(Math.cos(O)), N.push(Math.sin(O)) } for (var L = [], R = 0; R <= E; R++)for (var C = 0; C <= k; C++) { var T = R % 2 == 1; if ((0 !== C || !T) && (0 !== C || !I)) { var A = R * _ + o - w, D = C * b + s + S; if (T && (D -= v / 2), !0 === n.triangles) jm([A, D], f / 2, p / 2, JSON.parse(r), P, N).forEach((function (t) { n.mask ? Rm(ju([n.mask, t])) && L.push(t) : L.push(t) })); else { var j = Dm([A, D], f / 2, p / 2, JSON.parse(r), P, N); n.mask ? Rm(ju([n.mask, j])) && L.push(j) : L.push(j) } } } return ju(L) } function Dm(t, e, n, r, i, o) { for (var a = [], s = 0; s < 6; s++) { var u = t[0] + e * i[s], l = t[1] + n * o[s]; a.push([u, l]) } return a.push(a[0].slice()), Cu([a], r) } function jm(t, e, n, r, i, o) { for (var a = [], s = 0; s < 6; s++) { var u = []; u.push(t), u.push([t[0] + e * i[s], t[1] + n * o[s]]), u.push([t[0] + e * i[(s + 1) % 6], t[1] + n * o[(s + 1) % 6]]), u.push(t), a.push(Cu([u], r)) } return a } Tm(Am, "hexGrid"), Tm(Dm, "hexagon"), Tm(jm, "hexTriangles"); var Fm = Object.defineProperty; function Bm(t, e) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; n.mask && !n.units && (n.units = "kilometers"); for (var r = [], i = t[0], o = t[1], a = t[2], s = t[3], u = e / _l([i, o], [a, o], n) * (a - i), l = e / _l([i, o], [i, s], n) * (s - o), c = a - i, h = s - o, f = Math.floor(c / u), p = (h - Math.floor(h / l) * l) / 2, g = i + (c - f * u) / 2; g <= a;) { for (var y = o + p; y <= s;) { var v = Lu([g, y], n.properties); n.mask ? Jf(v, n.mask) && r.push(v) : r.push(v), y += l } g += u } return ju(r) } !function (t, e) { Fm(t, "name", { value: e, configurable: !0 }) }(Bm, "pointGrid"); var qm = Object.defineProperty; function Vm(t, e, n) { for (var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, i = [], o = t[0], a = t[1], s = t[2], u = t[3], l = s - o, c = Zu(e, r.units, "degrees"), h = u - a, f = Zu(n, r.units, "degrees"), p = Math.floor(Math.abs(l) / c), g = Math.floor(Math.abs(h) / f), y = (h - g * f) / 2, v = o + (l - p * c) / 2, d = 0; d < p; d++) { for (var m = a + y, _ = 0; _ < g; _++) { var b = Cu([[[v, m], [v, m + f], [v + c, m + f], [v + c, m], [v, m]]], r.properties); r.mask ? Gh(r.mask, b) && i.push(b) : i.push(b), m += f } v += c } return ju(i) } !function (t, e) { qm(t, "name", { value: e, configurable: !0 }) }(Vm, "rectangleGrid"); var Gm = Object.defineProperty; function Ym(t, e) { return Vm(t, e, e, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}) } !function (t, e) { Gm(t, "name", { value: e, configurable: !0 }) }(Ym, "squareGrid"); var zm = Object.defineProperty; function Um(t, e) { for (var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r = [], i = e / _l([t[0], t[1]], [t[2], t[1]], n) * (t[2] - t[0]), o = e / _l([t[0], t[1]], [t[0], t[3]], n) * (t[3] - t[1]), a = 0, s = t[0]; s <= t[2];) { for (var u = 0, l = t[1]; l <= t[3];) { var c = null, h = null; a % 2 == 0 && u % 2 == 0 ? (c = Cu([[[s, l], [s, l + o], [s + i, l], [s, l]]], n.properties), h = Cu([[[s, l + o], [s + i, l + o], [s + i, l], [s, l + o]]], n.properties)) : a % 2 == 0 && u % 2 == 1 ? (c = Cu([[[s, l], [s + i, l + o], [s + i, l], [s, l]]], n.properties), h = Cu([[[s, l], [s, l + o], [s + i, l + o], [s, l]]], n.properties)) : u % 2 == 0 && a % 2 == 1 ? (c = Cu([[[s, l], [s, l + o], [s + i, l + o], [s, l]]], n.properties), h = Cu([[[s, l], [s + i, l + o], [s + i, l], [s, l]]], n.properties)) : u % 2 == 1 && a % 2 == 1 && (c = Cu([[[s, l], [s, l + o], [s + i, l], [s, l]]], n.properties), h = Cu([[[s, l + o], [s + i, l + o], [s + i, l], [s, l + o]]], n.properties)), n.mask ? (Rm(ju([n.mask, c])) && r.push(c), Rm(ju([n.mask, h])) && r.push(h)) : (r.push(c), r.push(h)), l += o, u++ } a++, s += i } return ju(r) } !function (t, e) { zm(t, "name", { value: e, configurable: !0 }) }(Um, "triangleGrid"); var Xm = Object.defineProperty; function Wm(t, n, r) { if ("object" !== e(r = r || {})) throw new Error("options is invalid"); var i = r.gridType, o = r.property, a = r.weight; if (!t) throw new Error("points is required"); if (ll(t, "Point", "input must contain Points"), !n) throw new Error("cellSize is required"); if (void 0 !== a && "number" != typeof a) throw new Error("weight must be a number"); o = o || "elevation", i = i || "square", a = a || 1; var s, u = rc(t); switch (i) { case "point": case "points": s = Bm(u, n, r); break; case "square": case "squares": s = Ym(u, n, r); break; case "hex": case "hexes": s = Am(u, n, r); break; case "triangle": case "triangles": s = Um(u, n, r); break; default: throw new Error("invalid gridType") }var l = []; return Tl(s, (function (e) { var n = 0, s = 0; Tl(t, (function (t) { var u, l = _l("point" === i ? e : Ug(e), t, r); if (void 0 !== o && (u = t.properties[o]), void 0 === u && (u = t.geometry.coordinates[2]), void 0 === u) throw new Error("zValue is missing"); 0 === l && (n = u); var c = 1 / Math.pow(l, a); s += c, n += c * u })); var u = Ry(e); u.properties[o] = n / s, l.push(u) })), ju(l) }
            /*!
            * MarchingSquaresJS
            * version 1.3.3
            * https://github.com/RaumZeit/MarchingSquares.js
            *
            * @license GNU Affero General Public License.
            * Copyright (c) 2015-2019 Ronny Lorenz <ronny@tbi.univie.ac.at>
            */
            function Hm(t, e, n) { return t < e ? (n - t) / (e - t) : (t - n) / (t - e) } function Zm(t, e, n, r) { var i; return n > r && (i = n, n = r, r = i), t < e ? t < n ? (n - t) / (e - t) : (r - t) / (e - t) : t > r ? (t - r) / (t - e) : (t - n) / (t - e) } function Jm(t, e, n, r) { return t < e ? (n - t) / (e - t) : (t - r) / (t - e) } function $m(t, e, n, r) { return t < e ? (r - t) / (e - t) : (t - n) / (t - e) } function Qm() { this.successCallback = null, this.verbose = !1, this.polygons = !1, this.polygons_full = !1, this.linearRing = !0, this.noQuadTree = !1, this.noFrame = !1 } function Km(t, e, n, r) { var i = []; return t.polygons.forEach((function (t) { t.forEach((function (t) { t[0] += e, t[1] += n })), r.linearRing && t.push(t[0]), i.push(t) })), i } function t_(t, e, n, r) { return 0 === n ? (t += 1, e += r[0][1]) : 1 === n ? t += r[0][0] : 2 === n ? e += r[0][1] : 3 === n && (t += r[0][0], e += 1), [t, e] } function e_(t, e, n) { return 0 === n ? t++ : 1 === n || (2 === n ? e++ : 3 === n && (t++, e++)), [t, e] } function n_(t, e, n, r, i) { var o = r, a = i, s = 0, u = 0; if (this.x = e, this.y = n, this.lowerBound = null, this.upperBound = null, this.childA = null, this.childB = null, this.childC = null, this.childD = null, 1 === r && 1 === i) this.lowerBound = Math.min(t[n][e], t[n][e + 1], t[n + 1][e + 1], t[n + 1][e]), this.upperBound = Math.max(t[n][e], t[n][e + 1], t[n + 1][e + 1], t[n + 1][e]); else { if (r > 1) { for (; 0 !== o;)o >>= 1, s++; r === 1 << s - 1 && s--, o = 1 << s - 1 } if (i > 1) { for (; 0 !== a;)a >>= 1, u++; i === 1 << u - 1 && u--, a = 1 << u - 1 } this.childA = new n_(t, e, n, o, a), this.lowerBound = this.childA.lowerBound, this.upperBound = this.childA.upperBound, r - o > 0 && (this.childB = new n_(t, e + o, n, r - o, a), this.lowerBound = Math.min(this.lowerBound, this.childB.lowerBound), this.upperBound = Math.max(this.upperBound, this.childB.upperBound), i - a > 0 && (this.childC = new n_(t, e + o, n + a, r - o, i - a), this.lowerBound = Math.min(this.lowerBound, this.childC.lowerBound), this.upperBound = Math.max(this.upperBound, this.childC.upperBound))), i - a > 0 && (this.childD = new n_(t, e, n + a, o, i - a), this.lowerBound = Math.min(this.lowerBound, this.childD.lowerBound), this.upperBound = Math.max(this.upperBound, this.childD.upperBound)) } } function r_(t) { var e, n; if (!t) throw new Error("data is required"); if (!Array.isArray(t) || !Array.isArray(t[0])) throw new Error("data must be scalar field, i.e. array of arrays"); if (t.length < 2) throw new Error("data must contain at least two rows"); if ((n = t[0].length) < 2) throw new Error("data must contain at least two columns"); for (e = 1; e < t.length; e++) { if (!Array.isArray(t[e])) throw new Error("Row " + e + " is not an array"); if (t[e].length != n) throw new Error("unequal row lengths detected, please provide a regular grid") } this.data = t, this.root = new n_(t, 0, 0, t[0].length - 1, t.length - 1) } function i_(t, n, r) { var i, o, a, s = !1, u = !1, l = null, c = null, h = null, f = null, p = null, g = []; if (!t) throw new Error("data is required"); if (null == n) throw new Error("threshold is required"); if (r && "object" !== e(r)) throw new Error("options must be an object"); if (i = function (t) { var e, n, r, i, o; for (i = new Qm, t = t || {}, o = Object.keys(i), e = 0; e < o.length; e++)null != (r = t[n = o[e]]) && (i[n] = r); return i.polygons_full = !i.polygons, i.interpolate = Hm, i }(r), t instanceof r_) l = t, c = t.root, h = t.data, i.noQuadTree || (s = !0); else { if (!Array.isArray(t) || !Array.isArray(t[0])) throw new Error("input is neither array of arrays nor object retrieved from 'QuadTree()'"); h = t } if (Array.isArray(n)) { for (u = !0, i.noQuadTree || (s = !0), o = 0; o < n.length; o++)if (isNaN(+n[o])) throw new Error("threshold[" + o + "] is not a number") } else { if (isNaN(+n)) throw new Error("threshold must be a number or array of numbers"); n = [n] } return s && !c && (l = new r_(h), c = l.root, h = l.data), i.verbose && (i.polygons ? console.log("MarchingSquaresJS-isoLines: returning single lines (polygons) for each grid cell") : console.log("MarchingSquaresJS-isoLines: returning line paths (polygons) for entire data grid"), u && console.log("MarchingSquaresJS-isoLines: multiple lines requested, returning array of line paths instead of lines for a single threshold")), n.forEach((function (t, n) { if (p = [], i.threshold = t, i.verbose && console.log("MarchingSquaresJS-isoLines: computing iso lines for threshold " + t), i.polygons) if (s) c.cellsBelowThreshold(i.threshold, !0).forEach((function (t) { p = p.concat(Km(o_(h, t.x, t.y, i), t.x, t.y, i)) })); else for (a = 0; a < h.length - 1; ++a)for (n = 0; n < h[0].length - 1; ++n)p = p.concat(Km(o_(h, n, a, i), n, a, i)); else { for (f = [], n = 0; n < h[0].length - 1; ++n)f[n] = []; if (s) c.cellsBelowThreshold(i.threshold, !1).forEach((function (t) { f[t.x][t.y] = o_(h, t.x, t.y, i) })); else for (n = 0; n < h[0].length - 1; ++n)for (a = 0; a < h.length - 1; ++a)f[n][a] = o_(h, n, a, i); p = function (t, n, r) { var i, o, a, s, u, l, c, h, f, p, g, y, v, d, m, _ = [], b = t.length - 1, x = t[0].length - 1, E = ["right", "bottom", "left", "top"], w = [0, -1, 0, 1], k = [-1, 0, 1, 0], S = { bottom: 1, left: 2, top: 3, right: 0 }; return r.noFrame || function (t, e) { var n, r, i, o, a; for (n = !0, r = t[0].length, i = t.length, a = 0; a < i; a++)if (t[a][0] >= e || t[a][r - 1] >= e) { n = !1; break } if (n && (t[i - 1][0] >= e || t[i - 1][r - 1] >= e) && (n = !1), n) for (o = 0; o < r - 1; o++)if (t[0][o] >= e || t[i - 1][o] > e) { n = !1; break } return n }(t, r.threshold) && (r.linearRing ? _.push([[0, 0], [0, b], [x, b], [x, 0], [0, 0]]) : _.push([[0, 0], [0, b], [x, b], [x, 0]])), n.forEach((function (t, I) { t.forEach((function (t, P) { for (i = null, o = 0; o < 4; o++)if (i = E[o], "object" === e(t.edges[i])) { for (u = [], a = t.edges[i], l = i, c = I, h = P, f = !1, p = [I + a.path[0][0], P + a.path[0][1]], u.push(p); !f && "object" === e((s = n[c][h]).edges[l]);)if (a = s.edges[l], delete s.edges[l], (g = a.path[1])[0] += c, g[1] += h, u.push(g), l = a.move.enter, c += a.move.x, h += a.move.y, void 0 === n[c] || void 0 === n[c][h]) { if (!r.linearRing) break; if (y = 0, v = 0, c === x ? (c--, y = 0) : c < 0 ? (c++, y = 2) : h === b ? (h--, y = 3) : h < 0 && (h++, y = 1), c === I && h === P && y === S[i]) { f = !0, l = i; break } for (; ;) { if (d = !1, v > 4) throw new Error("Direction change counter overflow! This should never happen!"); if (void 0 !== n[c] && void 0 !== n[c][h] && (s = n[c][h], m = E[y], "object" === e(s.edges[m]))) { a = s.edges[m], u.push(t_(c, h, y, a.path)), l = m, d = !0; break } if (d) break; if (u.push(e_(c, h, y)), h += k[y], void 0 !== n[c += w[y]] && void 0 !== n[c][h] || (0 === y && h < 0 || 1 === y && c < 0 || 2 === y && h === b || 3 === y && c === x) && (c -= w[y], h -= k[y], y = (y + 1) % 4, v++), c === I && h === P && y === S[i]) { f = !0, l = i; break } } } !r.linearRing || u[u.length - 1][0] === p[0] && u[u.length - 1][1] === p[1] || u.push(p), _.push(u) } })) })), _ }(h, f, i) } u ? g.push(p) : g = p, "function" == typeof i.successCallback && i.successCallback(g, t) })), g } function o_(t, e, n, r) { var i, o, a, s, u, l, c = 0, h = t[n + 1][e], f = t[n + 1][e + 1], p = t[n][e + 1], g = t[n][e], y = r.threshold; if (!(isNaN(g) || isNaN(p) || isNaN(f) || isNaN(h))) { switch (c |= h >= y ? 8 : 0, c |= f >= y ? 4 : 0, c |= p >= y ? 2 : 0, l = { cval: c = +(c |= g >= y ? 1 : 0), polygons: [], edges: {}, x0: g, x1: p, x2: f, x3: h }, c) { case 0: r.polygons && l.polygons.push([[0, 0], [0, 1], [1, 1], [1, 0]]); break; case 15: break; case 14: i = r.interpolate(g, h, y), s = r.interpolate(g, p, y), r.polygons_full && (l.edges.left = { path: [[0, i], [s, 0]], move: { x: 0, y: -1, enter: "top" } }), r.polygons && l.polygons.push([[0, 0], [0, i], [s, 0]]); break; case 13: s = r.interpolate(g, p, y), o = r.interpolate(p, f, y), r.polygons_full && (l.edges.bottom = { path: [[s, 0], [1, o]], move: { x: 1, y: 0, enter: "left" } }), r.polygons && l.polygons.push([[s, 0], [1, o], [1, 0]]); break; case 11: o = r.interpolate(p, f, y), a = r.interpolate(h, f, y), r.polygons_full && (l.edges.right = { path: [[1, o], [a, 1]], move: { x: 0, y: 1, enter: "bottom" } }), r.polygons && l.polygons.push([[1, o], [a, 1], [1, 1]]); break; case 7: i = r.interpolate(g, h, y), a = r.interpolate(h, f, y), r.polygons_full && (l.edges.top = { path: [[a, 1], [0, i]], move: { x: -1, y: 0, enter: "right" } }), r.polygons && l.polygons.push([[a, 1], [0, i], [0, 1]]); break; case 1: i = r.interpolate(g, h, y), s = r.interpolate(g, p, y), r.polygons_full && (l.edges.bottom = { path: [[s, 0], [0, i]], move: { x: -1, y: 0, enter: "right" } }), r.polygons && l.polygons.push([[s, 0], [0, i], [0, 1], [1, 1], [1, 0]]); break; case 2: s = r.interpolate(g, p, y), o = r.interpolate(p, f, y), r.polygons_full && (l.edges.right = { path: [[1, o], [s, 0]], move: { x: 0, y: -1, enter: "top" } }), r.polygons && l.polygons.push([[0, 0], [0, 1], [1, 1], [1, o], [s, 0]]); break; case 4: o = r.interpolate(p, f, y), a = r.interpolate(h, f, y), r.polygons_full && (l.edges.top = { path: [[a, 1], [1, o]], move: { x: 1, y: 0, enter: "left" } }), r.polygons && l.polygons.push([[0, 0], [0, 1], [a, 1], [1, o], [1, 0]]); break; case 8: i = r.interpolate(g, h, y), a = r.interpolate(h, f, y), r.polygons_full && (l.edges.left = { path: [[0, i], [a, 1]], move: { x: 0, y: 1, enter: "bottom" } }), r.polygons && l.polygons.push([[0, 0], [0, i], [a, 1], [1, 1], [1, 0]]); break; case 12: i = r.interpolate(g, h, y), o = r.interpolate(p, f, y), r.polygons_full && (l.edges.left = { path: [[0, i], [1, o]], move: { x: 1, y: 0, enter: "left" } }), r.polygons && l.polygons.push([[0, 0], [0, i], [1, o], [1, 0]]); break; case 9: s = r.interpolate(g, p, y), a = r.interpolate(h, f, y), r.polygons_full && (l.edges.bottom = { path: [[s, 0], [a, 1]], move: { x: 0, y: 1, enter: "bottom" } }), r.polygons && l.polygons.push([[s, 0], [a, 1], [1, 1], [1, 0]]); break; case 3: i = r.interpolate(g, h, y), o = r.interpolate(p, f, y), r.polygons_full && (l.edges.right = { path: [[1, o], [0, i]], move: { x: -1, y: 0, enter: "right" } }), r.polygons && l.polygons.push([[0, i], [0, 1], [1, 1], [1, o]]); break; case 6: s = r.interpolate(g, p, y), a = r.interpolate(h, f, y), r.polygons_full && (l.edges.top = { path: [[a, 1], [s, 0]], move: { x: 0, y: -1, enter: "top" } }), r.polygons && l.polygons.push([[0, 0], [0, 1], [a, 1], [s, 0]]); break; case 10: i = r.interpolate(g, h, y), o = r.interpolate(p, f, y), s = r.interpolate(g, p, y), a = r.interpolate(h, f, y), u = (g + p + f + h) / 4, r.polygons_full && (u < y ? (l.edges.left = { path: [[0, i], [a, 1]], move: { x: 0, y: 1, enter: "bottom" } }, l.edges.right = { path: [[1, o], [s, 0]], move: { x: 0, y: -1, enter: "top" } }) : (l.edges.right = { path: [[1, o], [a, 1]], move: { x: 0, y: 1, enter: "bottom" } }, l.edges.left = { path: [[0, i], [s, 0]], move: { x: 0, y: -1, enter: "top" } })), r.polygons && (u < y ? l.polygons.push([[0, 0], [0, i], [a, 1], [1, 1], [1, o], [s, 0]]) : (l.polygons.push([[0, 0], [0, i], [s, 0]]), l.polygons.push([[a, 1], [1, 1], [1, o]]))); break; case 5: i = r.interpolate(g, h, y), o = r.interpolate(p, f, y), s = r.interpolate(g, p, y), a = r.interpolate(h, f, y), u = (g + p + f + h) / 4, r.polygons_full && (u < y ? (l.edges.bottom = { path: [[s, 0], [0, i]], move: { x: -1, y: 0, enter: "right" } }, l.edges.top = { path: [[a, 1], [1, o]], move: { x: 1, y: 0, enter: "left" } }) : (l.edges.top = { path: [[a, 1], [0, i]], move: { x: -1, y: 0, enter: "right" } }, l.edges.bottom = { path: [[s, 0], [1, o]], move: { x: 1, y: 0, enter: "left" } })), r.polygons && (u < y ? l.polygons.push([[0, i], [0, 1], [a, 1], [1, o], [1, 0], [s, 0]]) : (l.polygons.push([[0, i], [0, 1], [a, 1]]), l.polygons.push([[s, 0], [1, o], [1, 0]]))) }return l } } !function (t, e) { Xm(t, "name", { value: e, configurable: !0 }) }(Wm, "interpolate"), n_.prototype.cellsInBand = function (t, e, n) { var r = []; return n = void 0 === n || n, this.lowerBound > e || this.upperBound < t || (this.childA || this.childB || this.childC || this.childD ? (this.childA && (r = r.concat(this.childA.cellsInBand(t, e, n))), this.childB && (r = r.concat(this.childB.cellsInBand(t, e, n))), this.childD && (r = r.concat(this.childD.cellsInBand(t, e, n))), this.childC && (r = r.concat(this.childC.cellsInBand(t, e, n)))) : (n || this.lowerBound <= t || this.upperBound >= e) && r.push({ x: this.x, y: this.y })), r }, n_.prototype.cellsBelowThreshold = function (t, e) { var n = []; return e = void 0 === e || e, this.lowerBound > t || (this.childA || this.childB || this.childC || this.childD ? (this.childA && (n = n.concat(this.childA.cellsBelowThreshold(t, e))), this.childB && (n = n.concat(this.childB.cellsBelowThreshold(t, e))), this.childD && (n = n.concat(this.childD.cellsBelowThreshold(t, e))), this.childC && (n = n.concat(this.childC.cellsBelowThreshold(t, e)))) : (e || this.upperBound >= t) && n.push({ x: this.x, y: this.y })), n }; var a_ = { square: function (t, e, n, r, i, o) { o.polygons && t.polygons.push([[0, 0], [0, 1], [1, 1], [1, 0]]) }, triangle_bl: function (t, e, n, r, i, o) { var a = o.interpolate(e, n, o.minV, o.maxV), s = o.interpolate(e, i, o.minV, o.maxV); o.polygons_full && (t.edges.lb = { path: [[0, s], [a, 0]], move: { x: 0, y: -1, enter: "tl" } }), o.polygons && t.polygons.push([[0, s], [a, 0], [0, 0]]) }, triangle_br: function (t, e, n, r, i, o) { var a = o.interpolate(e, n, o.minV, o.maxV), s = o.interpolate(n, r, o.minV, o.maxV); o.polygons_full && (t.edges.br = { path: [[a, 0], [1, s]], move: { x: 1, y: 0, enter: "lb" } }), o.polygons && t.polygons.push([[a, 0], [1, s], [1, 0]]) }, triangle_tr: function (t, e, n, r, i, o) { var a = o.interpolate(n, r, o.minV, o.maxV), s = o.interpolate(i, r, o.minV, o.maxV); o.polygons_full && (t.edges.rt = { path: [[1, a], [s, 1]], move: { x: 0, y: 1, enter: "br" } }), o.polygons && t.polygons.push([[1, a], [s, 1], [1, 1]]) }, triangle_tl: function (t, e, n, r, i, o) { var a = o.interpolate(i, r, o.minV, o.maxV), s = o.interpolate(e, i, o.minV, o.maxV); o.polygons_full && (t.edges.tl = { path: [[a, 1], [0, s]], move: { x: -1, y: 0, enter: "rt" } }), o.polygons && t.polygons.push([[0, s], [0, 1], [a, 1]]) }, tetragon_t: function (t, e, n, r, i, o) { var a = o.interpolate(n, r, o.minV, o.maxV), s = o.interpolate(e, i, o.minV, o.maxV); o.polygons_full && (t.edges.rt = { path: [[1, a], [0, s]], move: { x: -1, y: 0, enter: "rt" } }), o.polygons && t.polygons.push([[0, s], [0, 1], [1, 1], [1, a]]) }, tetragon_r: function (t, e, n, r, i, o) { var a = o.interpolate(e, n, o.minV, o.maxV), s = o.interpolate(i, r, o.minV, o.maxV); o.polygons_full && (t.edges.br = { path: [[a, 0], [s, 1]], move: { x: 0, y: 1, enter: "br" } }), o.polygons && t.polygons.push([[a, 0], [s, 1], [1, 1], [1, 0]]) }, tetragon_b: function (t, e, n, r, i, o) { var a = o.interpolate(e, i, o.minV, o.maxV), s = o.interpolate(n, r, o.minV, o.maxV); o.polygons_full && (t.edges.lb = { path: [[0, a], [1, s]], move: { x: 1, y: 0, enter: "lb" } }), o.polygons && t.polygons.push([[0, 0], [0, a], [1, s], [1, 0]]) }, tetragon_l: function (t, e, n, r, i, o) { var a = o.interpolate(i, r, o.minV, o.maxV), s = o.interpolate(e, n, o.minV, o.maxV); o.polygons_full && (t.edges.tl = { path: [[a, 1], [s, 0]], move: { x: 0, y: -1, enter: "tl" } }), o.polygons && t.polygons.push([[0, 0], [0, 1], [a, 1], [s, 0]]) }, tetragon_bl: function (t, e, n, r, i, o) { var a = o.interpolate_a(e, n, o.minV, o.maxV), s = o.interpolate_b(e, n, o.minV, o.maxV), u = o.interpolate_a(e, i, o.minV, o.maxV), l = o.interpolate_b(e, i, o.minV, o.maxV); o.polygons_full && (t.edges.bl = { path: [[a, 0], [0, u]], move: { x: -1, y: 0, enter: "rb" } }, t.edges.lt = { path: [[0, l], [s, 0]], move: { x: 0, y: -1, enter: "tr" } }), o.polygons && t.polygons.push([[a, 0], [0, u], [0, l], [s, 0]]) }, tetragon_br: function (t, e, n, r, i, o) { var a = o.interpolate_a(e, n, o.minV, o.maxV), s = o.interpolate_b(e, n, o.minV, o.maxV), u = o.interpolate_a(n, r, o.minV, o.maxV), l = o.interpolate_b(n, r, o.minV, o.maxV); o.polygons_full && (t.edges.bl = { path: [[a, 0], [1, l]], move: { x: 1, y: 0, enter: "lt" } }, t.edges.rb = { path: [[1, u], [s, 0]], move: { x: 0, y: -1, enter: "tr" } }), o.polygons && t.polygons.push([[a, 0], [1, l], [1, u], [s, 0]]) }, tetragon_tr: function (t, e, n, r, i, o) { var a = o.interpolate_a(i, r, o.minV, o.maxV), s = o.interpolate_b(i, r, o.minV, o.maxV), u = o.interpolate_b(n, r, o.minV, o.maxV), l = o.interpolate_a(n, r, o.minV, o.maxV); o.polygons_full && (t.edges.rb = { path: [[1, l], [a, 1]], move: { x: 0, y: 1, enter: "bl" } }, t.edges.tr = { path: [[s, 1], [1, u]], move: { x: 1, y: 0, enter: "lt" } }), o.polygons && t.polygons.push([[1, l], [a, 1], [s, 1], [1, u]]) }, tetragon_tl: function (t, e, n, r, i, o) { var a = o.interpolate_a(i, r, o.minV, o.maxV), s = o.interpolate_b(i, r, o.minV, o.maxV), u = o.interpolate_b(e, i, o.minV, o.maxV), l = o.interpolate_a(e, i, o.minV, o.maxV); o.polygons_full && (t.edges.tr = { path: [[s, 1], [0, l]], move: { x: -1, y: 0, enter: "rb" } }, t.edges.lt = { path: [[0, u], [a, 1]], move: { x: 0, y: 1, enter: "bl" } }), o.polygons && t.polygons.push([[s, 1], [0, l], [0, u], [a, 1]]) }, tetragon_lr: function (t, e, n, r, i, o) { var a = o.interpolate_a(e, i, o.minV, o.maxV), s = o.interpolate_b(e, i, o.minV, o.maxV), u = o.interpolate_b(n, r, o.minV, o.maxV), l = o.interpolate_a(n, r, o.minV, o.maxV); o.polygons_full && (t.edges.lt = { path: [[0, s], [1, u]], move: { x: 1, y: 0, enter: "lt" } }, t.edges.rb = { path: [[1, l], [0, a]], move: { x: -1, y: 0, enter: "rb" } }), o.polygons && t.polygons.push([[0, a], [0, s], [1, u], [1, l]]) }, tetragon_tb: function (t, e, n, r, i, o) { var a = o.interpolate_a(i, r, o.minV, o.maxV), s = o.interpolate_b(i, r, o.minV, o.maxV), u = o.interpolate_b(e, n, o.minV, o.maxV), l = o.interpolate_a(e, n, o.minV, o.maxV); o.polygons_full && (t.edges.tr = { path: [[s, 1], [u, 0]], move: { x: 0, y: -1, enter: "tr" } }, t.edges.bl = { path: [[l, 0], [a, 1]], move: { x: 0, y: 1, enter: "bl" } }), o.polygons && t.polygons.push([[l, 0], [a, 1], [s, 1], [u, 0]]) }, pentagon_tr: function (t, e, n, r, i, o) { var a = o.interpolate(i, r, o.minV, o.maxV), s = o.interpolate(n, r, o.minV, o.maxV); o.polygons_full && (t.edges.tl = { path: [[a, 1], [1, s]], move: { x: 1, y: 0, enter: "lb" } }), o.polygons && t.polygons.push([[0, 0], [0, 1], [a, 1], [1, s], [1, 0]]) }, pentagon_tl: function (t, e, n, r, i, o) { var a = o.interpolate(e, i, o.minV, o.maxV), s = o.interpolate(i, r, o.minV, o.maxV); o.polygons_full && (t.edges.lb = { path: [[0, a], [s, 1]], move: { x: 0, y: 1, enter: "br" } }), o.polygons && t.polygons.push([[0, 0], [0, a], [s, 1], [1, 1], [1, 0]]) }, pentagon_br: function (t, e, n, r, i, o) { var a = o.interpolate(e, n, o.minV, o.maxV), s = o.interpolate(n, r, o.minV, o.maxV); o.polygons_full && (t.edges.rt = { path: [[1, s], [a, 0]], move: { x: 0, y: -1, enter: "tl" } }), o.polygons && t.polygons.push([[0, 0], [0, 1], [1, 1], [1, s], [a, 0]]) }, pentagon_bl: function (t, e, n, r, i, o) { var a = o.interpolate(e, i, o.minV, o.maxV), s = o.interpolate(e, n, o.minV, o.maxV); o.polygons_full && (t.edges.br = { path: [[s, 0], [0, a]], move: { x: -1, y: 0, enter: "rt" } }), o.polygons && t.polygons.push([[0, a], [0, 1], [1, 1], [1, 0], [s, 0]]) }, pentagon_tr_rl: function (t, e, n, r, i, o) { var a = o.interpolate(e, i, o.minV, o.maxV), s = o.interpolate(i, r, o.minV, o.maxV), u = o.interpolate_b(n, r, o.minV, o.maxV), l = o.interpolate_a(n, r, o.minV, o.maxV); o.polygons_full && (t.edges.tl = { path: [[s, 1], [1, u]], move: { x: 1, y: 0, enter: "lt" } }, t.edges.rb = { path: [[1, l], [0, a]], move: { x: -1, y: 0, enter: "rt" } }), o.polygons && t.polygons.push([[0, a], [0, 1], [s, 1], [1, u], [1, l]]) }, pentagon_rb_bt: function (t, e, n, r, i, o) { var a = o.interpolate(n, r, o.minV, o.maxV), s = o.interpolate_b(e, n, o.minV, o.maxV), u = o.interpolate_a(e, n, o.minV, o.maxV), l = o.interpolate(i, r, o.minV, o.maxV); o.polygons_full && (t.edges.rt = { path: [[1, a], [s, 0]], move: { x: 0, y: -1, enter: "tr" } }, t.edges.bl = { path: [[u, 0], [l, 1]], move: { x: 0, y: 1, enter: "br" } }), o.polygons && t.polygons.push([[l, 1], [1, 1], [1, a], [s, 0], [u, 0]]) }, pentagon_bl_lr: function (t, e, n, r, i, o) { var a = o.interpolate(e, n, o.minV, o.maxV), s = o.interpolate_a(e, i, o.minV, o.maxV), u = o.interpolate_b(e, i, o.minV, o.maxV), l = o.interpolate(n, r, o.minV, o.maxV); o.polygons_full && (t.edges.br = { path: [[a, 0], [0, s]], move: { x: -1, y: 0, enter: "rb" } }, t.edges.lt = { path: [[0, u], [1, l]], move: { x: 1, y: 0, enter: "lb" } }), o.polygons && t.polygons.push([[a, 0], [0, s], [0, u], [1, l], [1, 0]]) }, pentagon_lt_tb: function (t, e, n, r, i, o) { var a = o.interpolate(e, i, o.minV, o.maxV), s = o.interpolate_a(i, r, o.minV, o.maxV), u = o.interpolate_b(i, r, o.minV, o.maxV), l = o.interpolate(e, n, o.minV, o.maxV); o.polygons_full && (t.edges.lb = { path: [[0, a], [s, 1]], move: { x: 0, y: 1, enter: "bl" } }, t.edges.tr = { path: [[u, 1], [l, 0]], move: { x: 0, y: -1, enter: "tl" } }), o.polygons && t.polygons.push([[0, 0], [0, a], [s, 1], [u, 1], [l, 0]]) }, pentagon_bl_tb: function (t, e, n, r, i, o) { var a = o.interpolate(e, i, o.minV, o.maxV), s = o.interpolate(i, r, o.minV, o.maxV), u = o.interpolate_b(e, n, o.minV, o.maxV), l = o.interpolate_a(e, n, o.minV, o.maxV); o.polygons_full && (t.edges.bl = { path: [[l, 0], [0, a]], move: { x: -1, y: 0, enter: "rt" } }, t.edges.tl = { path: [[s, 1], [u, 0]], move: { x: 0, y: -1, enter: "tr" } }), o.polygons && t.polygons.push([[0, a], [0, 1], [s, 1], [u, 0], [l, 0]]) }, pentagon_lt_rl: function (t, e, n, r, i, o) { var a = o.interpolate_a(e, i, o.minV, o.maxV), s = o.interpolate_b(e, i, o.minV, o.maxV), u = o.interpolate(i, r, o.minV, o.maxV), l = o.interpolate(n, i, o.minV, o.maxV); o.polygons_full && (t.edges.lt = { path: [[0, s], [u, 1]], move: { x: 0, y: 1, enter: "br" } }, t.edges.rt = { path: [[1, l], [0, a]], move: { x: -1, y: 0, enter: "rb" } }), o.polygons && t.polygons.push([[0, a], [0, s], [u, 1], [1, 1], [1, l]]) }, pentagon_tr_bt: function (t, e, n, r, i, o) { var a = o.interpolate_a(i, r, o.minV, o.maxV), s = o.interpolate_b(i, r, o.minV, o.maxV), u = o.interpolate(n, r, o.minV, o.maxV), l = o.interpolate(e, n, o.minV, o.maxV); o.polygons_full && (t.edges.br = { path: [[l, 0], [a, 1]], move: { x: 0, y: 1, enter: "bl" } }, t.edges.tr = { path: [[s, 1], [1, u]], move: { x: 1, y: 0, enter: "lb" } }), o.polygons && t.polygons.push([[a, 1], [s, 1], [1, u], [1, 0], [l, 0]]) }, pentagon_rb_lr: function (t, e, n, r, i, o) { var a = o.interpolate(e, i, o.minV, o.maxV), s = o.interpolate_b(n, r, o.minV, o.maxV), u = o.interpolate_a(n, r, o.minV, o.maxV), l = o.interpolate(e, n, o.minV, o.maxV); o.polygons_full && (t.edges.lb = { path: [[0, a], [1, s]], move: { x: 1, y: 0, enter: "lt" } }, t.edges.rb = { path: [[1, u], [l, 0]], move: { x: 0, y: -1, enter: "tl" } }), o.polygons && t.polygons.push([[0, 0], [0, a], [1, s], [1, u], [l, 0]]) }, hexagon_lt_tr: function (t, e, n, r, i, o) { var a = o.interpolate(e, i, o.minV, o.maxV), s = o.interpolate_a(i, r, o.minV, o.maxV), u = o.interpolate_b(i, r, o.minV, o.maxV), l = o.interpolate(n, r, o.minV, o.maxV); o.polygons_full && (t.edges.lb = { path: [[0, a], [s, 1]], move: { x: 0, y: 1, enter: "bl" } }, t.edges.tr = { path: [[u, 1], [1, l]], move: { x: 1, y: 0, enter: "lb" } }), o.polygons && t.polygons.push([[0, 0], [0, a], [s, 1], [u, 1], [1, l], [1, 0]]) }, hexagon_bl_lt: function (t, e, n, r, i, o) { var a = o.interpolate(e, n, o.minV, o.maxV), s = o.interpolate_a(e, i, o.minV, o.maxV), u = o.interpolate_b(e, i, o.minV, o.maxV), l = o.interpolate(i, r, o.minV, o.maxV); o.polygons_full && (t.edges.br = { path: [[a, 0], [0, s]], move: { x: -1, y: 0, enter: "rb" } }, t.edges.lt = { path: [[0, u], [l, 1]], move: { x: 0, y: 1, enter: "br" } }), o.polygons && t.polygons.push([[a, 0], [0, s], [0, u], [l, 1], [1, 1], [1, 0]]) }, hexagon_bl_rb: function (t, e, n, r, i, o) { var a = o.interpolate_a(e, n, o.minV, o.maxV), s = o.interpolate_b(e, n, o.minV, o.maxV), u = o.interpolate(e, i, o.minV, o.maxV), l = o.interpolate(n, r, o.minV, o.maxV); o.polygons_full && (t.edges.bl = { path: [[a, 0], [0, u]], move: { x: -1, y: 0, enter: "rt" } }, t.edges.rt = { path: [[1, l], [s, 0]], move: { x: 0, y: -1, enter: "tr" } }), o.polygons && t.polygons.push([[a, 0], [0, u], [0, 1], [1, 1], [1, l], [s, 0]]) }, hexagon_tr_rb: function (t, e, n, r, i, o) { var a = o.interpolate(e, n, o.minV, o.maxV), s = o.interpolate(i, r, o.minV, o.maxV), u = o.interpolate_b(n, r, o.minV, o.maxV), l = o.interpolate_a(n, r, o.minV, o.maxV); o.polygons_full && (t.edges.tl = { path: [[s, 1], [1, u]], move: { x: 1, y: 0, enter: "lt" } }, t.edges.rb = { path: [[1, l], [a, 0]], move: { x: 0, y: -1, enter: "tl" } }), o.polygons && t.polygons.push([[0, 0], [0, 1], [s, 1], [1, u], [1, l], [a, 0]]) }, hexagon_lt_rb: function (t, e, n, r, i, o) { var a = o.interpolate(e, i, o.minV, o.maxV), s = o.interpolate(i, r, o.minV, o.maxV), u = o.interpolate(n, r, o.minV, o.maxV), l = o.interpolate(e, n, o.minV, o.maxV); o.polygons_full && (t.edges.lb = { path: [[0, a], [s, 1]], move: { x: 0, y: 1, enter: "br" } }, t.edges.rt = { path: [[1, u], [l, 0]], move: { x: 0, y: -1, enter: "tl" } }), o.polygons && t.polygons.push([[0, 0], [0, a], [s, 1], [1, 1], [1, u], [l, 0]]) }, hexagon_bl_tr: function (t, e, n, r, i, o) { var a = o.interpolate(e, n, o.minV, o.maxV), s = o.interpolate(e, i, o.minV, o.maxV), u = o.interpolate(i, r, o.minV, o.maxV), l = o.interpolate(n, r, o.minV, o.maxV); o.polygons_full && (t.edges.br = { path: [[a, 0], [0, s]], move: { x: -1, y: 0, enter: "rt" } }, t.edges.tl = { path: [[u, 1], [1, l]], move: { x: 1, y: 0, enter: "lb" } }), o.polygons && t.polygons.push([[a, 0], [0, s], [0, 1], [u, 1], [1, l], [1, 0]]) }, heptagon_tr: function (t, e, n, r, i, o) { var a = o.interpolate_a(e, n, o.minV, o.maxV), s = o.interpolate_b(e, n, o.minV, o.maxV), u = o.interpolate_a(e, i, o.minV, o.maxV), l = o.interpolate_b(e, i, o.minV, o.maxV), c = o.interpolate(i, r, o.minV, o.maxV), h = o.interpolate(n, r, o.minV, o.maxV); o.polygons_full && (t.edges.bl = { path: [[a, 0], [0, u]], move: { x: -1, y: 0, enter: "rb" } }, t.edges.lt = { path: [[0, l], [c, 1]], move: { x: 0, y: 1, enter: "br" } }, t.edges.rt = { path: [[1, h], [s, 0]], move: { x: 0, y: -1, enter: "tr" } }), o.polygons && t.polygons.push([[a, 0], [0, u], [0, l], [c, 1], [1, 1], [1, h], [s, 0]]) }, heptagon_bl: function (t, e, n, r, i, o) { var a = o.interpolate(e, n, o.minV, o.maxV), s = o.interpolate(e, i, o.minV, o.maxV), u = o.interpolate_a(i, r, o.minV, o.maxV), l = o.interpolate_b(i, r, o.minV, o.maxV), c = o.interpolate_b(n, r, o.minV, o.maxV), h = o.interpolate_a(n, r, o.minV, o.maxV); o.polygons_full && (t.edges.lb = { path: [[0, s], [u, 1]], move: { x: 0, y: 1, enter: "bl" } }, t.edges.tr = { path: [[l, 1], [1, c]], move: { x: 1, y: 0, enter: "lt" } }, t.edges.rb = { path: [[1, h], [a, 0]], move: { x: 0, y: -1, enter: "tl" } }), o.polygons && t.polygons.push([[0, 0], [0, s], [u, 1], [l, 1], [1, c], [1, h], [a, 0]]) }, heptagon_tl: function (t, e, n, r, i, o) { var a = o.interpolate_a(e, n, o.minV, o.maxV), s = o.interpolate_b(e, n, o.minV, o.maxV), u = o.interpolate(e, i, o.minV, o.maxV), l = o.interpolate(i, r, o.minV, o.maxV), c = o.interpolate_b(n, r, o.minV, o.maxV), h = o.interpolate_a(n, r, o.minV, o.maxV); o.polygons_full && (t.edges.bl = { path: [[a, 0], [0, u]], move: { x: -1, y: 0, enter: "rt" } }, t.edges.tl = { path: [[l, 1], [1, c]], move: { x: 1, y: 0, enter: "lt" } }, t.edges.rb = { path: [[1, h], [s, 0]], move: { x: 0, y: -1, enter: "tr" } }), o.polygons && t.polygons.push([[a, 0], [0, u], [0, 1], [l, 1], [1, c], [1, h], [s, 0]]) }, heptagon_br: function (t, e, n, r, i, o) { var a = o.interpolate(e, n, o.minV, o.maxV), s = o.interpolate_a(e, i, o.minV, o.maxV), u = o.interpolate_b(e, i, o.minV, o.maxV), l = o.interpolate_a(i, r, o.minV, o.maxV), c = o.interpolate_b(i, r, o.minV, o.maxV), h = o.interpolate(n, r, o.minV, o.maxV); o.polygons_full && (t.edges.br = { path: [[a, 0], [0, s]], move: { x: -1, y: 0, enter: "rb" } }, t.edges.lt = { path: [[0, u], [l, 1]], move: { x: 0, y: 1, enter: "bl" } }, t.edges.tr = { path: [[c, 1], [1, h]], move: { x: 1, y: 0, enter: "lb" } }), o.polygons && t.polygons.push([[a, 0], [0, s], [0, u], [l, 1], [c, 1], [1, h], [1, 0]]) }, octagon: function (t, e, n, r, i, o) { var a = o.interpolate_a(e, n, o.minV, o.maxV), s = o.interpolate_b(e, n, o.minV, o.maxV), u = o.interpolate_a(e, i, o.minV, o.maxV), l = o.interpolate_b(e, i, o.minV, o.maxV), c = o.interpolate_a(i, r, o.minV, o.maxV), h = o.interpolate_b(i, r, o.minV, o.maxV), f = o.interpolate_b(n, r, o.minV, o.maxV), p = o.interpolate_a(n, r, o.minV, o.maxV); o.polygons_full && (t.edges.bl = { path: [[a, 0], [0, u]], move: { x: -1, y: 0, enter: "rb" } }, t.edges.lt = { path: [[0, l], [c, 1]], move: { x: 0, y: 1, enter: "bl" } }, t.edges.tr = { path: [[h, 1], [1, f]], move: { x: 1, y: 0, enter: "lt" } }, t.edges.rb = { path: [[1, p], [s, 0]], move: { x: 0, y: -1, enter: "tr" } }), o.polygons && t.polygons.push([[a, 0], [0, u], [0, l], [c, 1], [h, 1], [1, f], [1, p], [s, 0]]) } }; function s_(t, n, r, i) { var o, a, s, u = !1, l = null, c = null, h = null, f = null, p = !1, g = [], y = [], v = []; if (!t) throw new Error("data is required"); if (null == n) throw new Error("lowerBound is required"); if (null == r) throw new Error("bandWidth is required"); if (i && "object" !== e(i)) throw new Error("options must be an object"); if (s = function (t) { var e, n, r, i, o; for (i = new Qm, t = t || {}, o = Object.keys(i), e = 0; e < o.length; e++)null != (r = t[n = o[e]]) && (i[n] = r); return i.polygons_full = !i.polygons, i.interpolate = Zm, i.interpolate_a = Jm, i.interpolate_b = $m, i }(i), t instanceof r_) l = t, c = t.root, h = t.data, s.noQuadTree || (u = !0); else { if (!Array.isArray(t) || !Array.isArray(t[0])) throw new Error("input is neither array of arrays nor object retrieved from 'QuadTree()'"); h = t } if (Array.isArray(n)) { for (p = !0, s.noQuadTree || (u = !0), o = 0; o < n.length; o++)if (isNaN(+n[o])) throw new Error("lowerBound[" + o + "] is not a number"); if (Array.isArray(r)) { if (n.length !== r.length) throw new Error("lowerBound and bandWidth have unequal lengths"); for (o = 0; o < r.length; o++)if (isNaN(+r[o])) throw new Error("bandWidth[" + o + "] is not a number") } else { if (isNaN(+r)) throw new Error("bandWidth must be a number"); for (g = [], o = 0; o < n.length; o++)g.push(r); r = g } } else { if (isNaN(+n)) throw new Error("lowerBound must be a number"); if (n = [n], isNaN(+r)) throw new Error("bandWidth must be a number"); r = [r] } return u && !c && (l = new r_(h), c = l.root, h = l.data), s.verbose && (s.polygons ? console.log("MarchingSquaresJS-isoBands: returning single polygons for each grid cell") : console.log("MarchingSquaresJS-isoBands: returning polygon paths for entire data grid"), p && console.log("MarchingSquaresJS-isoBands: multiple bands requested, returning array of band polygons instead of polygons for a single band")), n.forEach((function (t, n) { if (y = [], s.minV = t, s.maxV = t + r[n], s.verbose && console.log("MarchingSquaresJS-isoBands: computing isobands for [" + t + ":" + (t + r[n]) + "]"), s.polygons) if (u) c.cellsInBand(s.minV, s.maxV, !0).forEach((function (t) { y = y.concat(Km(l_(h, t.x, t.y, s), t.x, t.y, s)) })); else for (a = 0; a < h.length - 1; ++a)for (o = 0; o < h[0].length - 1; ++o)y = y.concat(Km(l_(h, o, a, s), o, a, s)); else { for (f = [], o = 0; o < h[0].length - 1; ++o)f[o] = []; if (u) c.cellsInBand(s.minV, s.maxV, !1).forEach((function (t) { f[t.x][t.y] = l_(h, t.x, t.y, s) })); else for (o = 0; o < h[0].length - 1; ++o)for (a = 0; a < h.length - 1; ++a)f[o][a] = l_(h, o, a, s); y = function (t, n, r) { var i, o, a, s, u, l, c, h, f, p, g, y, v, d, m, _, b = [], x = t.length - 1, E = t[0].length - 1, w = [["rt", "rb"], ["br", "bl"], ["lb", "lt"], ["tl", "tr"]], k = [0, -1, 0, 1], S = [-1, 0, 1, 0], I = ["bl", "lb", "lt", "tl", "tr", "rt", "rb", "br"], P = { bl: 1, br: 1, lb: 2, lt: 2, tl: 3, tr: 3, rt: 0, rb: 0 }; return function (t, e, n) { var r, i, o, a, s; for (r = !0, i = t[0].length, o = t.length, s = 0; s < o; s++)if (t[s][0] < e || t[s][0] > n || t[s][i - 1] < e || t[s][i - 1] > n) { r = !1; break } if (r && (t[o - 1][0] < e || t[o - 1][0] > n || t[o - 1][i - 1] < e || t[o - 1][i - 1] > n) && (r = !1), r) for (a = 0; a < i - 1; a++)if (t[0][a] < e || t[0][a] > n || t[o - 1][a] < e || t[o - 1][a] > n) { r = !1; break } return r }(t, r.minV, r.maxV) && (r.linearRing ? b.push([[0, 0], [0, x], [E, x], [E, 0], [0, 0]]) : b.push([[0, 0], [0, x], [E, x], [E, 0]])), n.forEach((function (t, N) { t.forEach((function (t, M) { for (i = null, a = 0; a < 8; a++)if (i = I[a], "object" === e(t.edges[i])) { for (o = [], s = t.edges[i], c = i, h = N, f = M, p = !1, g = [N + s.path[0][0], M + s.path[0][1]], o.push(g); !p && "object" === e((y = n[h][f]).edges[c]);)if (s = y.edges[c], delete y.edges[c], (m = s.path[1])[0] += h, m[1] += f, o.push(m), c = s.move.enter, h += s.move.x, f += s.move.y, void 0 === n[h] || void 0 === n[h][f]) { if (v = 0, d = 0, h === E) h--, v = 0; else if (h < 0) h++, v = 2; else if (f === x) f--, v = 3; else { if (!(f < 0)) throw new Error("Left the grid somewhere in the interior!"); f++, v = 1 } if (h === N && f === M && v === P[i]) { p = !0, c = i; break } for (; ;) { if (_ = !1, d > 4) throw new Error("Direction change counter overflow! This should never happen!"); if (void 0 !== n[h] && void 0 !== n[h][f]) for (y = n[h][f], u = 0; u < w[v].length; u++)if (l = w[v][u], "object" === e(y.edges[l])) { s = y.edges[l], o.push(t_(h, f, v, s.path)), c = l, _ = !0; break } if (_) break; if (o.push(e_(h, f, v)), f += S[v], void 0 !== n[h += k[v]] && void 0 !== n[h][f] || (0 === v && f < 0 || 1 === v && h < 0 || 2 === v && f === x || 3 === v && h === E) && (h -= k[v], f -= S[v], v = (v + 1) % 4, d++), h === N && f === M && v === P[i]) { p = !0, c = i; break } } } !r.linearRing || o[o.length - 1][0] === g[0] && o[o.length - 1][1] === g[1] || o.push(g), b.push(o) } })) })), b }(h, f, s) } p ? v.push(y) : v = y, "function" == typeof s.successCallback && s.successCallback(v, t, r[n]) })), v } function u_(t, e, n, r, i, o) { var a = (r + n + e + t) / 4; return a > o ? 2 : a < i ? 0 : 1 } function l_(t, e, n, r) { var i, o, a = 0, s = t[n + 1][e], u = t[n + 1][e + 1], l = t[n][e + 1], c = t[n][e], h = r.minV, f = r.maxV; if (!(isNaN(c) || isNaN(l) || isNaN(u) || isNaN(s))) { switch (a |= s < h ? 0 : s > f ? 128 : 64, a |= u < h ? 0 : u > f ? 32 : 16, a |= l < h ? 0 : l > f ? 8 : 4, o = 0, i = { cval: a = +(a |= c < h ? 0 : c > f ? 2 : 1), polygons: [], edges: {}, x0: c, x1: l, x2: u, x3: s, x: e, y: n }, a) { case 85: a_.square(i, c, l, u, s, r); case 0: case 170: break; case 169: a_.triangle_bl(i, c, l, u, s, r); break; case 166: a_.triangle_br(i, c, l, u, s, r); break; case 154: a_.triangle_tr(i, c, l, u, s, r); break; case 106: a_.triangle_tl(i, c, l, u, s, r); break; case 1: a_.triangle_bl(i, c, l, u, s, r); break; case 4: a_.triangle_br(i, c, l, u, s, r); break; case 16: a_.triangle_tr(i, c, l, u, s, r); break; case 64: a_.triangle_tl(i, c, l, u, s, r); break; case 168: a_.tetragon_bl(i, c, l, u, s, r); break; case 162: a_.tetragon_br(i, c, l, u, s, r); break; case 138: a_.tetragon_tr(i, c, l, u, s, r); break; case 42: a_.tetragon_tl(i, c, l, u, s, r); break; case 2: a_.tetragon_bl(i, c, l, u, s, r); break; case 8: a_.tetragon_br(i, c, l, u, s, r); break; case 32: a_.tetragon_tr(i, c, l, u, s, r); break; case 128: a_.tetragon_tl(i, c, l, u, s, r); break; case 5: a_.tetragon_b(i, c, l, u, s, r); break; case 20: a_.tetragon_r(i, c, l, u, s, r); break; case 80: a_.tetragon_t(i, c, l, u, s, r); break; case 65: a_.tetragon_l(i, c, l, u, s, r); break; case 165: a_.tetragon_b(i, c, l, u, s, r); break; case 150: a_.tetragon_r(i, c, l, u, s, r); break; case 90: a_.tetragon_t(i, c, l, u, s, r); break; case 105: a_.tetragon_l(i, c, l, u, s, r); break; case 160: a_.tetragon_lr(i, c, l, u, s, r); break; case 130: a_.tetragon_tb(i, c, l, u, s, r); break; case 10: a_.tetragon_lr(i, c, l, u, s, r); break; case 40: a_.tetragon_tb(i, c, l, u, s, r); break; case 101: a_.pentagon_tr(i, c, l, u, s, r); break; case 149: a_.pentagon_tl(i, c, l, u, s, r); break; case 86: a_.pentagon_bl(i, c, l, u, s, r); break; case 89: a_.pentagon_br(i, c, l, u, s, r); break; case 69: a_.pentagon_tr(i, c, l, u, s, r); break; case 21: a_.pentagon_tl(i, c, l, u, s, r); break; case 84: a_.pentagon_bl(i, c, l, u, s, r); break; case 81: a_.pentagon_br(i, c, l, u, s, r); break; case 96: a_.pentagon_tr_rl(i, c, l, u, s, r); break; case 24: a_.pentagon_rb_bt(i, c, l, u, s, r); break; case 6: a_.pentagon_bl_lr(i, c, l, u, s, r); break; case 129: a_.pentagon_lt_tb(i, c, l, u, s, r); break; case 74: a_.pentagon_tr_rl(i, c, l, u, s, r); break; case 146: a_.pentagon_rb_bt(i, c, l, u, s, r); break; case 164: a_.pentagon_bl_lr(i, c, l, u, s, r); break; case 41: a_.pentagon_lt_tb(i, c, l, u, s, r); break; case 66: a_.pentagon_bl_tb(i, c, l, u, s, r); break; case 144: a_.pentagon_lt_rl(i, c, l, u, s, r); break; case 36: a_.pentagon_tr_bt(i, c, l, u, s, r); break; case 9: a_.pentagon_rb_lr(i, c, l, u, s, r); break; case 104: a_.pentagon_bl_tb(i, c, l, u, s, r); break; case 26: a_.pentagon_lt_rl(i, c, l, u, s, r); break; case 134: a_.pentagon_tr_bt(i, c, l, u, s, r); break; case 161: a_.pentagon_rb_lr(i, c, l, u, s, r); break; case 37: a_.hexagon_lt_tr(i, c, l, u, s, r); break; case 148: a_.hexagon_bl_lt(i, c, l, u, s, r); break; case 82: a_.hexagon_bl_rb(i, c, l, u, s, r); break; case 73: a_.hexagon_tr_rb(i, c, l, u, s, r); break; case 133: a_.hexagon_lt_tr(i, c, l, u, s, r); break; case 22: a_.hexagon_bl_lt(i, c, l, u, s, r); break; case 88: a_.hexagon_bl_rb(i, c, l, u, s, r); break; case 97: a_.hexagon_tr_rb(i, c, l, u, s, r); break; case 145: case 25: a_.hexagon_lt_rb(i, c, l, u, s, r); break; case 70: case 100: a_.hexagon_bl_tr(i, c, l, u, s, r); break; case 17: 0 === (o = u_(c, l, u, s, h, f)) ? (a_.triangle_bl(i, c, l, u, s, r), a_.triangle_tr(i, c, l, u, s, r)) : a_.hexagon_lt_rb(i, c, l, u, s, r); break; case 68: 0 === (o = u_(c, l, u, s, h, f)) ? (a_.triangle_tl(i, c, l, u, s, r), a_.triangle_br(i, c, l, u, s, r)) : a_.hexagon_bl_tr(i, c, l, u, s, r); break; case 153: 2 === (o = u_(c, l, u, s, h, f)) ? (a_.triangle_bl(i, c, l, u, s, r), a_.triangle_tr(i, c, l, u, s, r)) : a_.hexagon_lt_rb(i, c, l, u, s, r); break; case 102: 2 === (o = u_(c, l, u, s, h, f)) ? (a_.triangle_tl(i, c, l, u, s, r), a_.triangle_br(i, c, l, u, s, r)) : a_.hexagon_bl_tr(i, c, l, u, s, r); break; case 152: 2 === (o = u_(c, l, u, s, h, f)) ? (a_.triangle_tr(i, c, l, u, s, r), a_.tetragon_bl(i, c, l, u, s, r)) : a_.heptagon_tr(i, c, l, u, s, r); break; case 137: 2 === (o = u_(c, l, u, s, h, f)) ? (a_.triangle_bl(i, c, l, u, s, r), a_.tetragon_tr(i, c, l, u, s, r)) : a_.heptagon_bl(i, c, l, u, s, r); break; case 98: 2 === (o = u_(c, l, u, s, h, f)) ? (a_.triangle_tl(i, c, l, u, s, r), a_.tetragon_br(i, c, l, u, s, r)) : a_.heptagon_tl(i, c, l, u, s, r); break; case 38: 2 === (o = u_(c, l, u, s, h, f)) ? (a_.triangle_br(i, c, l, u, s, r), a_.tetragon_tl(i, c, l, u, s, r)) : a_.heptagon_br(i, c, l, u, s, r); break; case 18: 0 === (o = u_(c, l, u, s, h, f)) ? (a_.triangle_tr(i, c, l, u, s, r), a_.tetragon_bl(i, c, l, u, s, r)) : a_.heptagon_tr(i, c, l, u, s, r); break; case 33: 0 === (o = u_(c, l, u, s, h, f)) ? (a_.triangle_bl(i, c, l, u, s, r), a_.tetragon_tr(i, c, l, u, s, r)) : a_.heptagon_bl(i, c, l, u, s, r); break; case 72: 0 === (o = u_(c, l, u, s, h, f)) ? (a_.triangle_tl(i, c, l, u, s, r), a_.tetragon_br(i, c, l, u, s, r)) : a_.heptagon_tl(i, c, l, u, s, r); break; case 132: 0 === (o = u_(c, l, u, s, h, f)) ? (a_.triangle_br(i, c, l, u, s, r), a_.tetragon_tl(i, c, l, u, s, r)) : a_.heptagon_br(i, c, l, u, s, r); break; case 136: 0 === (o = u_(c, l, u, s, h, f)) ? (a_.tetragon_tl(i, c, l, u, s, r), a_.tetragon_br(i, c, l, u, s, r)) : 1 === o ? a_.octagon(i, c, l, u, s, r) : (a_.tetragon_bl(i, c, l, u, s, r), a_.tetragon_tr(i, c, l, u, s, r)); break; case 34: 0 === (o = u_(c, l, u, s, h, f)) ? (a_.tetragon_bl(i, c, l, u, s, r), a_.tetragon_tr(i, c, l, u, s, r)) : 1 === o ? a_.octagon(i, c, l, u, s, r) : (a_.tetragon_tl(i, c, l, u, s, r), a_.tetragon_br(i, c, l, u, s, r)) }return i } } var c_ = Object.defineProperty, h_ = Object.getOwnPropertySymbols, f_ = Object.prototype.hasOwnProperty, p_ = Object.prototype.propertyIsEnumerable, g_ = function (t, e, n) { return e in t ? c_(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n }, y_ = function (t, e) { for (var n in e || (e = {})) f_.call(e, n) && g_(t, n, e[n]); if (h_) { var r, i = c(h_(e)); try { for (i.s(); !(r = i.n()).done;) { n = r.value; p_.call(e, n) && g_(t, n, e[n]) } } catch (t) { i.e(t) } finally { i.f() } } return t }, v_ = function (t, e) { return c_(t, "name", { value: e, configurable: !0 }) }; function d_(t, e) { if (!Qu(e = e || {})) throw new Error("options is invalid"); var n = e.zProperty || "elevation", r = e.flip, i = e.flags; ll(t, "Point", "input must contain Points"); for (var o = m_(t, r), a = [], s = 0; s < o.length; s++) { for (var u = o[s], l = [], c = 0; c < u.length; c++) { var h = u[c]; h.properties[n] ? l.push(h.properties[n]) : l.push(0), !0 === i && (h.properties.matrixPosition = [s, c]) } a.push(l) } return a } function m_(t, e) { var n = {}; Tl(t, (function (t) { var e = ol(t)[1]; n[e] || (n[e] = []), n[e].push(t) })); var r = Object.keys(n).map((function (t) { return n[t].sort((function (t, e) { return ol(t)[0] - ol(e)[0] })) })); return r.sort((function (t, n) { return e ? ol(t[0])[1] - ol(n[0])[1] : ol(n[0])[1] - ol(t[0])[1] })) } function __(t, e, n) { if (!Qu(n = n || {})) throw new Error("options is invalid"); var r = n.zProperty || "elevation", i = n.commonProperties || {}, o = n.breaksProperties || []; if (ll(t, "Point", "Input must contain Points"), !e) throw new Error("breaks is required"); if (!Array.isArray(e)) throw new Error("breaks is not an Array"); if (!Qu(i)) throw new Error("commonProperties is not an Object"); if (!Array.isArray(o)) throw new Error("breaksProperties is not an Array"); var a = d_(t, { zProperty: r, flip: !0 }), s = b_(a, e, r), u = (s = x_(s, a, t)).map((function (t, e) { if (o[e] && !Qu(o[e])) throw new Error("Each mappedProperty is required to be an Object"); var n = y_(y_({}, i), o[e]); return n[r] = t[r], qu(t.groupedRings, n) })); return ju(u) } function b_(t, e, n) { for (var r = [], i = 1; i < e.length; i++) { var a = +e[i - 1], s = +e[i], u = w_(E_(s_(t, a, s - a))); r.push(o({ groupedRings: u }, n, a + "-" + s)) } return r } function x_(t, e, n) { var r = rc(n), i = r[2] - r[0], o = r[3] - r[1], a = r[0], s = r[1], u = e[0].length - 1, l = e.length - 1, c = i / u, h = o / l; return t.map((function (t) { return t.groupedRings = t.groupedRings.map((function (t) { return t.map((function (t) { return t.map((function (t) { return [t[0] * c + a, t[1] * h + s] })) })) })), t })) } function E_(t) { var e = t.map((function (t) { return { ring: t, area: Jl(Cu([t])) } })); return e.sort((function (t, e) { return e.area - t.area })), e.map((function (t) { return t.ring })) } function w_(t) { for (var e = t.map((function (t) { return { lrCoordinates: t, grouped: !1 } })), n = []; !S_(e);)for (var r = 0; r < e.length; r++)if (!e[r].grouped) { var i = []; i.push(e[r].lrCoordinates), e[r].grouped = !0; for (var o = Cu([e[r].lrCoordinates]), a = r + 1; a < e.length; a++) { if (!e[a].grouped) k_(Cu([e[a].lrCoordinates]), o) && (i.push(e[a].lrCoordinates), e[a].grouped = !0) } n.push(i) } return n } function k_(t, e) { for (var n = _m(t), r = 0; r < n.features.length; r++)if (!Nc(n.features[r], e)) return !1; return !0 } function S_(t) { for (var e = 0; e < t.length; e++)if (!1 === t[e].grouped) return !1; return !0 } v_(d_, "gridToMatrix"), v_(m_, "sortPointsByLatLng"), v_(__, "isobands"), v_(b_, "createContourLines"), v_(x_, "rescaleContours"), v_(E_, "orderByArea"), v_(w_, "groupNestedRings"), v_(k_, "isInside"), v_(S_, "allGrouped"); var I_ = Object.defineProperty, P_ = Object.getOwnPropertySymbols, N_ = Object.prototype.hasOwnProperty, M_ = Object.prototype.propertyIsEnumerable, O_ = function (t, e, n) { return e in t ? I_(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n }, L_ = function (t, e) { for (var n in e || (e = {})) N_.call(e, n) && O_(t, n, e[n]); if (P_) { var r, i = c(P_(e)); try { for (i.s(); !(r = i.n()).done;) { n = r.value; M_.call(e, n) && O_(t, n, e[n]) } } catch (t) { i.e(t) } finally { i.f() } } return t }, R_ = function (t, e) { return I_(t, "name", { value: e, configurable: !0 }) }; function C_(t, e) { if (!Qu(e = e || {})) throw new Error("options is invalid"); var n = e.zProperty || "elevation", r = e.flip, i = e.flags; ll(t, "Point", "input must contain Points"); for (var o = T_(t, r), a = [], s = 0; s < o.length; s++) { for (var u = o[s], l = [], c = 0; c < u.length; c++) { var h = u[c]; h.properties[n] ? l.push(h.properties[n]) : l.push(0), !0 === i && (h.properties.matrixPosition = [s, c]) } a.push(l) } return a } function T_(t, e) { var n = {}; Tl(t, (function (t) { var e = ol(t)[1]; n[e] || (n[e] = []), n[e].push(t) })); var r = Object.keys(n).map((function (t) { return n[t].sort((function (t, e) { return ol(t)[0] - ol(e)[0] })) })); return r.sort((function (t, n) { return e ? ol(t[0])[1] - ol(n[0])[1] : ol(n[0])[1] - ol(t[0])[1] })) } function A_(t, e, n) { if (!Qu(n = n || {})) throw new Error("options is invalid"); var r = n.zProperty || "elevation", i = n.commonProperties || {}, o = n.breaksProperties || []; if (ll(t, "Point", "Input must contain Points"), !e) throw new Error("breaks is required"); if (!Array.isArray(e)) throw new Error("breaks must be an Array"); if (!Qu(i)) throw new Error("commonProperties must be an Object"); if (!Array.isArray(o)) throw new Error("breaksProperties must be an Array"); var a = C_(t, { zProperty: r, flip: !0 }); return ju(j_(D_(a, e, r, i, o), a, t)) } function D_(t, e, n, r, i) { for (var o = [], a = 0; a < e.length; a++) { var s = +e[a], u = L_(L_({}, r), i[a]); u[n] = s; var l = Fu(i_(t, s, { linearRing: !1, noFrame: !0 }), u); o.push(l) } return o } function j_(t, e, n) { var r = rc(n), i = r[2] - r[0], o = r[3] - r[1], a = r[0], s = r[1], u = e[0].length - 1, l = e.length - 1, c = i / u, h = o / l, f = R_((function (t) { t[0] = t[0] * c + a, t[1] = t[1] * h + s }), "resize"); return t.forEach((function (t) { Ol(t, f) })), t } R_(C_, "gridToMatrix"), R_(T_, "sortPointsByLatLng"), R_(A_, "isolines"), R_(D_, "createIsoLines"), R_(j_, "rescaleIsolines"); var F_ = Object.defineProperty, B_ = oh; function q_(t) { var e = { type: "FeatureCollection", features: [] }; if ("Feature" === t.type && ("Point" === t.geometry.type || "MultiPoint" === t.geometry.type)) throw new Error("Input must be a LineString, MultiLineString, Polygon, or MultiPolygon Feature or Geometry"); for (var n = B_(t, !1), r = 0; r < n.length; ++r) { var i = n[r]; e.features.push(Lu([i[0], i[1]])) } return e } !function (t, e) { F_(t, "name", { value: e, configurable: !0 }) }(q_, "kinks"); var V_ = Object.defineProperty; function G_(t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; return Gl(t, (function (t, n) { var r = n.geometry.coordinates; return t + _l(r[0], r[1], e) }), 0) } !function (t, e) { V_(t, "name", { value: e, configurable: !0 }) }(G_, "length"); var Y_ = Object.defineProperty, z_ = function (t, e) { return Y_(t, "name", { value: e, configurable: !0 }) }; function U_(t, e, n, r) { var i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {}, o = i.steps || 64, a = X_(n), s = X_(r), u = Array.isArray(t) || "Feature" !== t.type ? {} : t.properties; if (a === s) return Au(My(t, e, i).geometry.coordinates[0], u); for (var l = a, c = a < s ? s : s + 360, h = l, f = [], p = 0, g = (c - l) / o; h <= c;)f.push(dl(t, e, h, i).geometry.coordinates), h = l + ++p * g; return Au(f, u) } function X_(t) { var e = t % 360; return e < 0 && (e += 360), e } z_(U_, "lineArc"), z_(X_, "convertAngleTo360"); var W_ = Object.defineProperty; function H_(t, e, n, r) { if (!Qu(r = r || {})) throw new Error("options is invalid"); var i, o = []; if ("Feature" === t.type) i = t.geometry.coordinates; else { if ("LineString" !== t.type) throw new Error("input must be a LineString Feature or Geometry"); i = t.coordinates } for (var a, s, u, l = i.length, c = 0, h = 0; h < i.length && !(e >= c && h === i.length - 1); h++) { if (c > e && 0 === o.length) { if (!(a = e - c)) return o.push(i[h]), Au(o); s = yl(i[h], i[h - 1]) - 180, u = dl(i[h], a, s, r), o.push(u.geometry.coordinates) } if (c >= n) return (a = n - c) ? (s = yl(i[h], i[h - 1]) - 180, u = dl(i[h], a, s, r), o.push(u.geometry.coordinates), Au(o)) : (o.push(i[h]), Au(o)); if (c >= e && o.push(i[h]), h === i.length - 1) return Au(o); c += _l(i[h], i[h + 1], r) } if (c < e && i.length === l) throw new Error("Start position is beyond line"); var f = i[i.length - 1]; return Au([f, f]) } !function (t, e) { W_(t, "name", { value: e, configurable: !0 }) }(H_, "lineSliceAlong"); var Z_ = Object.defineProperty, J_ = function (t, e) { return Z_(t, "name", { value: e, configurable: !0 }) }; function $_(t, e, n) { if (!Qu(n = n || {})) throw new Error("options is invalid"); var r = n.units, i = n.reverse; if (!t) throw new Error("geojson is required"); if (e <= 0) throw new Error("segmentLength must be greater than 0"); var o = []; return Bl(t, (function (t) { i && (t.geometry.coordinates = t.geometry.coordinates.reverse()), Q_(t, e, r, (function (t) { o.push(t) })) })), ju(o) } function Q_(t, e, n, r) { var i = G_(t, { units: n }); if (i <= e) return r(t); var o = i / e; Number.isInteger(o) || (o = Math.floor(o) + 1); for (var a = 0; a < o; a++) { r(H_(t, e * a, e * (a + 1), { units: n }), a) } } J_($_, "lineChunk"), J_(Q_, "sliceLineSegments"); var K_ = Object.defineProperty, tb = function (t, e) { return K_(t, "name", { value: e, configurable: !0 }) }; function eb(t) { var e = t[0], n = t[1]; return [n[0] - e[0], n[1] - e[1]] } function nb(t, e) { return t[0] * e[1] - e[0] * t[1] } function rb(t, e) { return [t[0] + e[0], t[1] + e[1]] } function ib(t, e) { return [t[0] - e[0], t[1] - e[1]] } function ob(t, e) { return [t * e[0], t * e[1]] } function ab(t, e) { var n = t[0], r = eb(t), i = e[0], o = eb(e), a = nb(r, o); return rb(n, ob(nb(ib(i, n), o) / a, r)) } function sb(t, e) { return 0 === nb(eb(t), eb(e)) } function ub(t, e) { return !sb(t, e) && ab(t, e) } function lb(t, e, n) { if (!Qu(n = n || {})) throw new Error("options is invalid"); var r = n.units; if (!t) throw new Error("geojson is required"); if (null == e || isNaN(e)) throw new Error("distance is required"); var i = hl(t), o = t.properties; switch (i) { case "LineString": return cb(t, e, r); case "MultiLineString": var a = []; return Bl(t, (function (t) { a.push(cb(t, e, r).geometry.coordinates) })), Fu(a, o); default: throw new Error("geometry " + i + " is not supported") } } function cb(t, e, n) { var r = [], i = Uu(e, n), o = ol(t), a = []; return o.forEach((function (t, e) { if (e !== o.length - 1) { var n = hb(t, o[e + 1], i); if (r.push(n), e > 0) { var s = r[e - 1], u = ub(n, s); !1 !== u && (s[1] = u, n[0] = u), a.push(s[0]), e === o.length - 2 && (a.push(n[0]), a.push(n[1])) } 2 === o.length && (a.push(n[0]), a.push(n[1])) } })), Au(a, t.properties) } function hb(t, e, n) { var r = Math.sqrt((t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1])), i = t[0] + n * (e[1] - t[1]) / r, o = e[0] + n * (e[1] - t[1]) / r; return [[i, t[1] + n * (t[0] - e[0]) / r], [o, e[1] + n * (t[0] - e[0]) / r]] } tb(eb, "ab"), tb(nb, "crossProduct"), tb(rb, "add"), tb(ib, "sub"), tb(ob, "scalarMult"), tb(ab, "intersectSegments"), tb(sb, "isParallel"), tb(ub, "intersection"), tb(lb, "lineOffset"), tb(cb, "lineOffsetFeature"), tb(hb, "processSegment"); var fb = Object.defineProperty; function pb(t, e, n) { var r = ol(n); if ("LineString" !== hl(n)) throw new Error("line must be a LineString"); for (var i, o = Sf(n, t), a = Sf(n, e), s = [(i = o.properties.index <= a.properties.index ? [o, a] : [a, o])[0].geometry.coordinates], u = i[0].properties.index + 1; u < i[1].properties.index + 1; u++)s.push(r[u]); return s.push(i[1].geometry.coordinates), Au(s, n.properties) } !function (t, e) { fb(t, "name", { value: e, configurable: !0 }) }(pb, "lineSlice"); var gb = Object.defineProperty; function yb(t) { var e = t[0], n = t[1], r = t[2], i = t[3]; if (_l(t.slice(0, 2), [r, n]) >= _l(t.slice(0, 2), [e, i])) { var o = (n + i) / 2; return [e, o - (r - e) / 2, r, o + (r - e) / 2] } var a = (e + r) / 2; return [a - (i - n) / 2, n, a + (i - n) / 2, i] } !function (t, e) { gb(t, "name", { value: e, configurable: !0 }) }(yb, "square"); var vb = Object.defineProperty, db = function (t, e) { return vb(t, "name", { value: e, configurable: !0 }) }; function mb(t, e) { if (!Qu(e = null != e ? e : {})) throw new Error("options is invalid"); var n = e.precision, r = e.coordinates, i = e.mutate; if (n = null == n || isNaN(n) ? 6 : n, r = null == r || isNaN(r) ? 3 : r, !t) throw new Error("<geojson> is required"); if ("number" != typeof n) throw new Error("<precision> must be a number"); if ("number" != typeof r) throw new Error("<coordinates> must be a number"); !1 !== i && void 0 !== i || (t = JSON.parse(JSON.stringify(t))); var o = Math.pow(10, n); return Ol(t, (function (t) { _b(t, o, r) })), t } function _b(t, e, n) { t.length > n && t.splice(n, t.length); for (var r = 0; r < t.length; r++)t[r] = Math.round(t[r] * e) / e; return t } db(mb, "truncate"), db(_b, "truncateCoords"); var bb = Object.defineProperty, xb = function (t, e) { return bb(t, "name", { value: e, configurable: !0 }) }; function Eb(t, e) { if (!t) throw new Error("line is required"); if (!e) throw new Error("splitter is required"); var n = hl(t), r = hl(e); if ("LineString" !== n) throw new Error("line must be LineString"); if ("FeatureCollection" === r) throw new Error("splitter cannot be a FeatureCollection"); if ("GeometryCollection" === r) throw new Error("splitter cannot be a GeometryCollection"); var i = mb(e, { precision: 7 }); switch (r) { case "Point": return kb(t, i); case "MultiPoint": return wb(t, i); case "LineString": case "MultiLineString": case "Polygon": case "MultiPolygon": return wb(t, uh(t, i, { ignoreSelfIntersections: !0 })) } } function wb(t, e) { var n = [], r = lf(); return Bl(e, (function (e) { if (n.forEach((function (t, e) { t.id = e })), n.length) { var i = r.search(e); if (i.features.length) { var o = Sb(e, i); n = n.filter((function (t) { return t.id !== o.id })), r.remove(o), Tl(kb(o, e), (function (t) { n.push(t), r.insert(t) })) } } else (n = kb(t, e).features).forEach((function (t) { t.bbox || (t.bbox = yb(rc(t))) })), r.load(ju(n)) })), ju(n) } function kb(t, e) { var n = [], r = ol(t)[0], i = ol(t)[t.geometry.coordinates.length - 1]; if (Ib(r, il(e)) || Ib(i, il(e))) return ju([t]); var o = lf(), a = ff(t); o.load(a); var s = o.search(e); if (!s.features.length) return ju([t]); var u = Sb(e, s), l = Al(a, (function (t, r, i) { var o = ol(r)[1], a = il(e); return i === u.id ? (t.push(a), n.push(Au(t)), Ib(a, o) ? [a] : [a, o]) : (t.push(o), t) }), [r]); return l.length > 1 && n.push(Au(l)), ju(n) } function Sb(t, e) { if (!e.features.length) throw new Error("lines must contain features"); if (1 === e.features.length) return e.features[0]; var n, r = 1 / 0; return Tl(e, (function (e) { var i = Sf(e, t).properties.dist; i < r && (n = e, r = i) })), n } function Ib(t, e) { return t[0] === e[0] && t[1] === e[1] } xb(Eb, "lineSplit"), xb(wb, "splitLineWithPoints"), xb(kb, "splitLineWithPoint"), xb(Sb, "findClosestFeature"), xb(Ib, "pointsEquals"); var Pb = Object.defineProperty, Nb = function (t, e) { return Pb(t, "name", { value: e, configurable: !0 }) }; function Mb(t) { var e, n, r, i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, o = i.properties, a = null == (e = i.autoComplete) || e, s = null == (n = i.orderCoords) || n; if (null != (r = i.mutate) && r || (t = Ry(t)), "FeatureCollection" === t.type) { var u = []; return t.features.forEach((function (t) { u.push(ol(Ob(t, {}, a, s))) })), qu(u, o) } return Ob(t, o, a, s) } function Ob(t, e, n, r) { e = e || ("Feature" === t.type ? t.properties : {}); var i = cl(t), o = i.coordinates, a = i.type; if (!o.length) throw new Error("line must contain coordinates"); switch (a) { case "LineString": return n && (o = Lb(o)), Cu([o], e); case "MultiLineString": var s = [], u = 0; return o.forEach((function (t) { if (n && (t = Lb(t)), r) { var e = Rb(rc(Au(t))); e > u ? (s.unshift(t), u = e) : s.push(t) } else s.push(t) })), Cu(s, e); default: throw new Error("geometry type " + a + " is not supported") } } function Lb(t) { var e = t[0], n = e[0], r = e[1], i = t[t.length - 1], o = i[0], a = i[1]; return n === o && r === a || t.push(e), t } function Rb(t) { var e = t[0], n = t[1], r = t[2], i = t[3]; return Math.abs(e - r) * Math.abs(n - i) } Nb(Mb, "lineToPolygon"), Nb(Ob, "lineStringToPolygon"), Nb(Lb, "autoCompleteCoords"), Nb(Rb, "calculateArea"); var Cb = Object.defineProperty, Tb = function (t, e) { return Cb(t, "name", { value: e, configurable: !0 }) }; function Ab(t, e) { var n = Fb(e); return ("FeatureCollection" === t.type ? Db(t) : jb(Ud.union(t.geometry.coordinates))).geometry.coordinates.forEach((function (t) { n.geometry.coordinates.push(t[0]) })), n } function Db(t) { var e = 2 === t.features.length ? Ud.union(t.features[0].geometry.coordinates, t.features[1].geometry.coordinates) : Ud.union.apply(Ud, t.features.map((function (t) { return t.geometry.coordinates }))); return jb(e) } function jb(t) { return qu(t) } function Fb(t) { return Cu(t && t.geometry.coordinates || [[[180, 90], [-180, 90], [-180, -90], [180, -90], [180, 90]]]) } Tb(Ab, "mask"), Tb(Db, "unionFc"), Tb(jb, "createGeomFromPolygonClippingOutput"), Tb(Fb, "createMask"); var Bb = Object.defineProperty; function qb(t, e) { return dl(t, _l(t, e) / 2, yl(t, e)) } !function (t, e) { Bb(t, "name", { value: e, configurable: !0 }) }(qb, "midpoint"); var Vb = Object.defineProperty, Gb = function (t, e) { return Vb(t, "name", { value: e, configurable: !0 }) }; function Yb(t, e) { var n, r, i = e.inputField, o = e.threshold || 1e5, a = e.p || 2, s = null != (n = e.binary) && n, u = em(t, { alpha: e.alpha || -1, binary: s, p: a, standardization: null == (r = e.standardization) || r, threshold: o }), l = []; Tl(t, (function (t) { var e = t.properties || {}; l.push(e[i]) })); for (var c = zb(l), h = Ub(l), f = 0, p = 0, g = 0, y = 0, v = u.length, d = 0; d < v; d++) { for (var m = 0, _ = 0; _ < v; _++)f += u[d][_] * (l[d] - c) * (l[_] - c), p += u[d][_], g += Math.pow(u[d][_] + u[_][d], 2), m += u[d][_] + u[_][d]; y += Math.pow(m, 2) } var b = f / p / h, x = -1 / (v - 1), E = (v * v * (g *= .5) - v * y + p * p * 3) / ((v - 1) * (v + 1) * (p * p)) - x * x, w = Math.sqrt(E); return { expectedMoranIndex: x, moranIndex: b, stdNorm: w, zNorm: (b - x) / w } } function zb(t) { var e, n = 0, r = c(t); try { for (r.s(); !(e = r.n()).done;) { n += e.value } } catch (t) { r.e(t) } finally { r.f() } return n / t.length } function Ub(t) { var e, n = zb(t), r = 0, i = c(t); try { for (i.s(); !(e = i.n()).done;) { var o = e.value; r += Math.pow(o - n, 2) } } catch (t) { i.e(t) } finally { i.f() } return r / t.length } Gb(Yb, "moranIndex"), Gb(zb, "mean"), Gb(Ub, "variance"); var Xb = Object.defineProperty, Wb = Object.defineProperties, Hb = Object.getOwnPropertyDescriptors, Zb = Object.getOwnPropertySymbols, Jb = Object.prototype.hasOwnProperty, $b = Object.prototype.propertyIsEnumerable, Qb = function (t, e, n) { return e in t ? Xb(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n }, Kb = function (t, e) { for (var n in e || (e = {})) Jb.call(e, n) && Qb(t, n, e[n]); if (Zb) { var r, i = c(Zb(e)); try { for (i.s(); !(r = i.n()).done;) { n = r.value; $b.call(e, n) && Qb(t, n, e[n]) } } catch (t) { i.e(t) } finally { i.f() } } return t }, tx = function (t, e) { return Wb(t, Hb(e)) }; function ex(t, e) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; if (!t) throw new Error("targetPoint is required"); if (!e) throw new Error("points is required"); var r = 1 / 0, i = 0; Tl(e, (function (e, o) { var a = _l(t, e, n); a < r && (i = o, r = a) })); var o = Ry(e.features[i]); return tx(Kb({}, o), { properties: tx(Kb({}, o.properties), { featureIndex: i, distanceToPoint: r }) }) } !function (t, e) { Xb(t, "name", { value: e, configurable: !0 }) }(ex, "nearestPoint"); var nx = Object.defineProperty; function rx(t, e) { var n = (e = e || {}).studyArea || pc(rc(t)), r = e.properties || {}, i = e.units || "kilometers", o = []; Tl(t, (function (t) { o.push(Ug(t)) })); var a = o.length, s = o.map((function (t, e) { return _l(t, ex(t, ju(o.filter((function (t, n) { return n !== e })))).geometry.coordinates, { units: i }) })).reduce((function (t, e) { return t + e }), 0) / a, u = a / Ju(Jl(n), "meters", i), l = 1 / (2 * Math.sqrt(u)), c = .26136 / Math.sqrt(a * u); return r.nearestNeighborAnalysis = { units: i, arealUnits: i + "²", observedMeanDistance: s, expectedMeanDistance: l, nearestNeighborIndex: s / l, numberOfPoints: a, zScore: (s - l) / c }, n.properties = r, n } !function (t, e) { nx(t, "name", { value: e, configurable: !0 }) }(rx, "nearestNeighborAnalysis"); var ix = Object.defineProperty, ox = function (t, e) { return ix(t, "name", { value: e, configurable: !0 }) }; function ax(t, e) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; if (n.method || (n.method = "geodesic"), n.units || (n.units = "kilometers"), !t) throw new Error("pt is required"); if (Array.isArray(t) ? t = Lu(t) : "Point" === t.type ? t = Mu(t) : ul(t, "Point", "point"), !e) throw new Error("line is required"); Array.isArray(e) ? e = Au(e) : "LineString" === e.type ? e = Mu(e) : ul(e, "LineString", "line"); var r = 1 / 0, i = t.geometry.coordinates; return Vl(e, (function (t) { var e = t.geometry.coordinates[0], o = t.geometry.coordinates[1], a = sx(i, e, o, n); a < r && (r = a) })), Zu(r, "degrees", n.units) } function sx(t, e, n, r) { var i = [n[0] - e[0], n[1] - e[1]], o = ux([t[0] - e[0], t[1] - e[1]], i); if (o <= 0) return lx(t, e, { method: r.method, units: "degrees" }); var a = ux(i, i); if (a <= o) return lx(t, n, { method: r.method, units: "degrees" }); var s = o / a; return lx(t, [e[0] + s * i[0], e[1] + s * i[1]], { method: r.method, units: "degrees" }) } function ux(t, e) { return t[0] * e[0] + t[1] * e[1] } function lx(t, e, n) { return "planar" === n.method ? um(t, e, n) : _l(t, e, n) } ox(ax, "pointToLineDistance"), ox(sx, "distanceToSegment"), ox(ux, "dot"), ox(lx, "calcDistance"); var cx = Object.defineProperty, hx = Object.getOwnPropertySymbols, fx = Object.prototype.hasOwnProperty, px = Object.prototype.propertyIsEnumerable, gx = function (t, e, n) { return e in t ? cx(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n }, yx = function (t, e) { for (var n in e || (e = {})) fx.call(e, n) && gx(t, n, e[n]); if (hx) { var r, i = c(hx(e)); try { for (i.s(); !(r = i.n()).done;) { n = r.value; px.call(e, n) && gx(t, n, e[n]) } } catch (t) { i.e(t) } finally { i.f() } } return t }, vx = function (t, e) { return cx(t, "name", { value: e, configurable: !0 }) }; function dx(t, e) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r = n.units, i = n.properties || {}, o = mx(t); if (!o.features.length) throw new Error("points must contain features"); if (!e) throw new Error("line is required"); if ("LineString" !== hl(e)) throw new Error("line must be a LineString"); var a = 1 / 0, s = null; return Tl(o, (function (t) { var n = ax(t, e, { units: r }); n < a && (a = n, s = t) })), s && (s.properties = yx(yx(yx({}, { dist: a }), s.properties), i)), s } function mx(t) { var e = []; switch (t.geometry ? t.geometry.type : t.type) { case "GeometryCollection": return jl(t, (function (t) { "Point" === t.type && e.push({ type: "Feature", properties: {}, geometry: t }) })), { type: "FeatureCollection", features: e }; case "FeatureCollection": return t.features = t.features.filter((function (t) { return "Point" === t.geometry.type })), t; default: throw new Error("points must be a Point Collection") } } vx(dx, "nearestPointToLine"), vx(mx, "normalize"); var _x = Object.defineProperty; function bx(t, e) { var n = il(t), r = cl(e).coordinates[0]; if (r.length < 4) throw new Error("OuterRing of a Polygon must have 4 or more Positions."); var i = e.properties || {}, o = i.a, a = i.b, s = i.c, u = n[0], l = n[1], c = r[0][0], h = r[0][1], f = void 0 !== o ? o : r[0][2], p = r[1][0], g = r[1][1], y = void 0 !== a ? a : r[1][2], v = r[2][0], d = r[2][1], m = void 0 !== s ? s : r[2][2]; return (m * (u - c) * (l - g) + f * (u - p) * (l - d) + y * (u - v) * (l - h) - y * (u - c) * (l - d) - m * (u - p) * (l - h) - f * (u - v) * (l - g)) / ((u - c) * (l - g) + (u - p) * (l - d) + (u - v) * (l - h) - (u - c) * (l - d) - (u - p) * (l - h) - (u - v) * (l - g)) } !function (t, e) { _x(t, "name", { value: e, configurable: !0 }) }(bx, "planepoint"); var xx = Object.defineProperty, Ex = function (t, e) { return xx(t, "name", { value: e, configurable: !0 }) }; function wx(t) { for (var e = kx(t), n = up(e), r = !1, i = 0; !r && i < e.features.length;) { var o = e.features[i].geometry, a = !1; if ("Point" === o.type) n.geometry.coordinates[0] === o.coordinates[0] && n.geometry.coordinates[1] === o.coordinates[1] && (r = !0); else if ("MultiPoint" === o.type) for (var s = !1, u = 0; !s && u < o.coordinates.length;)n.geometry.coordinates[0] === o.coordinates[u][0] && n.geometry.coordinates[1] === o.coordinates[u][1] && (r = !0, s = !0), u++; else if ("LineString" === o.type) for (var l = 0; !a && l < o.coordinates.length - 1;)Sx(n.geometry.coordinates[0], n.geometry.coordinates[1], o.coordinates[l][0], o.coordinates[l][1], o.coordinates[l + 1][0], o.coordinates[l + 1][1]) && (a = !0, r = !0), l++; else if ("MultiLineString" === o.type) for (var c = 0; c < o.coordinates.length;) { a = !1; for (var h = 0, f = o.coordinates[c]; !a && h < f.length - 1;)Sx(n.geometry.coordinates[0], n.geometry.coordinates[1], f[h][0], f[h][1], f[h + 1][0], f[h + 1][1]) && (a = !0, r = !0), h++; c++ } else "Polygon" !== o.type && "MultiPolygon" !== o.type || Nc(n, o) && (r = !0); i++ } if (r) return n; for (var p = ju([]), g = 0; g < e.features.length; g++)p.features = p.features.concat(_m(e.features[g]).features); return Lu(ex(n, p).geometry.coordinates) } function kx(t) { return "FeatureCollection" !== t.type ? "Feature" !== t.type ? ju([Mu(t)]) : ju([t]) : t } function Sx(t, e, n, r, i, o) { return Math.sqrt((i - n) * (i - n) + (o - r) * (o - r)) === Math.sqrt((t - n) * (t - n) + (e - r) * (e - r)) + Math.sqrt((i - t) * (i - t) + (o - e) * (o - e)) } Ex(wx, "pointOnFeature"), Ex(kx, "normalize"), Ex(Sx, "pointOnSegment"); var Ix = Object.defineProperty; function Px(t, e) { var n = []; return Tl(t, (function (t) { var r = !1; if ("Point" === t.geometry.type) jl(e, (function (e) { Nc(t, e) && (r = !0) })), r && n.push(t); else { if ("MultiPoint" !== t.geometry.type) throw new Error("Input geometry must be a Point or MultiPoint"); var i = []; jl(e, (function (e) { Ol(t, (function (t) { Nc(t, e) && (r = !0, i.push(t)) })) })), r && n.push(Bu(i, t.properties)) } })), ju(n) } !function (t, e) { Ix(t, "name", { value: e, configurable: !0 }) }(Px, "pointsWithinPolygon"); var Nx = Object.defineProperty, Mx = function (t, e) { return Nx(t, "name", { value: e, configurable: !0 }) }; function Ox(t) { return (t > 0) - (t < 0) || +t } function Lx(t, e, n) { var r = e[0] - t[0], i = e[1] - t[1], o = n[0] - e[0]; return Ox(r * (n[1] - e[1]) - o * i) } function Rx(t, e) { var n = t.geometry.coordinates[0].map((function (t) { return t[0] })), r = t.geometry.coordinates[0].map((function (t) { return t[1] })), i = e.geometry.coordinates[0].map((function (t) { return t[0] })), o = e.geometry.coordinates[0].map((function (t) { return t[1] })); return Math.max.apply(null, n) === Math.max.apply(null, i) && Math.max.apply(null, r) === Math.max.apply(null, o) && Math.min.apply(null, n) === Math.min.apply(null, i) && Math.min.apply(null, r) === Math.min.apply(null, o) } function Cx(t, e) { return e.geometry.coordinates[0].every((function (e) { return Nc(Lu(e), t) })) } function Tx(t, e) { return t[0] === e[0] && t[1] === e[1] } Mx(Ox, "mathSign"), Mx(Lx, "orientationIndex"), Mx(Rx, "envelopeIsEqual"), Mx(Cx, "envelopeContains"), Mx(Tx, "coordinatesEqual"); var Ax = function () { function t(e) { n(this, t), this.id = t.buildId(e), this.coordinates = e, this.innerEdges = [], this.outerEdges = [], this.outerEdgesSorted = !1 } return i(t, [{ key: "removeInnerEdge", value: function (t) { this.innerEdges = this.innerEdges.filter((function (e) { return e.from.id !== t.from.id })) } }, { key: "removeOuterEdge", value: function (t) { this.outerEdges = this.outerEdges.filter((function (e) { return e.to.id !== t.to.id })) } }, { key: "addOuterEdge", value: function (t) { this.outerEdges.push(t), this.outerEdgesSorted = !1 } }, { key: "sortOuterEdges", value: function () { var t = this; this.outerEdgesSorted || (this.outerEdges.sort((function (e, n) { var r = e.to, i = n.to; if (r.coordinates[0] - t.coordinates[0] >= 0 && i.coordinates[0] - t.coordinates[0] < 0) return 1; if (r.coordinates[0] - t.coordinates[0] < 0 && i.coordinates[0] - t.coordinates[0] >= 0) return -1; if (r.coordinates[0] - t.coordinates[0] == 0 && i.coordinates[0] - t.coordinates[0] == 0) return r.coordinates[1] - t.coordinates[1] >= 0 || i.coordinates[1] - t.coordinates[1] >= 0 ? r.coordinates[1] - i.coordinates[1] : i.coordinates[1] - r.coordinates[1]; var o = Lx(t.coordinates, r.coordinates, i.coordinates); return o < 0 ? 1 : o > 0 ? -1 : Math.pow(r.coordinates[0] - t.coordinates[0], 2) + Math.pow(r.coordinates[1] - t.coordinates[1], 2) - (Math.pow(i.coordinates[0] - t.coordinates[0], 2) + Math.pow(i.coordinates[1] - t.coordinates[1], 2)) })), this.outerEdgesSorted = !0) } }, { key: "getOuterEdges", value: function () { return this.sortOuterEdges(), this.outerEdges } }, { key: "getOuterEdge", value: function (t) { return this.sortOuterEdges(), this.outerEdges[t] } }, { key: "addInnerEdge", value: function (t) { this.innerEdges.push(t) } }], [{ key: "buildId", value: function (t) { return t.join(",") } }]), t }(); Mx(Ax, "Node"); var Dx = Ax, jx = function () { function t(e, r) { n(this, t), this.from = e, this.to = r, this.next = void 0, this.label = void 0, this.symetric = void 0, this.ring = void 0, this.from.addOuterEdge(this), this.to.addInnerEdge(this) } return i(t, [{ key: "getSymetric", value: function () { return this.symetric || (this.symetric = new t(this.to, this.from), this.symetric.symetric = this), this.symetric } }, { key: "deleteEdge", value: function () { this.from.removeOuterEdge(this), this.to.removeInnerEdge(this) } }, { key: "isEqual", value: function (t) { return this.from.id === t.from.id && this.to.id === t.to.id } }, { key: "toString", value: function () { return "Edge { ".concat(this.from.id, " -> ").concat(this.to.id, " }") } }, { key: "toLineString", value: function () { return Au([this.from.coordinates, this.to.coordinates]) } }, { key: "compareTo", value: function (t) { return Lx(t.from.coordinates, t.to.coordinates, this.to.coordinates) } }]), t }(); Mx(jx, "Edge"); var Fx = jx, Bx = function () { function t() { n(this, t), this.edges = [], this.polygon = void 0, this.envelope = void 0 } return i(t, [{ key: "push", value: function (t) { this.edges.push(t), this.polygon = this.envelope = void 0 } }, { key: "get", value: function (t) { return this.edges[t] } }, { key: "length", get: function () { return this.edges.length } }, { key: "forEach", value: function (t) { this.edges.forEach(t) } }, { key: "map", value: function (t) { return this.edges.map(t) } }, { key: "some", value: function (t) { return this.edges.some(t) } }, { key: "isValid", value: function () { return !0 } }, { key: "isHole", value: function () { var t = this, e = this.edges.reduce((function (e, n, r) { return n.from.coordinates[1] > t.edges[e].from.coordinates[1] && (e = r), e }), 0), n = (0 === e ? this.length : e) - 1, r = (e + 1) % this.length, i = Lx(this.edges[n].from.coordinates, this.edges[e].from.coordinates, this.edges[r].from.coordinates); return 0 === i ? this.edges[n].from.coordinates[0] > this.edges[r].from.coordinates[0] : i > 0 } }, { key: "toMultiPoint", value: function () { return Bu(this.edges.map((function (t) { return t.from.coordinates }))) } }, { key: "toPolygon", value: function () { if (this.polygon) return this.polygon; var t = this.edges.map((function (t) { return t.from.coordinates })); return t.push(this.edges[0].from.coordinates), this.polygon = Cu([t]) } }, { key: "getEnvelope", value: function () { return this.envelope ? this.envelope : this.envelope = dm(this.toPolygon()) } }, { key: "inside", value: function (t) { return Nc(t, this.toPolygon()) } }], [{ key: "findEdgeRingContaining", value: function (t, e) { var n, r, i = t.getEnvelope(); return e.forEach((function (e) { var o = e.getEnvelope(); if (r && (n = r.getEnvelope()), !Rx(o, i) && Cx(o, i)) { var a, s, u = c(t.map((function (t) { return t.from.coordinates }))); try { var l = function () { var t = s.value; e.some((function (e) { return Tx(t, e.from.coordinates) })) || (a = t) }; for (u.s(); !(s = u.n()).done;)l() } catch (t) { u.e(t) } finally { u.f() } a && e.inside(Lu(a)) && (r && !Cx(n, o) || (r = e)) } })), r } }]), t }(); Mx(Bx, "EdgeRing"); var qx = Bx; function Vx(t) { if (!t) throw new Error("No geojson passed"); if ("FeatureCollection" !== t.type && "GeometryCollection" !== t.type && "MultiLineString" !== t.type && "LineString" !== t.type && "Feature" !== t.type) throw new Error("Invalid input type '".concat(t.type, "'. Geojson must be FeatureCollection, GeometryCollection, LineString, MultiLineString or Feature")) } Mx(Vx, "validateGeoJson"); var Gx = function () { function t() { n(this, t), this.edges = [], this.nodes = {} } return i(t, [{ key: "getNode", value: function (t) { var e = Dx.buildId(t), n = this.nodes[e]; return n || (n = this.nodes[e] = new Dx(t)), n } }, { key: "addEdge", value: function (t, e) { var n = new Fx(t, e), r = n.getSymetric(); this.edges.push(n), this.edges.push(r) } }, { key: "deleteDangles", value: function () { var t = this; Object.keys(this.nodes).map((function (e) { return t.nodes[e] })).forEach((function (e) { return t._removeIfDangle(e) })) } }, { key: "_removeIfDangle", value: function (t) { var e = this; if (t.innerEdges.length <= 1) { var n = t.getOuterEdges().map((function (t) { return t.to })); this.removeNode(t), n.forEach((function (t) { return e._removeIfDangle(t) })) } } }, { key: "deleteCutEdges", value: function () { var t = this; this._computeNextCWEdges(), this._findLabeledEdgeRings(), this.edges.forEach((function (e) { e.label === e.symetric.label && (t.removeEdge(e.symetric), t.removeEdge(e)) })) } }, { key: "_computeNextCWEdges", value: function (t) { var e = this; void 0 === t ? Object.keys(this.nodes).forEach((function (t) { return e._computeNextCWEdges(e.nodes[t]) })) : t.getOuterEdges().forEach((function (e, n) { t.getOuterEdge((0 === n ? t.getOuterEdges().length : n) - 1).symetric.next = e })) } }, { key: "_computeNextCCWEdges", value: function (t, e) { for (var n, r, i = t.getOuterEdges(), o = i.length - 1; o >= 0; --o) { var a = i[o], s = a.symetric, u = void 0, l = void 0; a.label === e && (u = a), s.label === e && (l = s), u && l && (l && (r = l), u && (r && (r.next = u, r = void 0), n || (n = u))) } r && (r.next = n) } }, { key: "_findLabeledEdgeRings", value: function () { var t = [], e = 0; return this.edges.forEach((function (n) { if (!(n.label >= 0)) { t.push(n); var r = n; do { r.label = e, r = r.next } while (!n.isEqual(r)); e++ } })), t } }, { key: "getEdgeRings", value: function () { var t = this; this._computeNextCWEdges(), this.edges.forEach((function (t) { t.label = void 0 })), this._findLabeledEdgeRings().forEach((function (e) { t._findIntersectionNodes(e).forEach((function (n) { t._computeNextCCWEdges(n, e.label) })) })); var e = []; return this.edges.forEach((function (n) { n.ring || e.push(t._findEdgeRing(n)) })), e } }, { key: "_findIntersectionNodes", value: function (t) { var e = [], n = t, r = function () { var r = 0; n.from.getOuterEdges().forEach((function (e) { e.label === t.label && ++r })), r > 1 && e.push(n.from), n = n.next }; do { r() } while (!t.isEqual(n)); return e } }, { key: "_findEdgeRing", value: function (t) { var e = t, n = new qx; do { n.push(e), e.ring = n, e = e.next } while (!t.isEqual(e)); return n } }, { key: "removeNode", value: function (t) { var e = this; t.getOuterEdges().forEach((function (t) { return e.removeEdge(t) })), t.innerEdges.forEach((function (t) { return e.removeEdge(t) })), delete this.nodes[t.id] } }, { key: "removeEdge", value: function (t) { this.edges = this.edges.filter((function (e) { return !e.isEqual(t) })), t.deleteEdge() } }], [{ key: "fromGeoJson", value: function (e) { Vx(e); var n = new t; return Bl(e, (function (t) { ul(t, "LineString", "Graph::fromGeoJson"), Ll(t, (function (t, e) { if (t) { var r = n.getNode(t), i = n.getNode(e); n.addEdge(r, i) } return e })) })), n } }]), t }(); Mx(Gx, "Graph"); var Yx = Gx; function zx(t) { var e = Yx.fromGeoJson(t); e.deleteDangles(), e.deleteCutEdges(); var n = [], r = []; return e.getEdgeRings().filter((function (t) { return t.isValid() })).forEach((function (t) { t.isHole() ? n.push(t) : r.push(t) })), n.forEach((function (t) { qx.findEdgeRingContaining(t, r) && r.push(t) })), ju(r.map((function (t) { return t.toPolygon() }))) } Mx(zx, "polygonize"); var Ux = Object.defineProperty, Xx = function (t, e) { return Ux(t, "name", { value: e, configurable: !0 }) }; function Wx(t, e) { (e = e || {}).iterations = e.iterations || 1; var n = e.iterations, r = []; if (!t) throw new Error("inputPolys is required"); return jl(t, (function (t, e, i) { if ("Polygon" === t.type) { for (var o = [[]], a = 0; a < n; a++) { var s = [], u = t; a > 0 && (u = Cu(o).geometry), Hx(u, s), o = s.slice(0) } r.push(Cu(o, i)) } else { if ("MultiPolygon" !== t.type) throw new Error("geometry is invalid, must be Polygon or MultiPolygon"); for (var l = [[[]]], c = 0; c < n; c++) { var h = [], f = t; c > 0 && (f = qu(l).geometry), Zx(f, h), l = h.slice(0) } r.push(qu(l, i)) } })), ju(r) } function Hx(t, e) { var n, r; Ol(t, (function (t, i, o, a, s) { if (r !== s) e.push([]); else { var u = n[0], l = n[1], c = t[0], h = t[1]; e[s].push([.75 * u + .25 * c, .75 * l + .25 * h]), e[s].push([.25 * u + .75 * c, .25 * l + .75 * h]) } n = t, r = s }), !1), e.forEach((function (t) { t.push(t[0]) })) } function Zx(t, e) { var n, r, i; Ol(t, (function (t, o, a, s, u) { if (r !== s) e.push([[]]); else if (i !== u) e[s].push([]); else { var l = n[0], c = n[1], h = t[0], f = t[1]; e[s][u].push([.75 * l + .25 * h, .75 * c + .25 * f]), e[s][u].push([.25 * l + .75 * h, .25 * c + .75 * f]) } n = t, r = s, i = u }), !1), e.forEach((function (t) { t.forEach((function (t) { t.push(t[0]) })) })) } Xx(Wx, "polygonSmooth"), Xx(Hx, "processPolygon"), Xx(Zx, "processMultiPolygon"); var Jx = Object.defineProperty, $x = function (t, e) { return Jx(t, "name", { value: e, configurable: !0 }) }; function Qx(t, e) { var n, r = ol(t), i = ol(e), o = [], s = [], u = rc(e), l = 0, c = null; switch (r[0] > u[0] && r[0] < u[2] && r[1] > u[1] && r[1] < u[3] && (l = (c = ex(t, _m(e))).properties.featureIndex), hl(e)) { case "Polygon": o = i[0][l], s = i[0][0], null !== c && c.geometry.coordinates[1] < r[1] && (s = i[0][l]), n = nE(i[0][0], i[0][i[0].length - 1], r); var h = a(Kx(i[0], r, n, o, s), 2); o = h[0], s = h[1]; break; case "MultiPolygon": for (var f = 0, p = 0, g = 0, y = 0; y < i[0].length; y++) { f = y; for (var v = !1, d = 0; d < i[0][y].length; d++) { if (p = d, g === l) { v = !0; break } g++ } if (v) break } o = i[0][f][p], s = i[0][f][p], n = nE(i[0][0][0], i[0][0][i[0][0].length - 1], r), i.forEach((function (t) { var e = a(Kx(t[0], r, n, o, s), 2); o = e[0], s = e[1] })) }return ju([Lu(o), Lu(s)]) } function Kx(t, e, n, r, i) { for (var o = 0; o < t.length; o++) { var a = t[o], s = t[o + 1]; o === t.length - 1 && (s = t[0]); var u = nE(a, s, e); n <= 0 && u > 0 ? eE(e, a, r) || (r = a) : n > 0 && u <= 0 && (tE(e, a, i) || (i = a)), n = u } return [r, i] } function tE(t, e, n) { return nE(t, e, n) > 0 } function eE(t, e, n) { return nE(t, e, n) < 0 } function nE(t, e, n) { return (e[0] - t[0]) * (n[1] - t[1]) - (n[0] - t[0]) * (e[1] - t[1]) } $x(Qx, "polygonTangents"), $x(Kx, "processPolygon"), $x(tE, "isAbove"), $x(eE, "isBelow"), $x(nE, "isLeft"); var rE = Object.defineProperty, iE = function (t, e) { return rE(t, "name", { value: e, configurable: !0 }) }; function oE(t) { return sE(t, "mercator", arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}) } function aE(t) { return sE(t, "wgs84", arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}) } function sE(t, e) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r = (n = n || {}).mutate; if (!t) throw new Error("geojson is required"); return Array.isArray(t) && $u(t[0]) ? t = "mercator" === e ? uE(t) : lE(t) : (!0 !== r && (t = Ry(t)), Ol(t, (function (t) { var n = "mercator" === e ? uE(t) : lE(t); t[0] = n[0], t[1] = n[1] }))), t } function uE(t) { var e = Math.PI / 180, n = 6378137, r = 20037508.342789244, i = [n * (Math.abs(t[0]) <= 180 ? t[0] : t[0] - 360 * cE(t[0])) * e, n * Math.log(Math.tan(.25 * Math.PI + .5 * t[1] * e))]; return i[0] > r && (i[0] = r), i[0] < -r && (i[0] = -r), i[1] > r && (i[1] = r), i[1] < -r && (i[1] = -r), i } function lE(t) { var e = 180 / Math.PI, n = 6378137; return [t[0] * e / n, (.5 * Math.PI - 2 * Math.atan(Math.exp(-t[1] / n))) * e] } function cE(t) { return t < 0 ? -1 : t > 0 ? 1 : 0 } iE(oE, "toMercator"), iE(aE, "toWgs84"), iE(sE, "convert"), iE(uE, "convertToMercator"), iE(lE, "convertToWgs84"), iE(cE, "sign"); var hE = Object.freeze({ __proto__: null, toMercator: oE, toWgs84: aE }), fE = Object.defineProperty, pE = function (t, e) { return fE(t, "name", { value: e, configurable: !0 }) }; function gE(t, e) { for (var n = (e = e || {}).studyBbox || rc(t), r = e.confidenceLevel || 20, i = t.features, o = i.length, a = Jl(pc(n)), s = Ym(n, Math.sqrt(a / o * 2), { units: "meters" }).features, u = {}, l = 0; l < s.length; l++)u[l] = { box: rc(s[l]), cnt: 0 }; var h, f = 0, p = c(i); try { for (p.s(); !(h = p.n()).done;)for (var g = h.value, y = 0, v = Object.keys(u); y < v.length; y++) { var d = v[y], m = u[d].box; if (vE(il(g), m)) { u[d].cnt += 1, f += 1; break } } } catch (t) { p.e(t) } finally { p.f() } for (var _ = 0, b = 0, x = Object.keys(u); b < x.length; b++) { var E = u[x[b]].cnt; E > _ && (_ = E) } for (var w = [], k = Object.keys(u).length, S = f / k, I = 0, P = 0; P < _ + 1; P++)I += Math.exp(-S) * Math.pow(S, P) / dE(P), w.push(I); for (var N = [], M = 0, O = 0; O < _ + 1; O++) { for (var L = 0, R = Object.keys(u); L < R.length; L++) { u[R[L]].cnt === O && (M += 1) } var C = M / k; N.push(C) } for (var T = 0, A = 0; A < _ + 1; A++) { var D = Math.abs(w[A] - N[A]); D > T && (T = D) } var j = yE[r] / Math.sqrt(k), F = { criticalValue: j, isRandom: !0, maxAbsoluteDifference: T, observedDistribution: N }; return T > j && (F.isRandom = !1), F } pE(gE, "quadratAnalysis"); var yE = { 20: 1.07275, 15: 1.13795, 10: 1.22385, 5: 1.3581, 2: 1.51743, 1: 1.62762 }; function vE(t, e) { return e[0] <= t[0] && e[1] <= t[1] && e[2] >= t[0] && e[3] >= t[1] } function dE(t) { var e = []; function n(t) { return 0 === t || 1 === t ? 1 : e[t] > 0 ? e[t] : e[t] = n(t - 1) * t } return pE(n, "inner"), n(t) } pE(vE, "inBBox"), pE(dE, "factorial"); var mE = Object.defineProperty, _E = function (t, e) { return mE(t, "name", { value: e, configurable: !0 }) }; function bE(t) { return EE(t), xE(t) } function xE(t) { return Array.isArray(t) ? OE(t) : t && t.bbox ? OE(t.bbox) : [NE(), ME()] } function EE(t) { null != t && (Array.isArray(t) ? Ku(t) : null != t.bbox && Ku(t.bbox)) } function wE(t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; EE(e.bbox), null == t && (t = 1); for (var n = [], r = 0; r < t; r++)n.push(Lu(xE(e.bbox))); return ju(n) } function kE(t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; EE(e.bbox), null == t && (t = 1), $u(e.num_vertices) && void 0 !== e.num_vertices || (e.num_vertices = 10), $u(e.max_radial_length) && void 0 !== e.max_radial_length || (e.max_radial_length = 10); for (var n = [], r = function () { var t = [], r = s(Array(e.num_vertices + 1)).map(Math.random); r.forEach((function (t, e, n) { n[e] = e > 0 ? t + n[e - 1] : t })), r.forEach((function (n) { n = 2 * n * Math.PI / r[r.length - 1]; var i = Math.random(); t.push([i * (e.max_radial_length || 10) * Math.sin(n), i * (e.max_radial_length || 10) * Math.cos(n)]) })), t[t.length - 1] = t[0], t = t.map(IE(xE(e.bbox))), n.push(Cu([t])) }, i = 0; i < t; i++)r(); return ju(n) } function SE(t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (!Qu(e = e || {})) throw new Error("options is invalid"); var n = e.bbox; EE(n); var r = e.num_vertices, i = e.max_length, o = e.max_rotation; null == t && (t = 1), (!$u(r) || void 0 === r || r < 2) && (r = 10), $u(i) && void 0 !== i || (i = 1e-4), $u(o) && void 0 !== o || (o = Math.PI / 8); for (var a = [], s = 0; s < t; s++) { for (var u = [xE(n)], l = 0; l < r - 1; l++) { var c = (0 === l ? 2 * Math.random() * Math.PI : Math.tan((u[l][1] - u[l - 1][1]) / (u[l][0] - u[l - 1][0]))) + (Math.random() - .5) * o * 2, h = Math.random() * i; u.push([u[l][0] + h * Math.cos(c), u[l][1] + h * Math.sin(c)]) } a.push(Au(u)) } return ju(a) } function IE(t) { return function (e) { return [e[0] + t[0], e[1] + t[1]] } } function PE() { return Math.random() - .5 } function NE() { return 360 * PE() } function ME() { return 180 * PE() } function OE(t) { return [Math.random() * (t[2] - t[0]) + t[0], Math.random() * (t[3] - t[1]) + t[1]] } _E(bE, "randomPosition"), _E(xE, "randomPositionUnchecked"), _E(EE, "checkBBox"), _E(wE, "randomPoint"), _E(kE, "randomPolygon"), _E(SE, "randomLineString"), _E(IE, "vertexToCoordinate"), _E(PE, "rnd"), _E(NE, "lon"), _E(ME, "lat"), _E(OE, "coordInBBox"); var LE = Object.freeze({ __proto__: null, randomLineString: SE, randomPoint: wE, randomPolygon: kE, randomPosition: bE }), RE = Object.defineProperty, CE = function (t, e) { return RE(t, "name", { value: e, configurable: !0 }) }; function TE(t) { var e, n, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (!Qu(r = r || {})) throw new Error("options is invalid"); var i = null != (e = r.mutate) && e, o = null != (n = r.reverse) && n; if (!t) throw new Error("<geojson> is required"); if ("boolean" != typeof o) throw new Error("<reverse> must be a boolean"); if ("boolean" != typeof i) throw new Error("<mutate> must be a boolean"); i || "Point" === t.type || "MultiPoint" === t.type || (t = Ry(t)); var a = []; switch (t.type) { case "GeometryCollection": return jl(t, (function (t) { AE(t, o) })), t; case "FeatureCollection": return Tl(t, (function (t) { Tl(AE(t, o), (function (t) { a.push(t) })) })), ju(a) }return AE(t, o) } function AE(t, e) { switch ("Feature" === t.type ? t.geometry.type : t.type) { case "GeometryCollection": return jl(t, (function (t) { AE(t, e) })), t; case "LineString": return DE(ol(t), e), t; case "Polygon": return jE(ol(t), e), t; case "MultiLineString": return ol(t).forEach((function (t) { DE(t, e) })), t; case "MultiPolygon": return ol(t).forEach((function (t) { jE(t, e) })), t; case "Point": case "MultiPoint": return t } } function DE(t, e) { Ec(t) === e && t.reverse() } function jE(t, e) { Ec(t[0]) !== e && t[0].reverse(); for (var n = 1; n < t.length; n++)Ec(t[n]) === e && t[n].reverse() } CE(TE, "rewind"), CE(AE, "rewindFeature"), CE(DE, "rewindLineString"), CE(jE, "rewindPolygon"); var FE = Object.defineProperty, BE = function (t, e) { return FE(t, "name", { value: e, configurable: !0 }) }; function qE(t, e) { if (!t) throw new Error("fc is required"); if (null == e) throw new Error("num is required"); if ("number" != typeof e) throw new Error("num must be a number"); return ju(VE(t.features, e)) } function VE(t, e) { for (var n, r, i = t.slice(0), o = t.length, a = o - e; o-- > a;)n = i[r = Math.floor((o + 1) * Math.random())], i[r] = i[o], i[o] = n; return i.slice(a) } BE(qE, "sample"), BE(VE, "getRandomSubarray"); var GE = Object.defineProperty, YE = function (t, e) { return GE(t, "name", { value: e, configurable: !0 }) }; function zE(t, n, r, i) { var o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : {}; if (!Qu(o = o || {})) throw new Error("options is invalid"); var a = o.properties; if (!t) throw new Error("center is required"); if (null == r) throw new Error("bearing1 is required"); if (null == i) throw new Error("bearing2 is required"); if (!n) throw new Error("radius is required"); if ("object" !== e(o)) throw new Error("options must be an object"); if (UE(r) === UE(i)) return My(t, n, o); var s = ol(t), u = U_(t, n, r, i, o), l = [[s]]; return Ol(u, (function (t) { l[0].push(t) })), l[0].push(s), Cu(l, a) } function UE(t) { var e = t % 360; return e < 0 && (e += 360), e } YE(zE, "sector"), YE(UE, "convertAngleTo360"); var XE = Object.defineProperty, WE = function (t, e) { return XE(t, "name", { value: e, configurable: !0 }) }; function HE(t, n, r) { if (!Qu(r = r || {})) throw new Error("options is invalid"); var i = r.origin, o = r.mutate; if (!t) throw new Error("geojson required"); if ("number" != typeof n || n <= 0) throw new Error("invalid factor"); var a = Array.isArray(i) || "object" === e(i); return !0 !== o && (t = Ry(t)), "FeatureCollection" !== t.type || a ? ZE(t, n, i) : (Tl(t, (function (e, r) { t.features[r] = ZE(e, n, i) })), t) } function ZE(t, e, n) { var r = "Point" === hl(t); return n = JE(t, n), 1 === e || r || (Ol(t, (function (t) { var r = um(n, t), i = kl(n, t), o = ol(im(n, r * e, i)); t[0] = o[0], t[1] = o[1], 3 === t.length && (t[2] *= e) })), delete t.bbox), t } function JE(t, n) { if (null == n && (n = "centroid"), Array.isArray(n) || "object" === e(n)) return il(n); var r = t.bbox ? t.bbox : rc(t, { recalculate: !0 }), i = r[0], o = r[1], a = r[2], s = r[3]; switch (n) { case "sw": case "southwest": case "westsouth": case "bottomleft": return Lu([i, o]); case "se": case "southeast": case "eastsouth": case "bottomright": return Lu([a, o]); case "nw": case "northwest": case "westnorth": case "topleft": return Lu([i, s]); case "ne": case "northeast": case "eastnorth": case "topright": return Lu([a, s]); case "center": return up(t); case void 0: case null: case "centroid": return Ug(t); default: throw new Error("invalid origin") } } WE(HE, "transformScale"), WE(ZE, "scale"), WE(JE, "defineOrigin"); var $E = Object.defineProperty, QE = function (t, e) { return $E(t, "name", { value: e, configurable: !0 }) }; function KE(t) { for (var e = t, n = []; e.parent;)n.unshift(e), e = e.parent; return n } function tw() { return new iw((function (t) { return t.f })) } QE(KE, "pathTo"), QE(tw, "getHeap"); var ew = { search: function (t, e, n, r) { var i; t.cleanDirty(); var o = (r = r || {}).heuristic || ew.heuristics.manhattan, a = null != (i = r.closest) && i, s = tw(), u = e; for (e.h = o(e, n), s.push(e); s.size() > 0;) { var l = s.pop(); if (l === n) return KE(l); l.closed = !0; for (var c = t.neighbors(l), h = 0, f = c.length; h < f; ++h) { var p = c[h]; if (!p.closed && !p.isWall()) { var g = l.g + p.getCost(l), y = p.visited; (!y || g < p.g) && (p.visited = !0, p.parent = l, p.h = p.h || o(p, n), p.g = g, p.f = p.g + p.h, t.markDirty(p), a && (p.h < u.h || p.h === u.h && p.g < u.g) && (u = p), y ? s.rescoreElement(p) : s.push(p)) } } } return a ? KE(u) : [] }, heuristics: { manhattan: function (t, e) { return Math.abs(e.x - t.x) + Math.abs(e.y - t.y) }, diagonal: function (t, e) { var n = Math.sqrt(2), r = Math.abs(e.x - t.x), i = Math.abs(e.y - t.y); return 1 * (r + i) + (n - 2) * Math.min(r, i) } }, cleanNode: function (t) { t.f = 0, t.g = 0, t.h = 0, t.visited = !1, t.closed = !1, t.parent = null } }; function nw(t, e) { e = e || {}, this.nodes = [], this.diagonal = !!e.diagonal, this.grid = []; for (var n = 0; n < t.length; n++) { this.grid[n] = []; for (var r = 0, i = t[n]; r < i.length; r++) { var o = new rw(n, r, i[r]); this.grid[n][r] = o, this.nodes.push(o) } } this.init() } function rw(t, e, n) { this.x = t, this.y = e, this.weight = n } function iw(t) { this.content = [], this.scoreFunction = t } function ow(t, e) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; if (!Qu(n = n || {})) throw new Error("options is invalid"); var r = n.obstacles || ju([]), i = n.resolution || 100; if (!t) throw new Error("start is required"); if (!e) throw new Error("end is required"); if (i && (!$u(i) || i <= 0)) throw new Error("options.resolution must be a number, greater than 0"); var o = il(t), s = il(e); if (t = Lu(o), e = Lu(s), "FeatureCollection" === r.type) { if (0 === r.features.length) return Au([o, s]) } else { if ("Polygon" !== r.type) throw new Error("invalid obstacles"); r = ju([Mu(cl(r))]) } var u = r; u.features.push(t), u.features.push(e); var l = a(rc(HE(pc(rc(u)), 1.15)), 4), c = l[0], h = l[1], f = l[2], p = l[3], g = _l([c, h], [f, h], n) / i; u.features.pop(), u.features.pop(); for (var y, v, d = g / _l([c, h], [f, h], n) * (f - c), m = g / _l([c, h], [c, p], n) * (p - h), _ = f - c, b = p - h, x = Math.floor(_ / d), E = Math.floor(b / m), w = (_ - x * d) / 2, k = [], S = [], I = 1 / 0, P = 1 / 0, N = p - (b - E * m) / 2, M = 0; N >= h;) { for (var O = [], L = [], R = c + w, C = 0; R <= f;) { var T = Lu([R, N]), A = aw(T, r); O.push(A ? 0 : 1), L.push(R + "|" + N); var D = _l(T, t); !A && D < I && (I = D, y = { x: C, y: M }); var j = _l(T, e); !A && j < P && (P = j, v = { x: C, y: M }), R += d, C++ } S.push(O), k.push(L), N -= m, M++ } var F = new nw(S, { diagonal: !0 }), B = F.grid[y.y][y.x], q = F.grid[v.y][v.x], V = ew.search(F, B, q), G = [o]; return V.forEach((function (t) { var e = k[t.x][t.y].split("|"); G.push([+e[0], +e[1]]) })), G.push(s), Ah(Au(G)) } function aw(t, e) { for (var n = 0; n < e.features.length; n++)if (Nc(t, e.features[n])) return !0; return !1 } QE(nw, "Graph"), nw.prototype.init = function () { this.dirtyNodes = []; for (var t = 0; t < this.nodes.length; t++)ew.cleanNode(this.nodes[t]) }, nw.prototype.cleanDirty = function () { for (var t = 0; t < this.dirtyNodes.length; t++)ew.cleanNode(this.dirtyNodes[t]); this.dirtyNodes = [] }, nw.prototype.markDirty = function (t) { this.dirtyNodes.push(t) }, nw.prototype.neighbors = function (t) { var e = [], n = t.x, r = t.y, i = this.grid; return i[n - 1] && i[n - 1][r] && e.push(i[n - 1][r]), i[n + 1] && i[n + 1][r] && e.push(i[n + 1][r]), i[n] && i[n][r - 1] && e.push(i[n][r - 1]), i[n] && i[n][r + 1] && e.push(i[n][r + 1]), this.diagonal && (i[n - 1] && i[n - 1][r - 1] && e.push(i[n - 1][r - 1]), i[n + 1] && i[n + 1][r - 1] && e.push(i[n + 1][r - 1]), i[n - 1] && i[n - 1][r + 1] && e.push(i[n - 1][r + 1]), i[n + 1] && i[n + 1][r + 1] && e.push(i[n + 1][r + 1])), e }, nw.prototype.toString = function () { for (var t, e, n, r, i = [], o = this.grid, a = 0, s = o.length; a < s; a++) { for (t = [], n = 0, r = (e = o[a]).length; n < r; n++)t.push(e[n].weight); i.push(t.join(" ")) } return i.join("\n") }, QE(rw, "GridNode"), rw.prototype.toString = function () { return "[" + this.x + " " + this.y + "]" }, rw.prototype.getCost = function (t) { return t && t.x !== this.x && t.y !== this.y ? 1.41421 * this.weight : this.weight }, rw.prototype.isWall = function () { return 0 === this.weight }, QE(iw, "BinaryHeap"), iw.prototype = { push: function (t) { this.content.push(t), this.sinkDown(this.content.length - 1) }, pop: function () { var t = this.content[0], e = this.content.pop(); return this.content.length > 0 && (this.content[0] = e, this.bubbleUp(0)), t }, remove: function (t) { var e = this.content.indexOf(t), n = this.content.pop(); e !== this.content.length - 1 && (this.content[e] = n, this.scoreFunction(n) < this.scoreFunction(t) ? this.sinkDown(e) : this.bubbleUp(e)) }, size: function () { return this.content.length }, rescoreElement: function (t) { this.sinkDown(this.content.indexOf(t)) }, sinkDown: function (t) { for (var e = this.content[t]; t > 0;) { var n = (t + 1 >> 1) - 1, r = this.content[n]; if (!(this.scoreFunction(e) < this.scoreFunction(r))) break; this.content[n] = e, this.content[t] = r, t = n } }, bubbleUp: function (t) { for (var e = this.content.length, n = this.content[t], r = this.scoreFunction(n); ;) { var i, o = t + 1 << 1, a = o - 1, s = null; if (a < e) { var u = this.content[a]; (i = this.scoreFunction(u)) < r && (s = a) } if (o < e) { var l = this.content[o]; this.scoreFunction(l) < (null === s ? r : i) && (s = o) } if (null === s) break; this.content[t] = this.content[s], this.content[s] = n, t = s } } }, QE(ow, "shortestPath"), QE(aw, "isInside"); var sw = Object.defineProperty, uw = function (t, e) { return sw(t, "name", { value: e, configurable: !0 }) }; function lw(t, e) { var n = t[0] - e[0], r = t[1] - e[1]; return n * n + r * r } function cw(t, e, n) { var r = e[0], i = e[1], o = n[0] - r, a = n[1] - i; if (0 !== o || 0 !== a) { var s = ((t[0] - r) * o + (t[1] - i) * a) / (o * o + a * a); s > 1 ? (r = n[0], i = n[1]) : s > 0 && (r += o * s, i += a * s) } return (o = t[0] - r) * o + (a = t[1] - i) * a } function hw(t, e) { for (var n, r = t[0], i = [r], o = 1, a = t.length; o < a; o++)lw(n = t[o], r) > e && (i.push(n), r = n); return r !== n && i.push(n), i } function fw(t, e, n, r, i) { for (var o, a = r, s = e + 1; s < n; s++) { var u = cw(t[s], t[e], t[n]); u > a && (o = s, a = u) } a > r && (o - e > 1 && fw(t, e, o, r, i), i.push(t[o]), n - o > 1 && fw(t, o, n, r, i)) } function pw(t, e) { var n = t.length - 1, r = [t[0]]; return fw(t, 0, n, e, r), r.push(t[n]), r } function gw(t, e, n) { if (t.length <= 2) return t; var r = void 0 !== e ? e * e : 1; return t = pw(t = n ? t : hw(t, r), r) } function yw(t) { var e, n, r, i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (!Qu(i = null != i ? i : {})) throw new Error("options is invalid"); var o = null != (e = i.tolerance) ? e : 1, a = null != (n = i.highQuality) && n, s = null != (r = i.mutate) && r; if (!t) throw new Error("geojson is required"); if (o && o < 0) throw new Error("invalid tolerance"); return !0 !== s && (t = Ry(t)), jl(t, (function (t) { vw(t, o, a) })), t } function vw(t, e, n) { var r = t.type; if ("Point" === r || "MultiPoint" === r) return t; if (Ah(t, { mutate: !0 }), "GeometryCollection" !== r) switch (r) { case "LineString": t.coordinates = gw(t.coordinates, e, n); break; case "MultiLineString": t.coordinates = t.coordinates.map((function (t) { return gw(t, e, n) })); break; case "Polygon": t.coordinates = dw(t.coordinates, e, n); break; case "MultiPolygon": t.coordinates = t.coordinates.map((function (t) { return dw(t, e, n) })) }return t } function dw(t, e, n) { return t.map((function (t) { if (t.length < 4) throw new Error("invalid polygon"); for (var r = e, i = gw(t, r, n); !mw(i);)i = gw(t, r -= .01 * r, n); return i[i.length - 1][0] === i[0][0] && i[i.length - 1][1] === i[0][1] || i.push(i[0]), i })) } function mw(t) { return !(t.length < 3) && !(3 === t.length && t[2][0] === t[0][0] && t[2][1] === t[0][1]) } uw(lw, "getSqDist"), uw(cw, "getSqSegDist"), uw(hw, "simplifyRadialDist"), uw(fw, "simplifyDPStep"), uw(pw, "simplifyDouglasPeucker"), uw(gw, "simplify"), uw(yw, "simplify"), uw(vw, "simplifyGeom"), uw(dw, "simplifyPolygon"), uw(mw, "checkValidity"); var _w = Object.defineProperty, bw = function (t, e) { return _w(t, "name", { value: e, configurable: !0 }) }; function xw(t, e) { if (!Qu(e = e || {})) throw new Error("options is invalid"); var n = e.steps || 64, r = e.weight, i = e.properties || {}; if (!$u(n)) throw new Error("steps must be a number"); if (!Qu(i)) throw new Error("properties must be a number"); var o = Dl(t).length, a = Yg(t, { weight: r }), s = 0, u = 0, l = 0; Tl(t, (function (t) { var e = t.properties[r] || 1, n = Ew(ol(t), ol(a)); s += Math.pow(n.x, 2) * e, u += Math.pow(n.y, 2) * e, l += n.x * n.y * e })); var c = s - u, h = Math.sqrt(Math.pow(c, 2) + 4 * Math.pow(l, 2)), f = 2 * l, p = Math.atan((c + h) / f), g = 180 * p / Math.PI, y = 0, v = 0, d = 0; Tl(t, (function (t) { var e = t.properties[r] || 1, n = Ew(ol(t), ol(a)); y += Math.pow(n.x * Math.cos(p) - n.y * Math.sin(p), 2) * e, v += Math.pow(n.x * Math.sin(p) + n.y * Math.cos(p), 2) * e, d += e })); var m = Math.sqrt(2 * y / d), _ = Math.sqrt(2 * v / d), b = gm(a, m, _, { units: "degrees", angle: g, steps: n, properties: i }), x = Px(t, ju([b])), E = { meanCenterCoordinates: ol(a), semiMajorAxis: m, semiMinorAxis: _, numberOfFeatures: o, angle: g, percentageWithinEllipse: 100 * Dl(x).length / o }; return b.properties.standardDeviationalEllipse = E, b } function Ew(t, e) { return { x: t[0] - e[0], y: t[1] - e[1] } } bw(xw, "standardDeviationalEllipse"), bw(Ew, "getDeviations"); var ww = Object.defineProperty; function kw(t, e, n, r) { return t = Ry(t), e = Ry(e), Tl(t, (function (t) { t.properties || (t.properties = {}), Tl(e, (function (e) { t.properties && e.properties && void 0 === t.properties[r] && Nc(t, e) && (t.properties[r] = e.properties[n]) })) })), t } !function (t, e) { ww(t, "name", { value: e, configurable: !0 }) }(kw, "tag"); var Sw = { exports: {} }; function Iw(t, e, n) { n = n || 2; var r, i, o, a, s, u, l, c = e && e.length, h = c ? e[0] * n : t.length, f = Pw(t, 0, h, n, !0), p = []; if (!f || f.next === f.prev) return p; if (c && (f = function (t, e, n, r) { var i, o, a, s = []; for (i = 0, o = e.length; i < o; i++)(a = Pw(t, e[i] * r, i < o - 1 ? e[i + 1] * r : t.length, r, !1)) === a.next && (a.steiner = !0), s.push(Fw(a)); for (s.sort(Tw), i = 0; i < s.length; i++)n = Aw(s[i], n); return n }(t, e, f, n)), t.length > 80 * n) { r = o = t[0], i = a = t[1]; for (var g = n; g < h; g += n)(s = t[g]) < r && (r = s), (u = t[g + 1]) < i && (i = u), s > o && (o = s), u > a && (a = u); l = 0 !== (l = Math.max(o - r, a - i)) ? 32767 / l : 0 } return Mw(f, p, n, r, i, l, 0), p } function Pw(t, e, n, r, i) { var o, a; if (i === $w(t, e, n, r) > 0) for (o = e; o < n; o += r)a = Hw(o, t[o], t[o + 1], a); else for (o = n - r; o >= e; o -= r)a = Hw(o, t[o], t[o + 1], a); return a && Gw(a, a.next) && (Zw(a), a = a.next), a } function Nw(t, e) { if (!t) return t; e || (e = t); var n, r = t; do { if (n = !1, r.steiner || !Gw(r, r.next) && 0 !== Vw(r.prev, r, r.next)) r = r.next; else { if (Zw(r), (r = e = r.prev) === r.next) break; n = !0 } } while (n || r !== e); return e } function Mw(t, e, n, r, i, o, a) { if (t) { !a && o && function (t, e, n, r) { var i = t; do { 0 === i.z && (i.z = jw(i.x, i.y, e, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next } while (i !== t); i.prevZ.nextZ = null, i.prevZ = null, function (t) { var e, n, r, i, o, a, s, u, l = 1; do { for (n = t, t = null, o = null, a = 0; n;) { for (a++, r = n, s = 0, e = 0; e < l && (s++, r = r.nextZ); e++); for (u = l; s > 0 || u > 0 && r;)0 !== s && (0 === u || !r || n.z <= r.z) ? (i = n, n = n.nextZ, s--) : (i = r, r = r.nextZ, u--), o ? o.nextZ = i : t = i, i.prevZ = o, o = i; n = r } o.nextZ = null, l *= 2 } while (a > 1) }(i) }(t, r, i, o); for (var s, u, l = t; t.prev !== t.next;)if (s = t.prev, u = t.next, o ? Lw(t, r, i, o) : Ow(t)) e.push(s.i / n | 0), e.push(t.i / n | 0), e.push(u.i / n | 0), Zw(t), t = u.next, l = u.next; else if ((t = u) === l) { a ? 1 === a ? Mw(t = Rw(Nw(t), e, n), e, n, r, i, o, 2) : 2 === a && Cw(t, e, n, r, i, o) : Mw(Nw(t), e, n, r, i, o, 1); break } } } function Ow(t) { var e = t.prev, n = t, r = t.next; if (Vw(e, n, r) >= 0) return !1; for (var i = e.x, o = n.x, a = r.x, s = e.y, u = n.y, l = r.y, c = i < o ? i < a ? i : a : o < a ? o : a, h = s < u ? s < l ? s : l : u < l ? u : l, f = i > o ? i > a ? i : a : o > a ? o : a, p = s > u ? s > l ? s : l : u > l ? u : l, g = r.next; g !== e;) { if (g.x >= c && g.x <= f && g.y >= h && g.y <= p && Bw(i, s, o, u, a, l, g.x, g.y) && Vw(g.prev, g, g.next) >= 0) return !1; g = g.next } return !0 } function Lw(t, e, n, r) { var i = t.prev, o = t, a = t.next; if (Vw(i, o, a) >= 0) return !1; for (var s = i.x, u = o.x, l = a.x, c = i.y, h = o.y, f = a.y, p = s < u ? s < l ? s : l : u < l ? u : l, g = c < h ? c < f ? c : f : h < f ? h : f, y = s > u ? s > l ? s : l : u > l ? u : l, v = c > h ? c > f ? c : f : h > f ? h : f, d = jw(p, g, e, n, r), m = jw(y, v, e, n, r), _ = t.prevZ, b = t.nextZ; _ && _.z >= d && b && b.z <= m;) { if (_.x >= p && _.x <= y && _.y >= g && _.y <= v && _ !== i && _ !== a && Bw(s, c, u, h, l, f, _.x, _.y) && Vw(_.prev, _, _.next) >= 0) return !1; if (_ = _.prevZ, b.x >= p && b.x <= y && b.y >= g && b.y <= v && b !== i && b !== a && Bw(s, c, u, h, l, f, b.x, b.y) && Vw(b.prev, b, b.next) >= 0) return !1; b = b.nextZ } for (; _ && _.z >= d;) { if (_.x >= p && _.x <= y && _.y >= g && _.y <= v && _ !== i && _ !== a && Bw(s, c, u, h, l, f, _.x, _.y) && Vw(_.prev, _, _.next) >= 0) return !1; _ = _.prevZ } for (; b && b.z <= m;) { if (b.x >= p && b.x <= y && b.y >= g && b.y <= v && b !== i && b !== a && Bw(s, c, u, h, l, f, b.x, b.y) && Vw(b.prev, b, b.next) >= 0) return !1; b = b.nextZ } return !0 } function Rw(t, e, n) { var r = t; do { var i = r.prev, o = r.next.next; !Gw(i, o) && Yw(i, r, r.next, o) && Xw(i, o) && Xw(o, i) && (e.push(i.i / n | 0), e.push(r.i / n | 0), e.push(o.i / n | 0), Zw(r), Zw(r.next), r = t = o), r = r.next } while (r !== t); return Nw(r) } function Cw(t, e, n, r, i, o) { var a = t; do { for (var s = a.next.next; s !== a.prev;) { if (a.i !== s.i && qw(a, s)) { var u = Ww(a, s); return a = Nw(a, a.next), u = Nw(u, u.next), Mw(a, e, n, r, i, o, 0), void Mw(u, e, n, r, i, o, 0) } s = s.next } a = a.next } while (a !== t) } function Tw(t, e) { return t.x - e.x } function Aw(t, e) { var n = function (t, e) { var n, r = e, i = t.x, o = t.y, a = -1 / 0; do { if (o <= r.y && o >= r.next.y && r.next.y !== r.y) { var s = r.x + (o - r.y) * (r.next.x - r.x) / (r.next.y - r.y); if (s <= i && s > a && (a = s, n = r.x < r.next.x ? r : r.next, s === i)) return n } r = r.next } while (r !== e); if (!n) return null; var u, l = n, c = n.x, h = n.y, f = 1 / 0; r = n; do { i >= r.x && r.x >= c && i !== r.x && Bw(o < h ? i : a, o, c, h, o < h ? a : i, o, r.x, r.y) && (u = Math.abs(o - r.y) / (i - r.x), Xw(r, t) && (u < f || u === f && (r.x > n.x || r.x === n.x && Dw(n, r))) && (n = r, f = u)), r = r.next } while (r !== l); return n }(t, e); if (!n) return e; var r = Ww(n, t); return Nw(r, r.next), Nw(n, n.next) } function Dw(t, e) { return Vw(t.prev, t, e.prev) < 0 && Vw(e.next, t, t.next) < 0 } function jw(t, e, n, r, i) { return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - n) * i | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - r) * i | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1 } function Fw(t) { var e = t, n = t; do { (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next } while (e !== t); return n } function Bw(t, e, n, r, i, o, a, s) { return (i - a) * (e - s) >= (t - a) * (o - s) && (t - a) * (r - s) >= (n - a) * (e - s) && (n - a) * (o - s) >= (i - a) * (r - s) } function qw(t, e) { return t.next.i !== e.i && t.prev.i !== e.i && !function (t, e) { var n = t; do { if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Yw(n, n.next, t, e)) return !0; n = n.next } while (n !== t); return !1 }(t, e) && (Xw(t, e) && Xw(e, t) && function (t, e) { var n = t, r = !1, i = (t.x + e.x) / 2, o = (t.y + e.y) / 2; do { n.y > o != n.next.y > o && n.next.y !== n.y && i < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next } while (n !== t); return r }(t, e) && (Vw(t.prev, t, e.prev) || Vw(t, e.prev, e)) || Gw(t, e) && Vw(t.prev, t, t.next) > 0 && Vw(e.prev, e, e.next) > 0) } function Vw(t, e, n) { return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y) } function Gw(t, e) { return t.x === e.x && t.y === e.y } function Yw(t, e, n, r) { var i = Uw(Vw(t, e, n)), o = Uw(Vw(t, e, r)), a = Uw(Vw(n, r, t)), s = Uw(Vw(n, r, e)); return i !== o && a !== s || (!(0 !== i || !zw(t, n, e)) || (!(0 !== o || !zw(t, r, e)) || (!(0 !== a || !zw(n, t, r)) || !(0 !== s || !zw(n, e, r))))) } function zw(t, e, n) { return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y) } function Uw(t) { return t > 0 ? 1 : t < 0 ? -1 : 0 } function Xw(t, e) { return Vw(t.prev, t, t.next) < 0 ? Vw(t, e, t.next) >= 0 && Vw(t, t.prev, e) >= 0 : Vw(t, e, t.prev) < 0 || Vw(t, t.next, e) < 0 } function Ww(t, e) { var n = new Jw(t.i, t.x, t.y), r = new Jw(e.i, e.x, e.y), i = t.next, o = e.prev; return t.next = e, e.prev = t, n.next = i, i.prev = n, r.next = n, n.prev = r, o.next = r, r.prev = o, r } function Hw(t, e, n, r) { var i = new Jw(t, e, n); return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i } function Zw(t) { t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ) } function Jw(t, e, n) { this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1 } function $w(t, e, n, r) { for (var i = 0, o = e, a = n - r; o < n; o += r)i += (t[a] - t[o]) * (t[o + 1] + t[a + 1]), a = o; return i } Sw.exports = Iw, Sw.exports.default = Iw, Iw.deviation = function (t, e, n, r) { var i = e && e.length, o = i ? e[0] * n : t.length, a = Math.abs($w(t, 0, o, n)); if (i) for (var s = 0, u = e.length; s < u; s++) { var l = e[s] * n, c = s < u - 1 ? e[s + 1] * n : t.length; a -= Math.abs($w(t, l, c, n)) } var h = 0; for (s = 0; s < r.length; s += 3) { var f = r[s] * n, p = r[s + 1] * n, g = r[s + 2] * n; h += Math.abs((t[f] - t[g]) * (t[p + 1] - t[f + 1]) - (t[f] - t[p]) * (t[g + 1] - t[f + 1])) } return 0 === a && 0 === h ? 0 : Math.abs((h - a) / a) }, Iw.flatten = function (t) { for (var e = t[0][0].length, n = { vertices: [], holes: [], dimensions: e }, r = 0, i = 0; i < t.length; i++) { for (var o = 0; o < t[i].length; o++)for (var a = 0; a < e; a++)n.vertices.push(t[i][o][a]); i > 0 && (r += t[i - 1].length, n.holes.push(r)) } return n }; var Qw = p(Sw.exports), Kw = Object.defineProperty, tk = function (t, e) { return Kw(t, "name", { value: e, configurable: !0 }) }; function ek(t) { if (!t.geometry || "Polygon" !== t.geometry.type && "MultiPolygon" !== t.geometry.type) throw new Error("input must be a Polygon or MultiPolygon"); var e = { type: "FeatureCollection", features: [] }; return "Polygon" === t.geometry.type ? e.features = nk(t.geometry.coordinates) : t.geometry.coordinates.forEach((function (t) { e.features = e.features.concat(nk(t)) })), e } function nk(t) { var e = rk(t), n = Qw(e.vertices, e.holes, 2), r = [], i = []; n.forEach((function (t, r) { var o = n[r]; i.push([e.vertices[2 * o], e.vertices[2 * o + 1]]) })); for (var o = 0; o < i.length; o += 3) { var a = i.slice(o, o + 3); a.push(i[o]), r.push(Cu([a])) } return r } function rk(t) { for (var e = t[0][0].length, n = { vertices: [], holes: [], dimensions: e }, r = 0, i = 0; i < t.length; i++) { for (var o = 0; o < t[i].length; o++)for (var a = 0; a < e; a++)n.vertices.push(t[i][o][a]); i > 0 && (r += t[i - 1].length, n.holes.push(r)) } return n } tk(ek, "tesselate"), tk(nk, "processPolygon"), tk(rk, "flattenCoords"); var ik = Object.defineProperty; function ok(t, e, n, r) { if (!Qu(r = r || {})) throw new Error("options is invalid"); var i = r.units, o = r.zTranslation, a = r.mutate; if (!t) throw new Error("geojson is required"); if (null == e || isNaN(e)) throw new Error("distance is required"); if (o && "number" != typeof o && isNaN(o)) throw new Error("zTranslation is not a number"); if (o = void 0 !== o ? o : 0, 0 === e && 0 === o) return t; if (null == n || isNaN(n)) throw new Error("direction is required"); return e < 0 && (e = -e, n += 180), !1 !== a && void 0 !== a || (t = Ry(t)), Ol(t, (function (t) { var r = ol(im(t, e, n, { units: i })); t[0] = r[0], t[1] = r[1], o && 3 === t.length && (t[2] += o) })), t } !function (t, e) { ik(t, "name", { value: e, configurable: !0 }) }(ok, "transformTranslate"); var ak = Object.defineProperty; function sk(t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = []; if (jl(t, (function (t) { n.push(t.coordinates) })), n.length < 2) throw new Error("Must have at least 2 geometries"); var r = Ud.union.apply(Ud, [n[0]].concat(s(n.slice(1)))); return 0 === r.length ? null : 1 === r.length ? Cu(r[0], e.properties) : qu(r, e.properties) } !function (t, e) { ak(t, "name", { value: e, configurable: !0 }) }(sk, "union"); var uk = Object.defineProperty, lk = function (t, e) { return uk(t, "name", { value: e, configurable: !0 }) }; function ck(t, e, n) { if ("Polygon" !== t.geometry.type) throw new Error("The input feature must be a Polygon"); void 0 === n && (n = 1); var r = t.geometry.coordinates, i = [], o = {}; if (n) { for (var a = [], s = 0; s < r.length; s++)for (var u = 0; u < r[s].length - 1; u++)a.push(y(s, u)); var l = new Wh; l.load(a) } for (var c = 0; c < r.length; c++)for (var h = 0; h < r[c].length - 1; h++) { if (n) l.search(y(c, h)).forEach((function (t) { var e = t.ring, n = t.edge; g(c, h, e, n) })); else for (var f = 0; f < r.length; f++)for (var p = 0; p < r[f].length - 1; p++)g(c, h, f, p) } return e || (i = { type: "Feature", geometry: { type: "MultiPoint", coordinates: i } }), i; function g(t, n, a, s) { var u, l, c = r[t][n], h = r[t][n + 1], f = r[a][s], p = r[a][s + 1], g = hk(c, h, f, p); if (null !== g && (u = h[0] !== c[0] ? (g[0] - c[0]) / (h[0] - c[0]) : (g[1] - c[1]) / (h[1] - c[1]), l = p[0] !== f[0] ? (g[0] - f[0]) / (p[0] - f[0]) : (g[1] - f[1]) / (p[1] - f[1]), !(u >= 1 || u <= 0 || l >= 1 || l <= 0))) { var y = g, v = !o[y]; v && (o[y] = !0), e ? i.push(e(g, t, n, c, h, u, a, s, f, p, l, v)) : i.push(g) } } function y(t, e) { var n, i, o, a, s = r[t][e], u = r[t][e + 1]; return s[0] < u[0] ? (n = s[0], i = u[0]) : (n = u[0], i = s[0]), s[1] < u[1] ? (o = s[1], a = u[1]) : (o = u[1], a = s[1]), { minX: n, minY: o, maxX: i, maxY: a, ring: t, edge: e } } } function hk(t, e, n, r) { if (fk(t, n) || fk(t, r) || fk(e, n) || fk(r, n)) return null; var i = t[0], o = t[1], a = e[0], s = e[1], u = n[0], l = n[1], c = r[0], h = r[1], f = (i - a) * (l - h) - (o - s) * (u - c); return 0 === f ? null : [((i * s - o * a) * (u - c) - (i - a) * (u * h - l * c)) / f, ((i * s - o * a) * (l - h) - (o - s) * (u * h - l * c)) / f] } function fk(t, e) { if (!t || !e) return !1; if (t.length !== e.length) return !1; for (var n = 0, r = t.length; n < r; n++)if (t[n] instanceof Array && e[n] instanceof Array) { if (!fk(t[n], e[n])) return !1 } else if (t[n] !== e[n]) return !1; return !0 } function pk(t) { if ("Feature" != t.type) throw new Error("The input must a geojson object of type Feature"); if (void 0 === t.geometry || null == t.geometry) throw new Error("The input must a geojson object with a non-empty geometry"); if ("Polygon" != t.geometry.type) throw new Error("The input must be a geojson Polygon"); for (var e = t.geometry.coordinates.length, n = [], r = 0; r < e; r++) { var i = t.geometry.coordinates[r]; mk(i[0], i[i.length - 1]) || i.push(i[0]); for (var o = 0; o < i.length - 1; o++)n.push(i[o]) } if (!bk(n)) throw new Error("The input polygon may not have duplicate vertices (except for the first and last vertex of each ring)"); var a = n.length, s = ck(t, lk((function (t, e, n, r, i, o, a, s, u, l, c, h) { return [t, e, n, r, i, o, a, s, u, l, c, h] }), "filterFn")), u = s.length; if (0 == u) { var l = []; for (r = 0; r < e; r++)l.push(Cu([t.geometry.coordinates[r]], { parent: -1, winding: dk(t.geometry.coordinates[r]) })); var c = ju(l); return D(), j(), c } var h = [], f = []; for (r = 0; r < e; r++) { h.push([]); for (o = 0; o < t.geometry.coordinates[r].length - 1; o++)h[r].push([new gk(t.geometry.coordinates[r][_k(o + 1, t.geometry.coordinates[r].length - 1)], 1, [r, o], [r, _k(o + 1, t.geometry.coordinates[r].length - 1)], void 0)]), f.push(new yk(t.geometry.coordinates[r][o], [r, _k(o - 1, t.geometry.coordinates[r].length - 1)], [r, o], void 0, void 0, !1, !0)) } for (r = 0; r < u; r++)h[s[r][1]][s[r][2]].push(new gk(s[r][0], s[r][5], [s[r][1], s[r][2]], [s[r][6], s[r][7]], void 0)), s[r][11] && f.push(new yk(s[r][0], [s[r][1], s[r][2]], [s[r][6], s[r][7]], void 0, void 0, !0, !0)); var p = f.length; for (r = 0; r < h.length; r++)for (o = 0; o < h[r].length; o++)h[r][o].sort((function (t, e) { return t.param < e.param ? -1 : 1 })); var g = []; for (r = 0; r < p; r++)g.push({ minX: f[r].coord[0], minY: f[r].coord[1], maxX: f[r].coord[0], maxY: f[r].coord[1], index: r }); var y = new Wh; y.load(g); for (r = 0; r < h.length; r++)for (o = 0; o < h[r].length; o++)for (var v = 0; v < h[r][o].length; v++) { m = v == h[r][o].length - 1 ? h[r][_k(o + 1, t.geometry.coordinates[r].length - 1)][0].coord : h[r][o][v + 1].coord; var d = y.search({ minX: m[0], minY: m[1], maxX: m[0], maxY: m[1] })[0]; h[r][o][v].nxtIsectAlongEdgeIn = d.index } for (r = 0; r < h.length; r++)for (o = 0; o < h[r].length; o++)for (v = 0; v < h[r][o].length; v++) { var m = h[r][o][v].coord, _ = (d = y.search({ minX: m[0], minY: m[1], maxX: m[0], maxY: m[1] })[0]).index; _ < a ? f[_].nxtIsectAlongRingAndEdge2 = h[r][o][v].nxtIsectAlongEdgeIn : mk(f[_].ringAndEdge1, h[r][o][v].ringAndEdgeIn) ? f[_].nxtIsectAlongRingAndEdge1 = h[r][o][v].nxtIsectAlongEdgeIn : f[_].nxtIsectAlongRingAndEdge2 = h[r][o][v].nxtIsectAlongEdgeIn } var b = []; for (r = 0, o = 0; o < e; o++) { var x = r; for (v = 0; v < t.geometry.coordinates[o].length - 1; v++)f[r].coord[0] < f[x].coord[0] && (x = r), r++; var E = f[x].nxtIsectAlongRingAndEdge2; for (v = 0; v < f.length; v++)if (f[v].nxtIsectAlongRingAndEdge1 == x || f[v].nxtIsectAlongRingAndEdge2 == x) { var w = v; break } var k = vk([f[w].coord, f[x].coord, f[E].coord], !0) ? 1 : -1; b.push({ isect: x, parent: -1, winding: k }) } b.sort((function (t, e) { return f[t.isect].coord > f[e.isect].coord ? -1 : 1 })); for (l = []; b.length > 0;) { var S = b.pop(), I = S.isect, P = S.parent, N = S.winding, M = l.length, O = [f[I].coord], L = I; if (f[I].ringAndEdge1Walkable) var R = f[I].ringAndEdge1, C = f[I].nxtIsectAlongRingAndEdge1; else R = f[I].ringAndEdge2, C = f[I].nxtIsectAlongRingAndEdge2; for (; !mk(f[I].coord, f[C].coord);) { O.push(f[C].coord); var T = void 0; for (r = 0; r < b.length; r++)if (b[r].isect == C) { T = r; break } if (null != T && b.splice(T, 1), mk(R, f[C].ringAndEdge1)) { if (R = f[C].ringAndEdge2, f[C].ringAndEdge2Walkable = !1, f[C].ringAndEdge1Walkable) { var A = { isect: C }; vk([f[L].coord, f[C].coord, f[f[C].nxtIsectAlongRingAndEdge2].coord], 1 == N) ? (A.parent = P, A.winding = -N) : (A.parent = M, A.winding = N), b.push(A) } L = C, C = f[C].nxtIsectAlongRingAndEdge2 } else { if (R = f[C].ringAndEdge1, f[C].ringAndEdge1Walkable = !1, f[C].ringAndEdge2Walkable) { A = { isect: C }; vk([f[L].coord, f[C].coord, f[f[C].nxtIsectAlongRingAndEdge1].coord], 1 == N) ? (A.parent = P, A.winding = -N) : (A.parent = M, A.winding = N), b.push(A) } L = C, C = f[C].nxtIsectAlongRingAndEdge1 } } O.push(f[C].coord), l.push(Cu([O], { index: M, parent: P, winding: N, netWinding: void 0 })) } c = ju(l); function D() { for (var t = [], e = 0; e < c.features.length; e++)-1 == c.features[e].properties.parent && t.push(e); if (t.length > 1) for (e = 0; e < t.length; e++) { for (var n = -1, r = 0; r < c.features.length; r++)t[e] != r && Nc(c.features[t[e]].geometry.coordinates[0][0], c.features[r], { ignoreBoundary: !0 }) && Jl(c.features[r]) < Infinity && (n = r); c.features[t[e]].properties.parent = n } } function j() { for (var t = 0; t < c.features.length; t++)if (-1 == c.features[t].properties.parent) { var e = c.features[t].properties.winding; c.features[t].properties.netWinding = e, F(t, e) } } function F(t, e) { for (var n = 0; n < c.features.length; n++)if (c.features[n].properties.parent == t) { var r = e + c.features[n].properties.winding; c.features[n].properties.netWinding = r, F(n, r) } } return D(), j(), lk(D, "determineParents"), lk(j, "setNetWinding"), lk(F, "setNetWindingOfChildren"), c } lk(ck, "geojsonPolygonSelfIntersections"), lk(hk, "intersect"), lk(fk, "equalArrays"), lk(pk, "simplepolygon"); var gk = lk((function (t, e, n, r, i) { this.coord = t, this.param = e, this.ringAndEdgeIn = n, this.ringAndEdgeOut = r, this.nxtIsectAlongEdgeIn = i }), "PseudoVtx"), yk = lk((function (t, e, n, r, i, o, a) { this.coord = t, this.ringAndEdge1 = e, this.ringAndEdge2 = n, this.nxtIsectAlongRingAndEdge1 = r, this.nxtIsectAlongRingAndEdge2 = i, this.ringAndEdge1Walkable = o, this.ringAndEdge2Walkable = a }), "Isect"); function vk(t, e) { if (void 0 === e && (e = !0), 3 != t.length) throw new Error("This function requires an array of three points [x,y]"); return (t[1][0] - t[0][0]) * (t[2][1] - t[0][1]) - (t[1][1] - t[0][1]) * (t[2][0] - t[0][0]) >= 0 == e } function dk(t) { for (var e = 0, n = 0; n < t.length - 1; n++)t[n][0] < t[e][0] && (e = n); if (vk([t[_k(e - 1, t.length - 1)], t[e], t[_k(e + 1, t.length - 1)]], !0)) var r = 1; else r = -1; return r } function mk(t, e) { if (!t || !e) return !1; if (t.length != e.length) return !1; for (var n = 0, r = t.length; n < r; n++)if (t[n] instanceof Array && e[n] instanceof Array) { if (!mk(t[n], e[n])) return !1 } else if (t[n] != e[n]) return !1; return !0 } function _k(t, e) { return (t % e + e) % e } function bk(t) { for (var e = {}, n = 1, r = 0, i = t.length; r < i; ++r) { if (Object.prototype.hasOwnProperty.call(e, t[r])) { n = 0; break } e[t[r]] = 1 } return n } function xk(t) { var e = []; return Bl(t, (function (t) { "Polygon" === t.geometry.type && Tl(pk(t), (function (n) { e.push(Cu(n.geometry.coordinates, t.properties)) })) })), ju(e) } function Ek(t) { return function () { return t } } function wk(t) { return t[0] } function kk(t) { return t[1] } function Sk() { this._ = null } function Ik(t) { t.U = t.C = t.L = t.R = t.P = t.N = null } function Pk(t, e) { var n = e, r = e.R, i = n.U; i ? i.L === n ? i.L = r : i.R = r : t._ = r, r.U = i, n.U = r, n.R = r.L, n.R && (n.R.U = n), r.L = n } function Nk(t, e) { var n = e, r = e.L, i = n.U; i ? i.L === n ? i.L = r : i.R = r : t._ = r, r.U = i, n.U = r, n.L = r.R, n.L && (n.L.U = n), r.R = n } function Mk(t) { for (; t.L;)t = t.L; return t } function Ok(t, e, n, r) { var i = [null, null], o = tS.push(i) - 1; return i.left = t, i.right = e, n && Rk(i, t, e, n), r && Rk(i, e, t, r), Qk[t.index].halfedges.push(o), Qk[e.index].halfedges.push(o), i } function Lk(t, e, n) { var r = [e, n]; return r.left = t, r } function Rk(t, e, n, r) { t[0] || t[1] ? t.left === n ? t[1] = r : t[0] = r : (t[0] = r, t.left = e, t.right = n) } function Ck(t, e, n, r, i) { var o, a = t[0], s = t[1], u = a[0], l = a[1], c = 0, h = 1, f = s[0] - u, p = s[1] - l; if (o = e - u, f || !(o > 0)) { if (o /= f, f < 0) { if (o < c) return; o < h && (h = o) } else if (f > 0) { if (o > h) return; o > c && (c = o) } if (o = r - u, f || !(o < 0)) { if (o /= f, f < 0) { if (o > h) return; o > c && (c = o) } else if (f > 0) { if (o < c) return; o < h && (h = o) } if (o = n - l, p || !(o > 0)) { if (o /= p, p < 0) { if (o < c) return; o < h && (h = o) } else if (p > 0) { if (o > h) return; o > c && (c = o) } if (o = i - l, p || !(o < 0)) { if (o /= p, p < 0) { if (o > h) return; o > c && (c = o) } else if (p > 0) { if (o < c) return; o < h && (h = o) } return !(c > 0 || h < 1) || (c > 0 && (t[0] = [u + c * f, l + c * p]), h < 1 && (t[1] = [u + h * f, l + h * p]), !0) } } } } } function Tk(t, e, n, r, i) { var o = t[1]; if (o) return !0; var a, s, u = t[0], l = t.left, c = t.right, h = l[0], f = l[1], p = c[0], g = c[1], y = (h + p) / 2, v = (f + g) / 2; if (g === f) { if (y < e || y >= r) return; if (h > p) { if (u) { if (u[1] >= i) return } else u = [y, n]; o = [y, i] } else { if (u) { if (u[1] < n) return } else u = [y, i]; o = [y, n] } } else if (s = v - (a = (h - p) / (g - f)) * y, a < -1 || a > 1) if (h > p) { if (u) { if (u[1] >= i) return } else u = [(n - s) / a, n]; o = [(i - s) / a, i] } else { if (u) { if (u[1] < n) return } else u = [(i - s) / a, i]; o = [(n - s) / a, n] } else if (f < g) { if (u) { if (u[0] >= r) return } else u = [e, a * e + s]; o = [r, a * r + s] } else { if (u) { if (u[0] < e) return } else u = [r, a * r + s]; o = [e, a * e + s] } return t[0] = u, t[1] = o, !0 } function Ak(t, e) { var n = t.site, r = e.left, i = e.right; return n === i && (i = r, r = n), i ? Math.atan2(i[1] - r[1], i[0] - r[0]) : (n === r ? (r = e[1], i = e[0]) : (r = e[0], i = e[1]), Math.atan2(r[0] - i[0], i[1] - r[1])) } function Dk(t, e) { return e[+(e.left !== t.site)] } function jk(t, e) { return e[+(e.left === t.site)] } lk(vk, "isConvex"), lk(dk, "windingOfRing"), lk(mk, "equalArrays"), lk(_k, "modulo"), lk(bk, "isUnique"), lk(xk, "unkinkPolygon"), Sk.prototype = { constructor: Sk, insert: function (t, e) { var n, r, i; if (t) { if (e.P = t, e.N = t.N, t.N && (t.N.P = e), t.N = e, t.R) { for (t = t.R; t.L;)t = t.L; t.L = e } else t.R = e; n = t } else this._ ? (t = Mk(this._), e.P = null, e.N = t, t.P = t.L = e, n = t) : (e.P = e.N = null, this._ = e, n = null); for (e.L = e.R = null, e.U = n, e.C = !0, t = e; n && n.C;)n === (r = n.U).L ? (i = r.R) && i.C ? (n.C = i.C = !1, r.C = !0, t = r) : (t === n.R && (Pk(this, n), n = (t = n).U), n.C = !1, r.C = !0, Nk(this, r)) : (i = r.L) && i.C ? (n.C = i.C = !1, r.C = !0, t = r) : (t === n.L && (Nk(this, n), n = (t = n).U), n.C = !1, r.C = !0, Pk(this, r)), n = t.U; this._.C = !1 }, remove: function (t) { t.N && (t.N.P = t.P), t.P && (t.P.N = t.N), t.N = t.P = null; var e, n, r, i = t.U, o = t.L, a = t.R; if (n = o ? a ? Mk(a) : o : a, i ? i.L === t ? i.L = n : i.R = n : this._ = n, o && a ? (r = n.C, n.C = t.C, n.L = o, o.U = n, n !== a ? (i = n.U, n.U = t.U, t = n.R, i.L = t, n.R = a, a.U = n) : (n.U = i, i = n, t = n.R)) : (r = t.C, t = n), t && (t.U = i), !r) if (t && t.C) t.C = !1; else { do { if (t === this._) break; if (t === i.L) { if ((e = i.R).C && (e.C = !1, i.C = !0, Pk(this, i), e = i.R), e.L && e.L.C || e.R && e.R.C) { e.R && e.R.C || (e.L.C = !1, e.C = !0, Nk(this, e), e = i.R), e.C = i.C, i.C = e.R.C = !1, Pk(this, i), t = this._; break } } else if ((e = i.L).C && (e.C = !1, i.C = !0, Nk(this, i), e = i.L), e.L && e.L.C || e.R && e.R.C) { e.L && e.L.C || (e.R.C = !1, e.C = !0, Pk(this, e), e = i.L), e.C = i.C, i.C = e.L.C = !1, Nk(this, i), t = this._; break } e.C = !0, t = i, i = i.U } while (!t.C); t && (t.C = !1) } } }; var Fk, Bk = []; function qk() { Ik(this), this.x = this.y = this.arc = this.site = this.cy = null } function Vk(t) { var e = t.P, n = t.N; if (e && n) { var r = e.site, i = t.site, o = n.site; if (r !== o) { var a = i[0], s = i[1], u = r[0] - a, l = r[1] - s, c = o[0] - a, h = o[1] - s, f = 2 * (u * h - l * c); if (!(f >= -nS)) { var p = u * u + l * l, g = c * c + h * h, y = (h * p - l * g) / f, v = (u * g - c * p) / f, d = Bk.pop() || new qk; d.arc = t, d.site = i, d.x = y + a, d.y = (d.cy = v + s) + Math.sqrt(y * y + v * v), t.circle = d; for (var m = null, _ = Kk._; _;)if (d.y < _.y || d.y === _.y && d.x <= _.x) { if (!_.L) { m = _.P; break } _ = _.L } else { if (!_.R) { m = _; break } _ = _.R } Kk.insert(m, d), m || (Fk = d) } } } } function Gk(t) { var e = t.circle; e && (e.P || (Fk = e.N), Kk.remove(e), Bk.push(e), Ik(e), t.circle = null) } var Yk = []; function zk() { Ik(this), this.edge = this.site = this.circle = null } function Uk(t) { var e = Yk.pop() || new zk; return e.site = t, e } function Xk(t) { Gk(t), $k.remove(t), Yk.push(t), Ik(t) } function Wk(t) { var e = t.circle, n = e.x, r = e.cy, i = [n, r], o = t.P, a = t.N, s = [t]; Xk(t); for (var u = o; u.circle && Math.abs(n - u.circle.x) < eS && Math.abs(r - u.circle.cy) < eS;)o = u.P, s.unshift(u), Xk(u), u = o; s.unshift(u), Gk(u); for (var l = a; l.circle && Math.abs(n - l.circle.x) < eS && Math.abs(r - l.circle.cy) < eS;)a = l.N, s.push(l), Xk(l), l = a; s.push(l), Gk(l); var c, h = s.length; for (c = 1; c < h; ++c)l = s[c], u = s[c - 1], Rk(l.edge, u.site, l.site, i); u = s[0], (l = s[h - 1]).edge = Ok(u.site, l.site, null, i), Vk(u), Vk(l) } function Hk(t) { for (var e, n, r, i, o = t[0], a = t[1], s = $k._; s;)if ((r = Zk(s, a) - o) > eS) s = s.L; else { if (!((i = o - Jk(s, a)) > eS)) { r > -eS ? (e = s.P, n = s) : i > -eS ? (e = s, n = s.N) : e = n = s; break } if (!s.R) { e = s; break } s = s.R } !function (t) { Qk[t.index] = { site: t, halfedges: [] } }(t); var u = Uk(t); if ($k.insert(e, u), e || n) { if (e === n) return Gk(e), n = Uk(e.site), $k.insert(u, n), u.edge = n.edge = Ok(e.site, u.site), Vk(e), void Vk(n); if (n) { Gk(e), Gk(n); var l = e.site, c = l[0], h = l[1], f = t[0] - c, p = t[1] - h, g = n.site, y = g[0] - c, v = g[1] - h, d = 2 * (f * v - p * y), m = f * f + p * p, _ = y * y + v * v, b = [(v * m - p * _) / d + c, (f * _ - y * m) / d + h]; Rk(n.edge, l, g, b), u.edge = Ok(l, t, null, b), n.edge = Ok(t, g, null, b), Vk(e), Vk(n) } else u.edge = Ok(e.site, u.site) } } function Zk(t, e) { var n = t.site, r = n[0], i = n[1], o = i - e; if (!o) return r; var a = t.P; if (!a) return -1 / 0; var s = (n = a.site)[0], u = n[1], l = u - e; if (!l) return s; var c = s - r, h = 1 / o - 1 / l, f = c / l; return h ? (-f + Math.sqrt(f * f - 2 * h * (c * c / (-2 * l) - u + l / 2 + i - o / 2))) / h + r : (r + s) / 2 } function Jk(t, e) { var n = t.N; if (n) return Zk(n, e); var r = t.site; return r[1] === e ? r[0] : 1 / 0 } var $k, Qk, Kk, tS, eS = 1e-6, nS = 1e-12; function rS(t, e) { return e[1] - t[1] || e[0] - t[0] } function iS(t, e) { var n, r, i, o = t.sort(rS).pop(); for (tS = [], Qk = new Array(t.length), $k = new Sk, Kk = new Sk; ;)if (i = Fk, o && (!i || o[1] < i.y || o[1] === i.y && o[0] < i.x)) o[0] === n && o[1] === r || (Hk(o), n = o[0], r = o[1]), o = t.pop(); else { if (!i) break; Wk(i.arc) } if (function () { for (var t, e, n, r, i = 0, o = Qk.length; i < o; ++i)if ((t = Qk[i]) && (r = (e = t.halfedges).length)) { var a = new Array(r), s = new Array(r); for (n = 0; n < r; ++n)a[n] = n, s[n] = Ak(t, tS[e[n]]); for (a.sort((function (t, e) { return s[e] - s[t] })), n = 0; n < r; ++n)s[n] = e[a[n]]; for (n = 0; n < r; ++n)e[n] = s[n] } }(), e) { var a = +e[0][0], s = +e[0][1], u = +e[1][0], l = +e[1][1]; !function (t, e, n, r) { for (var i, o = tS.length; o--;)Tk(i = tS[o], t, e, n, r) && Ck(i, t, e, n, r) && (Math.abs(i[0][0] - i[1][0]) > eS || Math.abs(i[0][1] - i[1][1]) > eS) || delete tS[o] }(a, s, u, l), function (t, e, n, r) { var i, o, a, s, u, l, c, h, f, p, g, y, v = Qk.length, d = !0; for (i = 0; i < v; ++i)if (o = Qk[i]) { for (a = o.site, s = (u = o.halfedges).length; s--;)tS[u[s]] || u.splice(s, 1); for (s = 0, l = u.length; s < l;)g = (p = jk(o, tS[u[s]]))[0], y = p[1], h = (c = Dk(o, tS[u[++s % l]]))[0], f = c[1], (Math.abs(g - h) > eS || Math.abs(y - f) > eS) && (u.splice(s, 0, tS.push(Lk(a, p, Math.abs(g - t) < eS && r - y > eS ? [t, Math.abs(h - t) < eS ? f : r] : Math.abs(y - r) < eS && n - g > eS ? [Math.abs(f - r) < eS ? h : n, r] : Math.abs(g - n) < eS && y - e > eS ? [n, Math.abs(h - n) < eS ? f : e] : Math.abs(y - e) < eS && g - t > eS ? [Math.abs(f - e) < eS ? h : t, e] : null)) - 1), ++l); l && (d = !1) } if (d) { var m, _, b, x = 1 / 0; for (i = 0, d = null; i < v; ++i)(o = Qk[i]) && (b = (m = (a = o.site)[0] - t) * m + (_ = a[1] - e) * _) < x && (x = b, d = o); if (d) { var E = [t, e], w = [t, r], k = [n, r], S = [n, e]; d.halfedges.push(tS.push(Lk(a = d.site, E, w)) - 1, tS.push(Lk(a, w, k)) - 1, tS.push(Lk(a, k, S)) - 1, tS.push(Lk(a, S, E)) - 1) } } for (i = 0; i < v; ++i)(o = Qk[i]) && (o.halfedges.length || delete Qk[i]) }(a, s, u, l) } this.edges = tS, this.cells = Qk, $k = Kk = tS = Qk = null } iS.prototype = { constructor: iS, polygons: function () { var t = this.edges; return this.cells.map((function (e) { var n = e.halfedges.map((function (n) { return Dk(e, t[n]) })); return n.data = e.site.data, n })) }, triangles: function () { var t = [], e = this.edges; return this.cells.forEach((function (n, r) { if (o = (i = n.halfedges).length) for (var i, o, a, s, u, l, c = n.site, h = -1, f = e[i[o - 1]], p = f.left === c ? f.right : f.left; ++h < o;)a = p, p = (f = e[i[h]]).left === c ? f.right : f.left, a && p && r < a.index && r < p.index && (u = a, l = p, ((s = c)[0] - l[0]) * (u[1] - s[1]) - (s[0] - u[0]) * (l[1] - s[1]) < 0) && t.push([c.data, a.data, p.data]) })), t }, links: function () { return this.edges.filter((function (t) { return t.right })).map((function (t) { return { source: t.left.data, target: t.right.data } })) }, find: function (t, e, n) { for (var r, i, o = this, a = o._found || 0, s = o.cells.length; !(i = o.cells[a]);)if (++a >= s) return null; var u = t - i.site[0], l = e - i.site[1], c = u * u + l * l; do { i = o.cells[r = a], a = null, i.halfedges.forEach((function (n) { var r = o.edges[n], s = r.left; if (s !== i.site && s || (s = r.right)) { var u = t - s[0], l = e - s[1], h = u * u + l * l; h < c && (c = h, a = s.index) } })) } while (null !== a); return o._found = r, null == n || c <= n * n ? i.site : null } }; var oS = Object.defineProperty, aS = function (t, e) { return oS(t, "name", { value: e, configurable: !0 }) }; function sS(t) { return (t = t.slice()).push(t[0]), Cu([t]) } function uS(t, e) { if (!Qu(e = e || {})) throw new Error("options is invalid"); var n = e.bbox || [-180, -85, 180, 85]; if (!t) throw new Error("points is required"); if (!Array.isArray(n)) throw new Error("bbox is invalid"); return ll(t, "Point", "points"), ju(function () { var t = wk, e = kk, n = null; function r(r) { return new iS(r.map((function (n, i) { var o = [Math.round(t(n, i, r) / eS) * eS, Math.round(e(n, i, r) / eS) * eS]; return o.index = i, o.data = n, o })), n) } return r.polygons = function (t) { return r(t).polygons() }, r.links = function (t) { return r(t).links() }, r.triangles = function (t) { return r(t).triangles() }, r.x = function (e) { return arguments.length ? (t = "function" == typeof e ? e : Ek(+e), r) : t }, r.y = function (t) { return arguments.length ? (e = "function" == typeof t ? t : Ek(+t), r) : e }, r.extent = function (t) { return arguments.length ? (n = null == t ? null : [[+t[0][0], +t[0][1]], [+t[1][0], +t[1][1]]], r) : n && [[n[0][0], n[0][1]], [n[1][0], n[1][1]]] }, r.size = function (t) { return arguments.length ? (n = null == t ? null : [[0, 0], [+t[0], +t[1]]], r) : n && [n[1][0] - n[0][0], n[1][1] - n[0][1]] }, r }().x((function (t) { return t.geometry.coordinates[0] })).y((function (t) { return t.geometry.coordinates[1] })).extent([[n[0], n[1]], [n[2], n[3]]]).polygons(t.features).map((function (e, n) { return Object.assign(sS(e), { properties: Ty(t.features[n].properties) }) }))) } aS(sS, "coordsToPolygon"), aS(uS, "voronoi"), t.GeojsonEquality = wu, t.along = xl, t.angle = Pl, t.applyFilter = zy, t.area = Jl, t.areaFactors = Nu, t.bbox = rc, t.bboxClip = cc, t.bboxPolygon = pc, t.bearing = yl, t.bearingToAzimuth = Xu, t.bezierSpline = bc, t.booleanClockwise = Ec, t.booleanConcave = kc, t.booleanContains = Dc, t.booleanCrosses = dh, t.booleanDisjoint = Sh, t.booleanEqual = qh, t.booleanIntersects = Gh, t.booleanOverlap = Lf, t.booleanParallel = Tf, t.booleanPointInPolygon = Nc, t.booleanPointOnLine = Rc, t.booleanTouches = Bf, t.booleanValid = zf, t.booleanWithin = Jf, t.buffer = Dg, t.center = up, t.centerMean = Yg, t.centerMedian = Hg, t.centerOfMass = Py, t.centroid = Ug, t.circle = My, t.cleanCoords = Ah, t.clone = Ry, t.cloneProperties = Ty, t.clusterEach = Vy, t.clusterReduce = Gy, t.clusters = Wy, t.clustersDbscan = $y, t.clustersKmeans = cv, t.collect = pv, t.collectionOf = ll, t.combine = yv, t.concave = td, t.containsNumber = al, t.convertArea = Ju, t.convertLength = Zu, t.convex = Sy, t.coordAll = Dl, t.coordEach = Ol, t.coordReduce = Ll, t.createBins = Yy, t.degreesToRadians = Hu, t.destination = dl, t.difference = Wd, t.dissolve = $d, t.distance = _l, t.distanceWeight = em, t.earthRadius = Iu, t.ellipse = gm, t.envelope = dm, t.explode = _m, t.factors = Pu, t.feature = Mu, t.featureCollection = ju, t.featureEach = Tl, t.featureOf = ul, t.featureReduce = Al, t.filterProperties = Xy, t.findPoint = Xl, t.findSegment = Ul, t.flatten = Zd, t.flattenEach = Bl, t.flattenReduce = ql, t.flip = xm, t.geojsonRbush = lf, t.geojsonType = sl, t.geomEach = jl, t.geomReduce = Fl, t.geometry = Ou, t.geometryCollection = Vu, t.getCluster = qy, t.getCoord = il, t.getCoords = ol, t.getGeom = cl, t.getType = hl, t.greatCircle = Om, t.helpers = el, t.hexGrid = Am, t.interpolate = Wm, t.intersect = Rm, t.invariant = fl, t.isNumber = $u, t.isObject = Qu, t.isobands = __, t.isolines = A_, t.kinks = q_, t.length = G_, t.lengthToDegrees = Uu, t.lengthToRadians = zu, t.lineArc = U_, t.lineChunk = $_, t.lineEach = Yl, t.lineIntersect = uh, t.lineOffset = lb, t.lineOverlap = Nf, t.lineReduce = zl, t.lineSegment = ff, t.lineSlice = pb, t.lineSliceAlong = H_, t.lineSplit = Eb, t.lineString = Au, t.lineStrings = Du, t.lineToPolygon = Mb, t.mask = Ab, t.meta = Wl, t.midpoint = qb, t.moranIndex = Yb, t.multiLineString = Fu, t.multiPoint = Bu, t.multiPolygon = qu, t.nearestNeighborAnalysis = rx, t.nearestPoint = ex, t.nearestPointOnLine = Sf, t.nearestPointToLine = dx, t.planepoint = bx, t.point = Lu, t.pointGrid = Bm, t.pointOnFeature = wx, t.pointToLineDistance = ax, t.points = Ru, t.pointsWithinPolygon = Px, t.polygon = Cu, t.polygonSmooth = Wx, t.polygonTangents = Qx, t.polygonToLine = hh, t.polygonize = zx, t.polygons = Tu, t.projection = hE, t.propEach = Rl, t.propReduce = Cl, t.propertiesContainsFilter = Uy, t.quadratAnalysis = gE, t.radiansToDegrees = Wu, t.radiansToLength = Yu, t.random = LE, t.randomLineString = SE, t.randomPoint = wE, t.randomPolygon = kE, t.randomPosition = bE, t.rectangleGrid = Vm, t.rewind = TE, t.rhumbBearing = kl, t.rhumbDestination = im, t.rhumbDistance = um, t.round = Gu, t.sample = qE, t.sector = zE, t.segmentEach = Vl, t.segmentReduce = Gl, t.shortestPath = ow, t.simplify = yw, t.square = yb, t.squareGrid = Ym, t.standardDeviationalEllipse = xw, t.tag = kw, t.tesselate = ek, t.tin = mv, t.toMercator = oE, t.toWgs84 = aE, t.transformRotate = hm, t.transformScale = HE, t.transformTranslate = ok, t.triangleGrid = Um, t.truncate = mb, t.union = sk, t.unkinkPolygon = xk, t.validateBBox = Ku, t.validateId = tl, t.voronoi = uS, Object.defineProperty(t, "__esModule", { value: !0 })
        }));
    </script>
    <script>
        /**
 * MapLibre GL JS
 * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.1.0/LICENSE.txt
 */
        (function (global, factory) {
            typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
                typeof define === 'function' && define.amd ? define(factory) :
                    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.maplibregl = factory());
        })(this, (function () {
            'use strict';

            /* eslint-disable */

            var maplibregl = {};
            var modules = {};
            function define(moduleName, _dependencies, moduleFactory) {
                modules[moduleName] = moduleFactory;

                // to get the list of modules see generated dist/maplibre-gl-dev.js file (look for `define(` calls)
                if (moduleName !== 'index') {
                    return;
                }

                // we assume that when an index module is initializing then other modules are loaded already
                var workerBundleString = 'var sharedModule = {}; (' + modules.shared + ')(sharedModule); (' + modules.worker + ')(sharedModule);'

                var sharedModule = {};
                // the order of arguments of a module factory depends on rollup (it decides who is whose dependency)
                // to check the correct order, see dist/maplibre-gl-dev.js file (look for `define(` calls)
                // we assume that for our 3 chunks it will generate 3 modules and their order is predefined like the following
                modules.shared(sharedModule);
                modules.index(maplibregl, sharedModule);

                if (typeof window !== 'undefined') {
                    maplibregl.setWorkerUrl(window.URL.createObjectURL(new Blob([workerBundleString], { type: 'text/javascript' })));
                }

                return maplibregl;
            };



            define("shared", ["exports"], (function (t) { "use strict"; function e(t, e, r, n) { return new (r || (r = Promise))((function (i, s) { function a(t) { try { l(n.next(t)); } catch (t) { s(t); } } function o(t) { try { l(n.throw(t)); } catch (t) { s(t); } } function l(t) { var e; t.done ? i(t.value) : (e = t.value, e instanceof r ? e : new r((function (t) { t(e); }))).then(a, o); } l((n = n.apply(t, e || [])).next()); })) } function r(t) { return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t } var n, i; function s() { if (i) return n; function t(t, e) { this.x = t, this.y = e; } return i = 1, n = t, t.prototype = { clone: function () { return new t(this.x, this.y) }, add: function (t) { return this.clone()._add(t) }, sub: function (t) { return this.clone()._sub(t) }, multByPoint: function (t) { return this.clone()._multByPoint(t) }, divByPoint: function (t) { return this.clone()._divByPoint(t) }, mult: function (t) { return this.clone()._mult(t) }, div: function (t) { return this.clone()._div(t) }, rotate: function (t) { return this.clone()._rotate(t) }, rotateAround: function (t, e) { return this.clone()._rotateAround(t, e) }, matMult: function (t) { return this.clone()._matMult(t) }, unit: function () { return this.clone()._unit() }, perp: function () { return this.clone()._perp() }, round: function () { return this.clone()._round() }, mag: function () { return Math.sqrt(this.x * this.x + this.y * this.y) }, equals: function (t) { return this.x === t.x && this.y === t.y }, dist: function (t) { return Math.sqrt(this.distSqr(t)) }, distSqr: function (t) { var e = t.x - this.x, r = t.y - this.y; return e * e + r * r }, angle: function () { return Math.atan2(this.y, this.x) }, angleTo: function (t) { return Math.atan2(this.y - t.y, this.x - t.x) }, angleWith: function (t) { return this.angleWithSep(t.x, t.y) }, angleWithSep: function (t, e) { return Math.atan2(this.x * e - this.y * t, this.x * t + this.y * e) }, _matMult: function (t) { var e = t[2] * this.x + t[3] * this.y; return this.x = t[0] * this.x + t[1] * this.y, this.y = e, this }, _add: function (t) { return this.x += t.x, this.y += t.y, this }, _sub: function (t) { return this.x -= t.x, this.y -= t.y, this }, _mult: function (t) { return this.x *= t, this.y *= t, this }, _div: function (t) { return this.x /= t, this.y /= t, this }, _multByPoint: function (t) { return this.x *= t.x, this.y *= t.y, this }, _divByPoint: function (t) { return this.x /= t.x, this.y /= t.y, this }, _unit: function () { return this._div(this.mag()), this }, _perp: function () { var t = this.y; return this.y = this.x, this.x = -t, this }, _rotate: function (t) { var e = Math.cos(t), r = Math.sin(t), n = r * this.x + e * this.y; return this.x = e * this.x - r * this.y, this.y = n, this }, _rotateAround: function (t, e) { var r = Math.cos(t), n = Math.sin(t), i = e.y + n * (this.x - e.x) + r * (this.y - e.y); return this.x = e.x + r * (this.x - e.x) - n * (this.y - e.y), this.y = i, this }, _round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this } }, t.convert = function (e) { return e instanceof t ? e : Array.isArray(e) ? new t(e[0], e[1]) : e }, n } "function" == typeof SuppressedError && SuppressedError; var a, o, l = r(s()), u = function () { if (o) return a; function t(t, e, r, n) { this.cx = 3 * t, this.bx = 3 * (r - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e, this.by = 3 * (n - e) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = e, this.p2x = r, this.p2y = n; } return o = 1, a = t, t.prototype = { sampleCurveX: function (t) { return ((this.ax * t + this.bx) * t + this.cx) * t }, sampleCurveY: function (t) { return ((this.ay * t + this.by) * t + this.cy) * t }, sampleCurveDerivativeX: function (t) { return (3 * this.ax * t + 2 * this.bx) * t + this.cx }, solveCurveX: function (t, e) { if (void 0 === e && (e = 1e-6), t < 0) return 0; if (t > 1) return 1; for (var r = t, n = 0; n < 8; n++) { var i = this.sampleCurveX(r) - t; if (Math.abs(i) < e) return r; var s = this.sampleCurveDerivativeX(r); if (Math.abs(s) < 1e-6) break; r -= i / s; } var a = 0, o = 1; for (r = t, n = 0; n < 20 && (i = this.sampleCurveX(r), !(Math.abs(i - t) < e)); n++)t > i ? a = r : o = r, r = .5 * (o - a) + a; return r }, solve: function (t, e) { return this.sampleCurveY(this.solveCurveX(t, e)) } }, a }(), c = r(u); let h, p; function f() { return null == h && (h = "undefined" != typeof OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof createImageBitmap), h } function d() { if (null == p && (p = !1, f())) { const t = 5, e = new OffscreenCanvas(t, t).getContext("2d", { willReadFrequently: !0 }); if (e) { for (let r = 0; r < t * t; r++) { const n = 4 * r; e.fillStyle = `rgb(${n},${n + 1},${n + 2})`, e.fillRect(r % t, Math.floor(r / t), 1, 1); } const r = e.getImageData(0, 0, t, t).data; for (let e = 0; e < t * t * 4; e++)if (e % 4 != 3 && r[e] !== e) { p = !0; break } } } return p || !1 } var y, m = 1e-6, g = "undefined" != typeof Float32Array ? Float32Array : Array; function x() { var t = new g(9); return g != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[0] = 1, t[4] = 1, t[8] = 1, t } function v(t) { return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t } function b() { var t = new g(3); return g != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t } function w(t, e, r) { var n = new g(3); return n[0] = t, n[1] = e, n[2] = r, n } function _(t, e, r) { var n = e[0], i = e[1], s = e[2], a = e[3]; return t[0] = r[0] * n + r[4] * i + r[8] * s + r[12] * a, t[1] = r[1] * n + r[5] * i + r[9] * s + r[13] * a, t[2] = r[2] * n + r[6] * i + r[10] * s + r[14] * a, t[3] = r[3] * n + r[7] * i + r[11] * s + r[15] * a, t } function S() { var t = new g(4); return g != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t[3] = 1, t } function A() { var t = new g(2); return g != Float32Array && (t[0] = 0, t[1] = 0), t } function k(t, e) { var r = new g(2); return r[0] = t, r[1] = e, r } Math.hypot || (Math.hypot = function () { for (var t = 0, e = arguments.length; e--;)t += arguments[e] * arguments[e]; return Math.sqrt(t) }), b(), y = new g(4), g != Float32Array && (y[0] = 0, y[1] = 0, y[2] = 0, y[3] = 0), b(), w(1, 0, 0), w(0, 1, 0), S(), S(), x(), A(); const M = 8192; function I(t, e, r) { return e * (M / (t.tileSize * Math.pow(2, r - t.tileID.overscaledZ))) } function z(t, e) { return (t % e + e) % e } function P(t, e, r) { return t * (1 - r) + e * r } function C(t) { if (t <= 0) return 0; if (t >= 1) return 1; const e = t * t, r = e * t; return 4 * (t < .5 ? r : 3 * (t - e) + r - .75) } function B(t, e, r, n) { const i = new c(t, e, r, n); return t => i.solve(t) } const V = B(.25, .1, .25, 1); function E(t, e, r) { return Math.min(r, Math.max(e, t)) } function T(t, e, r) { const n = r - e, i = ((t - e) % n + n) % n + e; return i === e ? r : i } function F(t, ...e) { for (const r of e) for (const e in r) t[e] = r[e]; return t } let $ = 1; function L(t, e, r) { const n = {}; for (const r in t) n[r] = e.call(this, t[r], r, t); return n } function O(t, e, r) { const n = {}; for (const r in t) e.call(this, t[r], r, t) && (n[r] = t[r]); return n } function D(t) { return Array.isArray(t) ? t.map(D) : "object" == typeof t && t ? L(t, D) : t } const R = {}; function j(t) { R[t] || ("undefined" != typeof console && console.warn(t), R[t] = !0); } function N(t, e, r) { return (r.y - t.y) * (e.x - t.x) > (e.y - t.y) * (r.x - t.x) } function U(t) { return "undefined" != typeof WorkerGlobalScope && void 0 !== t && t instanceof WorkerGlobalScope } let q = null; function G(t) { return "undefined" != typeof ImageBitmap && t instanceof ImageBitmap } const Z = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII="; function X(t, r, n, i, s) { return e(this, void 0, void 0, (function* () { if ("undefined" == typeof VideoFrame) throw new Error("VideoFrame not supported"); const e = new VideoFrame(t, { timestamp: 0 }); try { const a = null == e ? void 0 : e.format; if (!a || !a.startsWith("BGR") && !a.startsWith("RGB")) throw new Error(`Unrecognized format ${a}`); const o = a.startsWith("BGR"), l = new Uint8ClampedArray(i * s * 4); if (yield e.copyTo(l, function (t, e, r, n, i) { const s = 4 * Math.max(1, 0), a = (Math.max(0, r) - r) * n * 4 + s, o = 4 * n, l = Math.max(0, e), u = Math.max(0, r); return { rect: { x: l, y: u, width: Math.min(t.width, e + n) - l, height: Math.min(t.height, r + i) - u }, layout: [{ offset: a, stride: o }] } }(t, r, n, i, s)), o) for (let t = 0; t < l.length; t += 4) { const e = l[t]; l[t] = l[t + 2], l[t + 2] = e; } return l } finally { e.close(); } })) } let K, H; function Y(t) { return t / Math.PI * 180 } const J = "AbortError"; function W() { return new Error(J) } const Q = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" }; function tt(t) { return Q.REGISTERED_PROTOCOLS[t.substring(0, t.indexOf("://"))] } const et = "global-dispatcher"; class rt extends Error { constructor(t, e, r, n) { super(`AJAXError: ${e} (${t}): ${r}`), this.status = t, this.statusText = e, this.url = r, this.body = n; } } const nt = () => U(self) ? self.worker && self.worker.referrer : ("blob:" === window.location.protocol ? window.parent : window).location.href, it = function (t, r) { if (/:\/\//.test(t.url) && !/^https?:|^file:/.test(t.url)) { const e = tt(t.url); if (e) return e(t, r); if (U(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: t, targetMapId: et }, r) } if (!(/^file:/.test(n = t.url) || /^file:/.test(nt()) && !/^\w+:/.test(n))) { if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return function (t, r) { return e(this, void 0, void 0, (function* () { const e = new Request(t.url, { method: t.method || "GET", body: t.body, credentials: t.credentials, headers: t.headers, cache: t.cache, referrer: nt(), signal: r.signal }); let n, i; "json" !== t.type || e.headers.has("Accept") || e.headers.set("Accept", "application/json"); try { n = yield fetch(e); } catch (e) { throw new rt(0, e.message, t.url, new Blob) } if (!n.ok) { const e = yield n.blob(); throw new rt(n.status, n.statusText, t.url, e) } i = "arrayBuffer" === t.type || "image" === t.type ? n.arrayBuffer() : "json" === t.type ? n.json() : n.text(); const s = yield i; if (r.signal.aborted) throw W(); return { data: s, cacheControl: n.headers.get("Cache-Control"), expires: n.headers.get("Expires") } })) }(t, r); if (U(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: t, mustQueue: !0, targetMapId: et }, r) } var n; return function (t, e) { return new Promise(((r, n) => { var i; const s = new XMLHttpRequest; s.open(t.method || "GET", t.url, !0), "arrayBuffer" !== t.type && "image" !== t.type || (s.responseType = "arraybuffer"); for (const e in t.headers) s.setRequestHeader(e, t.headers[e]); "json" === t.type && (s.responseType = "text", (null === (i = t.headers) || void 0 === i ? void 0 : i.Accept) || s.setRequestHeader("Accept", "application/json")), s.withCredentials = "include" === t.credentials, s.onerror = () => { n(new Error(s.statusText)); }, s.onload = () => { if (!e.signal.aborted) if ((s.status >= 200 && s.status < 300 || 0 === s.status) && null !== s.response) { let e = s.response; if ("json" === t.type) try { e = JSON.parse(s.response); } catch (t) { return void n(t) } r({ data: e, cacheControl: s.getResponseHeader("Cache-Control"), expires: s.getResponseHeader("Expires") }); } else { const e = new Blob([s.response], { type: s.getResponseHeader("Content-Type") }); n(new rt(s.status, s.statusText, t.url, e)); } }, e.signal.addEventListener("abort", (() => { s.abort(), n(W()); })), s.send(t.body); })) }(t, r) }; function st(t) { if (!t || t.indexOf("://") <= 0 || 0 === t.indexOf("data:image/") || 0 === t.indexOf("blob:")) return !0; const e = new URL(t), r = window.location; return e.protocol === r.protocol && e.host === r.host } function at(t, e, r) { r[t] && -1 !== r[t].indexOf(e) || (r[t] = r[t] || [], r[t].push(e)); } function ot(t, e, r) { if (r && r[t]) { const n = r[t].indexOf(e); -1 !== n && r[t].splice(n, 1); } } class lt { constructor(t, e = {}) { F(this, e), this.type = t; } } class ut extends lt { constructor(t, e = {}) { super("error", F({ error: t }, e)); } } class ct { on(t, e) { return this._listeners = this._listeners || {}, at(t, e, this._listeners), { unsubscribe: () => { this.off(t, e); } } } off(t, e) { return ot(t, e, this._listeners), ot(t, e, this._oneTimeListeners), this } once(t, e) { return e ? (this._oneTimeListeners = this._oneTimeListeners || {}, at(t, e, this._oneTimeListeners), this) : new Promise((e => this.once(t, e))) } fire(t, e) { "string" == typeof t && (t = new lt(t, e || {})); const r = t.type; if (this.listens(r)) { t.target = this; const e = this._listeners && this._listeners[r] ? this._listeners[r].slice() : []; for (const r of e) r.call(this, t); const n = this._oneTimeListeners && this._oneTimeListeners[r] ? this._oneTimeListeners[r].slice() : []; for (const e of n) ot(r, e, this._oneTimeListeners), e.call(this, t); const i = this._eventedParent; i && (F(t, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i.fire(t)); } else t instanceof ut && console.error(t.error); return this } listens(t) { return this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t) } setEventedParent(t, e) { return this._eventedParent = t, this._eventedParentData = e, this } } var ht = { $version: 8, $root: { version: { required: !0, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, centerAltitude: { type: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, roll: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: !0, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: !0, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: !0, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster: { type: { required: !0, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster_dem: { type: { required: !0, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_geojson: { type: { required: !0, type: "enum", values: { geojson: {} } }, data: { required: !0, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: .375 }, cluster: { type: "boolean", default: !1 }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: !1 }, generateId: { type: "boolean", default: !1 }, promoteId: { type: "promoteId" } }, source_video: { type: { required: !0, type: "enum", values: { video: {} } }, urls: { required: !0, type: "array", value: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: !0, type: "enum", values: { image: {} } }, url: { required: !0, type: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: !0 }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: !0 }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: !1, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: !1, requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: !1, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: !0, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: !0, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: !1, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: !1, requires: ["text-field", "icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: !1 } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: !1, expression: { interpolated: !1, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, intensity: { type: "number", "property-type": "data-constant", default: .5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: .5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: .8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: .8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: .8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, terrain: { source: { type: "string", required: !0 }, exaggeration: { type: "number", minimum: 0, default: 1 } }, projection: { type: { type: "projectionDefinition", default: "mercator", "property-type": "data-constant", transition: !1, expression: { interpolated: !0, parameters: ["zoom"] } } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: !0, requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, requires: ["fill-extrusion-height"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: !0, transition: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "line-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: !0, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: !1, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: !0 } }], expression: { interpolated: !0, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: !1, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", .1, "royalblue", .3, "cyan", .5, "lime", .7, "yellow", 1, "red"], transition: !1, expression: { interpolated: !0, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: !0, overridable: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: !0, units: "degrees", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: !1, units: "milliseconds", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: .5, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "background-pattern" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } }; const pt = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"]; function ft(t, e) { const r = {}; for (const e in t) "ref" !== e && (r[e] = t[e]); return pt.forEach((t => { t in e && (r[t] = e[t]); })), r } function dt(t, e) { if (Array.isArray(t)) { if (!Array.isArray(e) || t.length !== e.length) return !1; for (let r = 0; r < t.length; r++)if (!dt(t[r], e[r])) return !1; return !0 } if ("object" == typeof t && null !== t && null !== e) { if ("object" != typeof e) return !1; if (Object.keys(t).length !== Object.keys(e).length) return !1; for (const r in t) if (!dt(t[r], e[r])) return !1; return !0 } return t === e } function yt(t, e) { t.push(e); } function mt(t, e, r) { yt(r, { command: "addSource", args: [t, e[t]] }); } function gt(t, e, r) { yt(e, { command: "removeSource", args: [t] }), r[t] = !0; } function xt(t, e, r, n) { gt(t, r, n), mt(t, e, r); } function vt(t, e, r) { let n; for (n in t[r]) if (Object.prototype.hasOwnProperty.call(t[r], n) && "data" !== n && !dt(t[r][n], e[r][n])) return !1; for (n in e[r]) if (Object.prototype.hasOwnProperty.call(e[r], n) && "data" !== n && !dt(t[r][n], e[r][n])) return !1; return !0 } function bt(t, e, r, n, i, s) { t = t || {}, e = e || {}; for (const a in t) Object.prototype.hasOwnProperty.call(t, a) && (dt(t[a], e[a]) || r.push({ command: s, args: [n, a, e[a], i] })); for (const a in e) Object.prototype.hasOwnProperty.call(e, a) && !Object.prototype.hasOwnProperty.call(t, a) && (dt(t[a], e[a]) || r.push({ command: s, args: [n, a, e[a], i] })); } function wt(t) { return t.id } function _t(t, e) { return t[e.id] = e, t } class St { constructor(t, e, r, n) { this.message = (t ? `${t}: ` : "") + r, n && (this.identifier = n), null != e && e.__line__ && (this.line = e.__line__); } } function At(t, ...e) { for (const r of e) for (const e in r) t[e] = r[e]; return t } class kt extends Error { constructor(t, e) { super(e), this.message = e, this.key = t; } } class Mt { constructor(t, e = []) { this.parent = t, this.bindings = {}; for (const [t, r] of e) this.bindings[t] = r; } concat(t) { return new Mt(this, t) } get(t) { if (this.bindings[t]) return this.bindings[t]; if (this.parent) return this.parent.get(t); throw new Error(`${t} not found in scope.`) } has(t) { return !!this.bindings[t] || !!this.parent && this.parent.has(t) } } const It = { kind: "null" }, zt = { kind: "number" }, Pt = { kind: "string" }, Ct = { kind: "boolean" }, Bt = { kind: "color" }, Vt = { kind: "projectionDefinition" }, Et = { kind: "object" }, Tt = { kind: "value" }, Ft = { kind: "collator" }, $t = { kind: "formatted" }, Lt = { kind: "padding" }, Ot = { kind: "resolvedImage" }, Dt = { kind: "variableAnchorOffsetCollection" }; function Rt(t, e) { return { kind: "array", itemType: t, N: e } } function jt(t) { if ("array" === t.kind) { const e = jt(t.itemType); return "number" == typeof t.N ? `array<${e}, ${t.N}>` : "value" === t.itemType.kind ? "array" : `array<${e}>` } return t.kind } const Nt = [It, zt, Pt, Ct, Bt, Vt, $t, Et, Rt(Tt), Lt, Ot, Dt]; function Ut(t, e) { if ("error" === e.kind) return null; if ("array" === t.kind) { if ("array" === e.kind && (0 === e.N && "value" === e.itemType.kind || !Ut(t.itemType, e.itemType)) && ("number" != typeof t.N || t.N === e.N)) return null } else { if (t.kind === e.kind) return null; if ("value" === t.kind) for (const t of Nt) if (!Ut(t, e)) return null } return `Expected ${jt(t)} but found ${jt(e)} instead.` } function qt(t, e) { return e.some((e => e.kind === t.kind)) } function Gt(t, e) { return e.some((e => "null" === e ? null === t : "array" === e ? Array.isArray(t) : "object" === e ? t && !Array.isArray(t) && "object" == typeof t : e === typeof t)) } function Zt(t, e) { return "array" === t.kind && "array" === e.kind ? t.itemType.kind === e.itemType.kind && "number" == typeof t.N : t.kind === e.kind } const Xt = .96422, Kt = .82521, Ht = 4 / 29, Yt = 6 / 29, Jt = 3 * Yt * Yt, Wt = Yt * Yt * Yt, Qt = Math.PI / 180, te = 180 / Math.PI; function ee(t) { return (t %= 360) < 0 && (t += 360), t } function re([t, e, r, n]) { let i, s; const a = ie((.2225045 * (t = ne(t)) + .7168786 * (e = ne(e)) + .0606169 * (r = ne(r))) / 1); t === e && e === r ? i = s = a : (i = ie((.4360747 * t + .3850649 * e + .1430804 * r) / Xt), s = ie((.0139322 * t + .0971045 * e + .7141733 * r) / Kt)); const o = 116 * a - 16; return [o < 0 ? 0 : o, 500 * (i - a), 200 * (a - s), n] } function ne(t) { return t <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4) } function ie(t) { return t > Wt ? Math.pow(t, 1 / 3) : t / Jt + Ht } function se([t, e, r, n]) { let i = (t + 16) / 116, s = isNaN(e) ? i : i + e / 500, a = isNaN(r) ? i : i - r / 200; return i = 1 * oe(i), s = Xt * oe(s), a = Kt * oe(a), [ae(3.1338561 * s - 1.6168667 * i - .4906146 * a), ae(-.9787684 * s + 1.9161415 * i + .033454 * a), ae(.0719453 * s - .2289914 * i + 1.4052427 * a), n] } function ae(t) { return (t = t <= .00304 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055) < 0 ? 0 : t > 1 ? 1 : t } function oe(t) { return t > Yt ? t * t * t : Jt * (t - Ht) } function le(t) { return parseInt(t.padEnd(2, t), 16) / 255 } function ue(t, e) { return ce(e ? t / 100 : t, 0, 1) } function ce(t, e, r) { return Math.min(Math.max(e, t), r) } function he(t) { return !t.some(Number.isNaN) } const pe = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] }; function fe(t, e, r) { return t + r * (e - t) } function de(t, e, r) { return t.map(((t, n) => fe(t, e[n], r))) } class ye { constructor(t, e, r, n = 1, i = !0) { this.r = t, this.g = e, this.b = r, this.a = n, i || (this.r *= n, this.g *= n, this.b *= n, n || this.overwriteGetter("rgb", [t, e, r, n])); } static parse(t) { if (t instanceof ye) return t; if ("string" != typeof t) return; const e = function (t) { if ("transparent" === (t = t.toLowerCase().trim())) return [0, 0, 0, 0]; const e = pe[t]; if (e) { const [t, r, n] = e; return [t / 255, r / 255, n / 255, 1] } if (t.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(t)) { const e = t.length < 6 ? 1 : 2; let r = 1; return [le(t.slice(r, r += e)), le(t.slice(r, r += e)), le(t.slice(r, r += e)), le(t.slice(r, r + e) || "ff")] } if (t.startsWith("rgb")) { const e = t.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/); if (e) { const [t, r, n, i, s, a, o, l, u, c, h, p] = e, f = [i || " ", o || " ", c].join(""); if ("  " === f || "  /" === f || ",," === f || ",,," === f) { const t = [n, a, u].join(""), e = "%%%" === t ? 100 : "" === t ? 255 : 0; if (e) { const t = [ce(+r / e, 0, 1), ce(+s / e, 0, 1), ce(+l / e, 0, 1), h ? ue(+h, p) : 1]; if (he(t)) return t } } return } } const r = t.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/); if (r) { const [t, e, n, i, s, a, o, l, u] = r, c = [n || " ", s || " ", o].join(""); if ("  " === c || "  /" === c || ",," === c || ",,," === c) { const t = [+e, ce(+i, 0, 100), ce(+a, 0, 100), l ? ue(+l, u) : 1]; if (he(t)) return function ([t, e, r, n]) { function i(n) { const i = (n + t / 30) % 12, s = e * Math.min(r, 1 - r); return r - s * Math.max(-1, Math.min(i - 3, 9 - i, 1)) } return t = ee(t), e /= 100, r /= 100, [i(0), i(8), i(4), n] }(t) } } }(t); return e ? new ye(...e, !1) : void 0 } get rgb() { const { r: t, g: e, b: r, a: n } = this, i = n || 1 / 0; return this.overwriteGetter("rgb", [t / i, e / i, r / i, n]) } get hcl() { return this.overwriteGetter("hcl", function (t) { const [e, r, n, i] = re(t), s = Math.sqrt(r * r + n * n); return [Math.round(1e4 * s) ? ee(Math.atan2(n, r) * te) : NaN, s, e, i] }(this.rgb)) } get lab() { return this.overwriteGetter("lab", re(this.rgb)) } overwriteGetter(t, e) { return Object.defineProperty(this, t, { value: e }), e } toString() { const [t, e, r, n] = this.rgb; return `rgba(${[t, e, r].map((t => Math.round(255 * t))).join(",")},${n})` } static interpolate(t, e, r, n = "rgb") { switch (n) { case "rgb": { const [n, i, s, a] = de(t.rgb, e.rgb, r); return new ye(n, i, s, a, !1) } case "hcl": { const [n, i, s, a] = t.hcl, [o, l, u, c] = e.hcl; let h, p; if (isNaN(n) || isNaN(o)) isNaN(n) ? isNaN(o) ? h = NaN : (h = o, 1 !== s && 0 !== s || (p = l)) : (h = n, 1 !== u && 0 !== u || (p = i)); else { let t = o - n; o > n && t > 180 ? t -= 360 : o < n && n - o > 180 && (t += 360), h = n + r * t; } const [f, d, y, m] = function ([t, e, r, n]) { return t = isNaN(t) ? 0 : t * Qt, se([r, Math.cos(t) * e, Math.sin(t) * e, n]) }([h, null != p ? p : fe(i, l, r), fe(s, u, r), fe(a, c, r)]); return new ye(f, d, y, m, !1) } case "lab": { const [n, i, s, a] = se(de(t.lab, e.lab, r)); return new ye(n, i, s, a, !1) } } } } ye.black = new ye(0, 0, 0, 1), ye.white = new ye(1, 1, 1, 1), ye.transparent = new ye(0, 0, 0, 0), ye.red = new ye(1, 0, 0, 1); class me { constructor(t, e, r) { this.sensitivity = t ? e ? "variant" : "case" : e ? "accent" : "base", this.locale = r, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" }); } compare(t, e) { return this.collator.compare(t, e) } resolvedLocale() { return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale } } const ge = ["bottom", "center", "top"]; class xe { constructor(t, e, r, n, i, s) { this.text = t, this.image = e, this.scale = r, this.fontStack = n, this.textColor = i, this.verticalAlign = s; } } class ve { constructor(t) { this.sections = t; } static fromString(t) { return new ve([new xe(t, null, null, null, null, null)]) } isEmpty() { return 0 === this.sections.length || !this.sections.some((t => 0 !== t.text.length || t.image && 0 !== t.image.name.length)) } static factory(t) { return t instanceof ve ? t : ve.fromString(t) } toString() { return 0 === this.sections.length ? "" : this.sections.map((t => t.text)).join("") } } class be { constructor(t) { this.values = t.slice(); } static parse(t) { if (t instanceof be) return t; if ("number" == typeof t) return new be([t, t, t, t]); if (Array.isArray(t) && !(t.length < 1 || t.length > 4)) { for (const e of t) if ("number" != typeof e) return; switch (t.length) { case 1: t = [t[0], t[0], t[0], t[0]]; break; case 2: t = [t[0], t[1], t[0], t[1]]; break; case 3: t = [t[0], t[1], t[2], t[1]]; }return new be(t) } } toString() { return JSON.stringify(this.values) } static interpolate(t, e, r) { return new be(de(t.values, e.values, r)) } } class we { constructor(t) { this.name = "ExpressionEvaluationError", this.message = t; } toJSON() { return this.message } } const _e = new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]); class Se { constructor(t) { this.values = t.slice(); } static parse(t) { if (t instanceof Se) return t; if (Array.isArray(t) && !(t.length < 1) && t.length % 2 == 0) { for (let e = 0; e < t.length; e += 2) { const r = t[e], n = t[e + 1]; if ("string" != typeof r || !_e.has(r)) return; if (!Array.isArray(n) || 2 !== n.length || "number" != typeof n[0] || "number" != typeof n[1]) return } return new Se(t) } } toString() { return JSON.stringify(this.values) } static interpolate(t, e, r) { const n = t.values, i = e.values; if (n.length !== i.length) throw new we(`Cannot interpolate values of different length. from: ${t.toString()}, to: ${e.toString()}`); const s = []; for (let t = 0; t < n.length; t += 2) { if (n[t] !== i[t]) throw new we(`Cannot interpolate values containing mismatched anchors. from[${t}]: ${n[t]}, to[${t}]: ${i[t]}`); s.push(n[t]); const [e, a] = n[t + 1], [o, l] = i[t + 1]; s.push([fe(e, o, r), fe(a, l, r)]); } return new Se(s) } } class Ae { constructor(t) { this.name = t.name, this.available = t.available; } toString() { return this.name } static fromString(t) { return t ? new Ae({ name: t, available: !1 }) : null } } class ke { constructor(t, e, r) { this.from = t, this.to = e, this.transition = r; } static interpolate(t, e, r) { return new ke(t, e, r) } static parse(t) { return t instanceof ke ? t : Array.isArray(t) && 3 === t.length && "string" == typeof t[0] && "string" == typeof t[1] && "number" == typeof t[2] ? new ke(t[0], t[1], t[2]) : "object" == typeof t && "string" == typeof t.from && "string" == typeof t.to && "number" == typeof t.transition ? new ke(t.from, t.to, t.transition) : "string" == typeof t ? new ke(t, t, 1) : void 0 } } function Me(t, e, r, n) { return "number" == typeof t && t >= 0 && t <= 255 && "number" == typeof e && e >= 0 && e <= 255 && "number" == typeof r && r >= 0 && r <= 255 ? void 0 === n || "number" == typeof n && n >= 0 && n <= 1 ? null : `Invalid rgba value [${[t, e, r, n].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n ? [t, e, r, n] : [t, e, r]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.` } function Ie(t) { if (null === t || "string" == typeof t || "boolean" == typeof t || "number" == typeof t || t instanceof ke || t instanceof ye || t instanceof me || t instanceof ve || t instanceof be || t instanceof Se || t instanceof Ae) return !0; if (Array.isArray(t)) { for (const e of t) if (!Ie(e)) return !1; return !0 } if ("object" == typeof t) { for (const e in t) if (!Ie(t[e])) return !1; return !0 } return !1 } function ze(t) { if (null === t) return It; if ("string" == typeof t) return Pt; if ("boolean" == typeof t) return Ct; if ("number" == typeof t) return zt; if (t instanceof ye) return Bt; if (t instanceof ke) return Vt; if (t instanceof me) return Ft; if (t instanceof ve) return $t; if (t instanceof be) return Lt; if (t instanceof Se) return Dt; if (t instanceof Ae) return Ot; if (Array.isArray(t)) { const e = t.length; let r; for (const e of t) { const t = ze(e); if (r) { if (r === t) continue; r = Tt; break } r = t; } return Rt(r || Tt, e) } return Et } function Pe(t) { const e = typeof t; return null === t ? "" : "string" === e || "number" === e || "boolean" === e ? String(t) : t instanceof ye || t instanceof ke || t instanceof ve || t instanceof be || t instanceof Se || t instanceof Ae ? t.toString() : JSON.stringify(t) } class Ce { constructor(t, e) { this.type = t, this.value = e; } static parse(t, e) { if (2 !== t.length) return e.error(`'literal' expression requires exactly one argument, but found ${t.length - 1} instead.`); if (!Ie(t[1])) return e.error("invalid value"); const r = t[1]; let n = ze(r); const i = e.expectedType; return "array" !== n.kind || 0 !== n.N || !i || "array" !== i.kind || "number" == typeof i.N && 0 !== i.N || (n = i), new Ce(n, r) } evaluate() { return this.value } eachChild() { } outputDefined() { return !0 } } const Be = { string: Pt, number: zt, boolean: Ct, object: Et }; class Ve { constructor(t, e) { this.type = t, this.args = e; } static parse(t, e) { if (t.length < 2) return e.error("Expected at least one argument."); let r, n = 1; const i = t[0]; if ("array" === i) { let i, s; if (t.length > 2) { const r = t[1]; if ("string" != typeof r || !(r in Be) || "object" === r) return e.error('The item type argument of "array" must be one of string, number, boolean', 1); i = Be[r], n++; } else i = Tt; if (t.length > 3) { if (null !== t[2] && ("number" != typeof t[2] || t[2] < 0 || t[2] !== Math.floor(t[2]))) return e.error('The length argument to "array" must be a positive integer literal', 2); s = t[2], n++; } r = Rt(i, s); } else { if (!Be[i]) throw new Error(`Types doesn't contain name = ${i}`); r = Be[i]; } const s = []; for (; n < t.length; n++) { const r = e.parse(t[n], n, Tt); if (!r) return null; s.push(r); } return new Ve(r, s) } evaluate(t) { for (let e = 0; e < this.args.length; e++) { const r = this.args[e].evaluate(t); if (!Ut(this.type, ze(r))) return r; if (e === this.args.length - 1) throw new we(`Expected value to be of type ${jt(this.type)}, but found ${jt(ze(r))} instead.`) } throw new Error } eachChild(t) { this.args.forEach(t); } outputDefined() { return this.args.every((t => t.outputDefined())) } } const Ee = { "to-boolean": Ct, "to-color": Bt, "to-number": zt, "to-string": Pt }; class Te { constructor(t, e) { this.type = t, this.args = e; } static parse(t, e) { if (t.length < 2) return e.error("Expected at least one argument."); const r = t[0]; if (!Ee[r]) throw new Error(`Can't parse ${r} as it is not part of the known types`); if (("to-boolean" === r || "to-string" === r) && 2 !== t.length) return e.error("Expected one argument."); const n = Ee[r], i = []; for (let r = 1; r < t.length; r++) { const n = e.parse(t[r], r, Tt); if (!n) return null; i.push(n); } return new Te(n, i) } evaluate(t) { switch (this.type.kind) { case "boolean": return Boolean(this.args[0].evaluate(t)); case "color": { let e, r; for (const n of this.args) { if (e = n.evaluate(t), r = null, e instanceof ye) return e; if ("string" == typeof e) { const r = t.parseColor(e); if (r) return r } else if (Array.isArray(e) && (r = e.length < 3 || e.length > 4 ? `Invalid rgba value ${JSON.stringify(e)}: expected an array containing either three or four numeric values.` : Me(e[0], e[1], e[2], e[3]), !r)) return new ye(e[0] / 255, e[1] / 255, e[2] / 255, e[3]) } throw new we(r || `Could not parse color from value '${"string" == typeof e ? e : JSON.stringify(e)}'`) } case "padding": { let e; for (const r of this.args) { e = r.evaluate(t); const n = be.parse(e); if (n) return n } throw new we(`Could not parse padding from value '${"string" == typeof e ? e : JSON.stringify(e)}'`) } case "variableAnchorOffsetCollection": { let e; for (const r of this.args) { e = r.evaluate(t); const n = Se.parse(e); if (n) return n } throw new we(`Could not parse variableAnchorOffsetCollection from value '${"string" == typeof e ? e : JSON.stringify(e)}'`) } case "number": { let e = null; for (const r of this.args) { if (e = r.evaluate(t), null === e) return 0; const n = Number(e); if (!isNaN(n)) return n } throw new we(`Could not convert ${JSON.stringify(e)} to number.`) } case "formatted": return ve.fromString(Pe(this.args[0].evaluate(t))); case "resolvedImage": return Ae.fromString(Pe(this.args[0].evaluate(t))); case "projectionDefinition": return this.args[0].evaluate(t); default: return Pe(this.args[0].evaluate(t)) } } eachChild(t) { this.args.forEach(t); } outputDefined() { return this.args.every((t => t.outputDefined())) } } const Fe = ["Unknown", "Point", "LineString", "Polygon"]; class $e { constructor() { this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null; } id() { return this.feature && "id" in this.feature ? this.feature.id : null } geometryType() { return this.feature ? "number" == typeof this.feature.type ? Fe[this.feature.type] : this.feature.type : null } geometry() { return this.feature && "geometry" in this.feature ? this.feature.geometry : null } canonicalID() { return this.canonical } properties() { return this.feature && this.feature.properties || {} } parseColor(t) { let e = this._parseColorCache[t]; return e || (e = this._parseColorCache[t] = ye.parse(t)), e } } class Le { constructor(t, e, r = [], n, i = new Mt, s = []) { this.registry = t, this.path = r, this.key = r.map((t => `[${t}]`)).join(""), this.scope = i, this.errors = s, this.expectedType = n, this._isConstant = e; } parse(t, e, r, n, i = {}) { return e ? this.concat(e, r, n)._parse(t, i) : this._parse(t, i) } _parse(t, e) { function r(t, e, r) { return "assert" === r ? new Ve(e, [t]) : "coerce" === r ? new Te(e, [t]) : t } if (null !== t && "string" != typeof t && "boolean" != typeof t && "number" != typeof t || (t = ["literal", t]), Array.isArray(t)) { if (0 === t.length) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].'); const n = t[0]; if ("string" != typeof n) return this.error(`Expression name must be a string, but found ${typeof n} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null; const i = this.registry[n]; if (i) { let n = i.parse(t, this); if (!n) return null; if (this.expectedType) { const t = this.expectedType, i = n.type; if ("string" !== t.kind && "number" !== t.kind && "boolean" !== t.kind && "object" !== t.kind && "array" !== t.kind || "value" !== i.kind) if ("projectionDefinition" !== t.kind || "string" !== i.kind && "array" !== i.kind) if ("color" !== t.kind && "formatted" !== t.kind && "resolvedImage" !== t.kind || "value" !== i.kind && "string" !== i.kind) if ("padding" !== t.kind || "value" !== i.kind && "number" !== i.kind && "array" !== i.kind) if ("variableAnchorOffsetCollection" !== t.kind || "value" !== i.kind && "array" !== i.kind) { if (this.checkSubtype(t, i)) return null } else n = r(n, t, e.typeAnnotation || "coerce"); else n = r(n, t, e.typeAnnotation || "coerce"); else n = r(n, t, e.typeAnnotation || "coerce"); else n = r(n, t, e.typeAnnotation || "coerce"); else n = r(n, t, e.typeAnnotation || "assert"); } if (!(n instanceof Ce) && "resolvedImage" !== n.type.kind && this._isConstant(n)) { const t = new $e; try { n = new Ce(n.type, n.evaluate(t)); } catch (t) { return this.error(t.message), null } } return n } return this.error(`Unknown expression "${n}". If you wanted a literal array, use ["literal", [...]].`, 0) } return this.error(void 0 === t ? "'undefined' value invalid. Use null instead." : "object" == typeof t ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`) } concat(t, e, r) { const n = "number" == typeof t ? this.path.concat(t) : this.path, i = r ? this.scope.concat(r) : this.scope; return new Le(this.registry, this._isConstant, n, e || null, i, this.errors) } error(t, ...e) { const r = `${this.key}${e.map((t => `[${t}]`)).join("")}`; this.errors.push(new kt(r, t)); } checkSubtype(t, e) { const r = Ut(t, e); return r && this.error(r), r } } class Oe { constructor(t, e) { this.type = e.type, this.bindings = [].concat(t), this.result = e; } evaluate(t) { return this.result.evaluate(t) } eachChild(t) { for (const e of this.bindings) t(e[1]); t(this.result); } static parse(t, e) { if (t.length < 4) return e.error(`Expected at least 3 arguments, but found ${t.length - 1} instead.`); const r = []; for (let n = 1; n < t.length - 1; n += 2) { const i = t[n]; if ("string" != typeof i) return e.error(`Expected string, but found ${typeof i} instead.`, n); if (/[^a-zA-Z0-9_]/.test(i)) return e.error("Variable names must contain only alphanumeric characters or '_'.", n); const s = e.parse(t[n + 1], n + 1); if (!s) return null; r.push([i, s]); } const n = e.parse(t[t.length - 1], t.length - 1, e.expectedType, r); return n ? new Oe(r, n) : null } outputDefined() { return this.result.outputDefined() } } class De { constructor(t, e) { this.type = e.type, this.name = t, this.boundExpression = e; } static parse(t, e) { if (2 !== t.length || "string" != typeof t[1]) return e.error("'var' expression requires exactly one string literal argument."); const r = t[1]; return e.scope.has(r) ? new De(r, e.scope.get(r)) : e.error(`Unknown variable "${r}". Make sure "${r}" has been bound in an enclosing "let" expression before using it.`, 1) } evaluate(t) { return this.boundExpression.evaluate(t) } eachChild() { } outputDefined() { return !1 } } class Re { constructor(t, e, r) { this.type = t, this.index = e, this.input = r; } static parse(t, e) { if (3 !== t.length) return e.error(`Expected 2 arguments, but found ${t.length - 1} instead.`); const r = e.parse(t[1], 1, zt), n = e.parse(t[2], 2, Rt(e.expectedType || Tt)); return r && n ? new Re(n.type.itemType, r, n) : null } evaluate(t) { const e = this.index.evaluate(t), r = this.input.evaluate(t); if (e < 0) throw new we(`Array index out of bounds: ${e} < 0.`); if (e >= r.length) throw new we(`Array index out of bounds: ${e} > ${r.length - 1}.`); if (e !== Math.floor(e)) throw new we(`Array index must be an integer, but found ${e} instead.`); return r[e] } eachChild(t) { t(this.index), t(this.input); } outputDefined() { return !1 } } class je { constructor(t, e) { this.type = Ct, this.needle = t, this.haystack = e; } static parse(t, e) { if (3 !== t.length) return e.error(`Expected 2 arguments, but found ${t.length - 1} instead.`); const r = e.parse(t[1], 1, Tt), n = e.parse(t[2], 2, Tt); return r && n ? qt(r.type, [Ct, Pt, zt, It, Tt]) ? new je(r, n) : e.error(`Expected first argument to be of type boolean, string, number or null, but found ${jt(r.type)} instead`) : null } evaluate(t) { const e = this.needle.evaluate(t), r = this.haystack.evaluate(t); if (!r) return !1; if (!Gt(e, ["boolean", "string", "number", "null"])) throw new we(`Expected first argument to be of type boolean, string, number or null, but found ${jt(ze(e))} instead.`); if (!Gt(r, ["string", "array"])) throw new we(`Expected second argument to be of type array or string, but found ${jt(ze(r))} instead.`); return r.indexOf(e) >= 0 } eachChild(t) { t(this.needle), t(this.haystack); } outputDefined() { return !0 } } class Ne { constructor(t, e, r) { this.type = zt, this.needle = t, this.haystack = e, this.fromIndex = r; } static parse(t, e) { if (t.length <= 2 || t.length >= 5) return e.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`); const r = e.parse(t[1], 1, Tt), n = e.parse(t[2], 2, Tt); if (!r || !n) return null; if (!qt(r.type, [Ct, Pt, zt, It, Tt])) return e.error(`Expected first argument to be of type boolean, string, number or null, but found ${jt(r.type)} instead`); if (4 === t.length) { const i = e.parse(t[3], 3, zt); return i ? new Ne(r, n, i) : null } return new Ne(r, n) } evaluate(t) { const e = this.needle.evaluate(t), r = this.haystack.evaluate(t); if (!Gt(e, ["boolean", "string", "number", "null"])) throw new we(`Expected first argument to be of type boolean, string, number or null, but found ${jt(ze(e))} instead.`); let n; if (this.fromIndex && (n = this.fromIndex.evaluate(t)), Gt(r, ["string"])) { const t = r.indexOf(e, n); return -1 === t ? -1 : [...r.slice(0, t)].length } if (Gt(r, ["array"])) return r.indexOf(e, n); throw new we(`Expected second argument to be of type array or string, but found ${jt(ze(r))} instead.`) } eachChild(t) { t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex); } outputDefined() { return !1 } } class Ue { constructor(t, e, r, n, i, s) { this.inputType = t, this.type = e, this.input = r, this.cases = n, this.outputs = i, this.otherwise = s; } static parse(t, e) { if (t.length < 5) return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`); if (t.length % 2 != 1) return e.error("Expected an even number of arguments."); let r, n; e.expectedType && "value" !== e.expectedType.kind && (n = e.expectedType); const i = {}, s = []; for (let a = 2; a < t.length - 1; a += 2) { let o = t[a]; const l = t[a + 1]; Array.isArray(o) || (o = [o]); const u = e.concat(a); if (0 === o.length) return u.error("Expected at least one branch label."); for (const t of o) { if ("number" != typeof t && "string" != typeof t) return u.error("Branch labels must be numbers or strings."); if ("number" == typeof t && Math.abs(t) > Number.MAX_SAFE_INTEGER) return u.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`); if ("number" == typeof t && Math.floor(t) !== t) return u.error("Numeric branch labels must be integer values."); if (r) { if (u.checkSubtype(r, ze(t))) return null } else r = ze(t); if (void 0 !== i[String(t)]) return u.error("Branch labels must be unique."); i[String(t)] = s.length; } const c = e.parse(l, a, n); if (!c) return null; n = n || c.type, s.push(c); } const a = e.parse(t[1], 1, Tt); if (!a) return null; const o = e.parse(t[t.length - 1], t.length - 1, n); return o ? "value" !== a.type.kind && e.concat(1).checkSubtype(r, a.type) ? null : new Ue(r, n, a, i, s, o) : null } evaluate(t) { const e = this.input.evaluate(t); return (ze(e) === this.inputType && this.outputs[this.cases[e]] || this.otherwise).evaluate(t) } eachChild(t) { t(this.input), this.outputs.forEach(t), t(this.otherwise); } outputDefined() { return this.outputs.every((t => t.outputDefined())) && this.otherwise.outputDefined() } } class qe { constructor(t, e, r) { this.type = t, this.branches = e, this.otherwise = r; } static parse(t, e) { if (t.length < 4) return e.error(`Expected at least 3 arguments, but found only ${t.length - 1}.`); if (t.length % 2 != 0) return e.error("Expected an odd number of arguments."); let r; e.expectedType && "value" !== e.expectedType.kind && (r = e.expectedType); const n = []; for (let i = 1; i < t.length - 1; i += 2) { const s = e.parse(t[i], i, Ct); if (!s) return null; const a = e.parse(t[i + 1], i + 1, r); if (!a) return null; n.push([s, a]), r = r || a.type; } const i = e.parse(t[t.length - 1], t.length - 1, r); if (!i) return null; if (!r) throw new Error("Can't infer output type"); return new qe(r, n, i) } evaluate(t) { for (const [e, r] of this.branches) if (e.evaluate(t)) return r.evaluate(t); return this.otherwise.evaluate(t) } eachChild(t) { for (const [e, r] of this.branches) t(e), t(r); t(this.otherwise); } outputDefined() { return this.branches.every((([t, e]) => e.outputDefined())) && this.otherwise.outputDefined() } } class Ge { constructor(t, e, r, n) { this.type = t, this.input = e, this.beginIndex = r, this.endIndex = n; } static parse(t, e) { if (t.length <= 2 || t.length >= 5) return e.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`); const r = e.parse(t[1], 1, Tt), n = e.parse(t[2], 2, zt); if (!r || !n) return null; if (!qt(r.type, [Rt(Tt), Pt, Tt])) return e.error(`Expected first argument to be of type array or string, but found ${jt(r.type)} instead`); if (4 === t.length) { const i = e.parse(t[3], 3, zt); return i ? new Ge(r.type, r, n, i) : null } return new Ge(r.type, r, n) } evaluate(t) { const e = this.input.evaluate(t), r = this.beginIndex.evaluate(t); let n; if (this.endIndex && (n = this.endIndex.evaluate(t)), Gt(e, ["string"])) return [...e].slice(r, n).join(""); if (Gt(e, ["array"])) return e.slice(r, n); throw new we(`Expected first argument to be of type array or string, but found ${jt(ze(e))} instead.`) } eachChild(t) { t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex); } outputDefined() { return !1 } } function Ze(t, e) { const r = t.length - 1; let n, i, s = 0, a = r, o = 0; for (; s <= a;)if (o = Math.floor((s + a) / 2), n = t[o], i = t[o + 1], n <= e) { if (o === r || e < i) return o; s = o + 1; } else { if (!(n > e)) throw new we("Input is not a number."); a = o - 1; } return 0 } class Xe { constructor(t, e, r) { this.type = t, this.input = e, this.labels = [], this.outputs = []; for (const [t, e] of r) this.labels.push(t), this.outputs.push(e); } static parse(t, e) { if (t.length - 1 < 4) return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`); if ((t.length - 1) % 2 != 0) return e.error("Expected an even number of arguments."); const r = e.parse(t[1], 1, zt); if (!r) return null; const n = []; let i = null; e.expectedType && "value" !== e.expectedType.kind && (i = e.expectedType); for (let r = 1; r < t.length; r += 2) { const s = 1 === r ? -1 / 0 : t[r], a = t[r + 1], o = r, l = r + 1; if ("number" != typeof s) return e.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o); if (n.length && n[n.length - 1][0] >= s) return e.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o); const u = e.parse(a, l, i); if (!u) return null; i = i || u.type, n.push([s, u]); } return new Xe(i, r, n) } evaluate(t) { const e = this.labels, r = this.outputs; if (1 === e.length) return r[0].evaluate(t); const n = this.input.evaluate(t); if (n <= e[0]) return r[0].evaluate(t); const i = e.length; return n >= e[i - 1] ? r[i - 1].evaluate(t) : r[Ze(e, n)].evaluate(t) } eachChild(t) { t(this.input); for (const e of this.outputs) t(e); } outputDefined() { return this.outputs.every((t => t.outputDefined())) } } function Ke(t) { return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t } var He, Ye, Je = function () { if (Ye) return He; function t(t, e, r, n) { this.cx = 3 * t, this.bx = 3 * (r - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e, this.by = 3 * (n - e) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = e, this.p2x = r, this.p2y = n; } return Ye = 1, He = t, t.prototype = { sampleCurveX: function (t) { return ((this.ax * t + this.bx) * t + this.cx) * t }, sampleCurveY: function (t) { return ((this.ay * t + this.by) * t + this.cy) * t }, sampleCurveDerivativeX: function (t) { return (3 * this.ax * t + 2 * this.bx) * t + this.cx }, solveCurveX: function (t, e) { if (void 0 === e && (e = 1e-6), t < 0) return 0; if (t > 1) return 1; for (var r = t, n = 0; n < 8; n++) { var i = this.sampleCurveX(r) - t; if (Math.abs(i) < e) return r; var s = this.sampleCurveDerivativeX(r); if (Math.abs(s) < 1e-6) break; r -= i / s; } var a = 0, o = 1; for (r = t, n = 0; n < 20 && (i = this.sampleCurveX(r), !(Math.abs(i - t) < e)); n++)t > i ? a = r : o = r, r = .5 * (o - a) + a; return r }, solve: function (t, e) { return this.sampleCurveY(this.solveCurveX(t, e)) } }, He }(), We = Ke(Je); class Qe { constructor(t, e, r, n, i) { this.type = t, this.operator = e, this.interpolation = r, this.input = n, this.labels = [], this.outputs = []; for (const [t, e] of i) this.labels.push(t), this.outputs.push(e); } static interpolationFactor(t, e, r, n) { let i = 0; if ("exponential" === t.name) i = tr(e, t.base, r, n); else if ("linear" === t.name) i = tr(e, 1, r, n); else if ("cubic-bezier" === t.name) { const s = t.controlPoints; i = new We(s[0], s[1], s[2], s[3]).solve(tr(e, 1, r, n)); } return i } static parse(t, e) { let [r, n, i, ...s] = t; if (!Array.isArray(n) || 0 === n.length) return e.error("Expected an interpolation type expression.", 1); if ("linear" === n[0]) n = { name: "linear" }; else if ("exponential" === n[0]) { const t = n[1]; if ("number" != typeof t) return e.error("Exponential interpolation requires a numeric base.", 1, 1); n = { name: "exponential", base: t }; } else { if ("cubic-bezier" !== n[0]) return e.error(`Unknown interpolation type ${String(n[0])}`, 1, 0); { const t = n.slice(1); if (4 !== t.length || t.some((t => "number" != typeof t || t < 0 || t > 1))) return e.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1); n = { name: "cubic-bezier", controlPoints: t }; } } if (t.length - 1 < 4) return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`); if ((t.length - 1) % 2 != 0) return e.error("Expected an even number of arguments."); if (i = e.parse(i, 2, zt), !i) return null; const a = []; let o = null; "interpolate-hcl" === r || "interpolate-lab" === r ? o = Bt : e.expectedType && "value" !== e.expectedType.kind && (o = e.expectedType); for (let t = 0; t < s.length; t += 2) { const r = s[t], n = s[t + 1], i = t + 3, l = t + 4; if ("number" != typeof r) return e.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i); if (a.length && a[a.length - 1][0] >= r) return e.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i); const u = e.parse(n, l, o); if (!u) return null; o = o || u.type, a.push([r, u]); } return Zt(o, zt) || Zt(o, Vt) || Zt(o, Bt) || Zt(o, Lt) || Zt(o, Dt) || Zt(o, Rt(zt)) ? new Qe(o, r, n, i, a) : e.error(`Type ${jt(o)} is not interpolatable.`) } evaluate(t) { const e = this.labels, r = this.outputs; if (1 === e.length) return r[0].evaluate(t); const n = this.input.evaluate(t); if (n <= e[0]) return r[0].evaluate(t); const i = e.length; if (n >= e[i - 1]) return r[i - 1].evaluate(t); const s = Ze(e, n), a = Qe.interpolationFactor(this.interpolation, n, e[s], e[s + 1]), o = r[s].evaluate(t), l = r[s + 1].evaluate(t); switch (this.operator) { case "interpolate": switch (this.type.kind) { case "number": return fe(o, l, a); case "color": return ye.interpolate(o, l, a); case "padding": return be.interpolate(o, l, a); case "variableAnchorOffsetCollection": return Se.interpolate(o, l, a); case "array": return de(o, l, a); case "projectionDefinition": return ke.interpolate(o, l, a) }case "interpolate-hcl": return ye.interpolate(o, l, a, "hcl"); case "interpolate-lab": return ye.interpolate(o, l, a, "lab") } } eachChild(t) { t(this.input); for (const e of this.outputs) t(e); } outputDefined() { return this.outputs.every((t => t.outputDefined())) } } function tr(t, e, r, n) { const i = n - r, s = t - r; return 0 === i ? 0 : 1 === e ? s / i : (Math.pow(e, s) - 1) / (Math.pow(e, i) - 1) } const er = { color: ye.interpolate, number: fe, padding: be.interpolate, variableAnchorOffsetCollection: Se.interpolate, array: de }; class rr { constructor(t, e) { this.type = t, this.args = e; } static parse(t, e) { if (t.length < 2) return e.error("Expected at least one argument."); let r = null; const n = e.expectedType; n && "value" !== n.kind && (r = n); const i = []; for (const n of t.slice(1)) { const t = e.parse(n, 1 + i.length, r, void 0, { typeAnnotation: "omit" }); if (!t) return null; r = r || t.type, i.push(t); } if (!r) throw new Error("No output type"); const s = n && i.some((t => Ut(n, t.type))); return new rr(s ? Tt : r, i) } evaluate(t) { let e, r = null, n = 0; for (const i of this.args) if (n++, r = i.evaluate(t), r && r instanceof Ae && !r.available && (e || (e = r.name), r = null, n === this.args.length && (r = e)), null !== r) break; return r } eachChild(t) { this.args.forEach(t); } outputDefined() { return this.args.every((t => t.outputDefined())) } } function nr(t, e) { return "==" === t || "!=" === t ? "boolean" === e.kind || "string" === e.kind || "number" === e.kind || "null" === e.kind || "value" === e.kind : "string" === e.kind || "number" === e.kind || "value" === e.kind } function ir(t, e, r, n) { return 0 === n.compare(e, r) } function sr(t, e, r) { const n = "==" !== t && "!=" !== t; return class i { constructor(t, e, r) { this.type = Ct, this.lhs = t, this.rhs = e, this.collator = r, this.hasUntypedArgument = "value" === t.type.kind || "value" === e.type.kind; } static parse(t, e) { if (3 !== t.length && 4 !== t.length) return e.error("Expected two or three arguments."); const r = t[0]; let s = e.parse(t[1], 1, Tt); if (!s) return null; if (!nr(r, s.type)) return e.concat(1).error(`"${r}" comparisons are not supported for type '${jt(s.type)}'.`); let a = e.parse(t[2], 2, Tt); if (!a) return null; if (!nr(r, a.type)) return e.concat(2).error(`"${r}" comparisons are not supported for type '${jt(a.type)}'.`); if (s.type.kind !== a.type.kind && "value" !== s.type.kind && "value" !== a.type.kind) return e.error(`Cannot compare types '${jt(s.type)}' and '${jt(a.type)}'.`); n && ("value" === s.type.kind && "value" !== a.type.kind ? s = new Ve(a.type, [s]) : "value" !== s.type.kind && "value" === a.type.kind && (a = new Ve(s.type, [a]))); let o = null; if (4 === t.length) { if ("string" !== s.type.kind && "string" !== a.type.kind && "value" !== s.type.kind && "value" !== a.type.kind) return e.error("Cannot use collator to compare non-string types."); if (o = e.parse(t[3], 3, Ft), !o) return null } return new i(s, a, o) } evaluate(i) { const s = this.lhs.evaluate(i), a = this.rhs.evaluate(i); if (n && this.hasUntypedArgument) { const e = ze(s), r = ze(a); if (e.kind !== r.kind || "string" !== e.kind && "number" !== e.kind) throw new we(`Expected arguments for "${t}" to be (string, string) or (number, number), but found (${e.kind}, ${r.kind}) instead.`) } if (this.collator && !n && this.hasUntypedArgument) { const t = ze(s), r = ze(a); if ("string" !== t.kind || "string" !== r.kind) return e(i, s, a) } return this.collator ? r(i, s, a, this.collator.evaluate(i)) : e(i, s, a) } eachChild(t) { t(this.lhs), t(this.rhs), this.collator && t(this.collator); } outputDefined() { return !0 } } } const ar = sr("==", (function (t, e, r) { return e === r }), ir), or = sr("!=", (function (t, e, r) { return e !== r }), (function (t, e, r, n) { return !ir(0, e, r, n) })), lr = sr("<", (function (t, e, r) { return e < r }), (function (t, e, r, n) { return n.compare(e, r) < 0 })), ur = sr(">", (function (t, e, r) { return e > r }), (function (t, e, r, n) { return n.compare(e, r) > 0 })), cr = sr("<=", (function (t, e, r) { return e <= r }), (function (t, e, r, n) { return n.compare(e, r) <= 0 })), hr = sr(">=", (function (t, e, r) { return e >= r }), (function (t, e, r, n) { return n.compare(e, r) >= 0 })); class pr { constructor(t, e, r) { this.type = Ft, this.locale = r, this.caseSensitive = t, this.diacriticSensitive = e; } static parse(t, e) { if (2 !== t.length) return e.error("Expected one argument."); const r = t[1]; if ("object" != typeof r || Array.isArray(r)) return e.error("Collator options argument must be an object."); const n = e.parse(void 0 !== r["case-sensitive"] && r["case-sensitive"], 1, Ct); if (!n) return null; const i = e.parse(void 0 !== r["diacritic-sensitive"] && r["diacritic-sensitive"], 1, Ct); if (!i) return null; let s = null; return r.locale && (s = e.parse(r.locale, 1, Pt), !s) ? null : new pr(n, i, s) } evaluate(t) { return new me(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null) } eachChild(t) { t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale); } outputDefined() { return !1 } } class fr { constructor(t, e, r, n, i) { this.type = Pt, this.number = t, this.locale = e, this.currency = r, this.minFractionDigits = n, this.maxFractionDigits = i; } static parse(t, e) { if (3 !== t.length) return e.error("Expected two arguments."); const r = e.parse(t[1], 1, zt); if (!r) return null; const n = t[2]; if ("object" != typeof n || Array.isArray(n)) return e.error("NumberFormat options argument must be an object."); let i = null; if (n.locale && (i = e.parse(n.locale, 1, Pt), !i)) return null; let s = null; if (n.currency && (s = e.parse(n.currency, 1, Pt), !s)) return null; let a = null; if (n["min-fraction-digits"] && (a = e.parse(n["min-fraction-digits"], 1, zt), !a)) return null; let o = null; return n["max-fraction-digits"] && (o = e.parse(n["max-fraction-digits"], 1, zt), !o) ? null : new fr(r, i, s, a, o) } evaluate(t) { return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0 }).format(this.number.evaluate(t)) } eachChild(t) { t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits); } outputDefined() { return !1 } } class dr { constructor(t) { this.type = $t, this.sections = t; } static parse(t, e) { if (t.length < 2) return e.error("Expected at least one argument."); const r = t[1]; if (!Array.isArray(r) && "object" == typeof r) return e.error("First argument must be an image or text section."); const n = []; let i = !1; for (let r = 1; r <= t.length - 1; ++r) { const s = t[r]; if (i && "object" == typeof s && !Array.isArray(s)) { i = !1; let t = null; if (s["font-scale"] && (t = e.parse(s["font-scale"], 1, zt), !t)) return null; let r = null; if (s["text-font"] && (r = e.parse(s["text-font"], 1, Rt(Pt)), !r)) return null; let a = null; if (s["text-color"] && (a = e.parse(s["text-color"], 1, Bt), !a)) return null; let o = null; if (s["vertical-align"]) { if ("string" == typeof s["vertical-align"] && !ge.includes(s["vertical-align"])) return e.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${s["vertical-align"]}' instead.`); if (o = e.parse(s["vertical-align"], 1, Pt), !o) return null } const l = n[n.length - 1]; l.scale = t, l.font = r, l.textColor = a, l.verticalAlign = o; } else { const s = e.parse(t[r], 1, Tt); if (!s) return null; const a = s.type.kind; if ("string" !== a && "value" !== a && "null" !== a && "resolvedImage" !== a) return e.error("Formatted text type must be 'string', 'value', 'image' or 'null'."); i = !0, n.push({ content: s, scale: null, font: null, textColor: null, verticalAlign: null }); } } return new dr(n) } evaluate(t) { return new ve(this.sections.map((e => { const r = e.content.evaluate(t); return ze(r) === Ot ? new xe("", r, null, null, null, e.verticalAlign ? e.verticalAlign.evaluate(t) : null) : new xe(Pe(r), null, e.scale ? e.scale.evaluate(t) : null, e.font ? e.font.evaluate(t).join(",") : null, e.textColor ? e.textColor.evaluate(t) : null, e.verticalAlign ? e.verticalAlign.evaluate(t) : null) }))) } eachChild(t) { for (const e of this.sections) t(e.content), e.scale && t(e.scale), e.font && t(e.font), e.textColor && t(e.textColor), e.verticalAlign && t(e.verticalAlign); } outputDefined() { return !1 } } class yr { constructor(t) { this.type = Ot, this.input = t; } static parse(t, e) { if (2 !== t.length) return e.error("Expected two arguments."); const r = e.parse(t[1], 1, Pt); return r ? new yr(r) : e.error("No image name provided.") } evaluate(t) { const e = this.input.evaluate(t), r = Ae.fromString(e); return r && t.availableImages && (r.available = t.availableImages.indexOf(e) > -1), r } eachChild(t) { t(this.input); } outputDefined() { return !1 } } class mr { constructor(t) { this.type = zt, this.input = t; } static parse(t, e) { if (2 !== t.length) return e.error(`Expected 1 argument, but found ${t.length - 1} instead.`); const r = e.parse(t[1], 1); return r ? "array" !== r.type.kind && "string" !== r.type.kind && "value" !== r.type.kind ? e.error(`Expected argument of type string or array, but found ${jt(r.type)} instead.`) : new mr(r) : null } evaluate(t) { const e = this.input.evaluate(t); if ("string" == typeof e) return [...e].length; if (Array.isArray(e)) return e.length; throw new we(`Expected value to be of type string or array, but found ${jt(ze(e))} instead.`) } eachChild(t) { t(this.input); } outputDefined() { return !1 } } const gr = 8192; function xr(t, e) { const r = (180 + t[0]) / 360, n = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t[1] * Math.PI / 360))) / 360, i = Math.pow(2, e.z); return [Math.round(r * i * gr), Math.round(n * i * gr)] } function vr(t, e) { const r = Math.pow(2, e.z); return [(i = (t[0] / gr + e.x) / r, 360 * i - 180), (n = (t[1] / gr + e.y) / r, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * n) * Math.PI / 180)) - 90)]; var n, i; } function br(t, e) { t[0] = Math.min(t[0], e[0]), t[1] = Math.min(t[1], e[1]), t[2] = Math.max(t[2], e[0]), t[3] = Math.max(t[3], e[1]); } function wr(t, e) { return !(t[0] <= e[0] || t[2] >= e[2] || t[1] <= e[1] || t[3] >= e[3]) } function _r(t, e, r) { const n = t[0] - e[0], i = t[1] - e[1], s = t[0] - r[0], a = t[1] - r[1]; return n * a - s * i == 0 && n * s <= 0 && i * a <= 0 } function Sr(t, e, r, n) { return 0 != (i = [n[0] - r[0], n[1] - r[1]])[0] * (s = [e[0] - t[0], e[1] - t[1]])[1] - i[1] * s[0] && !(!Pr(t, e, r, n) || !Pr(r, n, t, e)); var i, s; } function Ar(t, e, r) { for (const n of r) for (let r = 0; r < n.length - 1; ++r)if (Sr(t, e, n[r], n[r + 1])) return !0; return !1 } function kr(t, e, r = !1) { let n = !1; for (const o of e) for (let e = 0; e < o.length - 1; e++) { if (_r(t, o[e], o[e + 1])) return r; (s = o[e])[1] > (i = t)[1] != (a = o[e + 1])[1] > i[1] && i[0] < (a[0] - s[0]) * (i[1] - s[1]) / (a[1] - s[1]) + s[0] && (n = !n); } var i, s, a; return n } function Mr(t, e) { for (const r of e) if (kr(t, r)) return !0; return !1 } function Ir(t, e) { for (const r of t) if (!kr(r, e)) return !1; for (let r = 0; r < t.length - 1; ++r)if (Ar(t[r], t[r + 1], e)) return !1; return !0 } function zr(t, e) { for (const r of e) if (Ir(t, r)) return !0; return !1 } function Pr(t, e, r, n) { const i = n[0] - r[0], s = n[1] - r[1], a = (t[0] - r[0]) * s - i * (t[1] - r[1]), o = (e[0] - r[0]) * s - i * (e[1] - r[1]); return a > 0 && o < 0 || a < 0 && o > 0 } function Cr(t, e, r) { const n = []; for (let i = 0; i < t.length; i++) { const s = []; for (let n = 0; n < t[i].length; n++) { const a = xr(t[i][n], r); br(e, a), s.push(a); } n.push(s); } return n } function Br(t, e, r) { const n = []; for (let i = 0; i < t.length; i++) { const s = Cr(t[i], e, r); n.push(s); } return n } function Vr(t, e, r, n) { if (t[0] < r[0] || t[0] > r[2]) { const e = .5 * n; let i = t[0] - r[0] > e ? -n : r[0] - t[0] > e ? n : 0; 0 === i && (i = t[0] - r[2] > e ? -n : r[2] - t[0] > e ? n : 0), t[0] += i; } br(e, t); } function Er(t, e, r, n) { const i = Math.pow(2, n.z) * gr, s = [n.x * gr, n.y * gr], a = []; for (const n of t) for (const t of n) { const n = [t.x + s[0], t.y + s[1]]; Vr(n, e, r, i), a.push(n); } return a } function Tr(t, e, r, n) { const i = Math.pow(2, n.z) * gr, s = [n.x * gr, n.y * gr], a = []; for (const r of t) { const t = []; for (const n of r) { const r = [n.x + s[0], n.y + s[1]]; br(e, r), t.push(r); } a.push(t); } if (e[2] - e[0] <= i / 2) { (o = e)[0] = o[1] = 1 / 0, o[2] = o[3] = -1 / 0; for (const t of a) for (const n of t) Vr(n, e, r, i); } var o; return a } class Fr { constructor(t, e) { this.type = Ct, this.geojson = t, this.geometries = e; } static parse(t, e) { if (2 !== t.length) return e.error(`'within' expression requires exactly one argument, but found ${t.length - 1} instead.`); if (Ie(t[1])) { const e = t[1]; if ("FeatureCollection" === e.type) { const t = []; for (const r of e.features) { const { type: e, coordinates: n } = r.geometry; "Polygon" === e && t.push(n), "MultiPolygon" === e && t.push(...n); } if (t.length) return new Fr(e, { type: "MultiPolygon", coordinates: t }) } else if ("Feature" === e.type) { const t = e.geometry.type; if ("Polygon" === t || "MultiPolygon" === t) return new Fr(e, e.geometry) } else if ("Polygon" === e.type || "MultiPolygon" === e.type) return new Fr(e, e) } return e.error("'within' expression requires valid geojson object that contains polygon geometry type.") } evaluate(t) { if (null != t.geometry() && null != t.canonicalID()) { if ("Point" === t.geometryType()) return function (t, e) { const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i = t.canonicalID(); if ("Polygon" === e.type) { const s = Cr(e.coordinates, n, i), a = Er(t.geometry(), r, n, i); if (!wr(r, n)) return !1; for (const t of a) if (!kr(t, s)) return !1 } if ("MultiPolygon" === e.type) { const s = Br(e.coordinates, n, i), a = Er(t.geometry(), r, n, i); if (!wr(r, n)) return !1; for (const t of a) if (!Mr(t, s)) return !1 } return !0 }(t, this.geometries); if ("LineString" === t.geometryType()) return function (t, e) { const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i = t.canonicalID(); if ("Polygon" === e.type) { const s = Cr(e.coordinates, n, i), a = Tr(t.geometry(), r, n, i); if (!wr(r, n)) return !1; for (const t of a) if (!Ir(t, s)) return !1 } if ("MultiPolygon" === e.type) { const s = Br(e.coordinates, n, i), a = Tr(t.geometry(), r, n, i); if (!wr(r, n)) return !1; for (const t of a) if (!zr(t, s)) return !1 } return !0 }(t, this.geometries) } return !1 } eachChild() { } outputDefined() { return !0 } } let $r = class { constructor(t = [], e = ((t, e) => t < e ? -1 : t > e ? 1 : 0)) { if (this.data = t, this.length = this.data.length, this.compare = e, this.length > 0) for (let t = (this.length >> 1) - 1; t >= 0; t--)this._down(t); } push(t) { this.data.push(t), this._up(this.length++); } pop() { if (0 === this.length) return; const t = this.data[0], e = this.data.pop(); return --this.length > 0 && (this.data[0] = e, this._down(0)), t } peek() { return this.data[0] } _up(t) { const { data: e, compare: r } = this, n = e[t]; for (; t > 0;) { const i = t - 1 >> 1, s = e[i]; if (r(n, s) >= 0) break; e[t] = s, t = i; } e[t] = n; } _down(t) { const { data: e, compare: r } = this, n = this.length >> 1, i = e[t]; for (; t < n;) { let n = 1 + (t << 1); const s = n + 1; if (s < this.length && r(e[s], e[n]) < 0 && (n = s), r(e[n], i) >= 0) break; e[t] = e[n], t = n; } e[t] = i; } }; function Lr(t, e, r = 0, n = t.length - 1, i = Dr) { for (; n > r;) { if (n - r > 600) { const s = n - r + 1, a = e - r + 1, o = Math.log(s), l = .5 * Math.exp(2 * o / 3), u = .5 * Math.sqrt(o * l * (s - l) / s) * (a - s / 2 < 0 ? -1 : 1); Lr(t, e, Math.max(r, Math.floor(e - a * l / s + u)), Math.min(n, Math.floor(e + (s - a) * l / s + u)), i); } const s = t[e]; let a = r, o = n; for (Or(t, r, e), i(t[n], s) > 0 && Or(t, r, n); a < o;) { for (Or(t, a, o), a++, o--; i(t[a], s) < 0;)a++; for (; i(t[o], s) > 0;)o--; } 0 === i(t[r], s) ? Or(t, r, o) : (o++, Or(t, o, n)), o <= e && (r = o + 1), e <= o && (n = o - 1); } } function Or(t, e, r) { const n = t[e]; t[e] = t[r], t[r] = n; } function Dr(t, e) { return t < e ? -1 : t > e ? 1 : 0 } function Rr(t, e) { if (t.length <= 1) return [t]; const r = []; let n, i; for (const e of t) { const t = Nr(e); 0 !== t && (e.area = Math.abs(t), void 0 === i && (i = t < 0), i === t < 0 ? (n && r.push(n), n = [e]) : n.push(e)); } if (n && r.push(n), e > 1) for (let t = 0; t < r.length; t++)r[t].length <= e || (Lr(r[t], e, 1, r[t].length - 1, jr), r[t] = r[t].slice(0, e)); return r } function jr(t, e) { return e.area - t.area } function Nr(t) { let e = 0; for (let r, n, i = 0, s = t.length, a = s - 1; i < s; a = i++)r = t[i], n = t[a], e += (n.x - r.x) * (r.y + n.y); return e } const Ur = 1 / 298.257223563, qr = Ur * (2 - Ur), Gr = Math.PI / 180; class Zr { constructor(t) { const e = 6378.137 * Gr * 1e3, r = Math.cos(t * Gr), n = 1 / (1 - qr * (1 - r * r)), i = Math.sqrt(n); this.kx = e * i * r, this.ky = e * i * n * (1 - qr); } distance(t, e) { const r = this.wrap(t[0] - e[0]) * this.kx, n = (t[1] - e[1]) * this.ky; return Math.sqrt(r * r + n * n) } pointOnLine(t, e) { let r, n, i, s, a = 1 / 0; for (let o = 0; o < t.length - 1; o++) { let l = t[o][0], u = t[o][1], c = this.wrap(t[o + 1][0] - l) * this.kx, h = (t[o + 1][1] - u) * this.ky, p = 0; 0 === c && 0 === h || (p = (this.wrap(e[0] - l) * this.kx * c + (e[1] - u) * this.ky * h) / (c * c + h * h), p > 1 ? (l = t[o + 1][0], u = t[o + 1][1]) : p > 0 && (l += c / this.kx * p, u += h / this.ky * p)), c = this.wrap(e[0] - l) * this.kx, h = (e[1] - u) * this.ky; const f = c * c + h * h; f < a && (a = f, r = l, n = u, i = o, s = p); } return { point: [r, n], index: i, t: Math.max(0, Math.min(1, s)) } } wrap(t) { for (; t < -180;)t += 360; for (; t > 180;)t -= 360; return t } } function Xr(t, e) { return e[0] - t[0] } function Kr(t) { return t[1] - t[0] + 1 } function Hr(t, e) { return t[1] >= t[0] && t[1] < e } function Yr(t, e) { if (t[0] > t[1]) return [null, null]; const r = Kr(t); if (e) { if (2 === r) return [t, null]; const e = Math.floor(r / 2); return [[t[0], t[0] + e], [t[0] + e, t[1]]] } if (1 === r) return [t, null]; const n = Math.floor(r / 2) - 1; return [[t[0], t[0] + n], [t[0] + n + 1, t[1]]] } function Jr(t, e) { if (!Hr(e, t.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0]; const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0]; for (let n = e[0]; n <= e[1]; ++n)br(r, t[n]); return r } function Wr(t) { const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0]; for (const r of t) for (const t of r) br(e, t); return e } function Qr(t) { return t[0] !== -1 / 0 && t[1] !== -1 / 0 && t[2] !== 1 / 0 && t[3] !== 1 / 0 } function tn(t, e, r) { if (!Qr(t) || !Qr(e)) return NaN; let n = 0, i = 0; return t[2] < e[0] && (n = e[0] - t[2]), t[0] > e[2] && (n = t[0] - e[2]), t[1] > e[3] && (i = t[1] - e[3]), t[3] < e[1] && (i = e[1] - t[3]), r.distance([0, 0], [n, i]) } function en(t, e, r) { const n = r.pointOnLine(e, t); return r.distance(t, n.point) } function rn(t, e, r, n, i) { const s = Math.min(en(t, [r, n], i), en(e, [r, n], i)), a = Math.min(en(r, [t, e], i), en(n, [t, e], i)); return Math.min(s, a) } function nn(t, e, r, n, i) { if (!Hr(e, t.length) || !Hr(n, r.length)) return 1 / 0; let s = 1 / 0; for (let a = e[0]; a < e[1]; ++a) { const e = t[a], o = t[a + 1]; for (let t = n[0]; t < n[1]; ++t) { const n = r[t], a = r[t + 1]; if (Sr(e, o, n, a)) return 0; s = Math.min(s, rn(e, o, n, a, i)); } } return s } function sn(t, e, r, n, i) { if (!Hr(e, t.length) || !Hr(n, r.length)) return NaN; let s = 1 / 0; for (let a = e[0]; a <= e[1]; ++a)for (let e = n[0]; e <= n[1]; ++e)if (s = Math.min(s, i.distance(t[a], r[e])), 0 === s) return s; return s } function an(t, e, r) { if (kr(t, e, !0)) return 0; let n = 1 / 0; for (const i of e) { const e = i[0], s = i[i.length - 1]; if (e !== s && (n = Math.min(n, en(t, [s, e], r)), 0 === n)) return n; const a = r.pointOnLine(i, t); if (n = Math.min(n, r.distance(t, a.point)), 0 === n) return n } return n } function on(t, e, r, n) { if (!Hr(e, t.length)) return NaN; for (let n = e[0]; n <= e[1]; ++n)if (kr(t[n], r, !0)) return 0; let i = 1 / 0; for (let s = e[0]; s < e[1]; ++s) { const e = t[s], a = t[s + 1]; for (const t of r) for (let r = 0, s = t.length, o = s - 1; r < s; o = r++) { const s = t[o], l = t[r]; if (Sr(e, a, s, l)) return 0; i = Math.min(i, rn(e, a, s, l, n)); } } return i } function ln(t, e) { for (const r of t) for (const t of r) if (kr(t, e, !0)) return !0; return !1 } function un(t, e, r, n = 1 / 0) { const i = Wr(t), s = Wr(e); if (n !== 1 / 0 && tn(i, s, r) >= n) return n; if (wr(i, s)) { if (ln(t, e)) return 0 } else if (ln(e, t)) return 0; let a = 1 / 0; for (const n of t) for (let t = 0, i = n.length, s = i - 1; t < i; s = t++) { const i = n[s], o = n[t]; for (const t of e) for (let e = 0, n = t.length, s = n - 1; e < n; s = e++) { const n = t[s], l = t[e]; if (Sr(i, o, n, l)) return 0; a = Math.min(a, rn(i, o, n, l, r)); } } return a } function cn(t, e, r, n, i, s) { if (!s) return; const a = tn(Jr(n, s), i, r); a < e && t.push([a, s, [0, 0]]); } function hn(t, e, r, n, i, s, a) { if (!s || !a) return; const o = tn(Jr(n, s), Jr(i, a), r); o < e && t.push([o, s, a]); } function pn(t, e, r, n, i = 1 / 0) { let s = Math.min(n.distance(t[0], r[0][0]), i); if (0 === s) return s; const a = new $r([[0, [0, t.length - 1], [0, 0]]], Xr), o = Wr(r); for (; a.length > 0;) { const i = a.pop(); if (i[0] >= s) continue; const l = i[1], u = e ? 50 : 100; if (Kr(l) <= u) { if (!Hr(l, t.length)) return NaN; if (e) { const e = on(t, l, r, n); if (isNaN(e) || 0 === e) return e; s = Math.min(s, e); } else for (let e = l[0]; e <= l[1]; ++e) { const i = an(t[e], r, n); if (s = Math.min(s, i), 0 === s) return 0 } } else { const r = Yr(l, e); cn(a, s, n, t, o, r[0]), cn(a, s, n, t, o, r[1]); } } return s } function fn(t, e, r, n, i, s = 1 / 0) { let a = Math.min(s, i.distance(t[0], r[0])); if (0 === a) return a; const o = new $r([[0, [0, t.length - 1], [0, r.length - 1]]], Xr); for (; o.length > 0;) { const s = o.pop(); if (s[0] >= a) continue; const l = s[1], u = s[2], c = e ? 50 : 100, h = n ? 50 : 100; if (Kr(l) <= c && Kr(u) <= h) { if (!Hr(l, t.length) && Hr(u, r.length)) return NaN; let s; if (e && n) s = nn(t, l, r, u, i), a = Math.min(a, s); else if (e && !n) { const e = t.slice(l[0], l[1] + 1); for (let t = u[0]; t <= u[1]; ++t)if (s = en(r[t], e, i), a = Math.min(a, s), 0 === a) return a } else if (!e && n) { const e = r.slice(u[0], u[1] + 1); for (let r = l[0]; r <= l[1]; ++r)if (s = en(t[r], e, i), a = Math.min(a, s), 0 === a) return a } else s = sn(t, l, r, u, i), a = Math.min(a, s); } else { const s = Yr(l, e), c = Yr(u, n); hn(o, a, i, t, r, s[0], c[0]), hn(o, a, i, t, r, s[0], c[1]), hn(o, a, i, t, r, s[1], c[0]), hn(o, a, i, t, r, s[1], c[1]); } } return a } function dn(t) { return "MultiPolygon" === t.type ? t.coordinates.map((t => ({ type: "Polygon", coordinates: t }))) : "MultiLineString" === t.type ? t.coordinates.map((t => ({ type: "LineString", coordinates: t }))) : "MultiPoint" === t.type ? t.coordinates.map((t => ({ type: "Point", coordinates: t }))) : [t] } class yn { constructor(t, e) { this.type = zt, this.geojson = t, this.geometries = e; } static parse(t, e) { if (2 !== t.length) return e.error(`'distance' expression requires exactly one argument, but found ${t.length - 1} instead.`); if (Ie(t[1])) { const e = t[1]; if ("FeatureCollection" === e.type) return new yn(e, e.features.map((t => dn(t.geometry))).flat()); if ("Feature" === e.type) return new yn(e, dn(e.geometry)); if ("type" in e && "coordinates" in e) return new yn(e, dn(e)) } return e.error("'distance' expression requires valid geojson object that contains polygon geometry type.") } evaluate(t) { if (null != t.geometry() && null != t.canonicalID()) { if ("Point" === t.geometryType()) return function (t, e) { const r = t.geometry(), n = r.flat().map((e => vr([e.x, e.y], t.canonical))); if (0 === r.length) return NaN; const i = new Zr(n[0][1]); let s = 1 / 0; for (const t of e) { switch (t.type) { case "Point": s = Math.min(s, fn(n, !1, [t.coordinates], !1, i, s)); break; case "LineString": s = Math.min(s, fn(n, !1, t.coordinates, !0, i, s)); break; case "Polygon": s = Math.min(s, pn(n, !1, t.coordinates, i, s)); }if (0 === s) return s } return s }(t, this.geometries); if ("LineString" === t.geometryType()) return function (t, e) { const r = t.geometry(), n = r.flat().map((e => vr([e.x, e.y], t.canonical))); if (0 === r.length) return NaN; const i = new Zr(n[0][1]); let s = 1 / 0; for (const t of e) { switch (t.type) { case "Point": s = Math.min(s, fn(n, !0, [t.coordinates], !1, i, s)); break; case "LineString": s = Math.min(s, fn(n, !0, t.coordinates, !0, i, s)); break; case "Polygon": s = Math.min(s, pn(n, !0, t.coordinates, i, s)); }if (0 === s) return s } return s }(t, this.geometries); if ("Polygon" === t.geometryType()) return function (t, e) { const r = t.geometry(); if (0 === r.length || 0 === r[0].length) return NaN; const n = Rr(r, 0).map((e => e.map((e => e.map((e => vr([e.x, e.y], t.canonical))))))), i = new Zr(n[0][0][0][1]); let s = 1 / 0; for (const t of e) for (const e of n) { switch (t.type) { case "Point": s = Math.min(s, pn([t.coordinates], !1, e, i, s)); break; case "LineString": s = Math.min(s, pn(t.coordinates, !0, e, i, s)); break; case "Polygon": s = Math.min(s, un(e, t.coordinates, i, s)); }if (0 === s) return s } return s }(t, this.geometries) } return NaN } eachChild() { } outputDefined() { return !0 } } const mn = { "==": ar, "!=": or, ">": ur, "<": lr, ">=": hr, "<=": cr, array: Ve, at: Re, boolean: Ve, case: qe, coalesce: rr, collator: pr, format: dr, image: yr, in: je, "index-of": Ne, interpolate: Qe, "interpolate-hcl": Qe, "interpolate-lab": Qe, length: mr, let: Oe, literal: Ce, match: Ue, number: Ve, "number-format": fr, object: Ve, slice: Ge, step: Xe, string: Ve, "to-boolean": Te, "to-color": Te, "to-number": Te, "to-string": Te, var: De, within: Fr, distance: yn }; class gn { constructor(t, e, r, n) { this.name = t, this.type = e, this._evaluate = r, this.args = n; } evaluate(t) { return this._evaluate(t, this.args) } eachChild(t) { this.args.forEach(t); } outputDefined() { return !1 } static parse(t, e) { const r = t[0], n = gn.definitions[r]; if (!n) return e.error(`Unknown expression "${r}". If you wanted a literal array, use ["literal", [...]].`, 0); const i = Array.isArray(n) ? n[0] : n.type, s = Array.isArray(n) ? [[n[1], n[2]]] : n.overloads, a = s.filter((([e]) => !Array.isArray(e) || e.length === t.length - 1)); let o = null; for (const [n, s] of a) { o = new Le(e.registry, _n, e.path, null, e.scope); const a = []; let l = !1; for (let e = 1; e < t.length; e++) { const r = t[e], i = Array.isArray(n) ? n[e - 1] : n.type, s = o.parse(r, 1 + a.length, i); if (!s) { l = !0; break } a.push(s); } if (!l) if (Array.isArray(n) && n.length !== a.length) o.error(`Expected ${n.length} arguments, but found ${a.length} instead.`); else { for (let t = 0; t < a.length; t++) { const e = Array.isArray(n) ? n[t] : n.type, r = a[t]; o.concat(t + 1).checkSubtype(e, r.type); } if (0 === o.errors.length) return new gn(r, i, s, a) } } if (1 === a.length) e.errors.push(...o.errors); else { const r = (a.length ? a : s).map((([t]) => { return e = t, Array.isArray(e) ? `(${e.map(jt).join(", ")})` : `(${jt(e.type)}...)`; var e; })).join(" | "), n = []; for (let r = 1; r < t.length; r++) { const i = e.parse(t[r], 1 + n.length); if (!i) return null; n.push(jt(i.type)); } e.error(`Expected arguments of type ${r}, but found (${n.join(", ")}) instead.`); } return null } static register(t, e) { gn.definitions = e; for (const r in e) t[r] = gn; } } function xn(t, [e, r, n, i]) { e = e.evaluate(t), r = r.evaluate(t), n = n.evaluate(t); const s = i ? i.evaluate(t) : 1, a = Me(e, r, n, s); if (a) throw new we(a); return new ye(e / 255, r / 255, n / 255, s, !1) } function vn(t, e) { return t in e } function bn(t, e) { const r = e[t]; return void 0 === r ? null : r } function wn(t) { return { type: t } } function _n(t) { if (t instanceof De) return _n(t.boundExpression); if (t instanceof gn && "error" === t.name) return !1; if (t instanceof pr) return !1; if (t instanceof Fr) return !1; if (t instanceof yn) return !1; const e = t instanceof Te || t instanceof Ve; let r = !0; return t.eachChild((t => { r = e ? r && _n(t) : r && t instanceof Ce; })), !!r && Sn(t) && kn(t, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]) } function Sn(t) { if (t instanceof gn) { if ("get" === t.name && 1 === t.args.length) return !1; if ("feature-state" === t.name) return !1; if ("has" === t.name && 1 === t.args.length) return !1; if ("properties" === t.name || "geometry-type" === t.name || "id" === t.name) return !1; if (/^filter-/.test(t.name)) return !1 } if (t instanceof Fr) return !1; if (t instanceof yn) return !1; let e = !0; return t.eachChild((t => { e && !Sn(t) && (e = !1); })), e } function An(t) { if (t instanceof gn && "feature-state" === t.name) return !1; let e = !0; return t.eachChild((t => { e && !An(t) && (e = !1); })), e } function kn(t, e) { if (t instanceof gn && e.indexOf(t.name) >= 0) return !1; let r = !0; return t.eachChild((t => { r && !kn(t, e) && (r = !1); })), r } function Mn(t) { return { result: "success", value: t } } function In(t) { return { result: "error", value: t } } function zn(t) { return "data-driven" === t["property-type"] || "cross-faded-data-driven" === t["property-type"] } function Pn(t) { return !!t.expression && t.expression.parameters.indexOf("zoom") > -1 } function Cn(t) { return !!t.expression && t.expression.interpolated } function Bn(t) { return t instanceof Number ? "number" : t instanceof String ? "string" : t instanceof Boolean ? "boolean" : Array.isArray(t) ? "array" : null === t ? "null" : typeof t } function Vn(t) { return "object" == typeof t && null !== t && !Array.isArray(t) } function En(t) { return t } function Tn(t, e) { const r = "color" === e.type, n = t.stops && "object" == typeof t.stops[0][0], i = n || !(n || void 0 !== t.property), s = t.type || (Cn(e) ? "exponential" : "interval"); if (r || "padding" === e.type) { const n = r ? ye.parse : be.parse; (t = At({}, t)).stops && (t.stops = t.stops.map((t => [t[0], n(t[1])]))), t.default = n(t.default ? t.default : e.default); } if (t.colorSpace && "rgb" !== (a = t.colorSpace) && "hcl" !== a && "lab" !== a) throw new Error(`Unknown color space: "${t.colorSpace}"`); var a; let o, l, u; if ("exponential" === s) o = On; else if ("interval" === s) o = Ln; else if ("categorical" === s) { o = $n, l = Object.create(null); for (const e of t.stops) l[e[0]] = e[1]; u = typeof t.stops[0][0]; } else { if ("identity" !== s) throw new Error(`Unknown function type "${s}"`); o = Dn; } if (n) { const r = {}, n = []; for (let e = 0; e < t.stops.length; e++) { const i = t.stops[e], s = i[0].zoom; void 0 === r[s] && (r[s] = { zoom: s, type: t.type, property: t.property, default: t.default, stops: [] }, n.push(s)), r[s].stops.push([i[0].value, i[1]]); } const i = []; for (const t of n) i.push([r[t].zoom, Tn(r[t], e)]); const s = { name: "linear" }; return { kind: "composite", interpolationType: s, interpolationFactor: Qe.interpolationFactor.bind(void 0, s), zoomStops: i.map((t => t[0])), evaluate: ({ zoom: r }, n) => On({ stops: i, base: t.base }, e, r).evaluate(r, n) } } if (i) { const r = "exponential" === s ? { name: "exponential", base: void 0 !== t.base ? t.base : 1 } : null; return { kind: "camera", interpolationType: r, interpolationFactor: Qe.interpolationFactor.bind(void 0, r), zoomStops: t.stops.map((t => t[0])), evaluate: ({ zoom: r }) => o(t, e, r, l, u) } } return { kind: "source", evaluate(r, n) { const i = n && n.properties ? n.properties[t.property] : void 0; return void 0 === i ? Fn(t.default, e.default) : o(t, e, i, l, u) } } } function Fn(t, e, r) { return void 0 !== t ? t : void 0 !== e ? e : void 0 !== r ? r : void 0 } function $n(t, e, r, n, i) { return Fn(typeof r === i ? n[r] : void 0, t.default, e.default) } function Ln(t, e, r) { if ("number" !== Bn(r)) return Fn(t.default, e.default); const n = t.stops.length; if (1 === n) return t.stops[0][1]; if (r <= t.stops[0][0]) return t.stops[0][1]; if (r >= t.stops[n - 1][0]) return t.stops[n - 1][1]; const i = Ze(t.stops.map((t => t[0])), r); return t.stops[i][1] } function On(t, e, r) { const n = void 0 !== t.base ? t.base : 1; if ("number" !== Bn(r)) return Fn(t.default, e.default); const i = t.stops.length; if (1 === i) return t.stops[0][1]; if (r <= t.stops[0][0]) return t.stops[0][1]; if (r >= t.stops[i - 1][0]) return t.stops[i - 1][1]; const s = Ze(t.stops.map((t => t[0])), r), a = function (t, e, r, n) { const i = n - r, s = t - r; return 0 === i ? 0 : 1 === e ? s / i : (Math.pow(e, s) - 1) / (Math.pow(e, i) - 1) }(r, n, t.stops[s][0], t.stops[s + 1][0]), o = t.stops[s][1], l = t.stops[s + 1][1], u = er[e.type] || En; return "function" == typeof o.evaluate ? { evaluate(...e) { const r = o.evaluate.apply(void 0, e), n = l.evaluate.apply(void 0, e); if (void 0 !== r && void 0 !== n) return u(r, n, a, t.colorSpace) } } : u(o, l, a, t.colorSpace) } function Dn(t, e, r) { switch (e.type) { case "color": r = ye.parse(r); break; case "formatted": r = ve.fromString(r.toString()); break; case "resolvedImage": r = Ae.fromString(r.toString()); break; case "padding": r = be.parse(r); break; default: Bn(r) === e.type || "enum" === e.type && e.values[r] || (r = void 0); }return Fn(r, t.default, e.default) } gn.register(mn, { error: [{ kind: "error" }, [Pt], (t, [e]) => { throw new we(e.evaluate(t)) }], typeof: [Pt, [Tt], (t, [e]) => jt(ze(e.evaluate(t)))], "to-rgba": [Rt(zt, 4), [Bt], (t, [e]) => { const [r, n, i, s] = e.evaluate(t).rgb; return [255 * r, 255 * n, 255 * i, s] }], rgb: [Bt, [zt, zt, zt], xn], rgba: [Bt, [zt, zt, zt, zt], xn], has: { type: Ct, overloads: [[[Pt], (t, [e]) => vn(e.evaluate(t), t.properties())], [[Pt, Et], (t, [e, r]) => vn(e.evaluate(t), r.evaluate(t))]] }, get: { type: Tt, overloads: [[[Pt], (t, [e]) => bn(e.evaluate(t), t.properties())], [[Pt, Et], (t, [e, r]) => bn(e.evaluate(t), r.evaluate(t))]] }, "feature-state": [Tt, [Pt], (t, [e]) => bn(e.evaluate(t), t.featureState || {})], properties: [Et, [], t => t.properties()], "geometry-type": [Pt, [], t => t.geometryType()], id: [Tt, [], t => t.id()], zoom: [zt, [], t => t.globals.zoom], "heatmap-density": [zt, [], t => t.globals.heatmapDensity || 0], "line-progress": [zt, [], t => t.globals.lineProgress || 0], accumulated: [Tt, [], t => void 0 === t.globals.accumulated ? null : t.globals.accumulated], "+": [zt, wn(zt), (t, e) => { let r = 0; for (const n of e) r += n.evaluate(t); return r }], "*": [zt, wn(zt), (t, e) => { let r = 1; for (const n of e) r *= n.evaluate(t); return r }], "-": { type: zt, overloads: [[[zt, zt], (t, [e, r]) => e.evaluate(t) - r.evaluate(t)], [[zt], (t, [e]) => -e.evaluate(t)]] }, "/": [zt, [zt, zt], (t, [e, r]) => e.evaluate(t) / r.evaluate(t)], "%": [zt, [zt, zt], (t, [e, r]) => e.evaluate(t) % r.evaluate(t)], ln2: [zt, [], () => Math.LN2], pi: [zt, [], () => Math.PI], e: [zt, [], () => Math.E], "^": [zt, [zt, zt], (t, [e, r]) => Math.pow(e.evaluate(t), r.evaluate(t))], sqrt: [zt, [zt], (t, [e]) => Math.sqrt(e.evaluate(t))], log10: [zt, [zt], (t, [e]) => Math.log(e.evaluate(t)) / Math.LN10], ln: [zt, [zt], (t, [e]) => Math.log(e.evaluate(t))], log2: [zt, [zt], (t, [e]) => Math.log(e.evaluate(t)) / Math.LN2], sin: [zt, [zt], (t, [e]) => Math.sin(e.evaluate(t))], cos: [zt, [zt], (t, [e]) => Math.cos(e.evaluate(t))], tan: [zt, [zt], (t, [e]) => Math.tan(e.evaluate(t))], asin: [zt, [zt], (t, [e]) => Math.asin(e.evaluate(t))], acos: [zt, [zt], (t, [e]) => Math.acos(e.evaluate(t))], atan: [zt, [zt], (t, [e]) => Math.atan(e.evaluate(t))], min: [zt, wn(zt), (t, e) => Math.min(...e.map((e => e.evaluate(t))))], max: [zt, wn(zt), (t, e) => Math.max(...e.map((e => e.evaluate(t))))], abs: [zt, [zt], (t, [e]) => Math.abs(e.evaluate(t))], round: [zt, [zt], (t, [e]) => { const r = e.evaluate(t); return r < 0 ? -Math.round(-r) : Math.round(r) }], floor: [zt, [zt], (t, [e]) => Math.floor(e.evaluate(t))], ceil: [zt, [zt], (t, [e]) => Math.ceil(e.evaluate(t))], "filter-==": [Ct, [Pt, Tt], (t, [e, r]) => t.properties()[e.value] === r.value], "filter-id-==": [Ct, [Tt], (t, [e]) => t.id() === e.value], "filter-type-==": [Ct, [Pt], (t, [e]) => t.geometryType() === e.value], "filter-<": [Ct, [Pt, Tt], (t, [e, r]) => { const n = t.properties()[e.value], i = r.value; return typeof n == typeof i && n < i }], "filter-id-<": [Ct, [Tt], (t, [e]) => { const r = t.id(), n = e.value; return typeof r == typeof n && r < n }], "filter->": [Ct, [Pt, Tt], (t, [e, r]) => { const n = t.properties()[e.value], i = r.value; return typeof n == typeof i && n > i }], "filter-id->": [Ct, [Tt], (t, [e]) => { const r = t.id(), n = e.value; return typeof r == typeof n && r > n }], "filter-<=": [Ct, [Pt, Tt], (t, [e, r]) => { const n = t.properties()[e.value], i = r.value; return typeof n == typeof i && n <= i }], "filter-id-<=": [Ct, [Tt], (t, [e]) => { const r = t.id(), n = e.value; return typeof r == typeof n && r <= n }], "filter->=": [Ct, [Pt, Tt], (t, [e, r]) => { const n = t.properties()[e.value], i = r.value; return typeof n == typeof i && n >= i }], "filter-id->=": [Ct, [Tt], (t, [e]) => { const r = t.id(), n = e.value; return typeof r == typeof n && r >= n }], "filter-has": [Ct, [Tt], (t, [e]) => e.value in t.properties()], "filter-has-id": [Ct, [], t => null !== t.id() && void 0 !== t.id()], "filter-type-in": [Ct, [Rt(Pt)], (t, [e]) => e.value.indexOf(t.geometryType()) >= 0], "filter-id-in": [Ct, [Rt(Tt)], (t, [e]) => e.value.indexOf(t.id()) >= 0], "filter-in-small": [Ct, [Pt, Rt(Tt)], (t, [e, r]) => r.value.indexOf(t.properties()[e.value]) >= 0], "filter-in-large": [Ct, [Pt, Rt(Tt)], (t, [e, r]) => function (t, e, r, n) { for (; r <= n;) { const i = r + n >> 1; if (e[i] === t) return !0; e[i] > t ? n = i - 1 : r = i + 1; } return !1 }(t.properties()[e.value], r.value, 0, r.value.length - 1)], all: { type: Ct, overloads: [[[Ct, Ct], (t, [e, r]) => e.evaluate(t) && r.evaluate(t)], [wn(Ct), (t, e) => { for (const r of e) if (!r.evaluate(t)) return !1; return !0 }]] }, any: { type: Ct, overloads: [[[Ct, Ct], (t, [e, r]) => e.evaluate(t) || r.evaluate(t)], [wn(Ct), (t, e) => { for (const r of e) if (r.evaluate(t)) return !0; return !1 }]] }, "!": [Ct, [Ct], (t, [e]) => !e.evaluate(t)], "is-supported-script": [Ct, [Pt], (t, [e]) => { const r = t.globals && t.globals.isSupportedScript; return !r || r(e.evaluate(t)) }], upcase: [Pt, [Pt], (t, [e]) => e.evaluate(t).toUpperCase()], downcase: [Pt, [Pt], (t, [e]) => e.evaluate(t).toLowerCase()], concat: [Pt, wn(Tt), (t, e) => e.map((e => Pe(e.evaluate(t)))).join("")], "resolved-locale": [Pt, [Ft], (t, [e]) => e.evaluate(t).resolvedLocale()] }); class Rn { constructor(t, e) { var r; this.expression = t, this._warningHistory = {}, this._evaluator = new $e, this._defaultValue = e ? "color" === (r = e).type && Vn(r.default) ? new ye(0, 0, 0, 0) : "color" === r.type ? ye.parse(r.default) || null : "padding" === r.type ? be.parse(r.default) || null : "variableAnchorOffsetCollection" === r.type ? Se.parse(r.default) || null : "projectionDefinition" === r.type ? ke.parse(r.default) || null : void 0 === r.default ? null : r.default : null, this._enumValues = e && "enum" === e.type ? e.values : null; } evaluateWithoutErrorHandling(t, e, r, n, i, s) { return this._evaluator.globals = t, this._evaluator.feature = e, this._evaluator.featureState = r, this._evaluator.canonical = n, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = s, this.expression.evaluate(this._evaluator) } evaluate(t, e, r, n, i, s) { this._evaluator.globals = t, this._evaluator.feature = e || null, this._evaluator.featureState = r || null, this._evaluator.canonical = n, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = s || null; try { const t = this.expression.evaluate(this._evaluator); if (null == t || "number" == typeof t && t != t) return this._defaultValue; if (this._enumValues && !(t in this._enumValues)) throw new we(`Expected value to be one of ${Object.keys(this._enumValues).map((t => JSON.stringify(t))).join(", ")}, but found ${JSON.stringify(t)} instead.`); return t } catch (t) { return this._warningHistory[t.message] || (this._warningHistory[t.message] = !0, "undefined" != typeof console && console.warn(t.message)), this._defaultValue } } } function jn(t) { return Array.isArray(t) && t.length > 0 && "string" == typeof t[0] && t[0] in mn } function Nn(t, e) { const r = new Le(mn, _n, [], e ? function (t) { const e = { color: Bt, string: Pt, number: zt, enum: Pt, boolean: Ct, formatted: $t, padding: Lt, projectionDefinition: Vt, resolvedImage: Ot, variableAnchorOffsetCollection: Dt }; return "array" === t.type ? Rt(e[t.value] || Tt, t.length) : e[t.type] }(e) : void 0), n = r.parse(t, void 0, void 0, void 0, e && "string" === e.type ? { typeAnnotation: "coerce" } : void 0); return n ? Mn(new Rn(n, e)) : In(r.errors) } class Un { constructor(t, e) { this.kind = t, this._styleExpression = e, this.isStateDependent = "constant" !== t && !An(e.expression); } evaluateWithoutErrorHandling(t, e, r, n, i, s) { return this._styleExpression.evaluateWithoutErrorHandling(t, e, r, n, i, s) } evaluate(t, e, r, n, i, s) { return this._styleExpression.evaluate(t, e, r, n, i, s) } } class qn { constructor(t, e, r, n) { this.kind = t, this.zoomStops = r, this._styleExpression = e, this.isStateDependent = "camera" !== t && !An(e.expression), this.interpolationType = n; } evaluateWithoutErrorHandling(t, e, r, n, i, s) { return this._styleExpression.evaluateWithoutErrorHandling(t, e, r, n, i, s) } evaluate(t, e, r, n, i, s) { return this._styleExpression.evaluate(t, e, r, n, i, s) } interpolationFactor(t, e, r) { return this.interpolationType ? Qe.interpolationFactor(this.interpolationType, t, e, r) : 0 } } function Gn(t, e) { const r = Nn(t, e); if ("error" === r.result) return r; const n = r.value.expression, i = Sn(n); if (!i && !zn(e)) return In([new kt("", "data expressions not supported")]); const s = kn(n, ["zoom"]); if (!s && !Pn(e)) return In([new kt("", "zoom expressions not supported")]); const a = Xn(n); return a || s ? a instanceof kt ? In([a]) : a instanceof Qe && !Cn(e) ? In([new kt("", '"interpolate" expressions cannot be used with this property')]) : Mn(a ? new qn(i ? "camera" : "composite", r.value, a.labels, a instanceof Qe ? a.interpolation : void 0) : new Un(i ? "constant" : "source", r.value)) : In([new kt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]) } class Zn { constructor(t, e) { this._parameters = t, this._specification = e, At(this, Tn(this._parameters, this._specification)); } static deserialize(t) { return new Zn(t._parameters, t._specification) } static serialize(t) { return { _parameters: t._parameters, _specification: t._specification } } } function Xn(t) { let e = null; if (t instanceof Oe) e = Xn(t.result); else if (t instanceof rr) { for (const r of t.args) if (e = Xn(r), e) break } else (t instanceof Xe || t instanceof Qe) && t.input instanceof gn && "zoom" === t.input.name && (e = t); return e instanceof kt || t.eachChild((t => { const r = Xn(t); r instanceof kt ? e = r : !e && r ? e = new kt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e && r && e !== r && (e = new kt("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.')); })), e } function Kn(t) { if (!0 === t || !1 === t) return !0; if (!Array.isArray(t) || 0 === t.length) return !1; switch (t[0]) { case "has": return t.length >= 2 && "$id" !== t[1] && "$type" !== t[1]; case "in": return t.length >= 3 && ("string" != typeof t[1] || Array.isArray(t[2])); case "!in": case "!has": case "none": return !1; case "==": case "!=": case ">": case ">=": case "<": case "<=": return 3 !== t.length || Array.isArray(t[1]) || Array.isArray(t[2]); case "any": case "all": for (const e of t.slice(1)) if (!Kn(e) && "boolean" != typeof e) return !1; return !0; default: return !0 } } const Hn = { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } }; function Yn(t) { if (null == t) return { filter: () => !0, needGeometry: !1 }; Kn(t) || (t = Qn(t)); const e = Nn(t, Hn); if ("error" === e.result) throw new Error(e.value.map((t => `${t.key}: ${t.message}`)).join(", ")); return { filter: (t, r, n) => e.value.evaluate(t, r, {}, n), needGeometry: Wn(t) } } function Jn(t, e) { return t < e ? -1 : t > e ? 1 : 0 } function Wn(t) { if (!Array.isArray(t)) return !1; if ("within" === t[0] || "distance" === t[0]) return !0; for (let e = 1; e < t.length; e++)if (Wn(t[e])) return !0; return !1 } function Qn(t) { if (!t) return !0; const e = t[0]; return t.length <= 1 ? "any" !== e : "==" === e ? ti(t[1], t[2], "==") : "!=" === e ? ni(ti(t[1], t[2], "==")) : "<" === e || ">" === e || "<=" === e || ">=" === e ? ti(t[1], t[2], e) : "any" === e ? (r = t.slice(1), ["any"].concat(r.map(Qn))) : "all" === e ? ["all"].concat(t.slice(1).map(Qn)) : "none" === e ? ["all"].concat(t.slice(1).map(Qn).map(ni)) : "in" === e ? ei(t[1], t.slice(2)) : "!in" === e ? ni(ei(t[1], t.slice(2))) : "has" === e ? ri(t[1]) : "!has" !== e || ni(ri(t[1])); var r; } function ti(t, e, r) { switch (t) { case "$type": return [`filter-type-${r}`, e]; case "$id": return [`filter-id-${r}`, e]; default: return [`filter-${r}`, t, e] } } function ei(t, e) { if (0 === e.length) return !1; switch (t) { case "$type": return ["filter-type-in", ["literal", e]]; case "$id": return ["filter-id-in", ["literal", e]]; default: return e.length > 200 && !e.some((t => typeof t != typeof e[0])) ? ["filter-in-large", t, ["literal", e.sort(Jn)]] : ["filter-in-small", t, ["literal", e]] } } function ri(t) { switch (t) { case "$type": return !0; case "$id": return ["filter-has-id"]; default: return ["filter-has", t] } } function ni(t) { return ["!", t] } function ii(t) { const e = typeof t; if ("number" === e || "boolean" === e || "string" === e || null == t) return JSON.stringify(t); if (Array.isArray(t)) { let e = "["; for (const r of t) e += `${ii(r)},`; return `${e}]` } const r = Object.keys(t).sort(); let n = "{"; for (let e = 0; e < r.length; e++)n += `${JSON.stringify(r[e])}:${ii(t[r[e]])},`; return `${n}}` } function si(t) { let e = ""; for (const r of pt) e += `/${ii(t[r])}`; return e } function ai(t) { const e = t.value; return e ? [new St(t.key, e, "constants have been deprecated as of v8")] : [] } function oi(t) { return t instanceof Number || t instanceof String || t instanceof Boolean ? t.valueOf() : t } function li(t) { if (Array.isArray(t)) return t.map(li); if (t instanceof Object && !(t instanceof Number || t instanceof String || t instanceof Boolean)) { const e = {}; for (const r in t) e[r] = li(t[r]); return e } return oi(t) } function ui(t) { const e = t.key, r = t.value, n = t.valueSpec || {}, i = t.objectElementValidators || {}, s = t.style, a = t.styleSpec, o = t.validateSpec; let l = []; const u = Bn(r); if ("object" !== u) return [new St(e, r, `object expected, ${u} found`)]; for (const t in r) { const u = t.split(".")[0], c = n[u] || n["*"]; let h; if (i[u]) h = i[u]; else if (n[u]) h = o; else if (i["*"]) h = i["*"]; else { if (!n["*"]) { l.push(new St(e, r[t], `unknown property "${t}"`)); continue } h = o; } l = l.concat(h({ key: (e ? `${e}.` : e) + t, value: r[t], valueSpec: c, style: s, styleSpec: a, object: r, objectKey: t, validateSpec: o }, r)); } for (const t in n) i[t] || n[t].required && void 0 === n[t].default && void 0 === r[t] && l.push(new St(e, r, `missing required property "${t}"`)); return l } function ci(t) { const e = t.value, r = t.valueSpec, n = t.style, i = t.styleSpec, s = t.key, a = t.arrayElementValidator || t.validateSpec; if ("array" !== Bn(e)) return [new St(s, e, `array expected, ${Bn(e)} found`)]; if (r.length && e.length !== r.length) return [new St(s, e, `array length ${r.length} expected, length ${e.length} found`)]; if (r["min-length"] && e.length < r["min-length"]) return [new St(s, e, `array length at least ${r["min-length"]} expected, length ${e.length} found`)]; let o = { type: r.value, values: r.values }; i.$version < 7 && (o.function = r.function), "object" === Bn(r.value) && (o = r.value); let l = []; for (let r = 0; r < e.length; r++)l = l.concat(a({ array: e, arrayIndex: r, value: e[r], valueSpec: o, validateSpec: t.validateSpec, style: n, styleSpec: i, key: `${s}[${r}]` })); return l } function hi(t) { const e = t.key, r = t.value, n = t.valueSpec; let i = Bn(r); return "number" === i && r != r && (i = "NaN"), "number" !== i ? [new St(e, r, `number expected, ${i} found`)] : "minimum" in n && r < n.minimum ? [new St(e, r, `${r} is less than the minimum value ${n.minimum}`)] : "maximum" in n && r > n.maximum ? [new St(e, r, `${r} is greater than the maximum value ${n.maximum}`)] : [] } function pi(t) { const e = t.valueSpec, r = oi(t.value.type); let n, i, s, a = {}; const o = "categorical" !== r && void 0 === t.value.property, l = !o, u = "array" === Bn(t.value.stops) && "array" === Bn(t.value.stops[0]) && "object" === Bn(t.value.stops[0][0]), c = ui({ key: t.key, value: t.value, valueSpec: t.styleSpec.function, validateSpec: t.validateSpec, style: t.style, styleSpec: t.styleSpec, objectElementValidators: { stops: function (t) { if ("identity" === r) return [new St(t.key, t.value, 'identity function may not have a "stops" property')]; let e = []; const n = t.value; return e = e.concat(ci({ key: t.key, value: n, valueSpec: t.valueSpec, validateSpec: t.validateSpec, style: t.style, styleSpec: t.styleSpec, arrayElementValidator: h })), "array" === Bn(n) && 0 === n.length && e.push(new St(t.key, n, "array must have at least one stop")), e }, default: function (t) { return t.validateSpec({ key: t.key, value: t.value, valueSpec: e, validateSpec: t.validateSpec, style: t.style, styleSpec: t.styleSpec }) } } }); return "identity" === r && o && c.push(new St(t.key, t.value, 'missing required property "property"')), "identity" === r || t.value.stops || c.push(new St(t.key, t.value, 'missing required property "stops"')), "exponential" === r && t.valueSpec.expression && !Cn(t.valueSpec) && c.push(new St(t.key, t.value, "exponential functions not supported")), t.styleSpec.$version >= 8 && (l && !zn(t.valueSpec) ? c.push(new St(t.key, t.value, "property functions not supported")) : o && !Pn(t.valueSpec) && c.push(new St(t.key, t.value, "zoom functions not supported"))), "categorical" !== r && !u || void 0 !== t.value.property || c.push(new St(t.key, t.value, '"property" property is required')), c; function h(t) { let r = []; const n = t.value, o = t.key; if ("array" !== Bn(n)) return [new St(o, n, `array expected, ${Bn(n)} found`)]; if (2 !== n.length) return [new St(o, n, `array length 2 expected, length ${n.length} found`)]; if (u) { if ("object" !== Bn(n[0])) return [new St(o, n, `object expected, ${Bn(n[0])} found`)]; if (void 0 === n[0].zoom) return [new St(o, n, "object stop key must have zoom")]; if (void 0 === n[0].value) return [new St(o, n, "object stop key must have value")]; if (s && s > oi(n[0].zoom)) return [new St(o, n[0].zoom, "stop zoom values must appear in ascending order")]; oi(n[0].zoom) !== s && (s = oi(n[0].zoom), i = void 0, a = {}), r = r.concat(ui({ key: `${o}[0]`, value: n[0], valueSpec: { zoom: {} }, validateSpec: t.validateSpec, style: t.style, styleSpec: t.styleSpec, objectElementValidators: { zoom: hi, value: p } })); } else r = r.concat(p({ key: `${o}[0]`, value: n[0], valueSpec: {}, validateSpec: t.validateSpec, style: t.style, styleSpec: t.styleSpec }, n)); return jn(li(n[1])) ? r.concat([new St(`${o}[1]`, n[1], "expressions are not allowed in function stops.")]) : r.concat(t.validateSpec({ key: `${o}[1]`, value: n[1], valueSpec: e, validateSpec: t.validateSpec, style: t.style, styleSpec: t.styleSpec })) } function p(t, s) { const o = Bn(t.value), l = oi(t.value), u = null !== t.value ? t.value : s; if (n) { if (o !== n) return [new St(t.key, u, `${o} stop domain type must match previous stop domain type ${n}`)] } else n = o; if ("number" !== o && "string" !== o && "boolean" !== o) return [new St(t.key, u, "stop domain value must be a number, string, or boolean")]; if ("number" !== o && "categorical" !== r) { let n = `number expected, ${o} found`; return zn(e) && void 0 === r && (n += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new St(t.key, u, n)] } return "categorical" !== r || "number" !== o || isFinite(l) && Math.floor(l) === l ? "categorical" !== r && "number" === o && void 0 !== i && l < i ? [new St(t.key, u, "stop domain values must appear in ascending order")] : (i = l, "categorical" === r && l in a ? [new St(t.key, u, "stop domain values must be unique")] : (a[l] = !0, [])) : [new St(t.key, u, `integer expected, found ${l}`)] } } function fi(t) { const e = ("property" === t.expressionContext ? Gn : Nn)(li(t.value), t.valueSpec); if ("error" === e.result) return e.value.map((e => new St(`${t.key}${e.key}`, t.value, e.message))); const r = e.value.expression || e.value._styleExpression.expression; if ("property" === t.expressionContext && "text-font" === t.propertyKey && !r.outputDefined()) return [new St(t.key, t.value, `Invalid data expression for "${t.propertyKey}". Output values must be contained as literals within the expression.`)]; if ("property" === t.expressionContext && "layout" === t.propertyType && !An(r)) return [new St(t.key, t.value, '"feature-state" data expressions are not supported with layout properties.')]; if ("filter" === t.expressionContext && !An(r)) return [new St(t.key, t.value, '"feature-state" data expressions are not supported with filters.')]; if (t.expressionContext && 0 === t.expressionContext.indexOf("cluster")) { if (!kn(r, ["zoom", "feature-state"])) return [new St(t.key, t.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')]; if ("cluster-initial" === t.expressionContext && !Sn(r)) return [new St(t.key, t.value, "Feature data expressions are not supported with initial expression part of cluster properties.")] } return [] } function di(t) { const e = t.key, r = t.value, n = t.valueSpec, i = []; return Array.isArray(n.values) ? -1 === n.values.indexOf(oi(r)) && i.push(new St(e, r, `expected one of [${n.values.join(", ")}], ${JSON.stringify(r)} found`)) : -1 === Object.keys(n.values).indexOf(oi(r)) && i.push(new St(e, r, `expected one of [${Object.keys(n.values).join(", ")}], ${JSON.stringify(r)} found`)), i } function yi(t) { return Kn(li(t.value)) ? fi(At({}, t, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : mi(t) } function mi(t) { const e = t.value, r = t.key; if ("array" !== Bn(e)) return [new St(r, e, `array expected, ${Bn(e)} found`)]; const n = t.styleSpec; let i, s = []; if (e.length < 1) return [new St(r, e, "filter array must have at least 1 element")]; switch (s = s.concat(di({ key: `${r}[0]`, value: e[0], valueSpec: n.filter_operator, style: t.style, styleSpec: t.styleSpec })), oi(e[0])) { case "<": case "<=": case ">": case ">=": e.length >= 2 && "$type" === oi(e[1]) && s.push(new St(r, e, `"$type" cannot be use with operator "${e[0]}"`)); case "==": case "!=": 3 !== e.length && s.push(new St(r, e, `filter array for operator "${e[0]}" must have 3 elements`)); case "in": case "!in": e.length >= 2 && (i = Bn(e[1]), "string" !== i && s.push(new St(`${r}[1]`, e[1], `string expected, ${i} found`))); for (let a = 2; a < e.length; a++)i = Bn(e[a]), "$type" === oi(e[1]) ? s = s.concat(di({ key: `${r}[${a}]`, value: e[a], valueSpec: n.geometry_type, style: t.style, styleSpec: t.styleSpec })) : "string" !== i && "number" !== i && "boolean" !== i && s.push(new St(`${r}[${a}]`, e[a], `string, number, or boolean expected, ${i} found`)); break; case "any": case "all": case "none": for (let n = 1; n < e.length; n++)s = s.concat(mi({ key: `${r}[${n}]`, value: e[n], style: t.style, styleSpec: t.styleSpec })); break; case "has": case "!has": i = Bn(e[1]), 2 !== e.length ? s.push(new St(r, e, `filter array for "${e[0]}" operator must have 2 elements`)) : "string" !== i && s.push(new St(`${r}[1]`, e[1], `string expected, ${i} found`)); }return s } function gi(t, e) { const r = t.key, n = t.validateSpec, i = t.style, s = t.styleSpec, a = t.value, o = t.objectKey, l = s[`${e}_${t.layerType}`]; if (!l) return []; const u = o.match(/^(.*)-transition$/); if ("paint" === e && u && l[u[1]] && l[u[1]].transition) return n({ key: r, value: a, valueSpec: s.transition, style: i, styleSpec: s }); const c = t.valueSpec || l[o]; if (!c) return [new St(r, a, `unknown property "${o}"`)]; let h; if ("string" === Bn(a) && zn(c) && !c.tokens && (h = /^{([^}]+)}$/.exec(a))) return [new St(r, a, `"${o}" does not support interpolation syntax\nUse an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(h[1])} }\`.`)]; const p = []; return "symbol" === t.layerType && ("text-field" === o && i && !i.glyphs && p.push(new St(r, a, 'use of "text-field" requires a style "glyphs" property')), "text-font" === o && Vn(li(a)) && "identity" === oi(a.type) && p.push(new St(r, a, '"text-font" does not support identity functions'))), p.concat(n({ key: t.key, value: a, valueSpec: c, style: i, styleSpec: s, expressionContext: "property", propertyType: e, propertyKey: o })) } function xi(t) { return gi(t, "paint") } function vi(t) { return gi(t, "layout") } function bi(t) { let e = []; const r = t.value, n = t.key, i = t.style, s = t.styleSpec; r.type || r.ref || e.push(new St(n, r, 'either "type" or "ref" is required')); let a = oi(r.type); const o = oi(r.ref); if (r.id) { const s = oi(r.id); for (let a = 0; a < t.arrayIndex; a++) { const t = i.layers[a]; oi(t.id) === s && e.push(new St(n, r.id, `duplicate layer id "${r.id}", previously used at line ${t.id.__line__}`)); } } if ("ref" in r) { let t;["type", "source", "source-layer", "filter", "layout"].forEach((t => { t in r && e.push(new St(n, r[t], `"${t}" is prohibited for ref layers`)); })), i.layers.forEach((e => { oi(e.id) === o && (t = e); })), t ? t.ref ? e.push(new St(n, r.ref, "ref cannot reference another ref layer")) : a = oi(t.type) : e.push(new St(n, r.ref, `ref layer "${o}" not found`)); } else if ("background" !== a) if (r.source) { const t = i.sources && i.sources[r.source], s = t && oi(t.type); t ? "vector" === s && "raster" === a ? e.push(new St(n, r.source, `layer "${r.id}" requires a raster source`)) : "raster-dem" !== s && "hillshade" === a ? e.push(new St(n, r.source, `layer "${r.id}" requires a raster-dem source`)) : "raster" === s && "raster" !== a ? e.push(new St(n, r.source, `layer "${r.id}" requires a vector source`)) : "vector" !== s || r["source-layer"] ? "raster-dem" === s && "hillshade" !== a ? e.push(new St(n, r.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== a || !r.paint || !r.paint["line-gradient"] || "geojson" === s && t.lineMetrics || e.push(new St(n, r, `layer "${r.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e.push(new St(n, r, `layer "${r.id}" must specify a "source-layer"`)) : e.push(new St(n, r.source, `source "${r.source}" not found`)); } else e.push(new St(n, r, 'missing required property "source"')); return e = e.concat(ui({ key: n, value: r, valueSpec: s.layer, style: t.style, styleSpec: t.styleSpec, validateSpec: t.validateSpec, objectElementValidators: { "*": () => [], type: () => t.validateSpec({ key: `${n}.type`, value: r.type, valueSpec: s.layer.type, style: t.style, styleSpec: t.styleSpec, validateSpec: t.validateSpec, object: r, objectKey: "type" }), filter: yi, layout: t => ui({ layer: r, key: t.key, value: t.value, style: t.style, styleSpec: t.styleSpec, validateSpec: t.validateSpec, objectElementValidators: { "*": t => vi(At({ layerType: a }, t)) } }), paint: t => ui({ layer: r, key: t.key, value: t.value, style: t.style, styleSpec: t.styleSpec, validateSpec: t.validateSpec, objectElementValidators: { "*": t => xi(At({ layerType: a }, t)) } }) } })), e } function wi(t) { const e = t.value, r = t.key, n = Bn(e); return "string" !== n ? [new St(r, e, `string expected, ${n} found`)] : [] } const _i = { promoteId: function ({ key: t, value: e }) { if ("string" === Bn(e)) return wi({ key: t, value: e }); { const r = []; for (const n in e) r.push(...wi({ key: `${t}.${n}`, value: e[n] })); return r } } }; function Si(t) { const e = t.value, r = t.key, n = t.styleSpec, i = t.style, s = t.validateSpec; if (!e.type) return [new St(r, e, '"type" is required')]; const a = oi(e.type); let o; switch (a) { case "vector": case "raster": return o = ui({ key: r, value: e, valueSpec: n[`source_${a.replace("-", "_")}`], style: t.style, styleSpec: n, objectElementValidators: _i, validateSpec: s }), o; case "raster-dem": return o = function (t) { var e; const r = null !== (e = t.sourceName) && void 0 !== e ? e : "", n = t.value, i = t.styleSpec, s = i.source_raster_dem, a = t.style; let o = []; const l = Bn(n); if (void 0 === n) return o; if ("object" !== l) return o.push(new St("source_raster_dem", n, `object expected, ${l} found`)), o; const u = "custom" === oi(n.encoding), c = ["redFactor", "greenFactor", "blueFactor", "baseShift"], h = t.value.encoding ? `"${t.value.encoding}"` : "Default"; for (const e in n) !u && c.includes(e) ? o.push(new St(e, n[e], `In "${r}": "${e}" is only valid when "encoding" is set to "custom". ${h} encoding found`)) : s[e] ? o = o.concat(t.validateSpec({ key: e, value: n[e], valueSpec: s[e], validateSpec: t.validateSpec, style: a, styleSpec: i })) : o.push(new St(e, n[e], `unknown property "${e}"`)); return o }({ sourceName: r, value: e, style: t.style, styleSpec: n, validateSpec: s }), o; case "geojson": if (o = ui({ key: r, value: e, valueSpec: n.source_geojson, style: i, styleSpec: n, validateSpec: s, objectElementValidators: _i }), e.cluster) for (const t in e.clusterProperties) { const [n, i] = e.clusterProperties[t], a = "string" == typeof n ? [n, ["accumulated"], ["get", t]] : n; o.push(...fi({ key: `${r}.${t}.map`, value: i, validateSpec: s, expressionContext: "cluster-map" })), o.push(...fi({ key: `${r}.${t}.reduce`, value: a, validateSpec: s, expressionContext: "cluster-reduce" })); } return o; case "video": return ui({ key: r, value: e, valueSpec: n.source_video, style: i, validateSpec: s, styleSpec: n }); case "image": return ui({ key: r, value: e, valueSpec: n.source_image, style: i, validateSpec: s, styleSpec: n }); case "canvas": return [new St(r, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")]; default: return di({ key: `${r}.type`, value: e.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: i, validateSpec: s, styleSpec: n }) } } function Ai(t) { const e = t.value, r = t.styleSpec, n = r.light, i = t.style; let s = []; const a = Bn(e); if (void 0 === e) return s; if ("object" !== a) return s = s.concat([new St("light", e, `object expected, ${a} found`)]), s; for (const a in e) { const o = a.match(/^(.*)-transition$/); s = s.concat(o && n[o[1]] && n[o[1]].transition ? t.validateSpec({ key: a, value: e[a], valueSpec: r.transition, validateSpec: t.validateSpec, style: i, styleSpec: r }) : n[a] ? t.validateSpec({ key: a, value: e[a], valueSpec: n[a], validateSpec: t.validateSpec, style: i, styleSpec: r }) : [new St(a, e[a], `unknown property "${a}"`)]); } return s } function ki(t) { const e = t.value, r = t.styleSpec, n = r.sky, i = t.style, s = Bn(e); if (void 0 === e) return []; if ("object" !== s) return [new St("sky", e, `object expected, ${s} found`)]; let a = []; for (const s in e) a = a.concat(n[s] ? t.validateSpec({ key: s, value: e[s], valueSpec: n[s], style: i, styleSpec: r }) : [new St(s, e[s], `unknown property "${s}"`)]); return a } function Mi(t) { const e = t.value, r = t.styleSpec, n = r.terrain, i = t.style; let s = []; const a = Bn(e); if (void 0 === e) return s; if ("object" !== a) return s = s.concat([new St("terrain", e, `object expected, ${a} found`)]), s; for (const a in e) s = s.concat(n[a] ? t.validateSpec({ key: a, value: e[a], valueSpec: n[a], validateSpec: t.validateSpec, style: i, styleSpec: r }) : [new St(a, e[a], `unknown property "${a}"`)]); return s } function Ii(t) { let e = []; const r = t.value, n = t.key; if (Array.isArray(r)) { const i = [], s = []; for (const a in r) r[a].id && i.includes(r[a].id) && e.push(new St(n, r, `all the sprites' ids must be unique, but ${r[a].id} is duplicated`)), i.push(r[a].id), r[a].url && s.includes(r[a].url) && e.push(new St(n, r, `all the sprites' URLs must be unique, but ${r[a].url} is duplicated`)), s.push(r[a].url), e = e.concat(ui({ key: `${n}[${a}]`, value: r[a], valueSpec: { id: { type: "string", required: !0 }, url: { type: "string", required: !0 } }, validateSpec: t.validateSpec })); return e } return wi({ key: n, value: r }) } const zi = { "*": () => [], array: ci, boolean: function (t) { const e = t.value, r = t.key, n = Bn(e); return "boolean" !== n ? [new St(r, e, `boolean expected, ${n} found`)] : [] }, number: hi, color: function (t) { const e = t.key, r = t.value, n = Bn(r); return "string" !== n ? [new St(e, r, `color expected, ${n} found`)] : ye.parse(String(r)) ? [] : [new St(e, r, `color expected, "${r}" found`)] }, constants: ai, enum: di, filter: yi, function: pi, layer: bi, object: ui, source: Si, light: Ai, sky: ki, terrain: Mi, projection: function (t) { const e = t.value, r = t.styleSpec, n = r.projection, i = t.style, s = Bn(e); if (void 0 === e) return []; if ("object" !== s) return [new St("projection", e, `object expected, ${s} found`)]; let a = []; for (const s in e) a = a.concat(n[s] ? t.validateSpec({ key: s, value: e[s], valueSpec: n[s], style: i, styleSpec: r }) : [new St(s, e[s], `unknown property "${s}"`)]); return a }, projectionDefinition: function (t) { const e = t.key; let r = t.value; r = r instanceof String ? r.valueOf() : r; const n = Bn(r); return "array" !== n || function (t) { return Array.isArray(t) && 3 === t.length && "string" == typeof t[0] && "string" == typeof t[1] && "number" == typeof t[2] }(r) || function (t) { return !!["interpolate", "step", "literal"].includes(t[0]) }(r) ? ["array", "string"].includes(n) ? [] : [new St(e, r, `projection expected, invalid type "${n}" found`)] : [new St(e, r, `projection expected, invalid array ${JSON.stringify(r)} found`)] }, string: wi, formatted: function (t) { return 0 === wi(t).length ? [] : fi(t) }, resolvedImage: function (t) { return 0 === wi(t).length ? [] : fi(t) }, padding: function (t) { const e = t.key, r = t.value; if ("array" === Bn(r)) { if (r.length < 1 || r.length > 4) return [new St(e, r, `padding requires 1 to 4 values; ${r.length} values found`)]; const n = { type: "number" }; let i = []; for (let s = 0; s < r.length; s++)i = i.concat(t.validateSpec({ key: `${e}[${s}]`, value: r[s], validateSpec: t.validateSpec, valueSpec: n })); return i } return hi({ key: e, value: r, valueSpec: {} }) }, variableAnchorOffsetCollection: function (t) { const e = t.key, r = t.value, n = Bn(r), i = t.styleSpec; if ("array" !== n || r.length < 1 || r.length % 2 != 0) return [new St(e, r, "variableAnchorOffsetCollection requires a non-empty array of even length")]; let s = []; for (let n = 0; n < r.length; n += 2)s = s.concat(di({ key: `${e}[${n}]`, value: r[n], valueSpec: i.layout_symbol["text-anchor"] })), s = s.concat(ci({ key: `${e}[${n + 1}]`, value: r[n + 1], valueSpec: { length: 2, value: "number" }, validateSpec: t.validateSpec, style: t.style, styleSpec: i })); return s }, sprite: Ii }; function Pi(t) { const e = t.value, r = t.valueSpec, n = t.styleSpec; return t.validateSpec = Pi, r.expression && Vn(oi(e)) ? pi(t) : r.expression && jn(li(e)) ? fi(t) : r.type && zi[r.type] ? zi[r.type](t) : ui(At({}, t, { valueSpec: r.type ? n[r.type] : r })) } function Ci(t) { const e = t.value, r = t.key, n = wi(t); return n.length || (-1 === e.indexOf("{fontstack}") && n.push(new St(r, e, '"glyphs" url must include a "{fontstack}" token')), -1 === e.indexOf("{range}") && n.push(new St(r, e, '"glyphs" url must include a "{range}" token'))), n } function Bi(t, e = ht) { let r = []; return r = r.concat(Pi({ key: "", value: t, valueSpec: e.$root, styleSpec: e, style: t, validateSpec: Pi, objectElementValidators: { glyphs: Ci, "*": () => [] } })), t.constants && (r = r.concat(ai({ key: "constants", value: t.constants, style: t, styleSpec: e, validateSpec: Pi }))), Ei(r) } function Vi(t) { return function (e) { return t({ ...e, validateSpec: Pi }) } } function Ei(t) { return [].concat(t).sort(((t, e) => t.line - e.line)) } function Ti(t) { return function (...e) { return Ei(t.apply(this, e)) } } Bi.source = Ti(Vi(Si)), Bi.sprite = Ti(Vi(Ii)), Bi.glyphs = Ti(Vi(Ci)), Bi.light = Ti(Vi(Ai)), Bi.sky = Ti(Vi(ki)), Bi.terrain = Ti(Vi(Mi)), Bi.layer = Ti(Vi(bi)), Bi.filter = Ti(Vi(yi)), Bi.paintProperty = Ti(Vi(xi)), Bi.layoutProperty = Ti(Vi(vi)); const Fi = Bi, $i = Fi.light, Li = Fi.sky, Oi = Fi.paintProperty, Di = Fi.layoutProperty; function Ri(t, e) { let r = !1; if (e && e.length) for (const n of e) t.fire(new ut(new Error(n.message))), r = !0; return r } class ji { constructor(t, e, r) { const n = this.cells = []; if (t instanceof ArrayBuffer) { this.arrayBuffer = t; const i = new Int32Array(this.arrayBuffer); t = i[0], this.d = (e = i[1]) + 2 * (r = i[2]); for (let t = 0; t < this.d * this.d; t++) { const e = i[3 + t], r = i[3 + t + 1]; n.push(e === r ? null : i.subarray(e, r)); } const s = i[3 + n.length + 1]; this.keys = i.subarray(i[3 + n.length], s), this.bboxes = i.subarray(s), this.insert = this._insertReadonly; } else { this.d = e + 2 * r; for (let t = 0; t < this.d * this.d; t++)n.push([]); this.keys = [], this.bboxes = []; } this.n = e, this.extent = t, this.padding = r, this.scale = e / t, this.uid = 0; const i = r / e * t; this.min = -i, this.max = t + i; } insert(t, e, r, n, i) { this._forEachCell(e, r, n, i, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t), this.bboxes.push(e), this.bboxes.push(r), this.bboxes.push(n), this.bboxes.push(i); } _insertReadonly() { throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.") } _insertCell(t, e, r, n, i, s) { this.cells[i].push(s); } query(t, e, r, n, i) { const s = this.min, a = this.max; if (t <= s && e <= s && a <= r && a <= n && !i) return Array.prototype.slice.call(this.keys); { const s = []; return this._forEachCell(t, e, r, n, this._queryCell, s, {}, i), s } } _queryCell(t, e, r, n, i, s, a, o) { const l = this.cells[i]; if (null !== l) { const i = this.keys, u = this.bboxes; for (let c = 0; c < l.length; c++) { const h = l[c]; if (void 0 === a[h]) { const l = 4 * h; (o ? o(u[l + 0], u[l + 1], u[l + 2], u[l + 3]) : t <= u[l + 2] && e <= u[l + 3] && r >= u[l + 0] && n >= u[l + 1]) ? (a[h] = !0, s.push(i[h])) : a[h] = !1; } } } } _forEachCell(t, e, r, n, i, s, a, o) { const l = this._convertToCellCoord(t), u = this._convertToCellCoord(e), c = this._convertToCellCoord(r), h = this._convertToCellCoord(n); for (let p = l; p <= c; p++)for (let l = u; l <= h; l++) { const u = this.d * l + p; if ((!o || o(this._convertFromCellCoord(p), this._convertFromCellCoord(l), this._convertFromCellCoord(p + 1), this._convertFromCellCoord(l + 1))) && i.call(this, t, e, r, n, u, s, a, o)) return } } _convertFromCellCoord(t) { return (t - this.padding) / this.scale } _convertToCellCoord(t) { return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding)) } toArrayBuffer() { if (this.arrayBuffer) return this.arrayBuffer; const t = this.cells, e = 3 + this.cells.length + 1 + 1; let r = 0; for (let t = 0; t < this.cells.length; t++)r += this.cells[t].length; const n = new Int32Array(e + r + this.keys.length + this.bboxes.length); n[0] = this.extent, n[1] = this.n, n[2] = this.padding; let i = e; for (let e = 0; e < t.length; e++) { const r = t[e]; n[3 + e] = i, n.set(r, i), i += r.length; } return n[3 + t.length] = i, n.set(this.keys, i), i += this.keys.length, n[3 + t.length + 1] = i, n.set(this.bboxes, i), i += this.bboxes.length, n.buffer } static serialize(t, e) { const r = t.toArrayBuffer(); return e && e.push(r), { buffer: r } } static deserialize(t) { return new ji(t.buffer) } } const Ni = {}; function Ui(t, e, r = {}) { if (Ni[t]) throw new Error(`${t} is already registered.`); Object.defineProperty(e, "_classRegistryKey", { value: t, writeable: !1 }), Ni[t] = { klass: e, omit: r.omit || [], shallow: r.shallow || [] }; } Ui("Object", Object), Ui("TransferableGridIndex", ji), Ui("Color", ye), Ui("Error", Error), Ui("AJAXError", rt), Ui("ResolvedImage", Ae), Ui("StylePropertyFunction", Zn), Ui("StyleExpression", Rn, { omit: ["_evaluator"] }), Ui("ZoomDependentExpression", qn), Ui("ZoomConstantExpression", Un), Ui("CompoundExpression", gn, { omit: ["_evaluate"] }); for (const t in mn) mn[t]._classRegistryKey || Ui(`Expression_${t}`, mn[t]); function qi(t) { return t && "undefined" != typeof ArrayBuffer && (t instanceof ArrayBuffer || t.constructor && "ArrayBuffer" === t.constructor.name) } function Gi(t) { return t.$name || t.constructor._classRegistryKey } function Zi(t) { return !function (t) { if (null === t || "object" != typeof t) return !1; const e = Gi(t); return !(!e || "Object" === e) }(t) && (null == t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp || t instanceof Blob || t instanceof Error || qi(t) || G(t) || ArrayBuffer.isView(t) || t instanceof ImageData) } function Xi(t, e) { if (Zi(t)) return (qi(t) || G(t)) && e && e.push(t), ArrayBuffer.isView(t) && e && e.push(t.buffer), t instanceof ImageData && e && e.push(t.data.buffer), t; if (Array.isArray(t)) { const r = []; for (const n of t) r.push(Xi(n, e)); return r } if ("object" != typeof t) throw new Error("can't serialize object of type " + typeof t); const r = Gi(t); if (!r) throw new Error(`can't serialize object of unregistered class ${t.constructor.name}`); if (!Ni[r]) throw new Error(`${r} is not registered.`); const { klass: n } = Ni[r], i = n.serialize ? n.serialize(t, e) : {}; if (n.serialize) { if (e && i === e[e.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property") } else { for (const n in t) { if (!t.hasOwnProperty(n)) continue; if (Ni[r].omit.indexOf(n) >= 0) continue; const s = t[n]; i[n] = Ni[r].shallow.indexOf(n) >= 0 ? s : Xi(s, e); } t instanceof Error && (i.message = t.message); } if (i.$name) throw new Error("$name property is reserved for worker serialization logic."); return "Object" !== r && (i.$name = r), i } function Ki(t) { if (Zi(t)) return t; if (Array.isArray(t)) return t.map(Ki); if ("object" != typeof t) throw new Error("can't deserialize object of type " + typeof t); const e = Gi(t) || "Object"; if (!Ni[e]) throw new Error(`can't deserialize unregistered class ${e}`); const { klass: r } = Ni[e]; if (!r) throw new Error(`can't deserialize unregistered class ${e}`); if (r.deserialize) return r.deserialize(t); const n = Object.create(r.prototype); for (const r of Object.keys(t)) { if ("$name" === r) continue; const i = t[r]; n[r] = Ni[e].shallow.indexOf(r) >= 0 ? i : Ki(i); } return n } class Hi { constructor() { this.first = !0; } update(t, e) { const r = Math.floor(t); return this.first ? (this.first = !1, this.lastIntegerZoom = r, this.lastIntegerZoomTime = 0, this.lastZoom = t, this.lastFloorZoom = r, !0) : (this.lastFloorZoom > r ? (this.lastIntegerZoom = r + 1, this.lastIntegerZoomTime = e) : this.lastFloorZoom < r && (this.lastIntegerZoom = r, this.lastIntegerZoomTime = e), t !== this.lastZoom && (this.lastZoom = t, this.lastFloorZoom = r, !0)) } } const Yi = { "Latin-1 Supplement": t => t >= 128 && t <= 255, "Hangul Jamo": t => t >= 4352 && t <= 4607, Khmer: t => t >= 6016 && t <= 6143, "General Punctuation": t => t >= 8192 && t <= 8303, "Letterlike Symbols": t => t >= 8448 && t <= 8527, "Number Forms": t => t >= 8528 && t <= 8591, "Miscellaneous Technical": t => t >= 8960 && t <= 9215, "Control Pictures": t => t >= 9216 && t <= 9279, "Optical Character Recognition": t => t >= 9280 && t <= 9311, "Enclosed Alphanumerics": t => t >= 9312 && t <= 9471, "Geometric Shapes": t => t >= 9632 && t <= 9727, "Miscellaneous Symbols": t => t >= 9728 && t <= 9983, "Miscellaneous Symbols and Arrows": t => t >= 11008 && t <= 11263, "Ideographic Description Characters": t => t >= 12272 && t <= 12287, "CJK Symbols and Punctuation": t => t >= 12288 && t <= 12351, Katakana: t => t >= 12448 && t <= 12543, Kanbun: t => t >= 12688 && t <= 12703, "CJK Strokes": t => t >= 12736 && t <= 12783, "Enclosed CJK Letters and Months": t => t >= 12800 && t <= 13055, "CJK Compatibility": t => t >= 13056 && t <= 13311, "Yijing Hexagram Symbols": t => t >= 19904 && t <= 19967, "Private Use Area": t => t >= 57344 && t <= 63743, "Vertical Forms": t => t >= 65040 && t <= 65055, "CJK Compatibility Forms": t => t >= 65072 && t <= 65103, "Small Form Variants": t => t >= 65104 && t <= 65135, "Halfwidth and Fullwidth Forms": t => t >= 65280 && t <= 65519 }; function Ji(t) { for (const e of t) if (ns(e.charCodeAt(0))) return !0; return !1 } function Wi(t) { for (const e of t) if (!es(e.charCodeAt(0))) return !1; return !0 } function Qi(t) { const e = t.map((t => { try { return new RegExp(`\\p{sc=${t}}`, "u").source } catch (t) { return null } })).filter((t => t)); return new RegExp(e.join("|"), "u") } const ts = Qi(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]); function es(t) { return !ts.test(String.fromCodePoint(t)) } const rs = Qi(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]); function ns(t) { return !(746 !== t && 747 !== t && (t < 4352 || !(Yi["CJK Compatibility Forms"](t) && !(t >= 65097 && t <= 65103) || Yi["CJK Compatibility"](t) || Yi["CJK Strokes"](t) || !(!Yi["CJK Symbols and Punctuation"](t) || t >= 12296 && t <= 12305 || t >= 12308 && t <= 12319 || 12336 === t) || Yi["Enclosed CJK Letters and Months"](t) || Yi["Ideographic Description Characters"](t) || Yi.Kanbun(t) || Yi.Katakana(t) && 12540 !== t || !(!Yi["Halfwidth and Fullwidth Forms"](t) || 65288 === t || 65289 === t || 65293 === t || t >= 65306 && t <= 65310 || 65339 === t || 65341 === t || 65343 === t || t >= 65371 && t <= 65503 || 65507 === t || t >= 65512 && t <= 65519) || !(!Yi["Small Form Variants"](t) || t >= 65112 && t <= 65118 || t >= 65123 && t <= 65126) || Yi["Vertical Forms"](t) || Yi["Yijing Hexagram Symbols"](t) || /\p{sc=Cans}/u.test(String.fromCodePoint(t)) || /\p{sc=Hang}/u.test(String.fromCodePoint(t)) || rs.test(String.fromCodePoint(t))))) } function is(t) { return !(ns(t) || function (t) { return !!(Yi["Latin-1 Supplement"](t) && (167 === t || 169 === t || 174 === t || 177 === t || 188 === t || 189 === t || 190 === t || 215 === t || 247 === t) || Yi["General Punctuation"](t) && (8214 === t || 8224 === t || 8225 === t || 8240 === t || 8241 === t || 8251 === t || 8252 === t || 8258 === t || 8263 === t || 8264 === t || 8265 === t || 8273 === t) || Yi["Letterlike Symbols"](t) || Yi["Number Forms"](t) || Yi["Miscellaneous Technical"](t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || 9003 === t || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || 9167 === t || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || Yi["Control Pictures"](t) && 9251 !== t || Yi["Optical Character Recognition"](t) || Yi["Enclosed Alphanumerics"](t) || Yi["Geometric Shapes"](t) || Yi["Miscellaneous Symbols"](t) && !(t >= 9754 && t <= 9759) || Yi["Miscellaneous Symbols and Arrows"](t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || Yi["CJK Symbols and Punctuation"](t) || Yi.Katakana(t) || Yi["Private Use Area"](t) || Yi["CJK Compatibility Forms"](t) || Yi["Small Form Variants"](t) || Yi["Halfwidth and Fullwidth Forms"](t) || 8734 === t || 8756 === t || 8757 === t || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || 65532 === t || 65533 === t) }(t)) } const ss = Qi(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]); function as(t) { return ss.test(String.fromCodePoint(t)) } function os(t, e) { return !(!e && as(t) || t >= 2304 && t <= 3583 || t >= 3840 && t <= 4255 || Yi.Khmer(t)) } function ls(t) { for (const e of t) if (as(e.charCodeAt(0))) return !0; return !1 } const us = new class { constructor() { this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => { }; } setState(t) { this.pluginStatus = t.pluginStatus, this.pluginURL = t.pluginURL; } getState() { return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL } } setMethods(t) { if (us.isParsed()) throw new Error("RTL text plugin already registered."); this.applyArabicShaping = t.applyArabicShaping, this.processBidirectionalText = t.processBidirectionalText, this.processStyledBidirectionalText = t.processStyledBidirectionalText, this.loadScriptResolve(); } isParsed() { return null != this.applyArabicShaping && null != this.processBidirectionalText && null != this.processStyledBidirectionalText } getRTLTextPluginStatus() { return this.pluginStatus } syncState(t, r) { return e(this, void 0, void 0, (function* () { if (this.isParsed()) return this.getState(); if ("loading" !== t.pluginStatus) return this.setState(t), t; const e = t.pluginURL, n = new Promise((t => { this.loadScriptResolve = t; })); r(e); const i = new Promise((t => setTimeout((() => t()), this.TIMEOUT))); if (yield Promise.race([n, i]), this.isParsed()) { const t = { pluginStatus: "loaded", pluginURL: e }; return this.setState(t), t } throw this.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${e}`) })) } }; class cs { constructor(t, e) { this.zoom = t, e ? (this.now = e.now, this.fadeDuration = e.fadeDuration, this.zoomHistory = e.zoomHistory, this.transition = e.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Hi, this.transition = {}); } isSupportedScript(t) { return function (t, e) { for (const r of t) if (!os(r.charCodeAt(0), e)) return !1; return !0 }(t, "loaded" === us.getRTLTextPluginStatus()) } crossFadingFactor() { return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1) } getCrossfadeParameters() { const t = this.zoom, e = t - Math.floor(t), r = this.crossFadingFactor(); return t > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: e + (1 - e) * r } : { fromScale: .5, toScale: 1, t: 1 - (1 - r) * e } } } class hs { constructor(t, e) { this.property = t, this.value = e, this.expression = function (t, e) { if (Vn(t)) return new Zn(t, e); if (jn(t)) { const r = Gn(t, e); if ("error" === r.result) throw new Error(r.value.map((t => `${t.key}: ${t.message}`)).join(", ")); return r.value } { let r = t; return "color" === e.type && "string" == typeof t ? r = ye.parse(t) : "padding" !== e.type || "number" != typeof t && !Array.isArray(t) ? "variableAnchorOffsetCollection" === e.type && Array.isArray(t) ? r = Se.parse(t) : "projectionDefinition" === e.type && "string" == typeof t && (r = ke.parse(t)) : r = be.parse(t), { kind: "constant", evaluate: () => r } } }(void 0 === e ? t.specification.default : e, t.specification); } isDataDriven() { return "source" === this.expression.kind || "composite" === this.expression.kind } possiblyEvaluate(t, e, r) { return this.property.possiblyEvaluate(this, t, e, r) } } class ps { constructor(t) { this.property = t, this.value = new hs(t, void 0); } transitioned(t, e) { return new ds(this.property, this.value, e, F({}, t.transition, this.transition), t.now) } untransitioned() { return new ds(this.property, this.value, null, {}, 0) } } class fs { constructor(t) { this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues); } getValue(t) { return D(this._values[t].value.value) } setValue(t, e) { Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new ps(this._values[t].property)), this._values[t].value = new hs(this._values[t].property, null === e ? void 0 : D(e)); } getTransition(t) { return D(this._values[t].transition) } setTransition(t, e) { Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new ps(this._values[t].property)), this._values[t].transition = D(e) || void 0; } serialize() { const t = {}; for (const e of Object.keys(this._values)) { const r = this.getValue(e); void 0 !== r && (t[e] = r); const n = this.getTransition(e); void 0 !== n && (t[`${e}-transition`] = n); } return t } transitioned(t, e) { const r = new ys(this._properties); for (const n of Object.keys(this._values)) r._values[n] = this._values[n].transitioned(t, e._values[n]); return r } untransitioned() { const t = new ys(this._properties); for (const e of Object.keys(this._values)) t._values[e] = this._values[e].untransitioned(); return t } } class ds { constructor(t, e, r, n, i) { this.property = t, this.value = e, this.begin = i + n.delay || 0, this.end = this.begin + n.duration || 0, t.specification.transition && (n.delay || n.duration) && (this.prior = r); } possiblyEvaluate(t, e, r) { const n = t.now || 0, i = this.value.possiblyEvaluate(t, e, r), s = this.prior; if (s) { if (n > this.end) return this.prior = null, i; if (this.value.isDataDriven()) return this.prior = null, i; if (n < this.begin) return s.possiblyEvaluate(t, e, r); { const a = (n - this.begin) / (this.end - this.begin); return this.property.interpolate(s.possiblyEvaluate(t, e, r), i, C(a)) } } return i } } class ys { constructor(t) { this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues); } possiblyEvaluate(t, e, r) { const n = new xs(this._properties); for (const i of Object.keys(this._values)) n._values[i] = this._values[i].possiblyEvaluate(t, e, r); return n } hasTransition() { for (const t of Object.keys(this._values)) if (this._values[t].prior) return !0; return !1 } } class ms { constructor(t) { this._properties = t, this._values = Object.create(t.defaultPropertyValues); } hasValue(t) { return void 0 !== this._values[t].value } getValue(t) { return D(this._values[t].value) } setValue(t, e) { this._values[t] = new hs(this._values[t].property, null === e ? void 0 : D(e)); } serialize() { const t = {}; for (const e of Object.keys(this._values)) { const r = this.getValue(e); void 0 !== r && (t[e] = r); } return t } possiblyEvaluate(t, e, r) { const n = new xs(this._properties); for (const i of Object.keys(this._values)) n._values[i] = this._values[i].possiblyEvaluate(t, e, r); return n } } class gs { constructor(t, e, r) { this.property = t, this.value = e, this.parameters = r; } isConstant() { return "constant" === this.value.kind } constantOr(t) { return "constant" === this.value.kind ? this.value.value : t } evaluate(t, e, r, n) { return this.property.evaluate(this.value, this.parameters, t, e, r, n) } } class xs { constructor(t) { this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues); } get(t) { return this._values[t] } } class vs { constructor(t) { this.specification = t; } possiblyEvaluate(t, e) { if (t.isDataDriven()) throw new Error("Value should not be data driven"); return t.expression.evaluate(e) } interpolate(t, e, r) { const n = er[this.specification.type]; return n ? n(t, e, r) : t } } class bs { constructor(t, e) { this.specification = t, this.overrides = e; } possiblyEvaluate(t, e, r, n) { return new gs(this, "constant" === t.expression.kind || "camera" === t.expression.kind ? { kind: "constant", value: t.expression.evaluate(e, null, {}, r, n) } : t.expression, e) } interpolate(t, e, r) { if ("constant" !== t.value.kind || "constant" !== e.value.kind) return t; if (void 0 === t.value.value || void 0 === e.value.value) return new gs(this, { kind: "constant", value: void 0 }, t.parameters); const n = er[this.specification.type]; if (n) { const i = n(t.value.value, e.value.value, r); return new gs(this, { kind: "constant", value: i }, t.parameters) } return t } evaluate(t, e, r, n, i, s) { return "constant" === t.kind ? t.value : t.evaluate(e, r, n, i, s) } } class ws extends bs { possiblyEvaluate(t, e, r, n) { if (void 0 === t.value) return new gs(this, { kind: "constant", value: void 0 }, e); if ("constant" === t.expression.kind) { const i = t.expression.evaluate(e, null, {}, r, n), s = "resolvedImage" === t.property.specification.type && "string" != typeof i ? i.name : i, a = this._calculate(s, s, s, e); return new gs(this, { kind: "constant", value: a }, e) } if ("camera" === t.expression.kind) { const r = this._calculate(t.expression.evaluate({ zoom: e.zoom - 1 }), t.expression.evaluate({ zoom: e.zoom }), t.expression.evaluate({ zoom: e.zoom + 1 }), e); return new gs(this, { kind: "constant", value: r }, e) } return new gs(this, t.expression, e) } evaluate(t, e, r, n, i, s) { if ("source" === t.kind) { const a = t.evaluate(e, r, n, i, s); return this._calculate(a, a, a, e) } return "composite" === t.kind ? this._calculate(t.evaluate({ zoom: Math.floor(e.zoom) - 1 }, r, n), t.evaluate({ zoom: Math.floor(e.zoom) }, r, n), t.evaluate({ zoom: Math.floor(e.zoom) + 1 }, r, n), e) : t.value } _calculate(t, e, r, n) { return n.zoom > n.zoomHistory.lastIntegerZoom ? { from: t, to: e } : { from: r, to: e } } interpolate(t) { return t } } class _s { constructor(t) { this.specification = t; } possiblyEvaluate(t, e, r, n) { if (void 0 !== t.value) { if ("constant" === t.expression.kind) { const i = t.expression.evaluate(e, null, {}, r, n); return this._calculate(i, i, i, e) } return this._calculate(t.expression.evaluate(new cs(Math.floor(e.zoom - 1), e)), t.expression.evaluate(new cs(Math.floor(e.zoom), e)), t.expression.evaluate(new cs(Math.floor(e.zoom + 1), e)), e) } } _calculate(t, e, r, n) { return n.zoom > n.zoomHistory.lastIntegerZoom ? { from: t, to: e } : { from: r, to: e } } interpolate(t) { return t } } class Ss { constructor(t) { this.specification = t; } possiblyEvaluate(t, e, r, n) { return !!t.expression.evaluate(e, null, {}, r, n) } interpolate() { return !1 } } class As { constructor(t) { this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = []; for (const e in t) { const r = t[e]; r.specification.overridable && this.overridableProperties.push(e); const n = this.defaultPropertyValues[e] = new hs(r, void 0), i = this.defaultTransitionablePropertyValues[e] = new ps(r); this.defaultTransitioningPropertyValues[e] = i.untransitioned(), this.defaultPossiblyEvaluatedValues[e] = n.possiblyEvaluate({}); } } } Ui("DataDrivenProperty", bs), Ui("DataConstantProperty", vs), Ui("CrossFadedDataDrivenProperty", ws), Ui("CrossFadedProperty", _s), Ui("ColorRampProperty", Ss); const ks = "-transition"; class Ms extends ct { constructor(t, e) { if (super(), this.id = t.id, this.type = t.type, this._featureFilter = { filter: () => !0, needGeometry: !1 }, "custom" !== t.type && (this.metadata = t.metadata, this.minzoom = t.minzoom, this.maxzoom = t.maxzoom, "background" !== t.type && (this.source = t.source, this.sourceLayer = t["source-layer"], this.filter = t.filter), e.layout && (this._unevaluatedLayout = new ms(e.layout)), e.paint)) { this._transitionablePaint = new fs(e.paint); for (const e in t.paint) this.setPaintProperty(e, t.paint[e], { validate: !1 }); for (const e in t.layout) this.setLayoutProperty(e, t.layout[e], { validate: !1 }); this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new xs(e.paint); } } getCrossfadeParameters() { return this._crossfadeParameters } getLayoutProperty(t) { return "visibility" === t ? this.visibility : this._unevaluatedLayout.getValue(t) } setLayoutProperty(t, e, r = {}) { null != e && this._validate(Di, `layers.${this.id}.layout.${t}`, t, e, r) || ("visibility" !== t ? this._unevaluatedLayout.setValue(t, e) : this.visibility = e); } getPaintProperty(t) { return t.endsWith(ks) ? this._transitionablePaint.getTransition(t.slice(0, -11)) : this._transitionablePaint.getValue(t) } setPaintProperty(t, e, r = {}) { if (null != e && this._validate(Oi, `layers.${this.id}.paint.${t}`, t, e, r)) return !1; if (t.endsWith(ks)) return this._transitionablePaint.setTransition(t.slice(0, -11), e || void 0), !1; { const r = this._transitionablePaint._values[t], n = "cross-faded-data-driven" === r.property.specification["property-type"], i = r.value.isDataDriven(), s = r.value; this._transitionablePaint.setValue(t, e), this._handleSpecialPaintPropertyUpdate(t); const a = this._transitionablePaint._values[t].value; return a.isDataDriven() || i || n || this._handleOverridablePaintPropertyUpdate(t, s, a) } } _handleSpecialPaintPropertyUpdate(t) { } _handleOverridablePaintPropertyUpdate(t, e, r) { return !1 } isHidden(t) { return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || "none" === this.visibility } updateTransitions(t) { this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint); } hasTransition() { return this._transitioningPaint.hasTransition() } recalculate(t, e) { t.getCrossfadeParameters && (this._crossfadeParameters = t.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, e)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, e); } serialize() { const t = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() }; return this.visibility && (t.layout = t.layout || {}, t.layout.visibility = this.visibility), O(t, ((t, e) => !(void 0 === t || "layout" === e && !Object.keys(t).length || "paint" === e && !Object.keys(t).length))) } _validate(t, e, r, n, i = {}) { return (!i || !1 !== i.validate) && Ri(this, t.call(Fi, { key: e, layerType: this.type, objectKey: r, value: n, styleSpec: ht, style: { glyphs: !0, sprite: !0 } })) } is3D() { return !1 } isTileClipped() { return !1 } hasOffscreenPass() { return !1 } resize() { } isStateDependent() { for (const t in this.paint._values) { const e = this.paint.get(t); if (e instanceof gs && zn(e.property.specification) && ("source" === e.value.kind || "composite" === e.value.kind) && e.value.isStateDependent) return !0 } return !1 } } const Is = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array }; class zs { constructor(t, e) { this._structArray = t, this._pos1 = e * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8; } } class Ps { constructor() { this.isTransferred = !1, this.capacity = -1, this.resize(0); } static serialize(t, e) { return t._trim(), e && (t.isTransferred = !0, e.push(t.arrayBuffer)), { length: t.length, arrayBuffer: t.arrayBuffer } } static deserialize(t) { const e = Object.create(this.prototype); return e.arrayBuffer = t.arrayBuffer, e.length = t.length, e.capacity = t.arrayBuffer.byteLength / e.bytesPerElement, e._refreshViews(), e } _trim() { this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews()); } clear() { this.length = 0; } resize(t) { this.reserve(t), this.length = t; } reserve(t) { if (t > this.capacity) { this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement); const e = this.uint8; this._refreshViews(), e && this.uint8.set(e); } } _refreshViews() { throw new Error("_refreshViews() must be implemented by each concrete StructArray layout") } } function Cs(t, e = 1) { let r = 0, n = 0; return { members: t.map((t => { const i = Is[t.type].BYTES_PER_ELEMENT, s = r = Bs(r, Math.max(e, i)), a = t.components || 1; return n = Math.max(n, i), r += i * a, { name: t.name, type: t.type, components: a, offset: s } })), size: Bs(r, Math.max(n, e)), alignment: e } } function Bs(t, e) { return Math.ceil(t / e) * e } class Vs extends Ps { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer); } emplaceBack(t, e) { const r = this.length; return this.resize(r + 1), this.emplace(r, t, e) } emplace(t, e, r) { const n = 2 * t; return this.int16[n + 0] = e, this.int16[n + 1] = r, t } } Vs.prototype.bytesPerElement = 4, Ui("StructArrayLayout2i4", Vs); class Es extends Ps { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer); } emplaceBack(t, e, r) { const n = this.length; return this.resize(n + 1), this.emplace(n, t, e, r) } emplace(t, e, r, n) { const i = 3 * t; return this.int16[i + 0] = e, this.int16[i + 1] = r, this.int16[i + 2] = n, t } } Es.prototype.bytesPerElement = 6, Ui("StructArrayLayout3i6", Es); class Ts extends Ps { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer); } emplaceBack(t, e, r, n) { const i = this.length; return this.resize(i + 1), this.emplace(i, t, e, r, n) } emplace(t, e, r, n, i) { const s = 4 * t; return this.int16[s + 0] = e, this.int16[s + 1] = r, this.int16[s + 2] = n, this.int16[s + 3] = i, t } } Ts.prototype.bytesPerElement = 8, Ui("StructArrayLayout4i8", Ts); class Fs extends Ps { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer); } emplaceBack(t, e, r, n, i, s) { const a = this.length; return this.resize(a + 1), this.emplace(a, t, e, r, n, i, s) } emplace(t, e, r, n, i, s, a) { const o = 6 * t; return this.int16[o + 0] = e, this.int16[o + 1] = r, this.int16[o + 2] = n, this.int16[o + 3] = i, this.int16[o + 4] = s, this.int16[o + 5] = a, t } } Fs.prototype.bytesPerElement = 12, Ui("StructArrayLayout2i4i12", Fs); class $s extends Ps { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer); } emplaceBack(t, e, r, n, i, s) { const a = this.length; return this.resize(a + 1), this.emplace(a, t, e, r, n, i, s) } emplace(t, e, r, n, i, s, a) { const o = 4 * t, l = 8 * t; return this.int16[o + 0] = e, this.int16[o + 1] = r, this.uint8[l + 4] = n, this.uint8[l + 5] = i, this.uint8[l + 6] = s, this.uint8[l + 7] = a, t } } $s.prototype.bytesPerElement = 8, Ui("StructArrayLayout2i4ub8", $s); class Ls extends Ps { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer); } emplaceBack(t, e) { const r = this.length; return this.resize(r + 1), this.emplace(r, t, e) } emplace(t, e, r) { const n = 2 * t; return this.float32[n + 0] = e, this.float32[n + 1] = r, t } } Ls.prototype.bytesPerElement = 8, Ui("StructArrayLayout2f8", Ls); class Os extends Ps { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer); } emplaceBack(t, e, r, n, i, s, a, o, l, u) { const c = this.length; return this.resize(c + 1), this.emplace(c, t, e, r, n, i, s, a, o, l, u) } emplace(t, e, r, n, i, s, a, o, l, u, c) { const h = 10 * t; return this.uint16[h + 0] = e, this.uint16[h + 1] = r, this.uint16[h + 2] = n, this.uint16[h + 3] = i, this.uint16[h + 4] = s, this.uint16[h + 5] = a, this.uint16[h + 6] = o, this.uint16[h + 7] = l, this.uint16[h + 8] = u, this.uint16[h + 9] = c, t } } Os.prototype.bytesPerElement = 20, Ui("StructArrayLayout10ui20", Os); class Ds extends Ps { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer); } emplaceBack(t, e, r, n, i, s, a, o, l, u, c, h) { const p = this.length; return this.resize(p + 1), this.emplace(p, t, e, r, n, i, s, a, o, l, u, c, h) } emplace(t, e, r, n, i, s, a, o, l, u, c, h, p) { const f = 12 * t; return this.int16[f + 0] = e, this.int16[f + 1] = r, this.int16[f + 2] = n, this.int16[f + 3] = i, this.uint16[f + 4] = s, this.uint16[f + 5] = a, this.uint16[f + 6] = o, this.uint16[f + 7] = l, this.int16[f + 8] = u, this.int16[f + 9] = c, this.int16[f + 10] = h, this.int16[f + 11] = p, t } } Ds.prototype.bytesPerElement = 24, Ui("StructArrayLayout4i4ui4i24", Ds); class Rs extends Ps { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer); } emplaceBack(t, e, r) { const n = this.length; return this.resize(n + 1), this.emplace(n, t, e, r) } emplace(t, e, r, n) { const i = 3 * t; return this.float32[i + 0] = e, this.float32[i + 1] = r, this.float32[i + 2] = n, t } } Rs.prototype.bytesPerElement = 12, Ui("StructArrayLayout3f12", Rs); class js extends Ps { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer); } emplaceBack(t) { const e = this.length; return this.resize(e + 1), this.emplace(e, t) } emplace(t, e) { return this.uint32[1 * t + 0] = e, t } } js.prototype.bytesPerElement = 4, Ui("StructArrayLayout1ul4", js); class Ns extends Ps { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer); } emplaceBack(t, e, r, n, i, s, a, o, l) { const u = this.length; return this.resize(u + 1), this.emplace(u, t, e, r, n, i, s, a, o, l) } emplace(t, e, r, n, i, s, a, o, l, u) { const c = 10 * t, h = 5 * t; return this.int16[c + 0] = e, this.int16[c + 1] = r, this.int16[c + 2] = n, this.int16[c + 3] = i, this.int16[c + 4] = s, this.int16[c + 5] = a, this.uint32[h + 3] = o, this.uint16[c + 8] = l, this.uint16[c + 9] = u, t } } Ns.prototype.bytesPerElement = 20, Ui("StructArrayLayout6i1ul2ui20", Ns); class Us extends Ps { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer); } emplaceBack(t, e, r, n, i, s) { const a = this.length; return this.resize(a + 1), this.emplace(a, t, e, r, n, i, s) } emplace(t, e, r, n, i, s, a) { const o = 6 * t; return this.int16[o + 0] = e, this.int16[o + 1] = r, this.int16[o + 2] = n, this.int16[o + 3] = i, this.int16[o + 4] = s, this.int16[o + 5] = a, t } } Us.prototype.bytesPerElement = 12, Ui("StructArrayLayout2i2i2i12", Us); class qs extends Ps { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer); } emplaceBack(t, e, r, n, i) { const s = this.length; return this.resize(s + 1), this.emplace(s, t, e, r, n, i) } emplace(t, e, r, n, i, s) { const a = 4 * t, o = 8 * t; return this.float32[a + 0] = e, this.float32[a + 1] = r, this.float32[a + 2] = n, this.int16[o + 6] = i, this.int16[o + 7] = s, t } } qs.prototype.bytesPerElement = 16, Ui("StructArrayLayout2f1f2i16", qs); class Gs extends Ps { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer); } emplaceBack(t, e, r, n, i, s) { const a = this.length; return this.resize(a + 1), this.emplace(a, t, e, r, n, i, s) } emplace(t, e, r, n, i, s, a) { const o = 16 * t, l = 4 * t, u = 8 * t; return this.uint8[o + 0] = e, this.uint8[o + 1] = r, this.float32[l + 1] = n, this.float32[l + 2] = i, this.int16[u + 6] = s, this.int16[u + 7] = a, t } } Gs.prototype.bytesPerElement = 16, Ui("StructArrayLayout2ub2f2i16", Gs); class Zs extends Ps { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer); } emplaceBack(t, e, r) { const n = this.length; return this.resize(n + 1), this.emplace(n, t, e, r) } emplace(t, e, r, n) { const i = 3 * t; return this.uint16[i + 0] = e, this.uint16[i + 1] = r, this.uint16[i + 2] = n, t } } Zs.prototype.bytesPerElement = 6, Ui("StructArrayLayout3ui6", Zs); class Xs extends Ps { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer); } emplaceBack(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m) { const g = this.length; return this.resize(g + 1), this.emplace(g, t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m) } emplace(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g) { const x = 24 * t, v = 12 * t, b = 48 * t; return this.int16[x + 0] = e, this.int16[x + 1] = r, this.uint16[x + 2] = n, this.uint16[x + 3] = i, this.uint32[v + 2] = s, this.uint32[v + 3] = a, this.uint32[v + 4] = o, this.uint16[x + 10] = l, this.uint16[x + 11] = u, this.uint16[x + 12] = c, this.float32[v + 7] = h, this.float32[v + 8] = p, this.uint8[b + 36] = f, this.uint8[b + 37] = d, this.uint8[b + 38] = y, this.uint32[v + 10] = m, this.int16[x + 22] = g, t } } Xs.prototype.bytesPerElement = 48, Ui("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", Xs); class Ks extends Ps { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer); } emplaceBack(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, w, _, S, A, k, M, I) { const z = this.length; return this.resize(z + 1), this.emplace(z, t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, w, _, S, A, k, M, I) } emplace(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, w, _, S, A, k, M, I, z) { const P = 32 * t, C = 16 * t; return this.int16[P + 0] = e, this.int16[P + 1] = r, this.int16[P + 2] = n, this.int16[P + 3] = i, this.int16[P + 4] = s, this.int16[P + 5] = a, this.int16[P + 6] = o, this.int16[P + 7] = l, this.uint16[P + 8] = u, this.uint16[P + 9] = c, this.uint16[P + 10] = h, this.uint16[P + 11] = p, this.uint16[P + 12] = f, this.uint16[P + 13] = d, this.uint16[P + 14] = y, this.uint16[P + 15] = m, this.uint16[P + 16] = g, this.uint16[P + 17] = x, this.uint16[P + 18] = v, this.uint16[P + 19] = b, this.uint16[P + 20] = w, this.uint16[P + 21] = _, this.uint16[P + 22] = S, this.uint32[C + 12] = A, this.float32[C + 13] = k, this.float32[C + 14] = M, this.uint16[P + 30] = I, this.uint16[P + 31] = z, t } } Ks.prototype.bytesPerElement = 64, Ui("StructArrayLayout8i15ui1ul2f2ui64", Ks); class Hs extends Ps { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer); } emplaceBack(t) { const e = this.length; return this.resize(e + 1), this.emplace(e, t) } emplace(t, e) { return this.float32[1 * t + 0] = e, t } } Hs.prototype.bytesPerElement = 4, Ui("StructArrayLayout1f4", Hs); class Ys extends Ps { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer); } emplaceBack(t, e, r) { const n = this.length; return this.resize(n + 1), this.emplace(n, t, e, r) } emplace(t, e, r, n) { const i = 3 * t; return this.uint16[6 * t + 0] = e, this.float32[i + 1] = r, this.float32[i + 2] = n, t } } Ys.prototype.bytesPerElement = 12, Ui("StructArrayLayout1ui2f12", Ys); class Js extends Ps { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer); } emplaceBack(t, e, r) { const n = this.length; return this.resize(n + 1), this.emplace(n, t, e, r) } emplace(t, e, r, n) { const i = 4 * t; return this.uint32[2 * t + 0] = e, this.uint16[i + 2] = r, this.uint16[i + 3] = n, t } } Js.prototype.bytesPerElement = 8, Ui("StructArrayLayout1ul2ui8", Js); class Ws extends Ps { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer); } emplaceBack(t, e) { const r = this.length; return this.resize(r + 1), this.emplace(r, t, e) } emplace(t, e, r) { const n = 2 * t; return this.uint16[n + 0] = e, this.uint16[n + 1] = r, t } } Ws.prototype.bytesPerElement = 4, Ui("StructArrayLayout2ui4", Ws); class Qs extends Ps { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer); } emplaceBack(t) { const e = this.length; return this.resize(e + 1), this.emplace(e, t) } emplace(t, e) { return this.uint16[1 * t + 0] = e, t } } Qs.prototype.bytesPerElement = 2, Ui("StructArrayLayout1ui2", Qs); class ta extends Ps { _refreshViews() { this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer); } emplaceBack(t, e, r, n) { const i = this.length; return this.resize(i + 1), this.emplace(i, t, e, r, n) } emplace(t, e, r, n, i) { const s = 4 * t; return this.float32[s + 0] = e, this.float32[s + 1] = r, this.float32[s + 2] = n, this.float32[s + 3] = i, t } } ta.prototype.bytesPerElement = 16, Ui("StructArrayLayout4f16", ta); class ea extends zs { get anchorPointX() { return this._structArray.int16[this._pos2 + 0] } get anchorPointY() { return this._structArray.int16[this._pos2 + 1] } get x1() { return this._structArray.int16[this._pos2 + 2] } get y1() { return this._structArray.int16[this._pos2 + 3] } get x2() { return this._structArray.int16[this._pos2 + 4] } get y2() { return this._structArray.int16[this._pos2 + 5] } get featureIndex() { return this._structArray.uint32[this._pos4 + 3] } get sourceLayerIndex() { return this._structArray.uint16[this._pos2 + 8] } get bucketIndex() { return this._structArray.uint16[this._pos2 + 9] } get anchorPoint() { return new l(this.anchorPointX, this.anchorPointY) } } ea.prototype.size = 20; class ra extends Ns { get(t) { return new ea(this, t) } } Ui("CollisionBoxArray", ra); class na extends zs { get anchorX() { return this._structArray.int16[this._pos2 + 0] } get anchorY() { return this._structArray.int16[this._pos2 + 1] } get glyphStartIndex() { return this._structArray.uint16[this._pos2 + 2] } get numGlyphs() { return this._structArray.uint16[this._pos2 + 3] } get vertexStartIndex() { return this._structArray.uint32[this._pos4 + 2] } get lineStartIndex() { return this._structArray.uint32[this._pos4 + 3] } get lineLength() { return this._structArray.uint32[this._pos4 + 4] } get segment() { return this._structArray.uint16[this._pos2 + 10] } get lowerSize() { return this._structArray.uint16[this._pos2 + 11] } get upperSize() { return this._structArray.uint16[this._pos2 + 12] } get lineOffsetX() { return this._structArray.float32[this._pos4 + 7] } get lineOffsetY() { return this._structArray.float32[this._pos4 + 8] } get writingMode() { return this._structArray.uint8[this._pos1 + 36] } get placedOrientation() { return this._structArray.uint8[this._pos1 + 37] } set placedOrientation(t) { this._structArray.uint8[this._pos1 + 37] = t; } get hidden() { return this._structArray.uint8[this._pos1 + 38] } set hidden(t) { this._structArray.uint8[this._pos1 + 38] = t; } get crossTileID() { return this._structArray.uint32[this._pos4 + 10] } set crossTileID(t) { this._structArray.uint32[this._pos4 + 10] = t; } get associatedIconIndex() { return this._structArray.int16[this._pos2 + 22] } } na.prototype.size = 48; class ia extends Xs { get(t) { return new na(this, t) } } Ui("PlacedSymbolArray", ia); class sa extends zs { get anchorX() { return this._structArray.int16[this._pos2 + 0] } get anchorY() { return this._structArray.int16[this._pos2 + 1] } get rightJustifiedTextSymbolIndex() { return this._structArray.int16[this._pos2 + 2] } get centerJustifiedTextSymbolIndex() { return this._structArray.int16[this._pos2 + 3] } get leftJustifiedTextSymbolIndex() { return this._structArray.int16[this._pos2 + 4] } get verticalPlacedTextSymbolIndex() { return this._structArray.int16[this._pos2 + 5] } get placedIconSymbolIndex() { return this._structArray.int16[this._pos2 + 6] } get verticalPlacedIconSymbolIndex() { return this._structArray.int16[this._pos2 + 7] } get key() { return this._structArray.uint16[this._pos2 + 8] } get textBoxStartIndex() { return this._structArray.uint16[this._pos2 + 9] } get textBoxEndIndex() { return this._structArray.uint16[this._pos2 + 10] } get verticalTextBoxStartIndex() { return this._structArray.uint16[this._pos2 + 11] } get verticalTextBoxEndIndex() { return this._structArray.uint16[this._pos2 + 12] } get iconBoxStartIndex() { return this._structArray.uint16[this._pos2 + 13] } get iconBoxEndIndex() { return this._structArray.uint16[this._pos2 + 14] } get verticalIconBoxStartIndex() { return this._structArray.uint16[this._pos2 + 15] } get verticalIconBoxEndIndex() { return this._structArray.uint16[this._pos2 + 16] } get featureIndex() { return this._structArray.uint16[this._pos2 + 17] } get numHorizontalGlyphVertices() { return this._structArray.uint16[this._pos2 + 18] } get numVerticalGlyphVertices() { return this._structArray.uint16[this._pos2 + 19] } get numIconVertices() { return this._structArray.uint16[this._pos2 + 20] } get numVerticalIconVertices() { return this._structArray.uint16[this._pos2 + 21] } get useRuntimeCollisionCircles() { return this._structArray.uint16[this._pos2 + 22] } get crossTileID() { return this._structArray.uint32[this._pos4 + 12] } set crossTileID(t) { this._structArray.uint32[this._pos4 + 12] = t; } get textBoxScale() { return this._structArray.float32[this._pos4 + 13] } get collisionCircleDiameter() { return this._structArray.float32[this._pos4 + 14] } get textAnchorOffsetStartIndex() { return this._structArray.uint16[this._pos2 + 30] } get textAnchorOffsetEndIndex() { return this._structArray.uint16[this._pos2 + 31] } } sa.prototype.size = 64; class aa extends Ks { get(t) { return new sa(this, t) } } Ui("SymbolInstanceArray", aa); class oa extends Hs { getoffsetX(t) { return this.float32[1 * t + 0] } } Ui("GlyphOffsetArray", oa); class la extends Es { getx(t) { return this.int16[3 * t + 0] } gety(t) { return this.int16[3 * t + 1] } gettileUnitDistanceFromAnchor(t) { return this.int16[3 * t + 2] } } Ui("SymbolLineVertexArray", la); class ua extends zs { get textAnchor() { return this._structArray.uint16[this._pos2 + 0] } get textOffset0() { return this._structArray.float32[this._pos4 + 1] } get textOffset1() { return this._structArray.float32[this._pos4 + 2] } } ua.prototype.size = 12; class ca extends Ys { get(t) { return new ua(this, t) } } Ui("TextAnchorOffsetArray", ca); class ha extends zs { get featureIndex() { return this._structArray.uint32[this._pos4 + 0] } get sourceLayerIndex() { return this._structArray.uint16[this._pos2 + 2] } get bucketIndex() { return this._structArray.uint16[this._pos2 + 3] } } ha.prototype.size = 8; class pa extends Js { get(t) { return new ha(this, t) } } Ui("FeatureIndexArray", pa); class fa extends Vs { } class da extends Vs { } class ya extends Vs { } class ma extends Fs { } class ga extends $s { } class xa extends Ls { } class va extends Os { } class ba extends Ds { } class wa extends Rs { } class _a extends js { } class Sa extends Us { } class Aa extends Gs { } class ka extends Zs { } class Ma extends Ws { } const Ia = Cs([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: za } = Ia; class Pa { constructor(t = []) { this._forceNewSegmentOnNextPrepare = !1, this.segments = t; } prepareSegment(t, e, r, n) { const i = this.segments[this.segments.length - 1]; return t > Pa.MAX_VERTEX_ARRAY_LENGTH && j(`Max vertices per segment is ${Pa.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${Pa.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !i || i.vertexLength + t > Pa.MAX_VERTEX_ARRAY_LENGTH || i.sortKey !== n ? this.createNewSegment(e, r, n) : i } createNewSegment(t, e, r) { const n = { vertexOffset: t.length, primitiveOffset: e.length, vertexLength: 0, primitiveLength: 0, vaos: {} }; return void 0 !== r && (n.sortKey = r), this._forceNewSegmentOnNextPrepare = !1, this.segments.push(n), n } getOrCreateLatestSegment(t, e, r) { return this.prepareSegment(0, t, e, r) } forceNewSegmentOnNextPrepare() { this._forceNewSegmentOnNextPrepare = !0; } get() { return this.segments } destroy() { for (const t of this.segments) for (const e in t.vaos) t.vaos[e].destroy(); } static simpleSegment(t, e, r, n) { return new Pa([{ vertexOffset: t, primitiveOffset: e, vertexLength: r, primitiveLength: n, vaos: {}, sortKey: 0 }]) } } function Ca(t, e) { return 256 * (t = E(Math.floor(t), 0, 255)) + E(Math.floor(e), 0, 255) } Pa.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Ui("SegmentVector", Pa); const Ba = Cs([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]); var Va, Ea, Ta, Fa = { exports: {} }, $a = { exports: {} }, La = { exports: {} }, Oa = function () { if (Ta) return Fa.exports; Ta = 1; var t = (Va || (Va = 1, $a.exports = function (t, e) { var r, n, i, s, a, o, l, u; for (n = t.length - (r = 3 & t.length), i = e, a = 3432918353, o = 461845907, u = 0; u < n;)l = 255 & t.charCodeAt(u) | (255 & t.charCodeAt(++u)) << 8 | (255 & t.charCodeAt(++u)) << 16 | (255 & t.charCodeAt(++u)) << 24, ++u, i = 27492 + (65535 & (s = 5 * (65535 & (i = (i ^= l = (65535 & (l = (l = (65535 & l) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295) << 13 | i >>> 19)) + ((5 * (i >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s >>> 16) & 65535) << 16); switch (l = 0, r) { case 3: l ^= (255 & t.charCodeAt(u + 2)) << 16; case 2: l ^= (255 & t.charCodeAt(u + 1)) << 8; case 1: i ^= l = (65535 & (l = (l = (65535 & (l ^= 255 & t.charCodeAt(u))) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295; }return i ^= t.length, i = 2246822507 * (65535 & (i ^= i >>> 16)) + ((2246822507 * (i >>> 16) & 65535) << 16) & 4294967295, i = 3266489909 * (65535 & (i ^= i >>> 13)) + ((3266489909 * (i >>> 16) & 65535) << 16) & 4294967295, (i ^= i >>> 16) >>> 0 }), $a.exports), e = (Ea || (Ea = 1, La.exports = function (t, e) { for (var r, n = t.length, i = e ^ n, s = 0; n >= 4;)r = 1540483477 * (65535 & (r = 255 & t.charCodeAt(s) | (255 & t.charCodeAt(++s)) << 8 | (255 & t.charCodeAt(++s)) << 16 | (255 & t.charCodeAt(++s)) << 24)) + ((1540483477 * (r >>> 16) & 65535) << 16), i = 1540483477 * (65535 & i) + ((1540483477 * (i >>> 16) & 65535) << 16) ^ (r = 1540483477 * (65535 & (r ^= r >>> 24)) + ((1540483477 * (r >>> 16) & 65535) << 16)), n -= 4, ++s; switch (n) { case 3: i ^= (255 & t.charCodeAt(s + 2)) << 16; case 2: i ^= (255 & t.charCodeAt(s + 1)) << 8; case 1: i = 1540483477 * (65535 & (i ^= 255 & t.charCodeAt(s))) + ((1540483477 * (i >>> 16) & 65535) << 16); }return i = 1540483477 * (65535 & (i ^= i >>> 13)) + ((1540483477 * (i >>> 16) & 65535) << 16), (i ^= i >>> 15) >>> 0 }), La.exports); return Fa.exports = t, Fa.exports.murmur3 = t, Fa.exports.murmur2 = e, Fa.exports }(), Da = r(Oa); class Ra { constructor() { this.ids = [], this.positions = [], this.indexed = !1; } add(t, e, r, n) { this.ids.push(ja(t)), this.positions.push(e, r, n); } getPositions(t) { if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed"); const e = ja(t); let r = 0, n = this.ids.length - 1; for (; r < n;) { const t = r + n >> 1; this.ids[t] >= e ? n = t : r = t + 1; } const i = []; for (; this.ids[r] === e;)i.push({ index: this.positions[3 * r], start: this.positions[3 * r + 1], end: this.positions[3 * r + 2] }), r++; return i } static serialize(t, e) { const r = new Float64Array(t.ids), n = new Uint32Array(t.positions); return Na(r, n, 0, r.length - 1), e && e.push(r.buffer, n.buffer), { ids: r, positions: n } } static deserialize(t) { const e = new Ra; return e.ids = t.ids, e.positions = t.positions, e.indexed = !0, e } } function ja(t) { const e = +t; return !isNaN(e) && e <= Number.MAX_SAFE_INTEGER ? e : Da(String(t)) } function Na(t, e, r, n) { for (; r < n;) { const i = t[r + n >> 1]; let s = r - 1, a = n + 1; for (; ;) { do { s++; } while (t[s] < i); do { a--; } while (t[a] > i); if (s >= a) break; Ua(t, s, a), Ua(e, 3 * s, 3 * a), Ua(e, 3 * s + 1, 3 * a + 1), Ua(e, 3 * s + 2, 3 * a + 2); } a - r < n - a ? (Na(t, e, r, a), r = a + 1) : (Na(t, e, a + 1, n), n = a); } } function Ua(t, e, r) { const n = t[e]; t[e] = t[r], t[r] = n; } Ui("FeaturePositionMap", Ra); class qa { constructor(t, e) { this.gl = t.gl, this.location = e; } } class Ga extends qa { constructor(t, e) { super(t, e), this.current = 0; } set(t) { this.current !== t && (this.current = t, this.gl.uniform1f(this.location, t)); } } class Za extends qa { constructor(t, e) { super(t, e), this.current = [0, 0, 0, 0]; } set(t) { t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] && t[3] === this.current[3] || (this.current = t, this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3])); } } class Xa extends qa { constructor(t, e) { super(t, e), this.current = ye.transparent; } set(t) { t.r === this.current.r && t.g === this.current.g && t.b === this.current.b && t.a === this.current.a || (this.current = t, this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a)); } } const Ka = new Float32Array(16); function Ha(t) { return [Ca(255 * t.r, 255 * t.g), Ca(255 * t.b, 255 * t.a)] } class Ya { constructor(t, e, r) { this.value = t, this.uniformNames = e.map((t => `u_${t}`)), this.type = r; } setUniform(t, e, r) { t.set(r.constantOr(this.value)); } getBinding(t, e, r) { return "color" === this.type ? new Xa(t, e) : new Ga(t, e) } } class Ja { constructor(t, e) { this.uniformNames = e.map((t => `u_${t}`)), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1; } setConstantPatternPositions(t, e) { this.pixelRatioFrom = e.pixelRatio, this.pixelRatioTo = t.pixelRatio, this.patternFrom = e.tlbr, this.patternTo = t.tlbr; } setUniform(t, e, r, n) { const i = "u_pattern_to" === n ? this.patternTo : "u_pattern_from" === n ? this.patternFrom : "u_pixel_ratio_to" === n ? this.pixelRatioTo : "u_pixel_ratio_from" === n ? this.pixelRatioFrom : null; i && t.set(i); } getBinding(t, e, r) { return "u_pattern" === r.substr(0, 9) ? new Za(t, e) : new Ga(t, e) } } class Wa { constructor(t, e, r, n) { this.expression = t, this.type = r, this.maxValue = 0, this.paintVertexAttributes = e.map((t => ({ name: `a_${t}`, type: "Float32", components: "color" === r ? 2 : 1, offset: 0 }))), this.paintVertexArray = new n; } populatePaintArray(t, e, r, n, i) { const s = this.paintVertexArray.length, a = this.expression.evaluate(new cs(0), e, {}, n, [], i); this.paintVertexArray.resize(t), this._setPaintValue(s, t, a); } updatePaintArray(t, e, r, n) { const i = this.expression.evaluate({ zoom: 0 }, r, n); this._setPaintValue(t, e, i); } _setPaintValue(t, e, r) { if ("color" === this.type) { const n = Ha(r); for (let r = t; r < e; r++)this.paintVertexArray.emplace(r, n[0], n[1]); } else { for (let n = t; n < e; n++)this.paintVertexArray.emplace(n, r); this.maxValue = Math.max(this.maxValue, Math.abs(r)); } } upload(t) { this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent)); } destroy() { this.paintVertexBuffer && this.paintVertexBuffer.destroy(); } } class Qa { constructor(t, e, r, n, i, s) { this.expression = t, this.uniformNames = e.map((t => `u_${t}_t`)), this.type = r, this.useIntegerZoom = n, this.zoom = i, this.maxValue = 0, this.paintVertexAttributes = e.map((t => ({ name: `a_${t}`, type: "Float32", components: "color" === r ? 4 : 2, offset: 0 }))), this.paintVertexArray = new s; } populatePaintArray(t, e, r, n, i) { const s = this.expression.evaluate(new cs(this.zoom), e, {}, n, [], i), a = this.expression.evaluate(new cs(this.zoom + 1), e, {}, n, [], i), o = this.paintVertexArray.length; this.paintVertexArray.resize(t), this._setPaintValue(o, t, s, a); } updatePaintArray(t, e, r, n) { const i = this.expression.evaluate({ zoom: this.zoom }, r, n), s = this.expression.evaluate({ zoom: this.zoom + 1 }, r, n); this._setPaintValue(t, e, i, s); } _setPaintValue(t, e, r, n) { if ("color" === this.type) { const i = Ha(r), s = Ha(n); for (let r = t; r < e; r++)this.paintVertexArray.emplace(r, i[0], i[1], s[0], s[1]); } else { for (let i = t; i < e; i++)this.paintVertexArray.emplace(i, r, n); this.maxValue = Math.max(this.maxValue, Math.abs(r), Math.abs(n)); } } upload(t) { this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent)); } destroy() { this.paintVertexBuffer && this.paintVertexBuffer.destroy(); } setUniform(t, e) { const r = this.useIntegerZoom ? Math.floor(e.zoom) : e.zoom, n = E(this.expression.interpolationFactor(r, this.zoom, this.zoom + 1), 0, 1); t.set(n); } getBinding(t, e, r) { return new Ga(t, e) } } class to { constructor(t, e, r, n, i, s) { this.expression = t, this.type = e, this.useIntegerZoom = r, this.zoom = n, this.layerId = s, this.zoomInPaintVertexArray = new i, this.zoomOutPaintVertexArray = new i; } populatePaintArray(t, e, r) { const n = this.zoomInPaintVertexArray.length; this.zoomInPaintVertexArray.resize(t), this.zoomOutPaintVertexArray.resize(t), this._setPaintValues(n, t, e.patterns && e.patterns[this.layerId], r); } updatePaintArray(t, e, r, n, i) { this._setPaintValues(t, e, r.patterns && r.patterns[this.layerId], i); } _setPaintValues(t, e, r, n) { if (!n || !r) return; const { min: i, mid: s, max: a } = r, o = n[i], l = n[s], u = n[a]; if (o && l && u) for (let r = t; r < e; r++)this.zoomInPaintVertexArray.emplace(r, l.tl[0], l.tl[1], l.br[0], l.br[1], o.tl[0], o.tl[1], o.br[0], o.br[1], l.pixelRatio, o.pixelRatio), this.zoomOutPaintVertexArray.emplace(r, l.tl[0], l.tl[1], l.br[0], l.br[1], u.tl[0], u.tl[1], u.br[0], u.br[1], l.pixelRatio, u.pixelRatio); } upload(t) { this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t.createVertexBuffer(this.zoomInPaintVertexArray, Ba.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t.createVertexBuffer(this.zoomOutPaintVertexArray, Ba.members, this.expression.isStateDependent)); } destroy() { this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy(); } } class eo { constructor(t, e, r) { this.binders = {}, this._buffers = []; const n = []; for (const i in t.paint._values) { if (!r(i)) continue; const s = t.paint.get(i); if (!(s instanceof gs && zn(s.property.specification))) continue; const a = no(i, t.type), o = s.value, l = s.property.specification.type, u = s.property.useIntegerZoom, c = s.property.specification["property-type"], h = "cross-faded" === c || "cross-faded-data-driven" === c; if ("constant" === o.kind) this.binders[i] = h ? new Ja(o.value, a) : new Ya(o.value, a, l), n.push(`/u_${i}`); else if ("source" === o.kind || h) { const r = io(i, l, "source"); this.binders[i] = h ? new to(o, l, u, e, r, t.id) : new Wa(o, a, l, r), n.push(`/a_${i}`); } else { const t = io(i, l, "composite"); this.binders[i] = new Qa(o, a, l, u, e, t), n.push(`/z_${i}`); } } this.cacheKey = n.sort().join(""); } getMaxValue(t) { const e = this.binders[t]; return e instanceof Wa || e instanceof Qa ? e.maxValue : 0 } populatePaintArrays(t, e, r, n, i) { for (const s in this.binders) { const a = this.binders[s]; (a instanceof Wa || a instanceof Qa || a instanceof to) && a.populatePaintArray(t, e, r, n, i); } } setConstantPatternPositions(t, e) { for (const r in this.binders) { const n = this.binders[r]; n instanceof Ja && n.setConstantPatternPositions(t, e); } } updatePaintArrays(t, e, r, n, i) { let s = !1; for (const a in t) { const o = e.getPositions(a); for (const e of o) { const o = r.feature(e.index); for (const r in this.binders) { const l = this.binders[r]; if ((l instanceof Wa || l instanceof Qa || l instanceof to) && !0 === l.expression.isStateDependent) { const u = n.paint.get(r); l.expression = u.value, l.updatePaintArray(e.start, e.end, o, t[a], i), s = !0; } } } } return s } defines() { const t = []; for (const e in this.binders) { const r = this.binders[e]; (r instanceof Ya || r instanceof Ja) && t.push(...r.uniformNames.map((t => `#define HAS_UNIFORM_${t}`))); } return t } getBinderAttributes() { const t = []; for (const e in this.binders) { const r = this.binders[e]; if (r instanceof Wa || r instanceof Qa) for (let e = 0; e < r.paintVertexAttributes.length; e++)t.push(r.paintVertexAttributes[e].name); else if (r instanceof to) for (let e = 0; e < Ba.members.length; e++)t.push(Ba.members[e].name); } return t } getBinderUniforms() { const t = []; for (const e in this.binders) { const r = this.binders[e]; if (r instanceof Ya || r instanceof Ja || r instanceof Qa) for (const e of r.uniformNames) t.push(e); } return t } getPaintVertexBuffers() { return this._buffers } getUniforms(t, e) { const r = []; for (const n in this.binders) { const i = this.binders[n]; if (i instanceof Ya || i instanceof Ja || i instanceof Qa) for (const s of i.uniformNames) if (e[s]) { const a = i.getBinding(t, e[s], s); r.push({ name: s, property: n, binding: a }); } } return r } setUniforms(t, e, r, n) { for (const { name: t, property: i, binding: s } of e) this.binders[i].setUniform(s, n, r.get(i), t); } updatePaintBuffers(t) { this._buffers = []; for (const e in this.binders) { const r = this.binders[e]; if (t && r instanceof to) { const e = 2 === t.fromScale ? r.zoomInPaintVertexBuffer : r.zoomOutPaintVertexBuffer; e && this._buffers.push(e); } else (r instanceof Wa || r instanceof Qa) && r.paintVertexBuffer && this._buffers.push(r.paintVertexBuffer); } } upload(t) { for (const e in this.binders) { const r = this.binders[e]; (r instanceof Wa || r instanceof Qa || r instanceof to) && r.upload(t); } this.updatePaintBuffers(); } destroy() { for (const t in this.binders) { const e = this.binders[t]; (e instanceof Wa || e instanceof Qa || e instanceof to) && e.destroy(); } } } class ro { constructor(t, e, r = (() => !0)) { this.programConfigurations = {}; for (const n of t) this.programConfigurations[n.id] = new eo(n, e, r); this.needsUpload = !1, this._featureMap = new Ra, this._bufferOffset = 0; } populatePaintArrays(t, e, r, n, i, s) { for (const r in this.programConfigurations) this.programConfigurations[r].populatePaintArrays(t, e, n, i, s); void 0 !== e.id && this._featureMap.add(e.id, r, this._bufferOffset, t), this._bufferOffset = t, this.needsUpload = !0; } updatePaintArrays(t, e, r, n) { for (const i of r) this.needsUpload = this.programConfigurations[i.id].updatePaintArrays(t, this._featureMap, e, i, n) || this.needsUpload; } get(t) { return this.programConfigurations[t] } upload(t) { if (this.needsUpload) { for (const e in this.programConfigurations) this.programConfigurations[e].upload(t); this.needsUpload = !1; } } destroy() { for (const t in this.programConfigurations) this.programConfigurations[t].destroy(); } } function no(t, e) { return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[t] || [t.replace(`${e}-`, "").replace(/-/g, "_")] } function io(t, e, r) { const n = { color: { source: Ls, composite: ta }, number: { source: Hs, composite: Ls } }, i = function (t) { return { "line-pattern": { source: va, composite: va }, "fill-pattern": { source: va, composite: va }, "fill-extrusion-pattern": { source: va, composite: va } }[t] }(t); return i && i[r] || n[e][r] } Ui("ConstantBinder", Ya), Ui("CrossFadedConstantBinder", Ja), Ui("SourceExpressionBinder", Wa), Ui("CrossFadedCompositeBinder", to), Ui("CompositeExpressionBinder", Qa), Ui("ProgramConfiguration", eo, { omit: ["_buffers"] }), Ui("ProgramConfigurationSet", ro); const so = Math.pow(2, 14) - 1, ao = -so - 1; function oo(t) { const e = M / t.extent, r = t.loadGeometry(); for (let t = 0; t < r.length; t++) { const n = r[t]; for (let t = 0; t < n.length; t++) { const r = n[t], i = Math.round(r.x * e), s = Math.round(r.y * e); r.x = E(i, ao, so), r.y = E(s, ao, so), (i < r.x || i > r.x + 1 || s < r.y || s > r.y + 1) && j("Geometry exceeds allowed extent, reduce your vector tile buffer size"); } } return r } function lo(t, e) { return { type: t.type, id: t.id, properties: t.properties, geometry: e ? oo(t) : [] } } const uo = -32768; function co(t, e, r, n, i) { t.emplaceBack(uo + 8 * e + n, uo + 8 * r + i); } class ho { constructor(t) { this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((t => t.id)), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new da, this.indexArray = new ka, this.segments = new Pa, this.programConfigurations = new ro(t.layers, t.zoom), this.stateDependentLayerIds = this.layers.filter((t => t.isStateDependent())).map((t => t.id)); } populate(t, e, r) { const n = this.layers[0], i = []; let s = null, a = !1, o = "heatmap" === n.type; if ("circle" === n.type) { const t = n; s = t.layout.get("circle-sort-key"), a = !s.isConstant(), o = o || "map" === t.paint.get("circle-pitch-alignment"); } const l = o ? e.subdivisionGranularity.circle : 1; for (const { feature: e, id: n, index: o, sourceLayerIndex: l } of t) { const t = this.layers[0]._featureFilter.needGeometry, u = lo(e, t); if (!this.layers[0]._featureFilter.filter(new cs(this.zoom), u, r)) continue; const c = a ? s.evaluate(u, {}, r) : void 0, h = { id: n, properties: e.properties, type: e.type, sourceLayerIndex: l, index: o, geometry: t ? u.geometry : oo(e), patterns: {}, sortKey: c }; i.push(h); } a && i.sort(((t, e) => t.sortKey - e.sortKey)); for (const n of i) { const { geometry: i, index: s, sourceLayerIndex: a } = n, o = t[s].feature; this.addFeature(n, i, s, r, l), e.featureIndex.insert(o, i, s, a, this.index); } } update(t, e, r) { this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r); } isEmpty() { return 0 === this.layoutVertexArray.length } uploadPending() { return !this.uploaded || this.programConfigurations.needsUpload } upload(t) { this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, za), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0; } destroy() { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy()); } addFeature(t, e, r, n, i = 1) { let s; switch (i) { case 1: s = [0, 7]; break; case 3: s = [0, 2, 5, 7]; break; case 5: s = [0, 1, 3, 4, 6, 7]; break; case 7: s = [0, 1, 2, 3, 4, 5, 6, 7]; break; default: throw new Error(`Invalid circle bucket granularity: ${i}; valid values are 1, 3, 5, 7.`) }const a = s.length; for (const r of e) for (const e of r) { const r = e.x, n = e.y; if (r < 0 || r >= M || n < 0 || n >= M) continue; const i = this.segments.prepareSegment(a * a, this.layoutVertexArray, this.indexArray, t.sortKey), o = i.vertexLength; for (let t = 0; t < a; t++)for (let e = 0; e < a; e++)co(this.layoutVertexArray, r, n, s[e], s[t]); for (let t = 0; t < a - 1; t++)for (let e = 0; e < a - 1; e++) { const r = o + t * a + e, n = o + (t + 1) * a + e; this.indexArray.emplaceBack(r, n + 1, r + 1), this.indexArray.emplaceBack(r, n, n + 1); } i.vertexLength += a * a, i.primitiveLength += (a - 1) * (a - 1) * 2; } this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, {}, n); } } function po(t, e) { for (let r = 0; r < t.length; r++)if (_o(e, t[r])) return !0; for (let r = 0; r < e.length; r++)if (_o(t, e[r])) return !0; return !!go(t, e) } function fo(t, e, r) { return !!_o(t, e) || !!vo(e, t, r) } function yo(t, e) { if (1 === t.length) return wo(e, t[0]); for (let r = 0; r < e.length; r++) { const n = e[r]; for (let e = 0; e < n.length; e++)if (_o(t, n[e])) return !0 } for (let r = 0; r < t.length; r++)if (wo(e, t[r])) return !0; for (let r = 0; r < e.length; r++)if (go(t, e[r])) return !0; return !1 } function mo(t, e, r) { if (t.length > 1) { if (go(t, e)) return !0; for (let n = 0; n < e.length; n++)if (vo(e[n], t, r)) return !0 } for (let n = 0; n < t.length; n++)if (vo(t[n], e, r)) return !0; return !1 } function go(t, e) { if (0 === t.length || 0 === e.length) return !1; for (let r = 0; r < t.length - 1; r++) { const n = t[r], i = t[r + 1]; for (let t = 0; t < e.length - 1; t++)if (xo(n, i, e[t], e[t + 1])) return !0 } return !1 } function xo(t, e, r, n) { return N(t, r, n) !== N(e, r, n) && N(t, e, r) !== N(t, e, n) } function vo(t, e, r) { const n = r * r; if (1 === e.length) return t.distSqr(e[0]) < n; for (let r = 1; r < e.length; r++)if (bo(t, e[r - 1], e[r]) < n) return !0; return !1 } function bo(t, e, r) { const n = e.distSqr(r); if (0 === n) return t.distSqr(e); const i = ((t.x - e.x) * (r.x - e.x) + (t.y - e.y) * (r.y - e.y)) / n; return t.distSqr(i < 0 ? e : i > 1 ? r : r.sub(e)._mult(i)._add(e)) } function wo(t, e) { let r, n, i, s = !1; for (let a = 0; a < t.length; a++) { r = t[a]; for (let t = 0, a = r.length - 1; t < r.length; a = t++)n = r[t], i = r[a], n.y > e.y != i.y > e.y && e.x < (i.x - n.x) * (e.y - n.y) / (i.y - n.y) + n.x && (s = !s); } return s } function _o(t, e) { let r = !1; for (let n = 0, i = t.length - 1; n < t.length; i = n++) { const s = t[n], a = t[i]; s.y > e.y != a.y > e.y && e.x < (a.x - s.x) * (e.y - s.y) / (a.y - s.y) + s.x && (r = !r); } return r } function So(t, e, r) { const n = r[0], i = r[2]; if (t.x < n.x && e.x < n.x || t.x > i.x && e.x > i.x || t.y < n.y && e.y < n.y || t.y > i.y && e.y > i.y) return !1; const s = N(t, e, r[0]); return s !== N(t, e, r[1]) || s !== N(t, e, r[2]) || s !== N(t, e, r[3]) } function Ao(t, e, r) { const n = e.paint.get(t).value; return "constant" === n.kind ? n.value : r.programConfigurations.get(e.id).getMaxValue(t) } function ko(t) { return Math.sqrt(t[0] * t[0] + t[1] * t[1]) } function Mo(t, e, r, n, i) { if (!e[0] && !e[1]) return t; const s = l.convert(e)._mult(i); "viewport" === r && s._rotate(-n); const a = []; for (let e = 0; e < t.length; e++)a.push(t[e].sub(s)); return a } let Io, zo; Ui("CircleBucket", ho, { omit: ["layers"] }); var Po = { get paint() { return zo = zo || new As({ "circle-radius": new bs(ht.paint_circle["circle-radius"]), "circle-color": new bs(ht.paint_circle["circle-color"]), "circle-blur": new bs(ht.paint_circle["circle-blur"]), "circle-opacity": new bs(ht.paint_circle["circle-opacity"]), "circle-translate": new vs(ht.paint_circle["circle-translate"]), "circle-translate-anchor": new vs(ht.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new vs(ht.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new vs(ht.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new bs(ht.paint_circle["circle-stroke-width"]), "circle-stroke-color": new bs(ht.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new bs(ht.paint_circle["circle-stroke-opacity"]) }) }, get layout() { return Io = Io || new As({ "circle-sort-key": new bs(ht.layout_circle["circle-sort-key"]) }) } }; class Co extends Ms { constructor(t) { super(t, Po); } createBucket(t) { return new ho(t) } queryRadius(t) { const e = t; return Ao("circle-radius", this, e) + Ao("circle-stroke-width", this, e) + ko(this.paint.get("circle-translate")) } queryIntersectsFeature({ queryGeometry: t, feature: e, featureState: r, geometry: n, transform: i, pixelsToTileUnits: s, pixelPosMatrix: a }) { const o = Mo(t, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -i.bearingInRadians, s), l = this.paint.get("circle-radius").evaluate(e, r) + this.paint.get("circle-stroke-width").evaluate(e, r), u = "map" === this.paint.get("circle-pitch-alignment"), c = u ? o : function (t, e) { return t.map((t => Bo(t, e))) }(o, a), h = u ? l * s : l; for (const t of n) for (const e of t) { const t = u ? e : Bo(e, a); let r = h; const n = _([], [e.x, e.y, 0, 1], a); if ("viewport" === this.paint.get("circle-pitch-scale") && "map" === this.paint.get("circle-pitch-alignment") ? r *= n[3] / i.cameraToCenterDistance : "map" === this.paint.get("circle-pitch-scale") && "viewport" === this.paint.get("circle-pitch-alignment") && (r *= i.cameraToCenterDistance / n[3]), fo(c, t, r)) return !0 } return !1 } } function Bo(t, e) { const r = _([], [t.x, t.y, 0, 1], e); return new l(r[0] / r[3], r[1] / r[3]) } class Vo extends ho { } let Eo; Ui("HeatmapBucket", Vo, { omit: ["layers"] }); var To = { get paint() { return Eo = Eo || new As({ "heatmap-radius": new bs(ht.paint_heatmap["heatmap-radius"]), "heatmap-weight": new bs(ht.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new vs(ht.paint_heatmap["heatmap-intensity"]), "heatmap-color": new Ss(ht.paint_heatmap["heatmap-color"]), "heatmap-opacity": new vs(ht.paint_heatmap["heatmap-opacity"]) }) } }; function Fo(t, { width: e, height: r }, n, i) { if (i) { if (i instanceof Uint8ClampedArray) i = new Uint8Array(i.buffer); else if (i.length !== e * r * n) throw new RangeError(`mismatched image size. expected: ${i.length} but got: ${e * r * n}`) } else i = new Uint8Array(e * r * n); return t.width = e, t.height = r, t.data = i, t } function $o(t, { width: e, height: r }, n) { if (e === t.width && r === t.height) return; const i = Fo({}, { width: e, height: r }, n); Lo(t, i, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t.width, e), height: Math.min(t.height, r) }, n), t.width = e, t.height = r, t.data = i.data; } function Lo(t, e, r, n, i, s) { if (0 === i.width || 0 === i.height) return e; if (i.width > t.width || i.height > t.height || r.x > t.width - i.width || r.y > t.height - i.height) throw new RangeError("out of range source coordinates for image copy"); if (i.width > e.width || i.height > e.height || n.x > e.width - i.width || n.y > e.height - i.height) throw new RangeError("out of range destination coordinates for image copy"); const a = t.data, o = e.data; if (a === o) throw new Error("srcData equals dstData, so image is already copied"); for (let l = 0; l < i.height; l++) { const u = ((r.y + l) * t.width + r.x) * s, c = ((n.y + l) * e.width + n.x) * s; for (let t = 0; t < i.width * s; t++)o[c + t] = a[u + t]; } return e } class Oo { constructor(t, e) { Fo(this, t, 1, e); } resize(t) { $o(this, t, 1); } clone() { return new Oo({ width: this.width, height: this.height }, new Uint8Array(this.data)) } static copy(t, e, r, n, i) { Lo(t, e, r, n, i, 1); } } class Do { constructor(t, e) { Fo(this, t, 4, e); } resize(t) { $o(this, t, 4); } replace(t, e) { e ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t; } clone() { return new Do({ width: this.width, height: this.height }, new Uint8Array(this.data)) } static copy(t, e, r, n, i) { Lo(t, e, r, n, i, 4); } } function Ro(t) { const e = {}, r = t.resolution || 256, n = t.clips ? t.clips.length : 1, i = t.image || new Do({ width: r, height: n }); if (Math.log(r) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${r}`); const s = (r, n, s) => { e[t.evaluationKey] = s; const a = t.expression.evaluate(e); i.data[r + n + 0] = Math.floor(255 * a.r / a.a), i.data[r + n + 1] = Math.floor(255 * a.g / a.a), i.data[r + n + 2] = Math.floor(255 * a.b / a.a), i.data[r + n + 3] = Math.floor(255 * a.a); }; if (t.clips) for (let e = 0, i = 0; e < n; ++e, i += 4 * r)for (let n = 0, a = 0; n < r; n++, a += 4) { const o = n / (r - 1), { start: l, end: u } = t.clips[e]; s(i, a, l * (1 - o) + u * o); } else for (let t = 0, e = 0; t < r; t++, e += 4)s(0, e, t / (r - 1)); return i } Ui("AlphaImage", Oo), Ui("RGBAImage", Do); const jo = "big-fb"; class No extends Ms { createBucket(t) { return new Vo(t) } constructor(t) { super(t, To), this.heatmapFbos = new Map, this._updateColorRamp(); } _handleSpecialPaintPropertyUpdate(t) { "heatmap-color" === t && this._updateColorRamp(); } _updateColorRamp() { this.colorRamp = Ro({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null; } resize() { this.heatmapFbos.has(jo) && this.heatmapFbos.delete(jo); } queryRadius() { return 0 } queryIntersectsFeature() { return !1 } hasOffscreenPass() { return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility } } let Uo; var qo = { get paint() { return Uo = Uo || new As({ "hillshade-illumination-direction": new vs(ht.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new vs(ht.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new vs(ht.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new vs(ht.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new vs(ht.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new vs(ht.paint_hillshade["hillshade-accent-color"]) }) } }; class Go extends Ms { constructor(t) { super(t, qo); } hasOffscreenPass() { return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility } } const Zo = Cs([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Xo } = Zo; function Ko(t, e, r) { const n = r.patternDependencies; let i = !1; for (const r of e) { const e = r.paint.get(`${t}-pattern`); e.isConstant() || (i = !0); const s = e.constantOr(null); s && (i = !0, n[s.to] = !0, n[s.from] = !0); } return i } function Ho(t, e, r, n, i) { const s = i.patternDependencies; for (const a of e) { const e = a.paint.get(`${t}-pattern`).value; if ("constant" !== e.kind) { let t = e.evaluate({ zoom: n - 1 }, r, {}, i.availableImages), o = e.evaluate({ zoom: n }, r, {}, i.availableImages), l = e.evaluate({ zoom: n + 1 }, r, {}, i.availableImages); t = t && t.name ? t.name : t, o = o && o.name ? o.name : o, l = l && l.name ? l.name : l, s[t] = !0, s[o] = !0, s[l] = !0, r.patterns[a.id] = { min: t, mid: o, max: l }; } } return r } function Yo(t, e, r, n, i) { let s; if (i === function (t, e, r, n) { let i = 0; for (let s = e, a = r - n; s < r; s += n)i += (t[a] - t[s]) * (t[s + 1] + t[a + 1]), a = s; return i }(t, e, r, n) > 0) for (let i = e; i < r; i += n)s = xl(i / n | 0, t[i], t[i + 1], s); else for (let i = r - n; i >= e; i -= n)s = xl(i / n | 0, t[i], t[i + 1], s); return s && pl(s, s.next) && (vl(s), s = s.next), s } function Jo(t, e) { if (!t) return t; e || (e = t); let r, n = t; do { if (r = !1, n.steiner || !pl(n, n.next) && 0 !== hl(n.prev, n, n.next)) n = n.next; else { if (vl(n), n = e = n.prev, n === n.next) break; r = !0; } } while (r || n !== e); return e } function Wo(t, e, r, n, i, s, a) { if (!t) return; !a && s && function (t, e, r, n) { let i = t; do { 0 === i.z && (i.z = al(i.x, i.y, e, r, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next; } while (i !== t); i.prevZ.nextZ = null, i.prevZ = null, function (t) { let e, r = 1; do { let n, i = t; t = null; let s = null; for (e = 0; i;) { e++; let a = i, o = 0; for (let t = 0; t < r && (o++, a = a.nextZ, a); t++); let l = r; for (; o > 0 || l > 0 && a;)0 !== o && (0 === l || !a || i.z <= a.z) ? (n = i, i = i.nextZ, o--) : (n = a, a = a.nextZ, l--), s ? s.nextZ = n : t = n, n.prevZ = s, s = n; i = a; } s.nextZ = null, r *= 2; } while (e > 1) }(i); }(t, n, i, s); let o = t; for (; t.prev !== t.next;) { const l = t.prev, u = t.next; if (s ? tl(t, n, i, s) : Qo(t)) e.push(l.i, t.i, u.i), vl(t), t = u.next, o = u.next; else if ((t = u) === o) { a ? 1 === a ? Wo(t = el(Jo(t), e), e, r, n, i, s, 2) : 2 === a && rl(t, e, r, n, i, s) : Wo(Jo(t), e, r, n, i, s, 1); break } } } function Qo(t) { const e = t.prev, r = t, n = t.next; if (hl(e, r, n) >= 0) return !1; const i = e.x, s = r.x, a = n.x, o = e.y, l = r.y, u = n.y, c = Math.min(i, s, a), h = Math.min(o, l, u), p = Math.max(i, s, a), f = Math.max(o, l, u); let d = n.next; for (; d !== e;) { if (d.x >= c && d.x <= p && d.y >= h && d.y <= f && ul(i, o, s, l, a, u, d.x, d.y) && hl(d.prev, d, d.next) >= 0) return !1; d = d.next; } return !0 } function tl(t, e, r, n) { const i = t.prev, s = t, a = t.next; if (hl(i, s, a) >= 0) return !1; const o = i.x, l = s.x, u = a.x, c = i.y, h = s.y, p = a.y, f = Math.min(o, l, u), d = Math.min(c, h, p), y = Math.max(o, l, u), m = Math.max(c, h, p), g = al(f, d, e, r, n), x = al(y, m, e, r, n); let v = t.prevZ, b = t.nextZ; for (; v && v.z >= g && b && b.z <= x;) { if (v.x >= f && v.x <= y && v.y >= d && v.y <= m && v !== i && v !== a && ul(o, c, l, h, u, p, v.x, v.y) && hl(v.prev, v, v.next) >= 0) return !1; if (v = v.prevZ, b.x >= f && b.x <= y && b.y >= d && b.y <= m && b !== i && b !== a && ul(o, c, l, h, u, p, b.x, b.y) && hl(b.prev, b, b.next) >= 0) return !1; b = b.nextZ; } for (; v && v.z >= g;) { if (v.x >= f && v.x <= y && v.y >= d && v.y <= m && v !== i && v !== a && ul(o, c, l, h, u, p, v.x, v.y) && hl(v.prev, v, v.next) >= 0) return !1; v = v.prevZ; } for (; b && b.z <= x;) { if (b.x >= f && b.x <= y && b.y >= d && b.y <= m && b !== i && b !== a && ul(o, c, l, h, u, p, b.x, b.y) && hl(b.prev, b, b.next) >= 0) return !1; b = b.nextZ; } return !0 } function el(t, e) { let r = t; do { const n = r.prev, i = r.next.next; !pl(n, i) && fl(n, r, r.next, i) && ml(n, i) && ml(i, n) && (e.push(n.i, r.i, i.i), vl(r), vl(r.next), r = t = i), r = r.next; } while (r !== t); return Jo(r) } function rl(t, e, r, n, i, s) { let a = t; do { let t = a.next.next; for (; t !== a.prev;) { if (a.i !== t.i && cl(a, t)) { let o = gl(a, t); return a = Jo(a, a.next), o = Jo(o, o.next), Wo(a, e, r, n, i, s, 0), void Wo(o, e, r, n, i, s, 0) } t = t.next; } a = a.next; } while (a !== t) } function nl(t, e) { let r = t.x - e.x; return 0 === r && (r = t.y - e.y, 0 === r) && (r = (t.next.y - t.y) / (t.next.x - t.x) - (e.next.y - e.y) / (e.next.x - e.x)), r } function il(t, e) { const r = function (t, e) { let r = e; const n = t.x, i = t.y; let s, a = -1 / 0; if (pl(t, r)) return r; do { if (pl(t, r.next)) return r.next; if (i <= r.y && i >= r.next.y && r.next.y !== r.y) { const t = r.x + (i - r.y) * (r.next.x - r.x) / (r.next.y - r.y); if (t <= n && t > a && (a = t, s = r.x < r.next.x ? r : r.next, t === n)) return s } r = r.next; } while (r !== e); if (!s) return null; const o = s, l = s.x, u = s.y; let c = 1 / 0; r = s; do { if (n >= r.x && r.x >= l && n !== r.x && ll(i < u ? n : a, i, l, u, i < u ? a : n, i, r.x, r.y)) { const e = Math.abs(i - r.y) / (n - r.x); ml(r, t) && (e < c || e === c && (r.x > s.x || r.x === s.x && sl(s, r))) && (s = r, c = e); } r = r.next; } while (r !== o); return s }(t, e); if (!r) return e; const n = gl(r, t); return Jo(n, n.next), Jo(r, r.next) } function sl(t, e) { return hl(t.prev, t, e.prev) < 0 && hl(e.next, t, t.next) < 0 } function al(t, e, r, n, i) { return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - r) * i | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - n) * i | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1 } function ol(t) { let e = t, r = t; do { (e.x < r.x || e.x === r.x && e.y < r.y) && (r = e), e = e.next; } while (e !== t); return r } function ll(t, e, r, n, i, s, a, o) { return (i - a) * (e - o) >= (t - a) * (s - o) && (t - a) * (n - o) >= (r - a) * (e - o) && (r - a) * (s - o) >= (i - a) * (n - o) } function ul(t, e, r, n, i, s, a, o) { return !(t === a && e === o) && ll(t, e, r, n, i, s, a, o) } function cl(t, e) { return t.next.i !== e.i && t.prev.i !== e.i && !function (t, e) { let r = t; do { if (r.i !== t.i && r.next.i !== t.i && r.i !== e.i && r.next.i !== e.i && fl(r, r.next, t, e)) return !0; r = r.next; } while (r !== t); return !1 }(t, e) && (ml(t, e) && ml(e, t) && function (t, e) { let r = t, n = !1; const i = (t.x + e.x) / 2, s = (t.y + e.y) / 2; do { r.y > s != r.next.y > s && r.next.y !== r.y && i < (r.next.x - r.x) * (s - r.y) / (r.next.y - r.y) + r.x && (n = !n), r = r.next; } while (r !== t); return n }(t, e) && (hl(t.prev, t, e.prev) || hl(t, e.prev, e)) || pl(t, e) && hl(t.prev, t, t.next) > 0 && hl(e.prev, e, e.next) > 0) } function hl(t, e, r) { return (e.y - t.y) * (r.x - e.x) - (e.x - t.x) * (r.y - e.y) } function pl(t, e) { return t.x === e.x && t.y === e.y } function fl(t, e, r, n) { const i = yl(hl(t, e, r)), s = yl(hl(t, e, n)), a = yl(hl(r, n, t)), o = yl(hl(r, n, e)); return i !== s && a !== o || !(0 !== i || !dl(t, r, e)) || !(0 !== s || !dl(t, n, e)) || !(0 !== a || !dl(r, t, n)) || !(0 !== o || !dl(r, e, n)) } function dl(t, e, r) { return e.x <= Math.max(t.x, r.x) && e.x >= Math.min(t.x, r.x) && e.y <= Math.max(t.y, r.y) && e.y >= Math.min(t.y, r.y) } function yl(t) { return t > 0 ? 1 : t < 0 ? -1 : 0 } function ml(t, e) { return hl(t.prev, t, t.next) < 0 ? hl(t, e, t.next) >= 0 && hl(t, t.prev, e) >= 0 : hl(t, e, t.prev) < 0 || hl(t, t.next, e) < 0 } function gl(t, e) { const r = bl(t.i, t.x, t.y), n = bl(e.i, e.x, e.y), i = t.next, s = e.prev; return t.next = e, e.prev = t, r.next = i, i.prev = r, n.next = r, r.prev = n, s.next = n, n.prev = s, n } function xl(t, e, r, n) { const i = bl(t, e, r); return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i } function vl(t) { t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ); } function bl(t, e, r) { return { i: t, x: e, y: r, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: !1 } } class wl { constructor(t, e) { if (e > t) throw new Error("Min granularity must not be greater than base granularity."); this._baseZoomGranularity = t, this._minGranularity = e; } getGranularityForZoomLevel(t) { return Math.max(Math.floor(this._baseZoomGranularity / (1 << t)), this._minGranularity, 1) } } class _l { constructor(t) { this.fill = t.fill, this.line = t.line, this.tile = t.tile, this.stencil = t.stencil, this.circle = t.circle; } } _l.noSubdivision = new _l({ fill: new wl(0, 0), line: new wl(0, 0), tile: new wl(0, 0), stencil: new wl(0, 0), circle: 1 }), Ui("SubdivisionGranularityExpression", wl), Ui("SubdivisionGranularitySetting", _l); const Sl = -32768, Al = 32767; class kl { constructor(t, e) { this._vertexBuffer = [], this._vertexDictionary = new Map, this._used = !1, this._granularity = t, this._granularityCellSize = M / t, this._canonical = e; } _getKey(t, e) { return (t += 32768) << 16 | (e += 32768) << 0 } _vertexToIndex(t, e) { if (t < -32768 || e < -32768 || t > 32767 || e > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range."); const r = 0 | Math.round(t), n = 0 | Math.round(e), i = this._getKey(r, n); if (this._vertexDictionary.has(i)) return this._vertexDictionary.get(i); const s = this._vertexBuffer.length / 2; return this._vertexDictionary.set(i, s), this._vertexBuffer.push(r, n), s } _subdivideTrianglesScanline(t) { if (this._granularity < 2) return function (t, e) { const r = []; for (let n = 0; n < e.length; n += 3) { const i = e[n], s = e[n + 1], a = e[n + 2], o = t[2 * i], l = t[2 * i + 1]; (t[2 * s] - o) * (t[2 * a + 1] - l) - (t[2 * s + 1] - l) * (t[2 * a] - o) > 0 ? (r.push(i), r.push(a), r.push(s)) : (r.push(i), r.push(s), r.push(a)); } return r }(this._vertexBuffer, t); const e = [], r = t.length; for (let n = 0; n < r; n += 3) { const r = [t[n + 0], t[n + 1], t[n + 2]], i = [this._vertexBuffer[2 * t[n + 0] + 0], this._vertexBuffer[2 * t[n + 0] + 1], this._vertexBuffer[2 * t[n + 1] + 0], this._vertexBuffer[2 * t[n + 1] + 1], this._vertexBuffer[2 * t[n + 2] + 0], this._vertexBuffer[2 * t[n + 2] + 1]]; let s = 1 / 0, a = 1 / 0, o = -1 / 0, l = -1 / 0; for (let t = 0; t < 3; t++) { const e = i[2 * t], r = i[2 * t + 1]; s = Math.min(s, e), o = Math.max(o, e), a = Math.min(a, r), l = Math.max(l, r); } if (s === o || a === l) continue; const u = Math.floor(s / this._granularityCellSize), c = Math.ceil(o / this._granularityCellSize), h = Math.floor(a / this._granularityCellSize), p = Math.ceil(l / this._granularityCellSize); if (u !== c || h !== p) for (let t = h; t < p; t++) { const n = this._scanlineGenerateVertexRingForCellRow(t, i, r); zl(this._vertexBuffer, n, e); } else e.push(...r); } return e } _scanlineGenerateVertexRingForCellRow(t, e, r) { const n = t * this._granularityCellSize, i = n + this._granularityCellSize, s = []; for (let t = 0; t < 3; t++) { const a = e[2 * t], o = e[2 * t + 1], l = e[2 * (t + 1) % 6], u = e[(2 * (t + 1) + 1) % 6], c = e[2 * (t + 2) % 6], h = e[(2 * (t + 2) + 1) % 6], p = l - a, f = u - o, d = 0 === p, y = 0 === f, m = (n - o) / f, g = (i - o) / f, x = Math.min(m, g), v = Math.max(m, g); if (!y && (x >= 1 || v <= 0) || y && (o < n || o > i)) { u >= n && u <= i && s.push(r[(t + 1) % 3]); continue } !y && x > 0 && s.push(this._vertexToIndex(a + p * x, o + f * x)); const b = a + p * Math.max(x, 0), w = a + p * Math.min(v, 1); d || this._generateIntraEdgeVertices(s, a, o, l, u, b, w), !y && v < 1 && s.push(this._vertexToIndex(a + p * v, o + f * v)), (y || u >= n && u <= i) && s.push(r[(t + 1) % 3]), !y && (u <= n || u >= i) && this._generateInterEdgeVertices(s, a, o, l, u, c, h, w, n, i); } return s } _generateIntraEdgeVertices(t, e, r, n, i, s, a) { const o = n - e, l = i - r, u = 0 === l, c = u ? Math.min(e, n) : Math.min(s, a), h = u ? Math.max(e, n) : Math.max(s, a), p = Math.floor(c / this._granularityCellSize) + 1, f = Math.ceil(h / this._granularityCellSize) - 1; if (u ? e < n : s < a) for (let n = p; n <= f; n++) { const i = n * this._granularityCellSize; t.push(this._vertexToIndex(i, r + l * (i - e) / o)); } else for (let n = f; n >= p; n--) { const i = n * this._granularityCellSize; t.push(this._vertexToIndex(i, r + l * (i - e) / o)); } } _generateInterEdgeVertices(t, e, r, n, i, s, a, o, l, u) { const c = i - r, h = s - n, p = a - i, f = (l - i) / p, d = (u - i) / p, y = Math.min(f, d), m = Math.max(f, d), g = n + h * y; let x = Math.floor(Math.min(g, o) / this._granularityCellSize) + 1, v = Math.ceil(Math.max(g, o) / this._granularityCellSize) - 1, b = o < g; const w = 0 === p; if (w && (a === l || a === u)) return; if (w || y >= 1 || m <= 0) { const t = r - a, n = s + (e - s) * Math.min((l - a) / t, (u - a) / t); x = Math.floor(Math.min(n, o) / this._granularityCellSize) + 1, v = Math.ceil(Math.max(n, o) / this._granularityCellSize) - 1, b = o < n; } const _ = c > 0 ? u : l; if (b) for (let e = x; e <= v; e++)t.push(this._vertexToIndex(e * this._granularityCellSize, _)); else for (let e = v; e >= x; e--)t.push(this._vertexToIndex(e * this._granularityCellSize, _)); } _generateOutline(t) { const e = []; for (const r of t) { const t = Il(r, this._granularity, !0), n = this._pointArrayToIndices(t), i = []; for (let t = 1; t < n.length; t++)i.push(n[t - 1]), i.push(n[t]); e.push(i); } return e } _handlePoles(t) { let e = !1, r = !1; this._canonical && (0 === this._canonical.y && (e = !0), this._canonical.y === (1 << this._canonical.z) - 1 && (r = !0)), (e || r) && this._fillPoles(t, e, r); } _ensureNoPoleVertices() { const t = this._vertexBuffer; for (let e = 0; e < t.length; e += 2) { const r = t[e + 1]; r === Sl && (t[e + 1] = -32767), r === Al && (t[e + 1] = 32766); } } _generatePoleQuad(t, e, r, n, i, s) { n > i != (s === Sl) ? (t.push(e), t.push(r), t.push(this._vertexToIndex(n, s)), t.push(r), t.push(this._vertexToIndex(i, s)), t.push(this._vertexToIndex(n, s))) : (t.push(r), t.push(e), t.push(this._vertexToIndex(n, s)), t.push(this._vertexToIndex(i, s)), t.push(r), t.push(this._vertexToIndex(n, s))); } _fillPoles(t, e, r) { const n = this._vertexBuffer, i = M, s = t.length; for (let a = 2; a < s; a += 3) { const s = t[a - 2], o = t[a - 1], l = t[a], u = n[2 * s], c = n[2 * s + 1], h = n[2 * o], p = n[2 * o + 1], f = n[2 * l], d = n[2 * l + 1]; e && (0 === c && 0 === p && this._generatePoleQuad(t, s, o, u, h, Sl), 0 === p && 0 === d && this._generatePoleQuad(t, o, l, h, f, Sl), 0 === d && 0 === c && this._generatePoleQuad(t, l, s, f, u, Sl)), r && (c === i && p === i && this._generatePoleQuad(t, s, o, u, h, Al), p === i && d === i && this._generatePoleQuad(t, o, l, h, f, Al), d === i && c === i && this._generatePoleQuad(t, l, s, f, u, Al)); } } _initializeVertices(t) { for (let e = 0; e < t.length; e += 2)this._vertexToIndex(t[e], t[e + 1]); } subdividePolygonInternal(t, e) { if (this._used) throw new Error("Subdivision: multiple use not allowed."); this._used = !0; const { flattened: r, holeIndices: n } = function (t) { const e = [], r = []; for (const n of t) if (0 !== n.length) { n !== t[0] && e.push(r.length / 2); for (let t = 0; t < n.length; t++)r.push(n[t].x), r.push(n[t].y); } return { flattened: r, holeIndices: e } }(t); let i; this._initializeVertices(r); try { const t = function (t, e, r = 2) { const n = e && e.length, i = n ? e[0] * r : t.length; let s = Yo(t, 0, i, r, !0); const a = []; if (!s || s.next === s.prev) return a; let o, l, u; if (n && (s = function (t, e, r, n) { const i = []; for (let r = 0, s = e.length; r < s; r++) { const a = Yo(t, e[r] * n, r < s - 1 ? e[r + 1] * n : t.length, n, !1); a === a.next && (a.steiner = !0), i.push(ol(a)); } i.sort(nl); for (let t = 0; t < i.length; t++)r = il(i[t], r); return r }(t, e, s, r)), t.length > 80 * r) { o = 1 / 0, l = 1 / 0; let e = -1 / 0, n = -1 / 0; for (let s = r; s < i; s += r) { const r = t[s], i = t[s + 1]; r < o && (o = r), i < l && (l = i), r > e && (e = r), i > n && (n = i); } u = Math.max(e - o, n - l), u = 0 !== u ? 32767 / u : 0; } return Wo(s, a, r, o, l, u, 0), a }(r, n), e = this._convertIndices(r, t); i = this._subdivideTrianglesScanline(e); } catch (t) { console.error(t); } let s = []; return e && (s = this._generateOutline(t)), this._ensureNoPoleVertices(), this._handlePoles(i), { verticesFlattened: this._vertexBuffer, indicesTriangles: i, indicesLineList: s } } _convertIndices(t, e) { const r = []; for (let n = 0; n < e.length; n++)r.push(this._vertexToIndex(t[2 * e[n]], t[2 * e[n] + 1])); return r } _pointArrayToIndices(t) { const e = []; for (let r = 0; r < t.length; r++) { const n = t[r]; e.push(this._vertexToIndex(n.x, n.y)); } return e } } function Ml(t, e, r, n = !0) { return new kl(r, e).subdividePolygonInternal(t, n) } function Il(t, e, r = !1) { if (!t || t.length < 1) return []; if (t.length < 2) return []; const n = t[0], i = t[t.length - 1], s = r && (n.x !== i.x || n.y !== i.y); if (e < 2) return s ? [...t, t[0]] : [...t]; const a = Math.floor(M / e), o = []; o.push(new l(t[0].x, t[0].y)); const u = t.length, c = s ? u : u - 1; for (let e = 0; e < c; e++) { const r = t[e], n = e < u - 1 ? t[e + 1] : t[0], i = r.x, s = r.y, c = n.x, h = n.y, p = i !== c, f = s !== h; if (!p && !f) continue; const d = c - i, y = h - s, m = Math.abs(d), g = Math.abs(y); let x = i, v = s; for (; ;) { const t = d > 0 ? (Math.floor(x / a) + 1) * a : (Math.ceil(x / a) - 1) * a, e = y > 0 ? (Math.floor(v / a) + 1) * a : (Math.ceil(v / a) - 1) * a, r = Math.abs(x - t), n = Math.abs(v - e), i = Math.abs(x - c), s = Math.abs(v - h), u = p ? r / m : Number.POSITIVE_INFINITY, b = f ? n / g : Number.POSITIVE_INFINITY; if ((i <= r || !p) && (s <= n || !f)) break; if (u < b && p || !f) { x = t, v += y * u; const e = new l(x, Math.round(v)); o[o.length - 1].x === e.x && o[o.length - 1].y === e.y || o.push(e); } else { x += d * b, v = e; const t = new l(Math.round(x), v); o[o.length - 1].x === t.x && o[o.length - 1].y === t.y || o.push(t); } } const b = new l(c, h); o[o.length - 1].x === b.x && o[o.length - 1].y === b.y || o.push(b); } return o } function zl(t, e, r) { if (0 === e.length) throw new Error("Subdivision vertex ring is empty."); let n = 0, i = t[2 * e[0]]; for (let r = 1; r < e.length; r++) { const s = t[2 * e[r]]; s < i && (i = s, n = r); } const s = e.length; let a = n, o = (a + 1) % s; for (; ;) { const n = a - 1 >= 0 ? a - 1 : s - 1, i = (o + 1) % s, l = t[2 * e[n]], u = t[2 * e[i]], c = t[2 * e[a]], h = t[2 * e[a] + 1], p = t[2 * e[o] + 1]; let f = !1; if (l < u) f = !0; else if (l > u) f = !1; else { const r = p - h, s = -(t[2 * e[o]] - c), a = h < p ? 1 : -1; ((l - c) * r + (t[2 * e[n] + 1] - h) * s) * a > ((u - c) * r + (t[2 * e[i] + 1] - h) * s) * a && (f = !0); } if (f) { const t = e[n], i = e[a], l = e[o]; t !== i && t !== l && i !== l && r.push(l, i, t), a--, a < 0 && (a = s - 1); } else { const t = e[i], n = e[a], l = e[o]; t !== n && t !== l && n !== l && r.push(l, n, t), o++, o >= s && (o = 0); } if (n === i) break } } function Pl(t, e, r, n, i, s, a, o, l) { const u = i.length / 2, c = a && o && l; if (u < Pa.MAX_VERTEX_ARRAY_LENGTH) { const h = e.prepareSegment(u, r, n), p = h.vertexLength; for (let t = 0; t < s.length; t += 3)n.emplaceBack(p + s[t], p + s[t + 1], p + s[t + 2]); let f, d; h.vertexLength += u, h.primitiveLength += s.length / 3, c && (d = a.prepareSegment(u, r, o), f = d.vertexLength, d.vertexLength += u); for (let e = 0; e < i.length; e += 2)t(i[e], i[e + 1]); if (c) for (let t = 0; t < l.length; t++) { const e = l[t]; for (let t = 1; t < e.length; t += 2)o.emplaceBack(f + e[t - 1], f + e[t]); d.primitiveLength += e.length / 2; } } else !function (t, e, r, n, i, s) { const a = []; for (let t = 0; t < n.length / 2; t++)a.push(-1); const o = { count: 0 }; let l = 0, u = t.getOrCreateLatestSegment(e, r), c = u.vertexLength; for (let h = 2; h < i.length; h += 3) { const p = i[h - 2], f = i[h - 1], d = i[h]; let y = a[p] < l, m = a[f] < l, g = a[d] < l; u.vertexLength + ((y ? 1 : 0) + (m ? 1 : 0) + (g ? 1 : 0)) > Pa.MAX_VERTEX_ARRAY_LENGTH && (u = t.createNewSegment(e, r), l = o.count, y = !0, m = !0, g = !0, c = 0); const x = Cl(a, n, s, o, p, y, u), v = Cl(a, n, s, o, f, m, u), b = Cl(a, n, s, o, d, g, u); r.emplaceBack(c + x - l, c + v - l, c + b - l), u.primitiveLength++; } }(e, r, n, i, s, t), c && function (t, e, r, n, i, s) { const a = []; for (let t = 0; t < n.length / 2; t++)a.push(-1); const o = { count: 0 }; let l = 0, u = t.getOrCreateLatestSegment(e, r), c = u.vertexLength; for (let h = 0; h < i.length; h++) { const p = i[h]; for (let f = 1; f < i[h].length; f += 2) { const i = p[f - 1], h = p[f]; let d = a[i] < l, y = a[h] < l; u.vertexLength + ((d ? 1 : 0) + (y ? 1 : 0)) > Pa.MAX_VERTEX_ARRAY_LENGTH && (u = t.createNewSegment(e, r), l = o.count, d = !0, y = !0, c = 0); const m = Cl(a, n, s, o, i, d, u), g = Cl(a, n, s, o, h, y, u); r.emplaceBack(c + m - l, c + g - l), u.primitiveLength++; } } }(a, r, o, i, l, t), e.forceNewSegmentOnNextPrepare(), null == a || a.forceNewSegmentOnNextPrepare(); } function Cl(t, e, r, n, i, s, a) { if (s) { const s = n.count; return r(e[2 * i], e[2 * i + 1]), t[i] = n.count, n.count++, a.vertexLength++, s } return t[i] } class Bl { constructor(t) { this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((t => t.id)), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new ya, this.indexArray = new ka, this.indexArray2 = new Ma, this.programConfigurations = new ro(t.layers, t.zoom), this.segments = new Pa, this.segments2 = new Pa, this.stateDependentLayerIds = this.layers.filter((t => t.isStateDependent())).map((t => t.id)); } populate(t, e, r) { this.hasPattern = Ko("fill", this.layers, e); const n = this.layers[0].layout.get("fill-sort-key"), i = !n.isConstant(), s = []; for (const { feature: a, id: o, index: l, sourceLayerIndex: u } of t) { const t = this.layers[0]._featureFilter.needGeometry, c = lo(a, t); if (!this.layers[0]._featureFilter.filter(new cs(this.zoom), c, r)) continue; const h = i ? n.evaluate(c, {}, r, e.availableImages) : void 0, p = { id: o, properties: a.properties, type: a.type, sourceLayerIndex: u, index: l, geometry: t ? c.geometry : oo(a), patterns: {}, sortKey: h }; s.push(p); } i && s.sort(((t, e) => t.sortKey - e.sortKey)); for (const n of s) { const { geometry: i, index: s, sourceLayerIndex: a } = n; if (this.hasPattern) { const t = Ho("fill", this.layers, n, this.zoom, e); this.patternFeatures.push(t); } else this.addFeature(n, i, s, r, {}, e.subdivisionGranularity); e.featureIndex.insert(t[s].feature, i, s, a, this.index); } } update(t, e, r) { this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r); } addFeatures(t, e, r) { for (const n of this.patternFeatures) this.addFeature(n, n.geometry, n.index, e, r, t.subdivisionGranularity); } isEmpty() { return 0 === this.layoutVertexArray.length } uploadPending() { return !this.uploaded || this.programConfigurations.needsUpload } upload(t) { this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Xo), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t), this.uploaded = !0; } destroy() { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy()); } addFeature(t, e, r, n, i, s) { for (const t of Rr(e, 500)) { const e = Ml(t, n, s.fill.getGranularityForZoomLevel(n.z)), r = this.layoutVertexArray; Pl(((t, e) => { r.emplaceBack(t, e); }), this.segments, this.layoutVertexArray, this.indexArray, e.verticesFlattened, e.indicesTriangles, this.segments2, this.indexArray2, e.indicesLineList); } this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, n); } } let Vl, El; Ui("FillBucket", Bl, { omit: ["layers", "patternFeatures"] }); var Tl = { get paint() { return El = El || new As({ "fill-antialias": new vs(ht.paint_fill["fill-antialias"]), "fill-opacity": new bs(ht.paint_fill["fill-opacity"]), "fill-color": new bs(ht.paint_fill["fill-color"]), "fill-outline-color": new bs(ht.paint_fill["fill-outline-color"]), "fill-translate": new vs(ht.paint_fill["fill-translate"]), "fill-translate-anchor": new vs(ht.paint_fill["fill-translate-anchor"]), "fill-pattern": new ws(ht.paint_fill["fill-pattern"]) }) }, get layout() { return Vl = Vl || new As({ "fill-sort-key": new bs(ht.layout_fill["fill-sort-key"]) }) } }; class Fl extends Ms { constructor(t) { super(t, Tl); } recalculate(t, e) { super.recalculate(t, e); const r = this.paint._values["fill-outline-color"]; "constant" === r.value.kind && void 0 === r.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]); } createBucket(t) { return new Bl(t) } queryRadius() { return ko(this.paint.get("fill-translate")) } queryIntersectsFeature({ queryGeometry: t, geometry: e, transform: r, pixelsToTileUnits: n }) { return yo(Mo(t, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -r.bearingInRadians, n), e) } isTileClipped() { return !0 } } const $l = Cs([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), Ll = Cs([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: Ol } = $l; var Dl, Rl, jl, Nl, Ul, ql, Gl, Zl = {}; function Xl() { if (Rl) return Dl; Rl = 1; var t = s(); function e(t, e, n, i, s) { this.properties = {}, this.extent = n, this.type = 0, this._pbf = t, this._geometry = -1, this._keys = i, this._values = s, t.readFields(r, this, e); } function r(t, e, r) { 1 == t ? e.id = r.readVarint() : 2 == t ? function (t, e) { for (var r = t.readVarint() + t.pos; t.pos < r;) { var n = e._keys[t.readVarint()], i = e._values[t.readVarint()]; e.properties[n] = i; } }(r, e) : 3 == t ? e.type = r.readVarint() : 4 == t && (e._geometry = r.pos); } function n(t) { for (var e, r, n = 0, i = 0, s = t.length, a = s - 1; i < s; a = i++)n += ((r = t[a]).x - (e = t[i]).x) * (e.y + r.y); return n } return Dl = e, e.types = ["Unknown", "Point", "LineString", "Polygon"], e.prototype.loadGeometry = function () { var e = this._pbf; e.pos = this._geometry; for (var r, n = e.readVarint() + e.pos, i = 1, s = 0, a = 0, o = 0, l = []; e.pos < n;) { if (s <= 0) { var u = e.readVarint(); i = 7 & u, s = u >> 3; } if (s--, 1 === i || 2 === i) a += e.readSVarint(), o += e.readSVarint(), 1 === i && (r && l.push(r), r = []), r.push(new t(a, o)); else { if (7 !== i) throw new Error("unknown command " + i); r && r.push(r[0].clone()); } } return r && l.push(r), l }, e.prototype.bbox = function () { var t = this._pbf; t.pos = this._geometry; for (var e = t.readVarint() + t.pos, r = 1, n = 0, i = 0, s = 0, a = 1 / 0, o = -1 / 0, l = 1 / 0, u = -1 / 0; t.pos < e;) { if (n <= 0) { var c = t.readVarint(); r = 7 & c, n = c >> 3; } if (n--, 1 === r || 2 === r) (i += t.readSVarint()) < a && (a = i), i > o && (o = i), (s += t.readSVarint()) < l && (l = s), s > u && (u = s); else if (7 !== r) throw new Error("unknown command " + r) } return [a, l, o, u] }, e.prototype.toGeoJSON = function (t, r, i) { var s, a, o = this.extent * Math.pow(2, i), l = this.extent * t, u = this.extent * r, c = this.loadGeometry(), h = e.types[this.type]; function p(t) { for (var e = 0; e < t.length; e++) { var r = t[e]; t[e] = [360 * (r.x + l) / o - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r.y + u) / o) * Math.PI / 180)) - 90]; } } switch (this.type) { case 1: var f = []; for (s = 0; s < c.length; s++)f[s] = c[s][0]; p(c = f); break; case 2: for (s = 0; s < c.length; s++)p(c[s]); break; case 3: for (c = function (t) { var e = t.length; if (e <= 1) return [t]; for (var r, i, s = [], a = 0; a < e; a++) { var o = n(t[a]); 0 !== o && (void 0 === i && (i = o < 0), i === o < 0 ? (r && s.push(r), r = [t[a]]) : r.push(t[a])); } return r && s.push(r), s }(c), s = 0; s < c.length; s++)for (a = 0; a < c[s].length; a++)p(c[s][a]); }1 === c.length ? c = c[0] : h = "Multi" + h; var d = { type: "Feature", geometry: { type: h, coordinates: c }, properties: this.properties }; return "id" in this && (d.id = this.id), d }, Dl } function Kl() { if (Nl) return jl; Nl = 1; var t = Xl(); function e(t, e) { this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t, this._keys = [], this._values = [], this._features = [], t.readFields(r, this, e), this.length = this._features.length; } function r(t, e, r) { 15 === t ? e.version = r.readVarint() : 1 === t ? e.name = r.readString() : 5 === t ? e.extent = r.readVarint() : 2 === t ? e._features.push(r.pos) : 3 === t ? e._keys.push(r.readString()) : 4 === t && e._values.push(function (t) { for (var e = null, r = t.readVarint() + t.pos; t.pos < r;) { var n = t.readVarint() >> 3; e = 1 === n ? t.readString() : 2 === n ? t.readFloat() : 3 === n ? t.readDouble() : 4 === n ? t.readVarint64() : 5 === n ? t.readVarint() : 6 === n ? t.readSVarint() : 7 === n ? t.readBoolean() : null; } return e }(r)); } return jl = e, e.prototype.feature = function (e) { if (e < 0 || e >= this._features.length) throw new Error("feature index out of bounds"); this._pbf.pos = this._features[e]; var r = this._pbf.readVarint() + this._pbf.pos; return new t(this._pbf, r, this.extent, this._keys, this._values) }, jl } function Hl() { return Gl || (Gl = 1, Zl.VectorTile = function () { if (ql) return Ul; ql = 1; var t = Kl(); function e(e, r, n) { if (3 === e) { var i = new t(n, n.readVarint() + n.pos); i.length && (r[i.name] = i); } } return Ul = function (t, r) { this.layers = t.readFields(e, {}, r); }, Ul }(), Zl.VectorTileFeature = Xl(), Zl.VectorTileLayer = Kl()), Zl } var Yl = r(Hl()); const Jl = Yl.VectorTileFeature.types, Wl = Math.pow(2, 13); function Ql(t, e, r, n, i, s, a, o) { t.emplaceBack(e, r, 2 * Math.floor(n * Wl) + a, i * Wl * 2, s * Wl * 2, Math.round(o)); } class tu { constructor(t) { this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((t => t.id)), this.index = t.index, this.hasPattern = !1, this.layoutVertexArray = new ma, this.centroidVertexArray = new fa, this.indexArray = new ka, this.programConfigurations = new ro(t.layers, t.zoom), this.segments = new Pa, this.stateDependentLayerIds = this.layers.filter((t => t.isStateDependent())).map((t => t.id)); } populate(t, e, r) { this.features = [], this.hasPattern = Ko("fill-extrusion", this.layers, e); for (const { feature: n, id: i, index: s, sourceLayerIndex: a } of t) { const t = this.layers[0]._featureFilter.needGeometry, o = lo(n, t); if (!this.layers[0]._featureFilter.filter(new cs(this.zoom), o, r)) continue; const l = { id: i, sourceLayerIndex: a, index: s, geometry: t ? o.geometry : oo(n), properties: n.properties, type: n.type, patterns: {} }; this.hasPattern ? this.features.push(Ho("fill-extrusion", this.layers, l, this.zoom, e)) : this.addFeature(l, l.geometry, s, r, {}, e.subdivisionGranularity), e.featureIndex.insert(n, l.geometry, s, a, this.index, !0); } } addFeatures(t, e, r) { for (const n of this.features) { const { geometry: i } = n; this.addFeature(n, i, n.index, e, r, t.subdivisionGranularity); } } update(t, e, r) { this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r); } isEmpty() { return 0 === this.layoutVertexArray.length && 0 === this.centroidVertexArray.length } uploadPending() { return !this.uploaded || this.programConfigurations.needsUpload } upload(t) { this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Ol), this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, Ll.members, !0), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0; } destroy() { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy()); } addFeature(t, e, r, n, i, s) { for (const r of Rr(e, 500)) { const e = { x: 0, y: 0, sampleCount: 0 }, i = this.layoutVertexArray.length; this.processPolygon(e, n, t, r, s); const a = this.layoutVertexArray.length - i, o = Math.floor(e.x / e.sampleCount), l = Math.floor(e.y / e.sampleCount); for (let t = 0; t < a; t++)this.centroidVertexArray.emplaceBack(o, l); } this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, n); } processPolygon(t, e, r, n, i) { if (n.length < 1) return; if (nu(n[0])) return; for (const e of n) 0 !== e.length && eu(t, e); const s = { segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray) }, a = i.fill.getGranularityForZoomLevel(e.z), o = "Polygon" === Jl[r.type]; for (const t of n) { if (0 === t.length) continue; if (nu(t)) continue; const e = Il(t, a, o); this._generateSideFaces(e, s); } if (!o) return; const l = Ml(n, e, a, !1), u = this.layoutVertexArray; Pl(((t, e) => { Ql(u, t, e, 0, 0, 1, 1, 0); }), this.segments, this.layoutVertexArray, this.indexArray, l.verticesFlattened, l.indicesTriangles); } _generateSideFaces(t, e) { let r = 0; for (let n = 1; n < t.length; n++) { const i = t[n], s = t[n - 1]; if (ru(i, s)) continue; e.segment.vertexLength + 4 > Pa.MAX_VERTEX_ARRAY_LENGTH && (e.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray)); const a = i.sub(s)._perp()._unit(), o = s.dist(i); r + o > 32768 && (r = 0), Ql(this.layoutVertexArray, i.x, i.y, a.x, a.y, 0, 0, r), Ql(this.layoutVertexArray, i.x, i.y, a.x, a.y, 0, 1, r), r += o, Ql(this.layoutVertexArray, s.x, s.y, a.x, a.y, 0, 0, r), Ql(this.layoutVertexArray, s.x, s.y, a.x, a.y, 0, 1, r); const l = e.segment.vertexLength; this.indexArray.emplaceBack(l, l + 2, l + 1), this.indexArray.emplaceBack(l + 1, l + 2, l + 3), e.segment.vertexLength += 4, e.segment.primitiveLength += 2; } } } function eu(t, e) { for (let r = 0; r < e.length; r++) { const n = e[r]; r === e.length - 1 && e[0].x === n.x && e[0].y === n.y || (t.x += n.x, t.y += n.y, t.sampleCount++); } } function ru(t, e) { return t.x === e.x && (t.x < 0 || t.x > M) || t.y === e.y && (t.y < 0 || t.y > M) } function nu(t) { return t.every((t => t.x < 0)) || t.every((t => t.x > M)) || t.every((t => t.y < 0)) || t.every((t => t.y > M)) } let iu; Ui("FillExtrusionBucket", tu, { omit: ["layers", "features"] }); var su = { get paint() { return iu = iu || new As({ "fill-extrusion-opacity": new vs(ht["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new bs(ht["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new vs(ht["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new vs(ht["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new ws(ht["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new bs(ht["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new bs(ht["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new vs(ht["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) }) } }; class au extends Ms { constructor(t) { super(t, su); } createBucket(t) { return new tu(t) } queryRadius() { return ko(this.paint.get("fill-extrusion-translate")) } is3D() { return !0 } queryIntersectsFeature({ queryGeometry: t, feature: e, featureState: r, geometry: n, transform: i, pixelsToTileUnits: s, pixelPosMatrix: a }) { const o = Mo(t, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -i.bearingInRadians, s), u = this.paint.get("fill-extrusion-height").evaluate(e, r), c = this.paint.get("fill-extrusion-base").evaluate(e, r), h = function (t, e, r) { const n = []; for (const r of t) { const t = [r.x, r.y, 0, 1]; _(t, t, e), n.push(new l(t[0] / t[3], t[1] / t[3])); } return n }(o, a), p = function (t, e, r, n) { const i = [], s = [], a = n[8] * e, o = n[9] * e, u = n[10] * e, c = n[11] * e, h = n[8] * r, p = n[9] * r, f = n[10] * r, d = n[11] * r; for (const e of t) { const t = [], r = []; for (const i of e) { const e = i.x, s = i.y, y = n[0] * e + n[4] * s + n[12], m = n[1] * e + n[5] * s + n[13], g = n[2] * e + n[6] * s + n[14], x = n[3] * e + n[7] * s + n[15], v = g + u, b = x + c, w = y + h, _ = m + p, S = g + f, A = x + d, k = new l((y + a) / b, (m + o) / b); k.z = v / b, t.push(k); const M = new l(w / A, _ / A); M.z = S / A, r.push(M); } i.push(t), s.push(r); } return [i, s] }(n, c, u, a); return function (t, e, r) { let n = 1 / 0; yo(r, e) && (n = lu(r, e[0])); for (let i = 0; i < e.length; i++) { const s = e[i], a = t[i]; for (let t = 0; t < s.length - 1; t++) { const e = s[t], i = [e, s[t + 1], a[t + 1], a[t], e]; po(r, i) && (n = Math.min(n, lu(r, i))); } } return n !== 1 / 0 && n }(p[0], p[1], h) } } function ou(t, e) { return t.x * e.x + t.y * e.y } function lu(t, e) { if (1 === t.length) { let r = 0; const n = e[r++]; let i; for (; !i || n.equals(i);)if (i = e[r++], !i) return 1 / 0; for (; r < e.length; r++) { const s = e[r], a = t[0], o = i.sub(n), l = s.sub(n), u = a.sub(n), c = ou(o, o), h = ou(o, l), p = ou(l, l), f = ou(u, o), d = ou(u, l), y = c * p - h * h, m = (p * f - h * d) / y, g = (c * d - h * f) / y, x = n.z * (1 - m - g) + i.z * m + s.z * g; if (isFinite(x)) return x } return 1 / 0 } { let t = 1 / 0; for (const r of e) t = Math.min(t, r.z); return t } } const uu = Cs([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: cu } = uu, hu = Cs([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: pu } = hu, fu = Yl.VectorTileFeature.types, du = Math.cos(Math.PI / 180 * 37.5), yu = Math.pow(2, 14) / .5; class mu { constructor(t) { this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map((t => t.id)), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t => { this.gradients[t.id] = {}; })), this.layoutVertexArray = new ga, this.layoutVertexArray2 = new xa, this.indexArray = new ka, this.programConfigurations = new ro(t.layers, t.zoom), this.segments = new Pa, this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((t => t.isStateDependent())).map((t => t.id)); } populate(t, e, r) { this.hasPattern = Ko("line", this.layers, e); const n = this.layers[0].layout.get("line-sort-key"), i = !n.isConstant(), s = []; for (const { feature: e, id: a, index: o, sourceLayerIndex: l } of t) { const t = this.layers[0]._featureFilter.needGeometry, u = lo(e, t); if (!this.layers[0]._featureFilter.filter(new cs(this.zoom), u, r)) continue; const c = i ? n.evaluate(u, {}, r) : void 0, h = { id: a, properties: e.properties, type: e.type, sourceLayerIndex: l, index: o, geometry: t ? u.geometry : oo(e), patterns: {}, sortKey: c }; s.push(h); } i && s.sort(((t, e) => t.sortKey - e.sortKey)); for (const n of s) { const { geometry: i, index: s, sourceLayerIndex: a } = n; if (this.hasPattern) { const t = Ho("line", this.layers, n, this.zoom, e); this.patternFeatures.push(t); } else this.addFeature(n, i, s, r, {}, e.subdivisionGranularity); e.featureIndex.insert(t[s].feature, i, s, a, this.index); } } update(t, e, r) { this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, r); } addFeatures(t, e, r) { for (const n of this.patternFeatures) this.addFeature(n, n.geometry, n.index, e, r, t.subdivisionGranularity); } isEmpty() { return 0 === this.layoutVertexArray.length } uploadPending() { return !this.uploaded || this.programConfigurations.needsUpload } upload(t) { this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, pu)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, cu), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0; } destroy() { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy()); } lineFeatureClips(t) { if (t.properties && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_end")) return { start: +t.properties.mapbox_clip_start, end: +t.properties.mapbox_clip_end } } addFeature(t, e, r, n, i, s) { const a = this.layers[0].layout, o = a.get("line-join").evaluate(t, {}), l = a.get("line-cap"), u = a.get("line-miter-limit"), c = a.get("line-round-limit"); this.lineClips = this.lineFeatureClips(t); for (const r of e) this.addLine(r, t, o, l, u, c, n, s); this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, n); } addLine(t, e, r, n, i, s, a, o) { if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, t = Il(t, a ? o.line.getGranularityForZoomLevel(a.z) : 1), this.lineClips) { this.lineClipsArray.push(this.lineClips); for (let e = 0; e < t.length - 1; e++)this.totalDistance += t[e].dist(t[e + 1]); this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance); } const l = "Polygon" === fu[e.type]; let u = t.length; for (; u >= 2 && t[u - 1].equals(t[u - 2]);)u--; let c = 0; for (; c < u - 1 && t[c].equals(t[c + 1]);)c++; if (u < (l ? 3 : 2)) return; "bevel" === r && (i = 1.05); const h = this.overscaling <= 16 ? 15 * M / (512 * this.overscaling) : 0, p = this.segments.prepareSegment(10 * u, this.layoutVertexArray, this.indexArray); let f, d, y, m, g; this.e1 = this.e2 = -1, l && (f = t[u - 2], g = t[c].sub(f)._unit()._perp()); for (let e = c; e < u; e++) { if (y = e === u - 1 ? l ? t[c + 1] : void 0 : t[e + 1], y && t[e].equals(y)) continue; g && (m = g), f && (d = f), f = t[e], g = y ? y.sub(f)._unit()._perp() : m, m = m || g; let a = m.add(g); 0 === a.x && 0 === a.y || a._unit(); const o = m.x * g.x + m.y * g.y, x = a.x * g.x + a.y * g.y, v = 0 !== x ? 1 / x : 1 / 0, b = 2 * Math.sqrt(2 - 2 * x), w = x < du && d && y, _ = m.x * g.y - m.y * g.x > 0; if (w && e > c) { const t = f.dist(d); if (t > 2 * h) { const e = f.sub(f.sub(d)._mult(h / t)._round()); this.updateDistance(d, e), this.addCurrentVertex(e, m, 0, 0, p), d = e; } } const S = d && y; let A = S ? r : l ? "butt" : n; if (S && "round" === A && (v < s ? A = "miter" : v <= 2 && (A = "fakeround")), "miter" === A && v > i && (A = "bevel"), "bevel" === A && (v > 2 && (A = "flipbevel"), v < i && (A = "miter")), d && this.updateDistance(d, f), "miter" === A) a._mult(v), this.addCurrentVertex(f, a, 0, 0, p); else if ("flipbevel" === A) { if (v > 100) a = g.mult(-1); else { const t = v * m.add(g).mag() / m.sub(g).mag(); a._perp()._mult(t * (_ ? -1 : 1)); } this.addCurrentVertex(f, a, 0, 0, p), this.addCurrentVertex(f, a.mult(-1), 0, 0, p); } else if ("bevel" === A || "fakeround" === A) { const t = -Math.sqrt(v * v - 1), e = _ ? t : 0, r = _ ? 0 : t; if (d && this.addCurrentVertex(f, m, e, r, p), "fakeround" === A) { const t = Math.round(180 * b / Math.PI / 20); for (let e = 1; e < t; e++) { let r = e / t; if (.5 !== r) { const t = r - .5; r += r * t * (r - 1) * ((1.0904 + o * (o * (3.55645 - 1.43519 * o) - 3.2452)) * t * t + (.848013 + o * (.215638 * o - 1.06021))); } const n = g.sub(m)._mult(r)._add(m)._unit()._mult(_ ? -1 : 1); this.addHalfVertex(f, n.x, n.y, !1, _, 0, p); } } y && this.addCurrentVertex(f, g, -e, -r, p); } else if ("butt" === A) this.addCurrentVertex(f, a, 0, 0, p); else if ("square" === A) { const t = d ? 1 : -1; this.addCurrentVertex(f, a, t, t, p); } else "round" === A && (d && (this.addCurrentVertex(f, m, 0, 0, p), this.addCurrentVertex(f, m, 1, 1, p, !0)), y && (this.addCurrentVertex(f, g, -1, -1, p, !0), this.addCurrentVertex(f, g, 0, 0, p))); if (w && e < u - 1) { const t = f.dist(y); if (t > 2 * h) { const e = f.add(y.sub(f)._mult(h / t)._round()); this.updateDistance(f, e), this.addCurrentVertex(e, g, 0, 0, p), f = e; } } } } addCurrentVertex(t, e, r, n, i, s = !1) { const a = e.y * n - e.x, o = -e.y - e.x * n; this.addHalfVertex(t, e.x + e.y * r, e.y - e.x * r, s, !1, r, i), this.addHalfVertex(t, a, o, s, !0, -n, i), this.distance > yu / 2 && 0 === this.totalDistance && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t, e, r, n, i, s)); } addHalfVertex({ x: t, y: e }, r, n, i, s, a, o) { const l = .5 * (this.lineClips ? this.scaledDistance * (yu - 1) : this.scaledDistance); this.layoutVertexArray.emplaceBack((t << 1) + (i ? 1 : 0), (e << 1) + (s ? 1 : 0), Math.round(63 * r) + 128, Math.round(63 * n) + 128, 1 + (0 === a ? 0 : a < 0 ? -1 : 1) | (63 & l) << 2, l >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length); const u = o.vertexLength++; this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, u, this.e2), o.primitiveLength++), s ? this.e2 = u : this.e1 = u; } updateScaledDistance() { this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance; } updateDistance(t, e) { this.distance += t.dist(e), this.updateScaledDistance(); } } let gu, xu; Ui("LineBucket", mu, { omit: ["layers", "patternFeatures"] }); var vu = { get paint() { return xu = xu || new As({ "line-opacity": new bs(ht.paint_line["line-opacity"]), "line-color": new bs(ht.paint_line["line-color"]), "line-translate": new vs(ht.paint_line["line-translate"]), "line-translate-anchor": new vs(ht.paint_line["line-translate-anchor"]), "line-width": new bs(ht.paint_line["line-width"]), "line-gap-width": new bs(ht.paint_line["line-gap-width"]), "line-offset": new bs(ht.paint_line["line-offset"]), "line-blur": new bs(ht.paint_line["line-blur"]), "line-dasharray": new _s(ht.paint_line["line-dasharray"]), "line-pattern": new ws(ht.paint_line["line-pattern"]), "line-gradient": new Ss(ht.paint_line["line-gradient"]) }) }, get layout() { return gu = gu || new As({ "line-cap": new vs(ht.layout_line["line-cap"]), "line-join": new bs(ht.layout_line["line-join"]), "line-miter-limit": new vs(ht.layout_line["line-miter-limit"]), "line-round-limit": new vs(ht.layout_line["line-round-limit"]), "line-sort-key": new bs(ht.layout_line["line-sort-key"]) }) } }; class bu extends bs { possiblyEvaluate(t, e) { return e = new cs(Math.floor(e.zoom), { now: e.now, fadeDuration: e.fadeDuration, zoomHistory: e.zoomHistory, transition: e.transition }), super.possiblyEvaluate(t, e) } evaluate(t, e, r, n) { return e = F({}, e, { zoom: Math.floor(e.zoom) }), super.evaluate(t, e, r, n) } } let wu; class _u extends Ms { constructor(t) { super(t, vu), this.gradientVersion = 0, wu || (wu = new bu(vu.paint.properties["line-width"].specification), wu.useIntegerZoom = !0); } _handleSpecialPaintPropertyUpdate(t) { if ("line-gradient" === t) { const t = this.gradientExpression(); this.stepInterpolant = !!function (t) { return void 0 !== t._styleExpression }(t) && t._styleExpression.expression instanceof Xe, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER; } } gradientExpression() { return this._transitionablePaint._values["line-gradient"].value.expression } recalculate(t, e) { super.recalculate(t, e), this.paint._values["line-floorwidth"] = wu.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t); } createBucket(t) { return new mu(t) } queryRadius(t) { const e = t, r = Su(Ao("line-width", this, e), Ao("line-gap-width", this, e)), n = Ao("line-offset", this, e); return r / 2 + Math.abs(n) + ko(this.paint.get("line-translate")) } queryIntersectsFeature({ queryGeometry: t, feature: e, featureState: r, geometry: n, transform: i, pixelsToTileUnits: s }) { const a = Mo(t, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -i.bearingInRadians, s), o = s / 2 * Su(this.paint.get("line-width").evaluate(e, r), this.paint.get("line-gap-width").evaluate(e, r)), u = this.paint.get("line-offset").evaluate(e, r); return u && (n = function (t, e) { const r = []; for (let n = 0; n < t.length; n++) { const i = t[n], s = []; for (let t = 0; t < i.length; t++) { const r = i[t - 1], n = i[t], a = i[t + 1], o = 0 === t ? new l(0, 0) : n.sub(r)._unit()._perp(), u = t === i.length - 1 ? new l(0, 0) : a.sub(n)._unit()._perp(), c = o._add(u)._unit(), h = c.x * u.x + c.y * u.y; 0 !== h && c._mult(1 / h), s.push(c._mult(e)._add(n)); } r.push(s); } return r }(n, u * s)), function (t, e, r) { for (let n = 0; n < e.length; n++) { const i = e[n]; if (t.length >= 3) for (let e = 0; e < i.length; e++)if (_o(t, i[e])) return !0; if (mo(t, i, r)) return !0 } return !1 }(a, n, o) } isTileClipped() { return !0 } } function Su(t, e) { return e > 0 ? e + 2 * t : t } const Au = Cs([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), ku = Cs([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4); Cs([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4); const Mu = Cs([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_box_real", components: 2, type: "Int16" }]); Cs([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]); const Iu = Cs([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), zu = Cs([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4); function Pu(t, e, r) { return t.sections.forEach((t => { t.text = function (t, e, r) { const n = e.layout.get("text-transform").evaluate(r, {}); return "uppercase" === n ? t = t.toLocaleUpperCase() : "lowercase" === n && (t = t.toLocaleLowerCase()), us.applyArabicShaping && (t = us.applyArabicShaping(t)), t }(t.text, e, r); })), t } Cs([{ name: "triangle", components: 3, type: "Uint16" }]), Cs([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), Cs([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), Cs([{ type: "Float32", name: "offsetX" }]), Cs([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), Cs([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]); const Cu = { "!": "︕", "#": "＃", $: "＄", "%": "％", "&": "＆", "(": "︵", ")": "︶", "*": "＊", "+": "＋", ",": "︐", "-": "︲", ".": "・", "/": "／", ":": "︓", ";": "︔", "<": "︿", "=": "＝", ">": "﹀", "?": "︖", "@": "＠", "[": "﹇", "\\": "＼", "]": "﹈", "^": "＾", _: "︳", "`": "｀", "{": "︷", "|": "―", "}": "︸", "~": "～", "¢": "￠", "£": "￡", "¥": "￥", "¦": "￤", "¬": "￢", "¯": "￣", "–": "︲", "—": "︱", "‘": "﹃", "’": "﹄", "“": "﹁", "”": "﹂", "…": "︙", "‧": "・", "₩": "￦", "、": "︑", "。": "︒", "〈": "︿", "〉": "﹀", "《": "︽", "》": "︾", "「": "﹁", "」": "﹂", "『": "﹃", "』": "﹄", "【": "︻", "】": "︼", "〔": "︹", "〕": "︺", "〖": "︗", "〗": "︘", "！": "︕", "（": "︵", "）": "︶", "，": "︐", "－": "︲", "．": "・", "：": "︓", "；": "︔", "＜": "︿", "＞": "﹀", "？": "︖", "［": "﹇", "］": "﹈", "＿": "︳", "｛": "︷", "｜": "―", "｝": "︸", "｟": "︵", "｠": "︶", "｡": "︒", "｢": "﹁", "｣": "﹂" }; var Bu, Vu, Eu, Tu = 24, Fu = {}; function $u() { return Bu || (Bu = 1, Fu.read = function (t, e, r, n, i) { var s, a, o = 8 * i - n - 1, l = (1 << o) - 1, u = l >> 1, c = -7, h = r ? i - 1 : 0, p = r ? -1 : 1, f = t[e + h]; for (h += p, s = f & (1 << -c) - 1, f >>= -c, c += o; c > 0; s = 256 * s + t[e + h], h += p, c -= 8); for (a = s & (1 << -c) - 1, s >>= -c, c += n; c > 0; a = 256 * a + t[e + h], h += p, c -= 8); if (0 === s) s = 1 - u; else { if (s === l) return a ? NaN : 1 / 0 * (f ? -1 : 1); a += Math.pow(2, n), s -= u; } return (f ? -1 : 1) * a * Math.pow(2, s - n) }, Fu.write = function (t, e, r, n, i, s) { var a, o, l, u = 8 * s - i - 1, c = (1 << u) - 1, h = c >> 1, p = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f = n ? 0 : s - 1, d = n ? 1 : -1, y = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0; for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (o = isNaN(e) ? 1 : 0, a = c) : (a = Math.floor(Math.log(e) / Math.LN2), e * (l = Math.pow(2, -a)) < 1 && (a--, l *= 2), (e += a + h >= 1 ? p / l : p * Math.pow(2, 1 - h)) * l >= 2 && (a++, l /= 2), a + h >= c ? (o = 0, a = c) : a + h >= 1 ? (o = (e * l - 1) * Math.pow(2, i), a += h) : (o = e * Math.pow(2, h - 1) * Math.pow(2, i), a = 0)); i >= 8; t[r + f] = 255 & o, f += d, o /= 256, i -= 8); for (a = a << i | o, u += i; u > 0; t[r + f] = 255 & a, f += d, a /= 256, u -= 8); t[r + f - d] |= 128 * y; }), Fu } function Lu() { if (Eu) return Vu; Eu = 1, Vu = e; var t = $u(); function e(t) { this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t) ? t : new Uint8Array(t || 0), this.pos = 0, this.type = 0, this.length = this.buf.length; } e.Varint = 0, e.Fixed64 = 1, e.Bytes = 2, e.Fixed32 = 5; var r = 4294967296, n = 1 / r, i = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf-8"); function s(t) { return t.type === e.Bytes ? t.readVarint() + t.pos : t.pos + 1 } function a(t, e, r) { return r ? 4294967296 * e + (t >>> 0) : 4294967296 * (e >>> 0) + (t >>> 0) } function o(t, e, r) { var n = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (7 * Math.LN2)); r.realloc(n); for (var i = r.pos - 1; i >= t; i--)r.buf[i + n] = r.buf[i]; } function l(t, e) { for (var r = 0; r < t.length; r++)e.writeVarint(t[r]); } function u(t, e) { for (var r = 0; r < t.length; r++)e.writeSVarint(t[r]); } function c(t, e) { for (var r = 0; r < t.length; r++)e.writeFloat(t[r]); } function h(t, e) { for (var r = 0; r < t.length; r++)e.writeDouble(t[r]); } function p(t, e) { for (var r = 0; r < t.length; r++)e.writeBoolean(t[r]); } function f(t, e) { for (var r = 0; r < t.length; r++)e.writeFixed32(t[r]); } function d(t, e) { for (var r = 0; r < t.length; r++)e.writeSFixed32(t[r]); } function y(t, e) { for (var r = 0; r < t.length; r++)e.writeFixed64(t[r]); } function m(t, e) { for (var r = 0; r < t.length; r++)e.writeSFixed64(t[r]); } function g(t, e) { return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + 16777216 * t[e + 3] } function x(t, e, r) { t[r] = e, t[r + 1] = e >>> 8, t[r + 2] = e >>> 16, t[r + 3] = e >>> 24; } function v(t, e) { return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + (t[e + 3] << 24) } return e.prototype = { destroy: function () { this.buf = null; }, readFields: function (t, e, r) { for (r = r || this.length; this.pos < r;) { var n = this.readVarint(), i = n >> 3, s = this.pos; this.type = 7 & n, t(i, e, this), this.pos === s && this.skip(n); } return e }, readMessage: function (t, e) { return this.readFields(t, e, this.readVarint() + this.pos) }, readFixed32: function () { var t = g(this.buf, this.pos); return this.pos += 4, t }, readSFixed32: function () { var t = v(this.buf, this.pos); return this.pos += 4, t }, readFixed64: function () { var t = g(this.buf, this.pos) + g(this.buf, this.pos + 4) * r; return this.pos += 8, t }, readSFixed64: function () { var t = g(this.buf, this.pos) + v(this.buf, this.pos + 4) * r; return this.pos += 8, t }, readFloat: function () { var e = t.read(this.buf, this.pos, !0, 23, 4); return this.pos += 4, e }, readDouble: function () { var e = t.read(this.buf, this.pos, !0, 52, 8); return this.pos += 8, e }, readVarint: function (t) { var e, r, n = this.buf; return e = 127 & (r = n[this.pos++]), r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 7, r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 14, r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 21, r < 128 ? e : function (t, e, r) { var n, i, s = r.buf; if (n = (112 & (i = s[r.pos++])) >> 4, i < 128) return a(t, n, e); if (n |= (127 & (i = s[r.pos++])) << 3, i < 128) return a(t, n, e); if (n |= (127 & (i = s[r.pos++])) << 10, i < 128) return a(t, n, e); if (n |= (127 & (i = s[r.pos++])) << 17, i < 128) return a(t, n, e); if (n |= (127 & (i = s[r.pos++])) << 24, i < 128) return a(t, n, e); if (n |= (1 & (i = s[r.pos++])) << 31, i < 128) return a(t, n, e); throw new Error("Expected varint not more than 10 bytes") }(e |= (15 & (r = n[this.pos])) << 28, t, this)))) }, readVarint64: function () { return this.readVarint(!0) }, readSVarint: function () { var t = this.readVarint(); return t % 2 == 1 ? (t + 1) / -2 : t / 2 }, readBoolean: function () { return Boolean(this.readVarint()) }, readString: function () { var t = this.readVarint() + this.pos, e = this.pos; return this.pos = t, t - e >= 12 && i ? function (t, e, r) { return i.decode(t.subarray(e, r)) }(this.buf, e, t) : function (t, e, r) { for (var n = "", i = e; i < r;) { var s, a, o, l = t[i], u = null, c = l > 239 ? 4 : l > 223 ? 3 : l > 191 ? 2 : 1; if (i + c > r) break; 1 === c ? l < 128 && (u = l) : 2 === c ? 128 == (192 & (s = t[i + 1])) && (u = (31 & l) << 6 | 63 & s) <= 127 && (u = null) : 3 === c ? (a = t[i + 2], 128 == (192 & (s = t[i + 1])) && 128 == (192 & a) && ((u = (15 & l) << 12 | (63 & s) << 6 | 63 & a) <= 2047 || u >= 55296 && u <= 57343) && (u = null)) : 4 === c && (a = t[i + 2], o = t[i + 3], 128 == (192 & (s = t[i + 1])) && 128 == (192 & a) && 128 == (192 & o) && ((u = (15 & l) << 18 | (63 & s) << 12 | (63 & a) << 6 | 63 & o) <= 65535 || u >= 1114112) && (u = null)), null === u ? (u = 65533, c = 1) : u > 65535 && (u -= 65536, n += String.fromCharCode(u >>> 10 & 1023 | 55296), u = 56320 | 1023 & u), n += String.fromCharCode(u), i += c; } return n }(this.buf, e, t) }, readBytes: function () { var t = this.readVarint() + this.pos, e = this.buf.subarray(this.pos, t); return this.pos = t, e }, readPackedVarint: function (t, r) { if (this.type !== e.Bytes) return t.push(this.readVarint(r)); var n = s(this); for (t = t || []; this.pos < n;)t.push(this.readVarint(r)); return t }, readPackedSVarint: function (t) { if (this.type !== e.Bytes) return t.push(this.readSVarint()); var r = s(this); for (t = t || []; this.pos < r;)t.push(this.readSVarint()); return t }, readPackedBoolean: function (t) { if (this.type !== e.Bytes) return t.push(this.readBoolean()); var r = s(this); for (t = t || []; this.pos < r;)t.push(this.readBoolean()); return t }, readPackedFloat: function (t) { if (this.type !== e.Bytes) return t.push(this.readFloat()); var r = s(this); for (t = t || []; this.pos < r;)t.push(this.readFloat()); return t }, readPackedDouble: function (t) { if (this.type !== e.Bytes) return t.push(this.readDouble()); var r = s(this); for (t = t || []; this.pos < r;)t.push(this.readDouble()); return t }, readPackedFixed32: function (t) { if (this.type !== e.Bytes) return t.push(this.readFixed32()); var r = s(this); for (t = t || []; this.pos < r;)t.push(this.readFixed32()); return t }, readPackedSFixed32: function (t) { if (this.type !== e.Bytes) return t.push(this.readSFixed32()); var r = s(this); for (t = t || []; this.pos < r;)t.push(this.readSFixed32()); return t }, readPackedFixed64: function (t) { if (this.type !== e.Bytes) return t.push(this.readFixed64()); var r = s(this); for (t = t || []; this.pos < r;)t.push(this.readFixed64()); return t }, readPackedSFixed64: function (t) { if (this.type !== e.Bytes) return t.push(this.readSFixed64()); var r = s(this); for (t = t || []; this.pos < r;)t.push(this.readSFixed64()); return t }, skip: function (t) { var r = 7 & t; if (r === e.Varint) for (; this.buf[this.pos++] > 127;); else if (r === e.Bytes) this.pos = this.readVarint() + this.pos; else if (r === e.Fixed32) this.pos += 4; else { if (r !== e.Fixed64) throw new Error("Unimplemented type: " + r); this.pos += 8; } }, writeTag: function (t, e) { this.writeVarint(t << 3 | e); }, realloc: function (t) { for (var e = this.length || 16; e < this.pos + t;)e *= 2; if (e !== this.length) { var r = new Uint8Array(e); r.set(this.buf), this.buf = r, this.length = e; } }, finish: function () { return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length) }, writeFixed32: function (t) { this.realloc(4), x(this.buf, t, this.pos), this.pos += 4; }, writeSFixed32: function (t) { this.realloc(4), x(this.buf, t, this.pos), this.pos += 4; }, writeFixed64: function (t) { this.realloc(8), x(this.buf, -1 & t, this.pos), x(this.buf, Math.floor(t * n), this.pos + 4), this.pos += 8; }, writeSFixed64: function (t) { this.realloc(8), x(this.buf, -1 & t, this.pos), x(this.buf, Math.floor(t * n), this.pos + 4), this.pos += 8; }, writeVarint: function (t) { (t = +t || 0) > 268435455 || t < 0 ? function (t, e) { var r, n; if (t >= 0 ? (r = t % 4294967296 | 0, n = t / 4294967296 | 0) : (n = ~(-t / 4294967296), 4294967295 ^ (r = ~(-t % 4294967296)) ? r = r + 1 | 0 : (r = 0, n = n + 1 | 0)), t >= 0x10000000000000000 || t < -0x10000000000000000) throw new Error("Given varint doesn't fit into 10 bytes"); e.realloc(10), function (t, e, r) { r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, r.buf[r.pos] = 127 & (t >>>= 7); }(r, 0, e), function (t, e) { var r = (7 & t) << 4; e.buf[e.pos++] |= r | ((t >>>= 3) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t))))); }(n, e); }(t, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127)))); }, writeSVarint: function (t) { this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t); }, writeBoolean: function (t) { this.writeVarint(Boolean(t)); }, writeString: function (t) { t = String(t), this.realloc(4 * t.length), this.pos++; var e = this.pos; this.pos = function (t, e, r) { for (var n, i, s = 0; s < e.length; s++) { if ((n = e.charCodeAt(s)) > 55295 && n < 57344) { if (!i) { n > 56319 || s + 1 === e.length ? (t[r++] = 239, t[r++] = 191, t[r++] = 189) : i = n; continue } if (n < 56320) { t[r++] = 239, t[r++] = 191, t[r++] = 189, i = n; continue } n = i - 55296 << 10 | n - 56320 | 65536, i = null; } else i && (t[r++] = 239, t[r++] = 191, t[r++] = 189, i = null); n < 128 ? t[r++] = n : (n < 2048 ? t[r++] = n >> 6 | 192 : (n < 65536 ? t[r++] = n >> 12 | 224 : (t[r++] = n >> 18 | 240, t[r++] = n >> 12 & 63 | 128), t[r++] = n >> 6 & 63 | 128), t[r++] = 63 & n | 128); } return r }(this.buf, t, this.pos); var r = this.pos - e; r >= 128 && o(e, r, this), this.pos = e - 1, this.writeVarint(r), this.pos += r; }, writeFloat: function (e) { this.realloc(4), t.write(this.buf, e, this.pos, !0, 23, 4), this.pos += 4; }, writeDouble: function (e) { this.realloc(8), t.write(this.buf, e, this.pos, !0, 52, 8), this.pos += 8; }, writeBytes: function (t) { var e = t.length; this.writeVarint(e), this.realloc(e); for (var r = 0; r < e; r++)this.buf[this.pos++] = t[r]; }, writeRawMessage: function (t, e) { this.pos++; var r = this.pos; t(e, this); var n = this.pos - r; n >= 128 && o(r, n, this), this.pos = r - 1, this.writeVarint(n), this.pos += n; }, writeMessage: function (t, r, n) { this.writeTag(t, e.Bytes), this.writeRawMessage(r, n); }, writePackedVarint: function (t, e) { e.length && this.writeMessage(t, l, e); }, writePackedSVarint: function (t, e) { e.length && this.writeMessage(t, u, e); }, writePackedBoolean: function (t, e) { e.length && this.writeMessage(t, p, e); }, writePackedFloat: function (t, e) { e.length && this.writeMessage(t, c, e); }, writePackedDouble: function (t, e) { e.length && this.writeMessage(t, h, e); }, writePackedFixed32: function (t, e) { e.length && this.writeMessage(t, f, e); }, writePackedSFixed32: function (t, e) { e.length && this.writeMessage(t, d, e); }, writePackedFixed64: function (t, e) { e.length && this.writeMessage(t, y, e); }, writePackedSFixed64: function (t, e) { e.length && this.writeMessage(t, m, e); }, writeBytesField: function (t, r) { this.writeTag(t, e.Bytes), this.writeBytes(r); }, writeFixed32Field: function (t, r) { this.writeTag(t, e.Fixed32), this.writeFixed32(r); }, writeSFixed32Field: function (t, r) { this.writeTag(t, e.Fixed32), this.writeSFixed32(r); }, writeFixed64Field: function (t, r) { this.writeTag(t, e.Fixed64), this.writeFixed64(r); }, writeSFixed64Field: function (t, r) { this.writeTag(t, e.Fixed64), this.writeSFixed64(r); }, writeVarintField: function (t, r) { this.writeTag(t, e.Varint), this.writeVarint(r); }, writeSVarintField: function (t, r) { this.writeTag(t, e.Varint), this.writeSVarint(r); }, writeStringField: function (t, r) { this.writeTag(t, e.Bytes), this.writeString(r); }, writeFloatField: function (t, r) { this.writeTag(t, e.Fixed32), this.writeFloat(r); }, writeDoubleField: function (t, r) { this.writeTag(t, e.Fixed64), this.writeDouble(r); }, writeBooleanField: function (t, e) { this.writeVarintField(t, Boolean(e)); } }, Vu } var Ou = r(Lu()); const Du = 3; function Ru(t, e, r) { 1 === t && r.readMessage(ju, e); } function ju(t, e, r) { if (3 === t) { const { id: t, bitmap: n, width: i, height: s, left: a, top: o, advance: l } = r.readMessage(Nu, {}); e.push({ id: t, bitmap: new Oo({ width: i + 2 * Du, height: s + 2 * Du }, n), metrics: { width: i, height: s, left: a, top: o, advance: l } }); } } function Nu(t, e, r) { 1 === t ? e.id = r.readVarint() : 2 === t ? e.bitmap = r.readBytes() : 3 === t ? e.width = r.readVarint() : 4 === t ? e.height = r.readVarint() : 5 === t ? e.left = r.readSVarint() : 6 === t ? e.top = r.readSVarint() : 7 === t && (e.advance = r.readVarint()); } const Uu = Du; function qu(t) { let e = 0, r = 0; for (const n of t) e += n.w * n.h, r = Math.max(r, n.w); t.sort(((t, e) => e.h - t.h)); const n = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e / .95)), r), h: 1 / 0 }]; let i = 0, s = 0; for (const e of t) for (let t = n.length - 1; t >= 0; t--) { const r = n[t]; if (!(e.w > r.w || e.h > r.h)) { if (e.x = r.x, e.y = r.y, s = Math.max(s, e.y + e.h), i = Math.max(i, e.x + e.w), e.w === r.w && e.h === r.h) { const e = n.pop(); t < n.length && (n[t] = e); } else e.h === r.h ? (r.x += e.w, r.w -= e.w) : e.w === r.w ? (r.y += e.h, r.h -= e.h) : (n.push({ x: r.x + e.w, y: r.y, w: r.w - e.w, h: e.h }), r.y += e.h, r.h -= e.h); break } } return { w: i, h: s, fill: e / (i * s) || 0 } } const Gu = 1; class Zu { constructor(t, { pixelRatio: e, version: r, stretchX: n, stretchY: i, content: s, textFitWidth: a, textFitHeight: o }) { this.paddedRect = t, this.pixelRatio = e, this.stretchX = n, this.stretchY = i, this.content = s, this.version = r, this.textFitWidth = a, this.textFitHeight = o; } get tl() { return [this.paddedRect.x + Gu, this.paddedRect.y + Gu] } get br() { return [this.paddedRect.x + this.paddedRect.w - Gu, this.paddedRect.y + this.paddedRect.h - Gu] } get tlbr() { return this.tl.concat(this.br) } get displaySize() { return [(this.paddedRect.w - 2 * Gu) / this.pixelRatio, (this.paddedRect.h - 2 * Gu) / this.pixelRatio] } } class Xu { constructor(t, e) { const r = {}, n = {}; this.haveRenderCallbacks = []; const i = []; this.addImages(t, r, i), this.addImages(e, n, i); const { w: s, h: a } = qu(i), o = new Do({ width: s || 1, height: a || 1 }); for (const e in t) { const n = t[e], i = r[e].paddedRect; Do.copy(n.data, o, { x: 0, y: 0 }, { x: i.x + Gu, y: i.y + Gu }, n.data); } for (const t in e) { const r = e[t], i = n[t].paddedRect, s = i.x + Gu, a = i.y + Gu, l = r.data.width, u = r.data.height; Do.copy(r.data, o, { x: 0, y: 0 }, { x: s, y: a }, r.data), Do.copy(r.data, o, { x: 0, y: u - 1 }, { x: s, y: a - 1 }, { width: l, height: 1 }), Do.copy(r.data, o, { x: 0, y: 0 }, { x: s, y: a + u }, { width: l, height: 1 }), Do.copy(r.data, o, { x: l - 1, y: 0 }, { x: s - 1, y: a }, { width: 1, height: u }), Do.copy(r.data, o, { x: 0, y: 0 }, { x: s + l, y: a }, { width: 1, height: u }); } this.image = o, this.iconPositions = r, this.patternPositions = n; } addImages(t, e, r) { for (const n in t) { const i = t[n], s = { x: 0, y: 0, w: i.data.width + 2 * Gu, h: i.data.height + 2 * Gu }; r.push(s), e[n] = new Zu(s, i), i.hasRenderCallback && this.haveRenderCallbacks.push(n); } } patchUpdatedImages(t, e) { t.dispatchRenderCallbacks(this.haveRenderCallbacks); for (const r in t.updatedImages) this.patchUpdatedImage(this.iconPositions[r], t.getImage(r), e), this.patchUpdatedImage(this.patternPositions[r], t.getImage(r), e); } patchUpdatedImage(t, e, r) { if (!t || !e) return; if (t.version === e.version) return; t.version = e.version; const [n, i] = t.tl; r.update(e.data, void 0, { x: n, y: i }); } } var Ku; Ui("ImagePosition", Zu), Ui("ImageAtlas", Xu), t.ai = void 0, (Ku = t.ai || (t.ai = {}))[Ku.none = 0] = "none", Ku[Ku.horizontal = 1] = "horizontal", Ku[Ku.vertical = 2] = "vertical", Ku[Ku.horizontalOnly = 3] = "horizontalOnly"; const Hu = -17; class Yu { constructor() { this.scale = 1, this.fontStack = "", this.imageName = null, this.verticalAlign = "bottom"; } static forText(t, e, r) { const n = new Yu; return n.scale = t || 1, n.fontStack = e, n.verticalAlign = r || "bottom", n } static forImage(t, e) { const r = new Yu; return r.imageName = t, r.verticalAlign = e || "bottom", r } } class Ju { constructor() { this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null; } static fromFeature(t, e) { const r = new Ju; for (let n = 0; n < t.sections.length; n++) { const i = t.sections[n]; i.image ? r.addImageSection(i) : r.addTextSection(i, e); } return r } length() { return this.text.length } getSection(t) { return this.sections[this.sectionIndex[t]] } getSectionIndex(t) { return this.sectionIndex[t] } getCharCode(t) { return this.text.charCodeAt(t) } verticalizePunctuation() { this.text = function (t) { let e = ""; for (let r = 0; r < t.length; r++) { const n = t.charCodeAt(r + 1) || null, i = t.charCodeAt(r - 1) || null; e += n && is(n) && !Cu[t[r + 1]] || i && is(i) && !Cu[t[r - 1]] || !Cu[t[r]] ? t[r] : Cu[t[r]]; } return e }(this.text); } trim() { let t = 0; for (let e = 0; e < this.text.length && Qu[this.text.charCodeAt(e)]; e++)t++; let e = this.text.length; for (let r = this.text.length - 1; r >= 0 && r >= t && Qu[this.text.charCodeAt(r)]; r--)e--; this.text = this.text.substring(t, e), this.sectionIndex = this.sectionIndex.slice(t, e); } substring(t, e) { const r = new Ju; return r.text = this.text.substring(t, e), r.sectionIndex = this.sectionIndex.slice(t, e), r.sections = this.sections, r } toString() { return this.text } getMaxScale() { return this.sectionIndex.reduce(((t, e) => Math.max(t, this.sections[e].scale)), 0) } getMaxImageSize(t) { let e = 0, r = 0; for (let n = 0; n < this.length(); n++) { const i = this.getSection(n); if (i.imageName) { const n = t[i.imageName]; if (!n) continue; const s = n.displaySize; e = Math.max(e, s[0]), r = Math.max(r, s[1]); } } return { maxImageWidth: e, maxImageHeight: r } } addTextSection(t, e) { this.text += t.text, this.sections.push(Yu.forText(t.scale, t.fontStack || e, t.verticalAlign)); const r = this.sections.length - 1; for (let e = 0; e < t.text.length; ++e)this.sectionIndex.push(r); } addImageSection(t) { const e = t.image ? t.image.name : ""; if (0 === e.length) return void j("Can't add FormattedSection with an empty image."); const r = this.getNextImageSectionCharCode(); r ? (this.text += String.fromCharCode(r), this.sections.push(Yu.forImage(e, t.verticalAlign)), this.sectionIndex.push(this.sections.length - 1)) : j("Reached maximum number of images 6401"); } getNextImageSectionCharCode() { return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID) } } function Wu(e, r, n, i, s, a, o, l, u, c, h, p, f, d, y) { const m = Ju.fromFeature(e, s); let g; p === t.ai.vertical && m.verticalizePunctuation(); const { processBidirectionalText: x, processStyledBidirectionalText: v } = us; if (x && 1 === m.sections.length) { g = []; const t = x(m.toString(), oc(m, c, a, r, i, d)); for (const e of t) { const t = new Ju; t.text = e, t.sections = m.sections; for (let r = 0; r < e.length; r++)t.sectionIndex.push(0); g.push(t); } } else if (v) { g = []; const t = v(m.text, m.sectionIndex, oc(m, c, a, r, i, d)); for (const e of t) { const t = new Ju; t.text = e[0], t.sectionIndex = e[1], t.sections = m.sections, g.push(t); } } else g = function (t, e) { const r = [], n = t.text; let i = 0; for (const n of e) r.push(t.substring(i, n)), i = n; return i < n.length && r.push(t.substring(i, n.length)), r }(m, oc(m, c, a, r, i, d)); const b = [], w = { positionedLines: b, text: m.toString(), top: h[1], bottom: h[1], left: h[0], right: h[0], writingMode: p, iconsInText: !1, verticalizable: !1 }; return function (t, e, r, n, i, s, a, o, l, u, c, h) { let p = 0, f = 0, d = 0, y = 0; const m = "right" === o ? 1 : "left" === o ? 0 : .5, g = Tu / h; let x = 0; for (const a of i) { a.trim(); const i = a.getMaxScale(), o = { positionedGlyphs: [], lineOffset: 0 }; t.positionedLines[x] = o; const h = o.positionedGlyphs; let v = 0; if (!a.length()) { f += s, ++x; continue } const b = uc(n, a, g); for (let s = 0; s < a.length(); s++) { const o = a.getSection(s), d = a.getSectionIndex(s), y = a.getCharCode(s), m = hc(l, c, y); let x; if (o.imageName) { if (t.iconsInText = !0, o.scale = o.scale * g, x = fc(o, m, i, b, n), !x) continue; v = Math.max(v, x.imageOffset); } else if (x = pc(o, y, m, b, e, r), !x) continue; const { rect: w, metrics: _, baselineOffset: S } = x; h.push({ glyph: y, imageName: o.imageName, x: p, y: f + S + Hu, vertical: m, scale: o.scale, fontStack: o.fontStack, sectionIndex: d, metrics: _, rect: w }), m ? (t.verticalizable = !0, p += (o.imageName ? _.advance : Tu) * o.scale + u) : p += _.advance * o.scale + u; } 0 !== h.length && (d = Math.max(p - u, d), dc(h, 0, h.length - 1, m)), p = 0, o.lineOffset = Math.max(v, (i - 1) * Tu); const w = s * i + v; f += w, y = Math.max(w, y), ++x; } const { horizontalAlign: v, verticalAlign: b } = lc(a); ((function (t, e, r, n, i, s, a, o, l) { const u = (e - r) * i; let c = 0; c = s !== a ? -o * n - Hu : -n * l * a + .5 * a; for (const e of t) for (const t of e.positionedGlyphs) t.x += u, t.y += c; }))(t.positionedLines, m, v, b, d, y, s, f, i.length), t.top += -b * f, t.bottom = t.top + f, t.left += -v * d, t.right = t.left + d; }(w, r, n, i, g, o, l, u, p, c, f, y), !function (t) { for (const e of t) if (0 !== e.positionedGlyphs.length) return !1; return !0 }(b) && w } const Qu = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 }, tc = { 10: !0, 32: !0, 38: !0, 41: !0, 43: !0, 45: !0, 47: !0, 173: !0, 183: !0, 8203: !0, 8208: !0, 8211: !0, 8231: !0 }, ec = { 40: !0 }; function rc(t, e, r, n, i, s) { if (e.imageName) { const t = n[e.imageName]; return t ? t.displaySize[0] * e.scale * Tu / s + i : 0 } { const n = r[e.fontStack], s = n && n[t]; return s ? s.metrics.advance * e.scale + i : 0 } } function nc(t, e, r, n) { const i = Math.pow(t - e, 2); return n ? t < e ? i / 2 : 2 * i : i + Math.abs(r) * r } function ic(t, e, r) { let n = 0; return 10 === t && (n -= 1e4), r && (n += 150), 40 !== t && 65288 !== t || (n += 50), 41 !== e && 65289 !== e || (n += 50), n } function sc(t, e, r, n, i, s) { let a = null, o = nc(e, r, i, s); for (const t of n) { const n = nc(e - t.x, r, i, s) + t.badness; n <= o && (a = t, o = n); } return { index: t, x: e, priorBreak: a, badness: o } } function ac(t) { return t ? ac(t.priorBreak).concat(t.index) : [] } function oc(t, e, r, n, i, s) { if (!t) return []; const a = [], o = function (t, e, r, n, i, s) { let a = 0; for (let r = 0; r < t.length(); r++) { const o = t.getSection(r); a += rc(t.getCharCode(r), o, n, i, e, s); } return a / Math.max(1, Math.ceil(a / r)) }(t, e, r, n, i, s), l = t.text.indexOf("​") >= 0; let u = 0; for (let r = 0; r < t.length(); r++) { const h = t.getSection(r), p = t.getCharCode(r); if (Qu[p] || (u += rc(p, h, n, i, e, s)), r < t.length() - 1) { const e = !((c = p) < 11904) && (!!Yi["CJK Compatibility Forms"](c) || !!Yi["CJK Compatibility"](c) || !!Yi["CJK Strokes"](c) || !!Yi["CJK Symbols and Punctuation"](c) || !!Yi["Enclosed CJK Letters and Months"](c) || !!Yi["Halfwidth and Fullwidth Forms"](c) || !!Yi["Ideographic Description Characters"](c) || !!Yi["Vertical Forms"](c) || rs.test(String.fromCodePoint(c))); (tc[p] || e || h.imageName || r !== t.length() - 2 && ec[t.getCharCode(r + 1)]) && a.push(sc(r + 1, u, o, a, ic(p, t.getCharCode(r + 1), e && l), !1)); } } var c; return ac(sc(t.length(), u, o, a, 0, !0)) } function lc(t) { let e = .5, r = .5; switch (t) { case "right": case "top-right": case "bottom-right": e = 1; break; case "left": case "top-left": case "bottom-left": e = 0; }switch (t) { case "bottom": case "bottom-right": case "bottom-left": r = 1; break; case "top": case "top-right": case "top-left": r = 0; }return { horizontalAlign: e, verticalAlign: r } } function uc(t, e, r) { const n = e.getMaxScale() * Tu, { maxImageWidth: i, maxImageHeight: s } = e.getMaxImageSize(t), a = Math.max(n, s * r); return { verticalLineContentWidth: Math.max(n, i * r), horizontalLineContentHeight: a } } function cc(t) { switch (t) { case "top": return 0; case "center": return .5; default: return 1 } } function hc(e, r, n) { return !(e === t.ai.horizontal || !r && !ns(n) || r && (Qu[n] || (i = n, /\p{sc=Arab}/u.test(String.fromCodePoint(i))))); var i; } function pc(t, e, r, n, i, s) { const a = s[t.fontStack], o = function (t, e, r, n) { if (t && t.rect) return t; const i = e[r.fontStack], s = i && i[n]; return s ? { rect: null, metrics: s.metrics } : null }(a && a[e], i, t, e); if (null === o) return null; let l; if (r) l = n.verticalLineContentWidth - t.scale * Tu; else { const e = cc(t.verticalAlign); l = (n.horizontalLineContentHeight - t.scale * Tu) * e; } return { rect: o.rect, metrics: o.metrics, baselineOffset: l } } function fc(t, e, r, n, i) { const s = i[t.imageName]; if (!s) return null; const a = s.paddedRect, o = s.displaySize, l = { width: o[0], height: o[1], left: Gu, top: -3, advance: e ? o[1] : o[0] }; let u; if (e) u = n.verticalLineContentWidth - o[1] * t.scale; else { const e = cc(t.verticalAlign); u = (n.horizontalLineContentHeight - o[1] * t.scale) * e; } return { rect: a, metrics: l, baselineOffset: u, imageOffset: (e ? o[0] : o[1]) * t.scale - Tu * r } } function dc(t, e, r, n) { if (0 === n) return; const i = t[r], s = (t[r].x + i.metrics.advance * i.scale) * n; for (let n = e; n <= r; n++)t[n].x -= s; } function yc(t, e, r) { const { horizontalAlign: n, verticalAlign: i } = lc(r), s = e[0] - t.displaySize[0] * n, a = e[1] - t.displaySize[1] * i; return { image: t, top: a, bottom: a + t.displaySize[1], left: s, right: s + t.displaySize[0] } } function mc(t) { var e, r; let n = t.left, i = t.top, s = t.right - n, a = t.bottom - i; const o = null !== (e = t.image.textFitWidth) && void 0 !== e ? e : "stretchOrShrink", l = null !== (r = t.image.textFitHeight) && void 0 !== r ? r : "stretchOrShrink", u = (t.image.content[2] - t.image.content[0]) / (t.image.content[3] - t.image.content[1]); if ("proportional" === l) { if ("stretchOnly" === o && s / a < u || "proportional" === o) { const t = Math.ceil(a * u); n *= t / s, s = t; } } else if ("proportional" === o && "stretchOnly" === l && 0 !== u && s / a > u) { const t = Math.ceil(s / u); i *= t / a, a = t; } return { x1: n, y1: i, x2: n + s, y2: i + a } } function gc(t, e, r, n, i, s) { const a = t.image; let o; if (a.content) { const t = a.content, e = a.pixelRatio || 1; o = [t[0] / e, t[1] / e, a.displaySize[0] - t[2] / e, a.displaySize[1] - t[3] / e]; } const l = e.left * s, u = e.right * s; let c, h, p, f; "width" === r || "both" === r ? (f = i[0] + l - n[3], h = i[0] + u + n[1]) : (f = i[0] + (l + u - a.displaySize[0]) / 2, h = f + a.displaySize[0]); const d = e.top * s, y = e.bottom * s; return "height" === r || "both" === r ? (c = i[1] + d - n[0], p = i[1] + y + n[2]) : (c = i[1] + (d + y - a.displaySize[1]) / 2, p = c + a.displaySize[1]), { image: a, top: c, right: h, bottom: p, left: f, collisionPadding: o } } const xc = 255, vc = 128, bc = xc * vc; function wc(t, e) { const { expression: r } = e; if ("constant" === r.kind) return { kind: "constant", layoutSize: r.evaluate(new cs(t + 1)) }; if ("source" === r.kind) return { kind: "source" }; { const { zoomStops: e, interpolationType: n } = r; let i = 0; for (; i < e.length && e[i] <= t;)i++; i = Math.max(0, i - 1); let s = i; for (; s < e.length && e[s] < t + 1;)s++; s = Math.min(e.length - 1, s); const a = e[i], o = e[s]; return "composite" === r.kind ? { kind: "composite", minZoom: a, maxZoom: o, interpolationType: n } : { kind: "camera", minZoom: a, maxZoom: o, minSize: r.evaluate(new cs(a)), maxSize: r.evaluate(new cs(o)), interpolationType: n } } } function _c(t, e, r) { let n = "never"; const i = t.get(e); return i ? n = i : t.get(r) && (n = "always"), n } const Sc = Yl.VectorTileFeature.types, Ac = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }]; function kc(t, e, r, n, i, s, a, o, l, u, c, h, p) { const f = o ? Math.min(bc, Math.round(o[0])) : 0, d = o ? Math.min(bc, Math.round(o[1])) : 0; t.emplaceBack(e, r, Math.round(32 * n), Math.round(32 * i), s, a, (f << 1) + (l ? 1 : 0), d, 16 * u, 16 * c, 256 * h, 256 * p); } function Mc(t, e, r) { t.emplaceBack(e.x, e.y, r), t.emplaceBack(e.x, e.y, r), t.emplaceBack(e.x, e.y, r), t.emplaceBack(e.x, e.y, r); } function Ic(t) { for (const e of t.sections) if (ls(e.text)) return !0; return !1 } class zc { constructor(t) { this.layoutVertexArray = new ba, this.indexArray = new ka, this.programConfigurations = t, this.segments = new Pa, this.dynamicLayoutVertexArray = new wa, this.opacityVertexArray = new _a, this.hasVisibleVertices = !1, this.placedSymbolArray = new ia; } isEmpty() { return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length } upload(t, e, r, n) { this.isEmpty() || (r && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Au.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, e), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, ku.members, !0), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, Ac, !0), this.opacityVertexBuffer.itemSize = 1), (r || n) && this.programConfigurations.upload(t)); } destroy() { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy()); } } Ui("SymbolBuffers", zc); class Pc { constructor(t, e, r) { this.layoutVertexArray = new t, this.layoutAttributes = e, this.indexArray = new r, this.segments = new Pa, this.collisionVertexArray = new Aa; } upload(t) { this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, Mu.members, !0); } destroy() { this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy()); } } Ui("CollisionBuffers", Pc); class Cc { constructor(e) { this.collisionBoxArray = e.collisionBoxArray, this.zoom = e.zoom, this.overscaling = e.overscaling, this.layers = e.layers, this.layerIds = this.layers.map((t => t.id)), this.index = e.index, this.pixelRatio = e.pixelRatio, this.sourceLayerIndex = e.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = []; const r = this.layers[0]._unevaluatedLayout._values; this.textSizeData = wc(this.zoom, r["text-size"]), this.iconSizeData = wc(this.zoom, r["icon-size"]); const n = this.layers[0].layout, i = n.get("symbol-sort-key"), s = n.get("symbol-z-order"); this.canOverlap = "never" !== _c(n, "text-overlap", "text-allow-overlap") || "never" !== _c(n, "icon-overlap", "icon-allow-overlap") || n.get("text-ignore-placement") || n.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== s && !i.isConstant(), this.sortFeaturesByY = ("viewport-y" === s || "auto" === s && !this.sortFeaturesByKey) && this.canOverlap, "point" === n.get("symbol-placement") && (this.writingModes = n.get("text-writing-mode").map((e => t.ai[e]))), this.stateDependentLayerIds = this.layers.filter((t => t.isStateDependent())).map((t => t.id)), this.sourceID = e.sourceID; } createArrays() { this.text = new zc(new ro(this.layers, this.zoom, (t => /^text/.test(t)))), this.icon = new zc(new ro(this.layers, this.zoom, (t => /^icon/.test(t)))), this.glyphOffsetArray = new oa, this.lineVertexArray = new la, this.symbolInstances = new aa, this.textAnchorOffsets = new ca; } calculateGlyphDependencies(t, e, r, n, i) { for (let s = 0; s < t.length; s++)if (e[t.charCodeAt(s)] = !0, (r || n) && i) { const r = Cu[t.charAt(s)]; r && (e[r.charCodeAt(0)] = !0); } } populate(e, r, n) { const i = this.layers[0], s = i.layout, a = s.get("text-font"), o = s.get("text-field"), l = s.get("icon-image"), u = ("constant" !== o.value.kind || o.value.value instanceof ve && !o.value.value.isEmpty() || o.value.value.toString().length > 0) && ("constant" !== a.value.kind || a.value.value.length > 0), c = "constant" !== l.value.kind || !!l.value.value || Object.keys(l.parameters).length > 0, h = s.get("symbol-sort-key"); if (this.features = [], !u && !c) return; const p = r.iconDependencies, f = r.glyphDependencies, d = r.availableImages, y = new cs(this.zoom); for (const { feature: r, id: o, index: l, sourceLayerIndex: m } of e) { const e = i._featureFilter.needGeometry, g = lo(r, e); if (!i._featureFilter.filter(y, g, n)) continue; let x, v; if (e || (g.geometry = oo(r)), u) { const t = i.getValueAndResolveTokens("text-field", g, n, d), e = ve.factory(t), r = this.hasRTLText = this.hasRTLText || Ic(e); (!r || "unavailable" === us.getRTLTextPluginStatus() || r && us.isParsed()) && (x = Pu(e, i, g)); } if (c) { const t = i.getValueAndResolveTokens("icon-image", g, n, d); v = t instanceof Ae ? t : Ae.fromString(t); } if (!x && !v) continue; const b = this.sortFeaturesByKey ? h.evaluate(g, {}, n) : void 0; if (this.features.push({ id: o, text: x, icon: v, index: l, sourceLayerIndex: m, geometry: g.geometry, properties: r.properties, type: Sc[r.type], sortKey: b }), v && (p[v.name] = !0), x) { const e = a.evaluate(g, {}, n).join(","), r = "viewport" !== s.get("text-rotation-alignment") && "point" !== s.get("symbol-placement"); this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(t.ai.vertical) >= 0; for (const t of x.sections) if (t.image) p[t.image.name] = !0; else { const n = Ji(x.toString()), i = t.fontStack || e, s = f[i] = f[i] || {}; this.calculateGlyphDependencies(t.text, s, r, this.allowVerticalPlacement, n); } } } "line" === s.get("symbol-placement") && (this.features = function (t) { const e = {}, r = {}, n = []; let i = 0; function s(e) { n.push(t[e]), i++; } function a(t, e, i) { const s = r[t]; return delete r[t], r[e] = s, n[s].geometry[0].pop(), n[s].geometry[0] = n[s].geometry[0].concat(i[0]), s } function o(t, r, i) { const s = e[r]; return delete e[r], e[t] = s, n[s].geometry[0].shift(), n[s].geometry[0] = i[0].concat(n[s].geometry[0]), s } function l(t, e, r) { const n = r ? e[0][e[0].length - 1] : e[0][0]; return `${t}:${n.x}:${n.y}` } for (let u = 0; u < t.length; u++) { const c = t[u], h = c.geometry, p = c.text ? c.text.toString() : null; if (!p) { s(u); continue } const f = l(p, h), d = l(p, h, !0); if (f in r && d in e && r[f] !== e[d]) { const t = o(f, d, h), i = a(f, d, n[t].geometry); delete e[f], delete r[d], r[l(p, n[i].geometry, !0)] = i, n[t].geometry = null; } else f in r ? a(f, d, h) : d in e ? o(f, d, h) : (s(u), e[f] = i - 1, r[d] = i - 1); } return n.filter((t => t.geometry)) }(this.features)), this.sortFeaturesByKey && this.features.sort(((t, e) => t.sortKey - e.sortKey)); } update(t, e, r) { this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, e, this.layers, r), this.icon.programConfigurations.updatePaintArrays(t, e, this.layers, r)); } isEmpty() { return 0 === this.symbolInstances.length && !this.hasRTLText } uploadPending() { return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload } upload(t) { !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0; } destroyDebugData() { this.textCollisionBox.destroy(), this.iconCollisionBox.destroy(); } destroy() { this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData(); } addToLineVertexArray(t, e) { const r = this.lineVertexArray.length; if (void 0 !== t.segment) { let r = t.dist(e[t.segment + 1]), n = t.dist(e[t.segment]); const i = {}; for (let n = t.segment + 1; n < e.length; n++)i[n] = { x: e[n].x, y: e[n].y, tileUnitDistanceFromAnchor: r }, n < e.length - 1 && (r += e[n + 1].dist(e[n])); for (let r = t.segment || 0; r >= 0; r--)i[r] = { x: e[r].x, y: e[r].y, tileUnitDistanceFromAnchor: n }, r > 0 && (n += e[r - 1].dist(e[r])); for (let t = 0; t < e.length; t++) { const e = i[t]; this.lineVertexArray.emplaceBack(e.x, e.y, e.tileUnitDistanceFromAnchor); } } return { lineStartIndex: r, lineLength: this.lineVertexArray.length - r } } addSymbols(e, r, n, i, s, a, o, l, u, c, h, p) { const f = e.indexArray, d = e.layoutVertexArray, y = e.segments.prepareSegment(4 * r.length, d, f, this.canOverlap ? a.sortKey : void 0), m = this.glyphOffsetArray.length, g = y.vertexLength, x = this.allowVerticalPlacement && o === t.ai.vertical ? Math.PI / 2 : 0, v = a.text && a.text.sections; for (let t = 0; t < r.length; t++) { const { tl: i, tr: s, bl: o, br: u, tex: c, pixelOffsetTL: h, pixelOffsetBR: m, minFontScaleX: g, minFontScaleY: b, glyphOffset: w, isSDF: _, sectionIndex: S } = r[t], A = y.vertexLength, k = w[1]; kc(d, l.x, l.y, i.x, k + i.y, c.x, c.y, n, _, h.x, h.y, g, b), kc(d, l.x, l.y, s.x, k + s.y, c.x + c.w, c.y, n, _, m.x, h.y, g, b), kc(d, l.x, l.y, o.x, k + o.y, c.x, c.y + c.h, n, _, h.x, m.y, g, b), kc(d, l.x, l.y, u.x, k + u.y, c.x + c.w, c.y + c.h, n, _, m.x, m.y, g, b), Mc(e.dynamicLayoutVertexArray, l, x), f.emplaceBack(A, A + 2, A + 1), f.emplaceBack(A + 1, A + 2, A + 3), y.vertexLength += 4, y.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(w[0]), t !== r.length - 1 && S === r[t + 1].sectionIndex || e.programConfigurations.populatePaintArrays(d.length, a, a.index, {}, p, v && v[S]); } e.placedSymbolArray.emplaceBack(l.x, l.y, m, this.glyphOffsetArray.length - m, g, u, c, l.segment, n ? n[0] : 0, n ? n[1] : 0, i[0], i[1], o, 0, !1, 0, h); } _addCollisionDebugVertex(t, e, r, n, i, s) { return e.emplaceBack(0, 0), t.emplaceBack(r.x, r.y, n, i, Math.round(s.x), Math.round(s.y)) } addCollisionDebugVertices(t, e, r, n, i, s, a) { const o = i.segments.prepareSegment(4, i.layoutVertexArray, i.indexArray), u = o.vertexLength, c = i.layoutVertexArray, h = i.collisionVertexArray, p = a.anchorX, f = a.anchorY; this._addCollisionDebugVertex(c, h, s, p, f, new l(t, e)), this._addCollisionDebugVertex(c, h, s, p, f, new l(r, e)), this._addCollisionDebugVertex(c, h, s, p, f, new l(r, n)), this._addCollisionDebugVertex(c, h, s, p, f, new l(t, n)), o.vertexLength += 4; const d = i.indexArray; d.emplaceBack(u, u + 1), d.emplaceBack(u + 1, u + 2), d.emplaceBack(u + 2, u + 3), d.emplaceBack(u + 3, u), o.primitiveLength += 4; } addDebugCollisionBoxes(t, e, r, n) { for (let i = t; i < e; i++) { const t = this.collisionBoxArray.get(i); this.addCollisionDebugVertices(t.x1, t.y1, t.x2, t.y2, n ? this.textCollisionBox : this.iconCollisionBox, t.anchorPoint, r); } } generateCollisionDebugBuffers() { this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Pc(Sa, Iu.members, Ma), this.iconCollisionBox = new Pc(Sa, Iu.members, Ma); for (let t = 0; t < this.symbolInstances.length; t++) { const e = this.symbolInstances.get(t); this.addDebugCollisionBoxes(e.textBoxStartIndex, e.textBoxEndIndex, e, !0), this.addDebugCollisionBoxes(e.verticalTextBoxStartIndex, e.verticalTextBoxEndIndex, e, !0), this.addDebugCollisionBoxes(e.iconBoxStartIndex, e.iconBoxEndIndex, e, !1), this.addDebugCollisionBoxes(e.verticalIconBoxStartIndex, e.verticalIconBoxEndIndex, e, !1); } } _deserializeCollisionBoxesForSymbol(t, e, r, n, i, s, a, o, l) { const u = {}; for (let n = e; n < r; n++) { const e = t.get(n); u.textBox = { x1: e.x1, y1: e.y1, x2: e.x2, y2: e.y2, anchorPointX: e.anchorPointX, anchorPointY: e.anchorPointY }, u.textFeatureIndex = e.featureIndex; break } for (let e = n; e < i; e++) { const r = t.get(e); u.verticalTextBox = { x1: r.x1, y1: r.y1, x2: r.x2, y2: r.y2, anchorPointX: r.anchorPointX, anchorPointY: r.anchorPointY }, u.verticalTextFeatureIndex = r.featureIndex; break } for (let e = s; e < a; e++) { const r = t.get(e); u.iconBox = { x1: r.x1, y1: r.y1, x2: r.x2, y2: r.y2, anchorPointX: r.anchorPointX, anchorPointY: r.anchorPointY }, u.iconFeatureIndex = r.featureIndex; break } for (let e = o; e < l; e++) { const r = t.get(e); u.verticalIconBox = { x1: r.x1, y1: r.y1, x2: r.x2, y2: r.y2, anchorPointX: r.anchorPointX, anchorPointY: r.anchorPointY }, u.verticalIconFeatureIndex = r.featureIndex; break } return u } deserializeCollisionBoxes(t) { this.collisionArrays = []; for (let e = 0; e < this.symbolInstances.length; e++) { const r = this.symbolInstances.get(e); this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, r.textBoxStartIndex, r.textBoxEndIndex, r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r.iconBoxStartIndex, r.iconBoxEndIndex, r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex)); } } hasTextData() { return this.text.segments.get().length > 0 } hasIconData() { return this.icon.segments.get().length > 0 } hasDebugData() { return this.textCollisionBox && this.iconCollisionBox } hasTextCollisionBoxData() { return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0 } hasIconCollisionBoxData() { return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0 } addIndicesForPlacedSymbol(t, e) { const r = t.placedSymbolArray.get(e), n = r.vertexStartIndex + 4 * r.numGlyphs; for (let e = r.vertexStartIndex; e < n; e += 4)t.indexArray.emplaceBack(e, e + 2, e + 1), t.indexArray.emplaceBack(e + 1, e + 2, e + 3); } getSortedSymbolIndexes(t) { if (this.sortedAngle === t && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes; const e = Math.sin(t), r = Math.cos(t), n = [], i = [], s = []; for (let t = 0; t < this.symbolInstances.length; ++t) { s.push(t); const a = this.symbolInstances.get(t); n.push(0 | Math.round(e * a.anchorX + r * a.anchorY)), i.push(a.featureIndex); } return s.sort(((t, e) => n[t] - n[e] || i[e] - i[t])), s } addToSortKeyRanges(t, e) { const r = this.sortKeyRanges[this.sortKeyRanges.length - 1]; r && r.sortKey === e ? r.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({ sortKey: e, symbolInstanceStart: t, symbolInstanceEnd: t + 1 }); } sortFeatures(t) { if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) { this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = []; for (const t of this.symbolInstanceIndexes) { const e = this.symbolInstances.get(t); this.featureSortOrder.push(e.featureIndex), [e.rightJustifiedTextSymbolIndex, e.centerJustifiedTextSymbolIndex, e.leftJustifiedTextSymbolIndex].forEach(((t, e, r) => { t >= 0 && r.indexOf(t) === e && this.addIndicesForPlacedSymbol(this.text, t); })), e.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, e.verticalPlacedTextSymbolIndex), e.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e.placedIconSymbolIndex), e.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e.verticalPlacedIconSymbolIndex); } this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray); } } } let Bc, Vc; Ui("SymbolBucket", Cc, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Cc.MAX_GLYPHS = 65535, Cc.addDynamicAttributes = Mc; var Ec = { get paint() { return Vc = Vc || new As({ "icon-opacity": new bs(ht.paint_symbol["icon-opacity"]), "icon-color": new bs(ht.paint_symbol["icon-color"]), "icon-halo-color": new bs(ht.paint_symbol["icon-halo-color"]), "icon-halo-width": new bs(ht.paint_symbol["icon-halo-width"]), "icon-halo-blur": new bs(ht.paint_symbol["icon-halo-blur"]), "icon-translate": new vs(ht.paint_symbol["icon-translate"]), "icon-translate-anchor": new vs(ht.paint_symbol["icon-translate-anchor"]), "text-opacity": new bs(ht.paint_symbol["text-opacity"]), "text-color": new bs(ht.paint_symbol["text-color"], { runtimeType: Bt, getOverride: t => t.textColor, hasOverride: t => !!t.textColor }), "text-halo-color": new bs(ht.paint_symbol["text-halo-color"]), "text-halo-width": new bs(ht.paint_symbol["text-halo-width"]), "text-halo-blur": new bs(ht.paint_symbol["text-halo-blur"]), "text-translate": new vs(ht.paint_symbol["text-translate"]), "text-translate-anchor": new vs(ht.paint_symbol["text-translate-anchor"]) }) }, get layout() { return Bc = Bc || new As({ "symbol-placement": new vs(ht.layout_symbol["symbol-placement"]), "symbol-spacing": new vs(ht.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new vs(ht.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new bs(ht.layout_symbol["symbol-sort-key"]), "symbol-z-order": new vs(ht.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new vs(ht.layout_symbol["icon-allow-overlap"]), "icon-overlap": new vs(ht.layout_symbol["icon-overlap"]), "icon-ignore-placement": new vs(ht.layout_symbol["icon-ignore-placement"]), "icon-optional": new vs(ht.layout_symbol["icon-optional"]), "icon-rotation-alignment": new vs(ht.layout_symbol["icon-rotation-alignment"]), "icon-size": new bs(ht.layout_symbol["icon-size"]), "icon-text-fit": new vs(ht.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new vs(ht.layout_symbol["icon-text-fit-padding"]), "icon-image": new bs(ht.layout_symbol["icon-image"]), "icon-rotate": new bs(ht.layout_symbol["icon-rotate"]), "icon-padding": new bs(ht.layout_symbol["icon-padding"]), "icon-keep-upright": new vs(ht.layout_symbol["icon-keep-upright"]), "icon-offset": new bs(ht.layout_symbol["icon-offset"]), "icon-anchor": new bs(ht.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new vs(ht.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new vs(ht.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new vs(ht.layout_symbol["text-rotation-alignment"]), "text-field": new bs(ht.layout_symbol["text-field"]), "text-font": new bs(ht.layout_symbol["text-font"]), "text-size": new bs(ht.layout_symbol["text-size"]), "text-max-width": new bs(ht.layout_symbol["text-max-width"]), "text-line-height": new vs(ht.layout_symbol["text-line-height"]), "text-letter-spacing": new bs(ht.layout_symbol["text-letter-spacing"]), "text-justify": new bs(ht.layout_symbol["text-justify"]), "text-radial-offset": new bs(ht.layout_symbol["text-radial-offset"]), "text-variable-anchor": new vs(ht.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new bs(ht.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new bs(ht.layout_symbol["text-anchor"]), "text-max-angle": new vs(ht.layout_symbol["text-max-angle"]), "text-writing-mode": new vs(ht.layout_symbol["text-writing-mode"]), "text-rotate": new bs(ht.layout_symbol["text-rotate"]), "text-padding": new vs(ht.layout_symbol["text-padding"]), "text-keep-upright": new vs(ht.layout_symbol["text-keep-upright"]), "text-transform": new bs(ht.layout_symbol["text-transform"]), "text-offset": new bs(ht.layout_symbol["text-offset"]), "text-allow-overlap": new vs(ht.layout_symbol["text-allow-overlap"]), "text-overlap": new vs(ht.layout_symbol["text-overlap"]), "text-ignore-placement": new vs(ht.layout_symbol["text-ignore-placement"]), "text-optional": new vs(ht.layout_symbol["text-optional"]) }) } }; class Tc { constructor(t) { if (void 0 === t.property.overrides) throw new Error("overrides must be provided to instantiate FormatSectionOverride class"); this.type = t.property.overrides ? t.property.overrides.runtimeType : It, this.defaultValue = t; } evaluate(t) { if (t.formattedSection) { const e = this.defaultValue.property.overrides; if (e && e.hasOverride(t.formattedSection)) return e.getOverride(t.formattedSection) } return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default } eachChild(t) { this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression); } outputDefined() { return !1 } serialize() { return null } } Ui("FormatSectionOverride", Tc, { omit: ["defaultValue"] }); class Fc extends Ms { constructor(t) { super(t, Ec); } recalculate(t, e) { if (super.recalculate(t, e), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = "map" === this.layout.get("text-rotation-alignment") ? "map" : "viewport"), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), "point" === this.layout.get("symbol-placement")) { const t = this.layout.get("text-writing-mode"); if (t) { const e = []; for (const r of t) e.indexOf(r) < 0 && e.push(r); this.layout._values["text-writing-mode"] = e; } else this.layout._values["text-writing-mode"] = ["horizontal"]; } this._setPaintOverrides(); } getValueAndResolveTokens(t, e, r, n) { const i = this.layout.get(t).evaluate(e, {}, r, n), s = this._unevaluatedLayout._values[t]; return s.isDataDriven() || jn(s.value) || !i ? i : function (t, e) { return e.replace(/{([^{}]+)}/g, ((e, r) => t && r in t ? String(t[r]) : "")) }(e.properties, i) } createBucket(t) { return new Cc(t) } queryRadius() { return 0 } queryIntersectsFeature() { throw new Error("Should take a different path in FeatureIndex") } _setPaintOverrides() { for (const t of Ec.paint.overridableProperties) { if (!Fc.hasPaintOverride(this.layout, t)) continue; const e = this.paint.get(t), r = new Tc(e), n = new Rn(r, e.property.specification); let i = null; i = "constant" === e.value.kind || "source" === e.value.kind ? new Un("source", n) : new qn("composite", n, e.value.zoomStops), this.paint._values[t] = new gs(e.property, i, e.parameters); } } _handleOverridablePaintPropertyUpdate(t, e, r) { return !(!this.layout || e.isDataDriven() || r.isDataDriven()) && Fc.hasPaintOverride(this.layout, t) } static hasPaintOverride(t, e) { const r = t.get("text-field"), n = Ec.paint.properties[e]; let i = !1; const s = t => { for (const e of t) if (n.overrides && n.overrides.hasOverride(e)) return void (i = !0) }; if ("constant" === r.value.kind && r.value.value instanceof ve) s(r.value.value.sections); else if ("source" === r.value.kind) { const t = e => { i || (e instanceof Ce && ze(e.value) === $t ? s(e.value.sections) : e instanceof dr ? s(e.sections) : e.eachChild(t)); }, e = r.value; e._styleExpression && t(e._styleExpression.expression); } return i } } let $c; var Lc = { get paint() { return $c = $c || new As({ "background-color": new vs(ht.paint_background["background-color"]), "background-pattern": new _s(ht.paint_background["background-pattern"]), "background-opacity": new vs(ht.paint_background["background-opacity"]) }) } }; class Oc extends Ms { constructor(t) { super(t, Lc); } } let Dc; var Rc = { get paint() { return Dc = Dc || new As({ "raster-opacity": new vs(ht.paint_raster["raster-opacity"]), "raster-hue-rotate": new vs(ht.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new vs(ht.paint_raster["raster-brightness-min"]), "raster-brightness-max": new vs(ht.paint_raster["raster-brightness-max"]), "raster-saturation": new vs(ht.paint_raster["raster-saturation"]), "raster-contrast": new vs(ht.paint_raster["raster-contrast"]), "raster-resampling": new vs(ht.paint_raster["raster-resampling"]), "raster-fade-duration": new vs(ht.paint_raster["raster-fade-duration"]) }) } }; class jc extends Ms { constructor(t) { super(t, Rc); } } class Nc extends Ms { constructor(t) { super(t, {}), this.onAdd = t => { this.implementation.onAdd && this.implementation.onAdd(t, t.painter.context.gl); }, this.onRemove = t => { this.implementation.onRemove && this.implementation.onRemove(t, t.painter.context.gl); }, this.implementation = t; } is3D() { return "3d" === this.implementation.renderingMode } hasOffscreenPass() { return void 0 !== this.implementation.prerender } recalculate() { } updateTransitions() { } hasTransition() { return !1 } serialize() { throw new Error("Custom layers cannot be serialized") } } class Uc { constructor(t) { this._methodToThrottle = t, this._triggered = !1, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel, this._channel.port2.onmessage = () => { this._triggered = !1, this._methodToThrottle(); }); } trigger() { this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout((() => { this._triggered = !1, this._methodToThrottle(); }), 0)); } remove() { delete this._channel, this._methodToThrottle = () => { }; } } const qc = 6371008.8; class Gc { constructor(t, e) { if (isNaN(t) || isNaN(e)) throw new Error(`Invalid LngLat object: (${t}, ${e})`); if (this.lng = +t, this.lat = +e, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90") } wrap() { return new Gc(T(this.lng, -180, 180), this.lat) } toArray() { return [this.lng, this.lat] } toString() { return `LngLat(${this.lng}, ${this.lat})` } distanceTo(t) { const e = Math.PI / 180, r = this.lat * e, n = t.lat * e, i = Math.sin(r) * Math.sin(n) + Math.cos(r) * Math.cos(n) * Math.cos((t.lng - this.lng) * e); return qc * Math.acos(Math.min(i, 1)) } static convert(t) { if (t instanceof Gc) return t; if (Array.isArray(t) && (2 === t.length || 3 === t.length)) return new Gc(Number(t[0]), Number(t[1])); if (!Array.isArray(t) && "object" == typeof t && null !== t) return new Gc(Number("lng" in t ? t.lng : t.lon), Number(t.lat)); throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]") } } const Zc = 2 * Math.PI * qc; function Xc(t) { return Zc * Math.cos(t * Math.PI / 180) } function Kc(t) { return (180 + t) / 360 } function Hc(t) { return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t * Math.PI / 360))) / 360 } function Yc(t, e) { return t / Xc(e) } function Jc(t) { return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t) * Math.PI / 180)) - 90 } function Wc(t, e) { return t * Xc(Jc(e)) } class Qc { constructor(t, e, r = 0) { this.x = +t, this.y = +e, this.z = +r; } static fromLngLat(t, e = 0) { const r = Gc.convert(t); return new Qc(Kc(r.lng), Hc(r.lat), Yc(e, r.lat)) } toLngLat() { return new Gc(360 * this.x - 180, Jc(this.y)) } toAltitude() { return Wc(this.z, this.y) } meterInMercatorCoordinateUnits() { return 1 / Zc * (t = Jc(this.y), 1 / Math.cos(t * Math.PI / 180)); var t; } } function th(t, e, r) { var n = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r); return [t * n - 2 * Math.PI * 6378137 / 2, e * n - 2 * Math.PI * 6378137 / 2] } class eh { constructor(t, e, r) { if (!function (t, e, r) { return !(t < 0 || t > 25 || r < 0 || r >= Math.pow(2, t) || e < 0 || e >= Math.pow(2, t)) }(t, e, r)) throw new Error(`x=${e}, y=${r}, z=${t} outside of bounds. 0<=x<${Math.pow(2, t)}, 0<=y<${Math.pow(2, t)} 0<=z<=25 `); this.z = t, this.x = e, this.y = r, this.key = ih(0, t, t, e, r); } equals(t) { return this.z === t.z && this.x === t.x && this.y === t.y } url(t, e, r) { const n = (s = this.y, a = this.z, o = th(256 * (i = this.x), 256 * (s = Math.pow(2, a) - s - 1), a), l = th(256 * (i + 1), 256 * (s + 1), a), o[0] + "," + o[1] + "," + l[0] + "," + l[1]); var i, s, a, o, l; const u = function (t, e, r) { let n, i = ""; for (let s = t; s > 0; s--)n = 1 << s - 1, i += (e & n ? 1 : 0) + (r & n ? 2 : 0); return i }(this.z, this.x, this.y); return t[(this.x + this.y) % t.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === r ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, e > 1 ? "@2x" : "").replace(/{quadkey}/g, u).replace(/{bbox-epsg-3857}/g, n) } isChildOf(t) { const e = this.z - t.z; return e > 0 && t.x === this.x >> e && t.y === this.y >> e } getTilePoint(t) { const e = Math.pow(2, this.z); return new l((t.x * e - this.x) * M, (t.y * e - this.y) * M) } toString() { return `${this.z}/${this.x}/${this.y}` } } class rh { constructor(t, e) { this.wrap = t, this.canonical = e, this.key = ih(t, e.z, e.z, e.x, e.y); } } class nh { constructor(t, e, r, n, i) { if (this.terrainRttPosMatrix32f = null, t < r) throw new Error(`overscaledZ should be >= z; overscaledZ = ${t}; z = ${r}`); this.overscaledZ = t, this.wrap = e, this.canonical = new eh(r, +n, +i), this.key = ih(e, t, r, n, i); } clone() { return new nh(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) } equals(t) { return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical) } scaledTo(t) { if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`); const e = this.canonical.z - t; return t > this.canonical.z ? new nh(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new nh(t, this.wrap, t, this.canonical.x >> e, this.canonical.y >> e) } calculateScaledKey(t, e) { if (t > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`); const r = this.canonical.z - t; return t > this.canonical.z ? ih(this.wrap * +e, t, this.canonical.z, this.canonical.x, this.canonical.y) : ih(this.wrap * +e, t, t, this.canonical.x >> r, this.canonical.y >> r) } isChildOf(t) { if (t.wrap !== this.wrap) return !1; const e = this.canonical.z - t.canonical.z; return 0 === t.overscaledZ || t.overscaledZ < this.overscaledZ && t.canonical.x === this.canonical.x >> e && t.canonical.y === this.canonical.y >> e } children(t) { if (this.overscaledZ >= t) return [new nh(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)]; const e = this.canonical.z + 1, r = 2 * this.canonical.x, n = 2 * this.canonical.y; return [new nh(e, this.wrap, e, r, n), new nh(e, this.wrap, e, r + 1, n), new nh(e, this.wrap, e, r, n + 1), new nh(e, this.wrap, e, r + 1, n + 1)] } isLessThan(t) { return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y)) } wrapped() { return new nh(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y) } unwrapTo(t) { return new nh(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y) } overscaleFactor() { return Math.pow(2, this.overscaledZ - this.canonical.z) } toUnwrapped() { return new rh(this.wrap, this.canonical) } toString() { return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}` } getTilePoint(t) { return this.canonical.getTilePoint(new Qc(t.x - this.wrap, t.y)) } } function ih(t, e, r, n, i) { (t *= 2) < 0 && (t = -1 * t - 1); const s = 1 << r; return (s * s * t + s * i + n).toString(36) + r.toString(36) + e.toString(36) } Ui("CanonicalTileID", eh), Ui("OverscaledTileID", nh, { omit: ["terrainRttPosMatrix32f"] }); class sh { constructor(t, e, r, n = 1, i = 1, s = 1, a = 0) { if (this.uid = t, e.height !== e.width) throw new RangeError("DEM tiles must be square"); if (r && !["mapbox", "terrarium", "custom"].includes(r)) return void j(`"${r}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`); this.stride = e.height; const o = this.dim = e.height - 2; switch (this.data = new Uint32Array(e.data.buffer), r) { case "terrarium": this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768; break; case "custom": this.redFactor = n, this.greenFactor = i, this.blueFactor = s, this.baseShift = a; break; default: this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = .1, this.baseShift = 1e4; }for (let t = 0; t < o; t++)this.data[this._idx(-1, t)] = this.data[this._idx(0, t)], this.data[this._idx(o, t)] = this.data[this._idx(o - 1, t)], this.data[this._idx(t, -1)] = this.data[this._idx(t, 0)], this.data[this._idx(t, o)] = this.data[this._idx(t, o - 1)]; this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(o, -1)] = this.data[this._idx(o - 1, 0)], this.data[this._idx(-1, o)] = this.data[this._idx(0, o - 1)], this.data[this._idx(o, o)] = this.data[this._idx(o - 1, o - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER; for (let t = 0; t < o; t++)for (let e = 0; e < o; e++) { const r = this.get(t, e); r > this.max && (this.max = r), r < this.min && (this.min = r); } } get(t, e) { const r = new Uint8Array(this.data.buffer), n = 4 * this._idx(t, e); return this.unpack(r[n], r[n + 1], r[n + 2]) } getUnpackVector() { return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift] } _idx(t, e) { if (t < -1 || t >= this.dim + 1 || e < -1 || e >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data"); return (e + 1) * this.stride + (t + 1) } unpack(t, e, r) { return t * this.redFactor + e * this.greenFactor + r * this.blueFactor - this.baseShift } getPixels() { return new Do({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer)) } backfillBorder(t, e, r) { if (this.dim !== t.dim) throw new Error("dem dimension mismatch"); let n = e * this.dim, i = e * this.dim + this.dim, s = r * this.dim, a = r * this.dim + this.dim; switch (e) { case -1: n = i - 1; break; case 1: i = n + 1; }switch (r) { case -1: s = a - 1; break; case 1: a = s + 1; }const o = -e * this.dim, l = -r * this.dim; for (let e = s; e < a; e++)for (let r = n; r < i; r++)this.data[this._idx(r, e)] = t.data[this._idx(r + o, e + l)]; } } Ui("DEMData", sh); class ah { constructor(t) { this._stringToNumber = {}, this._numberToString = []; for (let e = 0; e < t.length; e++) { const r = t[e]; this._stringToNumber[r] = e, this._numberToString[e] = r; } } encode(t) { return this._stringToNumber[t] } decode(t) { if (t >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${t} can't be >= this._numberToString.length ${this._numberToString.length}`); return this._numberToString[t] } } class oh { constructor(t, e, r, n, i) { this.type = "Feature", this._vectorTileFeature = t, t._z = e, t._x = r, t._y = n, this.properties = t.properties, this.id = i; } get geometry() { return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry } set geometry(t) { this._geometry = t; } toJSON() { const t = { geometry: this.geometry }; for (const e in this) "_geometry" !== e && "_vectorTileFeature" !== e && (t[e] = this[e]); return t } } class lh { constructor(t, e) { this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new ji(M, 16, 0), this.grid3D = new ji(M, 16, 0), this.featureIndexArray = new pa, this.promoteId = e; } insert(t, e, r, n, i, s) { const a = this.featureIndexArray.length; this.featureIndexArray.emplaceBack(r, n, i); const o = s ? this.grid3D : this.grid; for (let t = 0; t < e.length; t++) { const r = e[t], n = [1 / 0, 1 / 0, -1 / 0, -1 / 0]; for (let t = 0; t < r.length; t++) { const e = r[t]; n[0] = Math.min(n[0], e.x), n[1] = Math.min(n[1], e.y), n[2] = Math.max(n[2], e.x), n[3] = Math.max(n[3], e.y); } n[0] < M && n[1] < M && n[2] >= 0 && n[3] >= 0 && o.insert(a, n[0], n[1], n[2], n[3]); } } loadVTLayers() { return this.vtLayers || (this.vtLayers = new Yl.VectorTile(new Ou(this.rawTileData)).layers, this.sourceLayerCoder = new ah(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers } query(t, e, r, n) { this.loadVTLayers(); const i = t.params, s = M / t.tileSize / t.scale, a = Yn(i.filter), o = t.queryGeometry, u = t.queryPadding * s, c = ch(o), h = this.grid.query(c.minX - u, c.minY - u, c.maxX + u, c.maxY + u), p = ch(t.cameraQueryGeometry), f = this.grid3D.query(p.minX - u, p.minY - u, p.maxX + u, p.maxY + u, ((e, r, n, i) => function (t, e, r, n, i) { for (const s of t) if (e <= s.x && r <= s.y && n >= s.x && i >= s.y) return !0; const s = [new l(e, r), new l(e, i), new l(n, i), new l(n, r)]; if (t.length > 2) for (const e of s) if (_o(t, e)) return !0; for (let e = 0; e < t.length - 1; e++)if (So(t[e], t[e + 1], s)) return !0; return !1 }(t.cameraQueryGeometry, e - u, r - u, n + u, i + u))); for (const t of f) h.push(t); h.sort(hh); const d = {}; let y; for (let l = 0; l < h.length; l++) { const u = h[l]; if (u === y) continue; y = u; const c = this.featureIndexArray.get(u); let p = null; this.loadMatchingFeature(d, c.bucketIndex, c.sourceLayerIndex, c.featureIndex, a, i.layers, i.availableImages, e, r, n, ((e, r, n) => (p || (p = oo(e)), r.queryIntersectsFeature({ queryGeometry: o, feature: e, featureState: n, geometry: p, zoom: this.z, transform: t.transform, pixelsToTileUnits: s, pixelPosMatrix: t.pixelPosMatrix })))); } return d } loadMatchingFeature(t, e, r, n, i, s, a, o, l, u, c) { const h = this.bucketLayerIDs[e]; if (s && !h.some((t => s.has(t)))) return; const p = this.sourceLayerCoder.decode(r), f = this.vtLayers[p].feature(n); if (i.needGeometry) { const t = lo(f, !0); if (!i.filter(new cs(this.tileID.overscaledZ), t, this.tileID.canonical)) return } else if (!i.filter(new cs(this.tileID.overscaledZ), f)) return; const d = this.getId(f, p); for (let e = 0; e < h.length; e++) { const r = h[e]; if (s && !s.has(r)) continue; const i = o[r]; if (!i) continue; let p = {}; d && u && (p = u.getState(i.sourceLayer || "_geojsonTileLayer", d)); const y = F({}, l[r]); y.paint = uh(y.paint, i.paint, f, p, a), y.layout = uh(y.layout, i.layout, f, p, a); const m = !c || c(f, i, p); if (!m) continue; const g = new oh(f, this.z, this.x, this.y, d); g.layer = y; let x = t[r]; void 0 === x && (x = t[r] = []), x.push({ featureIndex: n, feature: g, intersectionZ: m }); } } lookupSymbolFeatures(t, e, r, n, i, s, a, o) { const l = {}; this.loadVTLayers(); const u = Yn(i); for (const i of t) this.loadMatchingFeature(l, r, n, i, u, s, a, o, e); return l } hasLayer(t) { for (const e of this.bucketLayerIDs) for (const r of e) if (t === r) return !0; return !1 } getId(t, e) { var r; let n = t.id; return this.promoteId && (n = t.properties["string" == typeof this.promoteId ? this.promoteId : this.promoteId[e]], "boolean" == typeof n && (n = Number(n)), void 0 === n && (null === (r = t.properties) || void 0 === r ? void 0 : r.cluster) && this.promoteId && (n = Number(t.properties.cluster_id))), n } } function uh(t, e, r, n, i) { return L(t, ((t, s) => { const a = e instanceof xs ? e.get(s) : null; return a && a.evaluate ? a.evaluate(r, n, i) : a })) } function ch(t) { let e = 1 / 0, r = 1 / 0, n = -1 / 0, i = -1 / 0; for (const s of t) e = Math.min(e, s.x), r = Math.min(r, s.y), n = Math.max(n, s.x), i = Math.max(i, s.y); return { minX: e, minY: r, maxX: n, maxY: i } } function hh(t, e) { return e - t } function ph(t, e, r, n, i) { const s = []; for (let a = 0; a < t.length; a++) { const o = t[a]; let u; for (let t = 0; t < o.length - 1; t++) { let a = o[t], c = o[t + 1]; a.x < e && c.x < e || (a.x < e ? a = new l(e, a.y + (e - a.x) / (c.x - a.x) * (c.y - a.y))._round() : c.x < e && (c = new l(e, a.y + (e - a.x) / (c.x - a.x) * (c.y - a.y))._round()), a.y < r && c.y < r || (a.y < r ? a = new l(a.x + (r - a.y) / (c.y - a.y) * (c.x - a.x), r)._round() : c.y < r && (c = new l(a.x + (r - a.y) / (c.y - a.y) * (c.x - a.x), r)._round()), a.x >= n && c.x >= n || (a.x >= n ? a = new l(n, a.y + (n - a.x) / (c.x - a.x) * (c.y - a.y))._round() : c.x >= n && (c = new l(n, a.y + (n - a.x) / (c.x - a.x) * (c.y - a.y))._round()), a.y >= i && c.y >= i || (a.y >= i ? a = new l(a.x + (i - a.y) / (c.y - a.y) * (c.x - a.x), i)._round() : c.y >= i && (c = new l(a.x + (i - a.y) / (c.y - a.y) * (c.x - a.x), i)._round()), u && a.equals(u[u.length - 1]) || (u = [a], s.push(u)), u.push(c))))); } } return s } Ui("FeatureIndex", lh, { omit: ["rawTileData", "sourceLayerCoder"] }); class fh extends l { constructor(t, e, r, n) { super(t, e), this.angle = r, void 0 !== n && (this.segment = n); } clone() { return new fh(this.x, this.y, this.angle, this.segment) } } function dh(t, e, r, n, i) { if (void 0 === e.segment || 0 === r) return !0; let s = e, a = e.segment + 1, o = 0; for (; o > -r / 2;) { if (a--, a < 0) return !1; o -= t[a].dist(s), s = t[a]; } o += t[a].dist(t[a + 1]), a++; const l = []; let u = 0; for (; o < r / 2;) { const e = t[a], r = t[a + 1]; if (!r) return !1; let s = t[a - 1].angleTo(e) - e.angleTo(r); for (s = Math.abs((s + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l.push({ distance: o, angleDelta: s }), u += s; o - l[0].distance > n;)u -= l.shift().angleDelta; if (u > i) return !1; a++, o += e.dist(r); } return !0 } function yh(t) { let e = 0; for (let r = 0; r < t.length - 1; r++)e += t[r].dist(t[r + 1]); return e } function mh(t, e, r) { return t ? .6 * e * r : 0 } function gh(t, e) { return Math.max(t ? t.right - t.left : 0, e ? e.right - e.left : 0) } function xh(t, e, r, n, i, s) { const a = mh(r, i, s), o = gh(r, n) * s; let l = 0; const u = yh(t) / 2; for (let r = 0; r < t.length - 1; r++) { const n = t[r], i = t[r + 1], s = n.dist(i); if (l + s > u) { const c = (u - l) / s, h = er.number(n.x, i.x, c), p = er.number(n.y, i.y, c), f = new fh(h, p, i.angleTo(n), r); return f._round(), !a || dh(t, f, o, a, e) ? f : void 0 } l += s; } } function vh(t, e, r, n, i, s, a, o, l) { const u = mh(n, s, a), c = gh(n, i), h = c * a, p = 0 === t[0].x || t[0].x === l || 0 === t[0].y || t[0].y === l; return e - h < e / 4 && (e = h + e / 4), bh(t, p ? e / 2 * o % e : (c / 2 + 2 * s) * a * o % e, e, u, r, h, p, !1, l) } function bh(t, e, r, n, i, s, a, o, l) { const u = s / 2, c = yh(t); let h = 0, p = e - r, f = []; for (let e = 0; e < t.length - 1; e++) { const a = t[e], o = t[e + 1], d = a.dist(o), y = o.angleTo(a); for (; p + r < h + d;) { p += r; const m = (p - h) / d, g = er.number(a.x, o.x, m), x = er.number(a.y, o.y, m); if (g >= 0 && g < l && x >= 0 && x < l && p - u >= 0 && p + u <= c) { const r = new fh(g, x, y, e); r._round(), n && !dh(t, r, s, n, i) || f.push(r); } } h += d; } return o || f.length || a || (f = bh(t, h / 2, r, n, i, s, a, !0, l)), f } Ui("Anchor", fh); const wh = Gu; function _h(t, e, r, n) { const i = [], s = t.image, a = s.pixelRatio, o = s.paddedRect.w - 2 * wh, u = s.paddedRect.h - 2 * wh; let c = { x1: t.left, y1: t.top, x2: t.right, y2: t.bottom }; const h = s.stretchX || [[0, o]], p = s.stretchY || [[0, u]], f = (t, e) => t + e[1] - e[0], d = h.reduce(f, 0), y = p.reduce(f, 0), m = o - d, g = u - y; let x = 0, v = d, b = 0, w = y, _ = 0, S = m, A = 0, k = g; if (s.content && n) { const e = s.content, r = e[2] - e[0], n = e[3] - e[1]; (s.textFitWidth || s.textFitHeight) && (c = mc(t)), x = Sh(h, 0, e[0]), b = Sh(p, 0, e[1]), v = Sh(h, e[0], e[2]), w = Sh(p, e[1], e[3]), _ = e[0] - x, A = e[1] - b, S = r - v, k = n - w; } const M = c.x1, I = c.y1, z = c.x2 - M, P = c.y2 - I, C = (t, n, i, o) => { const u = kh(t.stretch - x, v, z, M), c = Mh(t.fixed - _, S, t.stretch, d), h = kh(n.stretch - b, w, P, I), p = Mh(n.fixed - A, k, n.stretch, y), f = kh(i.stretch - x, v, z, M), m = Mh(i.fixed - _, S, i.stretch, d), g = kh(o.stretch - b, w, P, I), C = Mh(o.fixed - A, k, o.stretch, y), B = new l(u, h), V = new l(f, h), E = new l(f, g), T = new l(u, g), F = new l(c / a, p / a), $ = new l(m / a, C / a), L = e * Math.PI / 180; if (L) { const t = Math.sin(L), e = Math.cos(L), r = [e, -t, t, e]; B._matMult(r), V._matMult(r), T._matMult(r), E._matMult(r); } const O = t.stretch + t.fixed, D = n.stretch + n.fixed; return { tl: B, tr: V, bl: T, br: E, tex: { x: s.paddedRect.x + wh + O, y: s.paddedRect.y + wh + D, w: i.stretch + i.fixed - O, h: o.stretch + o.fixed - D }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: F, pixelOffsetBR: $, minFontScaleX: S / a / z, minFontScaleY: k / a / P, isSDF: r } }; if (n && (s.stretchX || s.stretchY)) { const t = Ah(h, m, d), e = Ah(p, g, y); for (let r = 0; r < t.length - 1; r++) { const n = t[r], s = t[r + 1]; for (let t = 0; t < e.length - 1; t++)i.push(C(n, e[t], s, e[t + 1])); } } else i.push(C({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: o + 1 }, { fixed: 0, stretch: u + 1 })); return i } function Sh(t, e, r) { let n = 0; for (const i of t) n += Math.max(e, Math.min(r, i[1])) - Math.max(e, Math.min(r, i[0])); return n } function Ah(t, e, r) { const n = [{ fixed: -1, stretch: 0 }]; for (const [e, r] of t) { const t = n[n.length - 1]; n.push({ fixed: e - t.stretch, stretch: t.stretch }), n.push({ fixed: e - t.stretch, stretch: t.stretch + (r - e) }); } return n.push({ fixed: e + wh, stretch: r }), n } function kh(t, e, r, n) { return t / e * r + n } function Mh(t, e, r, n) { return t - e * r / n } class Ih { constructor(t, e, r, n, i, s, a, o, u, c) { var h; if (this.boxStartIndex = t.length, u) { let t = s.top, e = s.bottom; const r = s.collisionPadding; r && (t -= r[1], e += r[3]); let n = e - t; n > 0 && (n = Math.max(10, n), this.circleDiameter = n); } else { const u = (null === (h = s.image) || void 0 === h ? void 0 : h.content) && (s.image.textFitWidth || s.image.textFitHeight) ? mc(s) : { x1: s.left, y1: s.top, x2: s.right, y2: s.bottom }; u.y1 = u.y1 * a - o[0], u.y2 = u.y2 * a + o[2], u.x1 = u.x1 * a - o[3], u.x2 = u.x2 * a + o[1]; const p = s.collisionPadding; if (p && (u.x1 -= p[0] * a, u.y1 -= p[1] * a, u.x2 += p[2] * a, u.y2 += p[3] * a), c) { const t = new l(u.x1, u.y1), e = new l(u.x2, u.y1), r = new l(u.x1, u.y2), n = new l(u.x2, u.y2), i = c * Math.PI / 180; t._rotate(i), e._rotate(i), r._rotate(i), n._rotate(i), u.x1 = Math.min(t.x, e.x, r.x, n.x), u.x2 = Math.max(t.x, e.x, r.x, n.x), u.y1 = Math.min(t.y, e.y, r.y, n.y), u.y2 = Math.max(t.y, e.y, r.y, n.y); } t.emplaceBack(e.x, e.y, u.x1, u.y1, u.x2, u.y2, r, n, i); } this.boxEndIndex = t.length; } } class zh { constructor(t = [], e = ((t, e) => t < e ? -1 : t > e ? 1 : 0)) { if (this.data = t, this.length = this.data.length, this.compare = e, this.length > 0) for (let t = (this.length >> 1) - 1; t >= 0; t--)this._down(t); } push(t) { this.data.push(t), this._up(this.length++); } pop() { if (0 === this.length) return; const t = this.data[0], e = this.data.pop(); return --this.length > 0 && (this.data[0] = e, this._down(0)), t } peek() { return this.data[0] } _up(t) { const { data: e, compare: r } = this, n = e[t]; for (; t > 0;) { const i = t - 1 >> 1, s = e[i]; if (r(n, s) >= 0) break; e[t] = s, t = i; } e[t] = n; } _down(t) { const { data: e, compare: r } = this, n = this.length >> 1, i = e[t]; for (; t < n;) { let n = 1 + (t << 1); const s = n + 1; if (s < this.length && r(e[s], e[n]) < 0 && (n = s), r(e[n], i) >= 0) break; e[t] = e[n], t = n; } e[t] = i; } } function Ph(t, e = 1, r = !1) { let n = 1 / 0, i = 1 / 0, s = -1 / 0, a = -1 / 0; const o = t[0]; for (let t = 0; t < o.length; t++) { const e = o[t]; (!t || e.x < n) && (n = e.x), (!t || e.y < i) && (i = e.y), (!t || e.x > s) && (s = e.x), (!t || e.y > a) && (a = e.y); } const u = Math.min(s - n, a - i); let c = u / 2; const h = new zh([], Ch); if (0 === u) return new l(n, i); for (let e = n; e < s; e += u)for (let r = i; r < a; r += u)h.push(new Bh(e + c, r + c, c, t)); let p = function (t) { let e = 0, r = 0, n = 0; const i = t[0]; for (let t = 0, s = i.length, a = s - 1; t < s; a = t++) { const s = i[t], o = i[a], l = s.x * o.y - o.x * s.y; r += (s.x + o.x) * l, n += (s.y + o.y) * l, e += 3 * l; } return new Bh(r / e, n / e, 0, t) }(t), f = h.length; for (; h.length;) { const n = h.pop(); (n.d > p.d || !p.d) && (p = n, r && console.log("found best %d after %d probes", Math.round(1e4 * n.d) / 1e4, f)), n.max - p.d <= e || (c = n.h / 2, h.push(new Bh(n.p.x - c, n.p.y - c, c, t)), h.push(new Bh(n.p.x + c, n.p.y - c, c, t)), h.push(new Bh(n.p.x - c, n.p.y + c, c, t)), h.push(new Bh(n.p.x + c, n.p.y + c, c, t)), f += 4); } return r && (console.log(`num probes: ${f}`), console.log(`best distance: ${p.d}`)), p.p } function Ch(t, e) { return e.max - t.max } function Bh(t, e, r, n) { this.p = new l(t, e), this.h = r, this.d = function (t, e) { let r = !1, n = 1 / 0; for (let i = 0; i < e.length; i++) { const s = e[i]; for (let e = 0, i = s.length, a = i - 1; e < i; a = e++) { const i = s[e], o = s[a]; i.y > t.y != o.y > t.y && t.x < (o.x - i.x) * (t.y - i.y) / (o.y - i.y) + i.x && (r = !r), n = Math.min(n, bo(t, i, o)); } } return (r ? 1 : -1) * Math.sqrt(n) }(this.p, n), this.max = this.d + this.h * Math.SQRT2; } var Vh; t.av = void 0, (Vh = t.av || (t.av = {}))[Vh.center = 1] = "center", Vh[Vh.left = 2] = "left", Vh[Vh.right = 3] = "right", Vh[Vh.top = 4] = "top", Vh[Vh.bottom = 5] = "bottom", Vh[Vh["top-left"] = 6] = "top-left", Vh[Vh["top-right"] = 7] = "top-right", Vh[Vh["bottom-left"] = 8] = "bottom-left", Vh[Vh["bottom-right"] = 9] = "bottom-right"; const Eh = 7, Th = Number.POSITIVE_INFINITY; function Fh(t, e) { return e[1] !== Th ? function (t, e, r) { let n = 0, i = 0; switch (e = Math.abs(e), r = Math.abs(r), t) { case "top-right": case "top-left": case "top": i = r - Eh; break; case "bottom-right": case "bottom-left": case "bottom": i = -r + Eh; }switch (t) { case "top-right": case "bottom-right": case "right": n = -e; break; case "top-left": case "bottom-left": case "left": n = e; }return [n, i] }(t, e[0], e[1]) : function (t, e) { let r = 0, n = 0; e < 0 && (e = 0); const i = e / Math.SQRT2; switch (t) { case "top-right": case "top-left": n = i - Eh; break; case "bottom-right": case "bottom-left": n = -i + Eh; break; case "bottom": n = -e + Eh; break; case "top": n = e - Eh; }switch (t) { case "top-right": case "bottom-right": r = -i; break; case "top-left": case "bottom-left": r = i; break; case "left": r = e; break; case "right": r = -e; }return [r, n] }(t, e[0]) } function $h(t, e, r) { var n; const i = t.layout, s = null === (n = i.get("text-variable-anchor-offset")) || void 0 === n ? void 0 : n.evaluate(e, {}, r); if (s) { const t = s.values, e = []; for (let r = 0; r < t.length; r += 2) { const n = e[r] = t[r], i = t[r + 1].map((t => t * Tu)); n.startsWith("top") ? i[1] -= Eh : n.startsWith("bottom") && (i[1] += Eh), e[r + 1] = i; } return new Se(e) } const a = i.get("text-variable-anchor"); if (a) { let n; n = void 0 !== t._unevaluatedLayout.getValue("text-radial-offset") ? [i.get("text-radial-offset").evaluate(e, {}, r) * Tu, Th] : i.get("text-offset").evaluate(e, {}, r).map((t => t * Tu)); const s = []; for (const t of a) s.push(t, Fh(t, n)); return new Se(s) } return null } function Lh(t) { switch (t) { case "right": case "top-right": case "bottom-right": return "right"; case "left": case "top-left": case "bottom-left": return "left" }return "center" } function Oh(e, r, n, i, s, a, o, l, u, c, h, p) { let f = a.textMaxSize.evaluate(r, {}); void 0 === f && (f = o); const d = e.layers[0].layout, y = d.get("icon-offset").evaluate(r, {}, h), m = Rh(n.horizontal), g = o / 24, x = e.tilePixelRatio * g, v = e.tilePixelRatio * f / 24, b = e.tilePixelRatio * l, w = e.tilePixelRatio * d.get("symbol-spacing"), _ = d.get("text-padding") * e.tilePixelRatio, S = function (t, e, r, n = 1) { const i = t.get("icon-padding").evaluate(e, {}, r), s = i && i.values; return [s[0] * n, s[1] * n, s[2] * n, s[3] * n] }(d, r, h, e.tilePixelRatio), A = d.get("text-max-angle") / 180 * Math.PI, k = "viewport" !== d.get("text-rotation-alignment") && "point" !== d.get("symbol-placement"), I = "map" === d.get("icon-rotation-alignment") && "point" !== d.get("symbol-placement"), z = d.get("symbol-placement"), P = w / 2, C = d.get("icon-text-fit"); let B; i && "none" !== C && (e.allowVerticalPlacement && n.vertical && (B = gc(i, n.vertical, C, d.get("icon-text-fit-padding"), y, g)), m && (i = gc(i, m, C, d.get("icon-text-fit-padding"), y, g))); const V = h ? p.line.getGranularityForZoomLevel(h.z) : 1, E = (l, p) => { p.x < 0 || p.x >= M || p.y < 0 || p.y >= M || function (e, r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v, b, w, _, S, A, k) { const M = e.addToLineVertexArray(r, n); let I, z, P, C, B = 0, V = 0, E = 0, T = 0, F = -1, $ = -1; const L = {}; let O = Da(""); if (e.allowVerticalPlacement && i.vertical) { const t = l.layout.get("text-rotate").evaluate(w, {}, A) + 90; P = new Ih(u, r, c, h, p, i.vertical, f, d, y, t), o && (C = new Ih(u, r, c, h, p, o, g, x, y, t)); } if (s) { const n = l.layout.get("icon-rotate").evaluate(w, {}), i = "none" !== l.layout.get("icon-text-fit"), a = _h(s, n, S, i), f = o ? _h(o, n, S, i) : void 0; z = new Ih(u, r, c, h, p, s, g, x, !1, n), B = 4 * a.length; const d = e.iconSizeData; let y = null; "source" === d.kind ? (y = [vc * l.layout.get("icon-size").evaluate(w, {})], y[0] > bc && j(`${e.layerIds[0]}: Value for "icon-size" is >= ${xc}. Reduce your "icon-size".`)) : "composite" === d.kind && (y = [vc * _.compositeIconSizes[0].evaluate(w, {}, A), vc * _.compositeIconSizes[1].evaluate(w, {}, A)], (y[0] > bc || y[1] > bc) && j(`${e.layerIds[0]}: Value for "icon-size" is >= ${xc}. Reduce your "icon-size".`)), e.addSymbols(e.icon, a, y, b, v, w, t.ai.none, r, M.lineStartIndex, M.lineLength, -1, A), F = e.icon.placedSymbolArray.length - 1, f && (V = 4 * f.length, e.addSymbols(e.icon, f, y, b, v, w, t.ai.vertical, r, M.lineStartIndex, M.lineLength, -1, A), $ = e.icon.placedSymbolArray.length - 1); } const D = Object.keys(i.horizontal); for (const n of D) { const s = i.horizontal[n]; if (!I) { O = Da(s.text); const t = l.layout.get("text-rotate").evaluate(w, {}, A); I = new Ih(u, r, c, h, p, s, f, d, y, t); } const o = 1 === s.positionedLines.length; if (E += Dh(e, r, s, a, l, y, w, m, M, i.vertical ? t.ai.horizontal : t.ai.horizontalOnly, o ? D : [n], L, F, _, A), o) break } i.vertical && (T += Dh(e, r, i.vertical, a, l, y, w, m, M, t.ai.vertical, ["vertical"], L, $, _, A)); const R = I ? I.boxStartIndex : e.collisionBoxArray.length, N = I ? I.boxEndIndex : e.collisionBoxArray.length, U = P ? P.boxStartIndex : e.collisionBoxArray.length, q = P ? P.boxEndIndex : e.collisionBoxArray.length, G = z ? z.boxStartIndex : e.collisionBoxArray.length, Z = z ? z.boxEndIndex : e.collisionBoxArray.length, X = C ? C.boxStartIndex : e.collisionBoxArray.length, K = C ? C.boxEndIndex : e.collisionBoxArray.length; let H = -1; const Y = (t, e) => t && t.circleDiameter ? Math.max(t.circleDiameter, e) : e; H = Y(I, H), H = Y(P, H), H = Y(z, H), H = Y(C, H); const J = H > -1 ? 1 : 0; J && (H *= k / Tu), e.glyphOffsetArray.length >= Cc.MAX_GLYPHS && j("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== w.sortKey && e.addToSortKeyRanges(e.symbolInstances.length, w.sortKey); const W = $h(l, w, A), [Q, tt] = function (e, r) { const n = e.length, i = null == r ? void 0 : r.values; if ((null == i ? void 0 : i.length) > 0) for (let r = 0; r < i.length; r += 2) { const n = i[r + 1]; e.emplaceBack(t.av[i[r]], n[0], n[1]); } return [n, e.length] }(e.textAnchorOffsets, W); e.symbolInstances.emplaceBack(r.x, r.y, L.right >= 0 ? L.right : -1, L.center >= 0 ? L.center : -1, L.left >= 0 ? L.left : -1, L.vertical || -1, F, $, O, R, N, U, q, G, Z, X, K, c, E, T, B, V, J, 0, f, H, Q, tt); }(e, p, l, n, i, s, B, e.layers[0], e.collisionBoxArray, r.index, r.sourceLayerIndex, e.index, x, [_, _, _, _], k, u, b, S, I, y, r, a, c, h, o); }; if ("line" === z) for (const t of ph(r.geometry, 0, 0, M, M)) { const r = Il(t, V), s = vh(r, w, A, n.vertical || m, i, 24, v, e.overscaling, M); for (const t of s) m && jh(e, m.text, P, t) || E(r, t); } else if ("line-center" === z) { for (const t of r.geometry) if (t.length > 1) { const e = Il(t, V), r = xh(e, A, n.vertical || m, i, 24, v); r && E(e, r); } } else if ("Polygon" === r.type) for (const t of Rr(r.geometry, 0)) { const e = Ph(t, 16); E(Il(t[0], V, !0), new fh(e.x, e.y, 0)); } else if ("LineString" === r.type) for (const t of r.geometry) { const e = Il(t, V); E(e, new fh(e[0].x, e[0].y, 0)); } else if ("Point" === r.type) for (const t of r.geometry) for (const e of t) E([e], new fh(e.x, e.y, 0)); } function Dh(t, e, r, n, i, s, a, o, u, c, h, p, f, d, y) { const m = function (t, e, r, n, i, s, a, o) { const u = n.layout.get("text-rotate").evaluate(s, {}) * Math.PI / 180, c = []; for (const t of e.positionedLines) for (const n of t.positionedGlyphs) { if (!n.rect) continue; const s = n.rect || {}; let h = Uu + 1, p = !0, f = 1, d = 0; const y = (i || o) && n.vertical, m = n.metrics.advance * n.scale / 2; if (o && e.verticalizable && (d = t.lineOffset / 2 - (n.imageName ? -(Tu - n.metrics.width * n.scale) / 2 : (n.scale - 1) * Tu)), n.imageName) { const t = a[n.imageName]; p = t.sdf, f = t.pixelRatio, h = Gu / f; } const g = i ? [n.x + m, n.y] : [0, 0]; let x = i ? [0, 0] : [n.x + m + r[0], n.y + r[1] - d], v = [0, 0]; y && (v = x, x = [0, 0]); const b = n.metrics.isDoubleResolution ? 2 : 1, w = (n.metrics.left - h) * n.scale - m + x[0], _ = (-n.metrics.top - h) * n.scale + x[1], S = w + s.w / b * n.scale / f, A = _ + s.h / b * n.scale / f, k = new l(w, _), M = new l(S, _), I = new l(w, A), z = new l(S, A); if (y) { const t = new l(-m, m - Hu), e = -Math.PI / 2, r = Tu / 2 - m, i = new l(5 - Hu - r, -(n.imageName ? r : 0)), s = new l(...v); k._rotateAround(e, t)._add(i)._add(s), M._rotateAround(e, t)._add(i)._add(s), I._rotateAround(e, t)._add(i)._add(s), z._rotateAround(e, t)._add(i)._add(s); } if (u) { const t = Math.sin(u), e = Math.cos(u), r = [e, -t, t, e]; k._matMult(r), M._matMult(r), I._matMult(r), z._matMult(r); } const P = new l(0, 0), C = new l(0, 0); c.push({ tl: k, tr: M, bl: I, br: z, tex: s, writingMode: e.writingMode, glyphOffset: g, sectionIndex: n.sectionIndex, isSDF: p, pixelOffsetTL: P, pixelOffsetBR: C, minFontScaleX: 0, minFontScaleY: 0 }); } return c }(0, r, o, i, s, a, n, t.allowVerticalPlacement), g = t.textSizeData; let x = null; "source" === g.kind ? (x = [vc * i.layout.get("text-size").evaluate(a, {})], x[0] > bc && j(`${t.layerIds[0]}: Value for "text-size" is >= ${xc}. Reduce your "text-size".`)) : "composite" === g.kind && (x = [vc * d.compositeTextSizes[0].evaluate(a, {}, y), vc * d.compositeTextSizes[1].evaluate(a, {}, y)], (x[0] > bc || x[1] > bc) && j(`${t.layerIds[0]}: Value for "text-size" is >= ${xc}. Reduce your "text-size".`)), t.addSymbols(t.text, m, x, o, s, a, c, e, u.lineStartIndex, u.lineLength, f, y); for (const e of h) p[e] = t.text.placedSymbolArray.length - 1; return 4 * m.length } function Rh(t) { for (const e in t) return t[e]; return null } function jh(t, e, r, n) { const i = t.compareText; if (e in i) { const t = i[e]; for (let e = t.length - 1; e >= 0; e--)if (n.dist(t[e]) < r) return !0 } else i[e] = []; return i[e].push(n), !1 } const Nh = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array]; class Uh { static from(t) { if (!(t instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer."); const [e, r] = new Uint8Array(t, 0, 2); if (219 !== e) throw new Error("Data does not appear to be in a KDBush format."); const n = r >> 4; if (1 !== n) throw new Error(`Got v${n} data when expected v1.`); const i = Nh[15 & r]; if (!i) throw new Error("Unrecognized array type."); const [s] = new Uint16Array(t, 2, 1), [a] = new Uint32Array(t, 4, 1); return new Uh(a, s, i, t) } constructor(t, e = 64, r = Float64Array, n) { if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`); this.numItems = +t, this.nodeSize = Math.min(Math.max(+e, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array; const i = Nh.indexOf(this.ArrayType), s = 2 * t * this.ArrayType.BYTES_PER_ELEMENT, a = t * this.IndexArrayType.BYTES_PER_ELEMENT, o = (8 - a % 8) % 8; if (i < 0) throw new Error(`Unexpected typed array class: ${r}.`); n && n instanceof ArrayBuffer ? (this.data = n, this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + a + o, 2 * t), this._pos = 2 * t, this._finished = !0) : (this.data = new ArrayBuffer(8 + s + a + o), this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + a + o, 2 * t), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + i]), new Uint16Array(this.data, 2, 1)[0] = e, new Uint32Array(this.data, 4, 1)[0] = t); } add(t, e) { const r = this._pos >> 1; return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = e, r } finish() { const t = this._pos >> 1; if (t !== this.numItems) throw new Error(`Added ${t} items when expected ${this.numItems}.`); return qh(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this } range(t, e, r, n) { if (!this._finished) throw new Error("Data not yet indexed - call index.finish()."); const { ids: i, coords: s, nodeSize: a } = this, o = [0, i.length - 1, 0], l = []; for (; o.length;) { const u = o.pop() || 0, c = o.pop() || 0, h = o.pop() || 0; if (c - h <= a) { for (let a = h; a <= c; a++) { const o = s[2 * a], u = s[2 * a + 1]; o >= t && o <= r && u >= e && u <= n && l.push(i[a]); } continue } const p = h + c >> 1, f = s[2 * p], d = s[2 * p + 1]; f >= t && f <= r && d >= e && d <= n && l.push(i[p]), (0 === u ? t <= f : e <= d) && (o.push(h), o.push(p - 1), o.push(1 - u)), (0 === u ? r >= f : n >= d) && (o.push(p + 1), o.push(c), o.push(1 - u)); } return l } within(t, e, r) { if (!this._finished) throw new Error("Data not yet indexed - call index.finish()."); const { ids: n, coords: i, nodeSize: s } = this, a = [0, n.length - 1, 0], o = [], l = r * r; for (; a.length;) { const u = a.pop() || 0, c = a.pop() || 0, h = a.pop() || 0; if (c - h <= s) { for (let r = h; r <= c; r++)Kh(i[2 * r], i[2 * r + 1], t, e) <= l && o.push(n[r]); continue } const p = h + c >> 1, f = i[2 * p], d = i[2 * p + 1]; Kh(f, d, t, e) <= l && o.push(n[p]), (0 === u ? t - r <= f : e - r <= d) && (a.push(h), a.push(p - 1), a.push(1 - u)), (0 === u ? t + r >= f : e + r >= d) && (a.push(p + 1), a.push(c), a.push(1 - u)); } return o } } function qh(t, e, r, n, i, s) { if (i - n <= r) return; const a = n + i >> 1; Gh(t, e, a, n, i, s), qh(t, e, r, n, a - 1, 1 - s), qh(t, e, r, a + 1, i, 1 - s); } function Gh(t, e, r, n, i, s) { for (; i > n;) { if (i - n > 600) { const a = i - n + 1, o = r - n + 1, l = Math.log(a), u = .5 * Math.exp(2 * l / 3), c = .5 * Math.sqrt(l * u * (a - u) / a) * (o - a / 2 < 0 ? -1 : 1); Gh(t, e, r, Math.max(n, Math.floor(r - o * u / a + c)), Math.min(i, Math.floor(r + (a - o) * u / a + c)), s); } const a = e[2 * r + s]; let o = n, l = i; for (Zh(t, e, n, r), e[2 * i + s] > a && Zh(t, e, n, i); o < l;) { for (Zh(t, e, o, l), o++, l--; e[2 * o + s] < a;)o++; for (; e[2 * l + s] > a;)l--; } e[2 * n + s] === a ? Zh(t, e, n, l) : (l++, Zh(t, e, l, i)), l <= r && (n = l + 1), r <= l && (i = l - 1); } } function Zh(t, e, r, n) { Xh(t, r, n), Xh(e, 2 * r, 2 * n), Xh(e, 2 * r + 1, 2 * n + 1); } function Xh(t, e, r) { const n = t[e]; t[e] = t[r], t[r] = n; } function Kh(t, e, r, n) { const i = t - r, s = e - n; return i * i + s * s } var Hh; t.ce = void 0, (Hh = t.ce || (t.ce = {})).create = "create", Hh.load = "load", Hh.fullLoad = "fullLoad"; let Yh = null, Jh = []; const Wh = 1e3 / 60, Qh = "loadTime", tp = "fullLoadTime", ep = { mark(t) { performance.mark(t); }, frame(t) { const e = t; null != Yh && Jh.push(e - Yh), Yh = e; }, clearMetrics() { Yh = null, Jh = [], performance.clearMeasures(Qh), performance.clearMeasures(tp); for (const e in t.ce) performance.clearMarks(t.ce[e]); }, getPerformanceMetrics() { performance.measure(Qh, t.ce.create, t.ce.load), performance.measure(tp, t.ce.create, t.ce.fullLoad); const e = performance.getEntriesByName(Qh)[0].duration, r = performance.getEntriesByName(tp)[0].duration, n = Jh.length, i = 1 / (Jh.reduce(((t, e) => t + e), 0) / n / 1e3), s = Jh.filter((t => t > Wh)).reduce(((t, e) => t + (e - Wh) / Wh), 0); return { loadTime: e, fullLoadTime: r, fps: i, percentDroppedFrames: s / (n + s) * 100, totalFrames: n } } }; t.$ = St, t.A = g, t.B = Li, t.C = function (t) { if (null == q) { const e = t.navigator ? t.navigator.userAgent : null; q = !!t.safari || !(!e || !(/\b(iPad|iPhone|iPod)\b/.test(e) || e.match("Safari") && !e.match("Chrome"))); } return q }, t.D = vs, t.E = ct, t.F = class { constructor(t, e) { this.target = t, this.mapId = e, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new Uc((() => this.process())), this.subscription = function (t, e, r, n) { return t.addEventListener(e, r, !1), { unsubscribe: () => { t.removeEventListener(e, r, !1); } } }(this.target, "message", (t => this.receive(t))), this.globalScope = U(self) ? t : window; } registerMessageHandler(t, e) { this.messageHandlers[t] = e; } sendAsync(t, e) { return new Promise(((r, n) => { const i = Math.round(1e18 * Math.random()).toString(36).substring(0, 10); this.resolveRejects[i] = { resolve: r, reject: n }, e && e.signal.addEventListener("abort", (() => { delete this.resolveRejects[i]; const e = { id: i, type: "<cancel>", origin: location.origin, targetMapId: t.targetMapId, sourceMapId: this.mapId }; this.target.postMessage(e); }), { once: !0 }); const s = [], a = Object.assign(Object.assign({}, t), { id: i, sourceMapId: this.mapId, origin: location.origin, data: Xi(t.data, s) }); this.target.postMessage(a, { transfer: s }); })) } receive(t) { const e = t.data, r = e.id; if (!("file://" !== e.origin && "file://" !== location.origin && "resource://android" !== e.origin && "resource://android" !== location.origin && e.origin !== location.origin || e.targetMapId && this.mapId !== e.targetMapId)) { if ("<cancel>" === e.type) { delete this.tasks[r]; const t = this.abortControllers[r]; return delete this.abortControllers[r], void (t && t.abort()) } if (U(self) || e.mustQueue) return this.tasks[r] = e, this.taskQueue.push(r), void this.invoker.trigger(); this.processTask(r, e); } } process() { if (0 === this.taskQueue.length) return; const t = this.taskQueue.shift(), e = this.tasks[t]; delete this.tasks[t], this.taskQueue.length > 0 && this.invoker.trigger(), e && this.processTask(t, e); } processTask(t, r) { return e(this, void 0, void 0, (function* () { if ("<response>" === r.type) { const e = this.resolveRejects[t]; if (delete this.resolveRejects[t], !e) return; return void (r.error ? e.reject(Ki(r.error)) : e.resolve(Ki(r.data))) } if (!this.messageHandlers[r.type]) return void this.completeTask(t, new Error(`Could not find a registered handler for ${r.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`)); const e = Ki(r.data), n = new AbortController; this.abortControllers[t] = n; try { const i = yield this.messageHandlers[r.type](r.sourceMapId, e, n); this.completeTask(t, null, i); } catch (e) { this.completeTask(t, e); } })) } completeTask(t, e, r) { const n = []; delete this.abortControllers[t]; const i = { id: t, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: e ? Xi(e) : null, data: Xi(r, n) }; this.target.postMessage(i, { transfer: n }); } remove() { this.invoker.remove(), this.subscription.unsubscribe(); } }, t.G = et, t.H = function () { var t = new g(16); return g != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0), t[0] = 1, t[5] = 1, t[10] = 1, t[15] = 1, t }, t.I = Zu, t.J = function (t, e, r) { var n, i, s, a, o, l, u, c, h, p, f, d, y = r[0], m = r[1], g = r[2]; return e === t ? (t[12] = e[0] * y + e[4] * m + e[8] * g + e[12], t[13] = e[1] * y + e[5] * m + e[9] * g + e[13], t[14] = e[2] * y + e[6] * m + e[10] * g + e[14], t[15] = e[3] * y + e[7] * m + e[11] * g + e[15]) : (i = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8], p = e[9], f = e[10], d = e[11], t[0] = n = e[0], t[1] = i, t[2] = s, t[3] = a, t[4] = o, t[5] = l, t[6] = u, t[7] = c, t[8] = h, t[9] = p, t[10] = f, t[11] = d, t[12] = n * y + o * m + h * g + e[12], t[13] = i * y + l * m + p * g + e[13], t[14] = s * y + u * m + f * g + e[14], t[15] = a * y + c * m + d * g + e[15]), t }, t.K = function (t, e, r) { var n = r[0], i = r[1], s = r[2]; return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t[3] = e[3] * n, t[4] = e[4] * i, t[5] = e[5] * i, t[6] = e[6] * i, t[7] = e[7] * i, t[8] = e[8] * s, t[9] = e[9] * s, t[10] = e[10] * s, t[11] = e[11] * s, t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t }, t.L = function (t, e, r) { var n = e[0], i = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8], p = e[9], f = e[10], d = e[11], y = e[12], m = e[13], g = e[14], x = e[15], v = r[0], b = r[1], w = r[2], _ = r[3]; return t[0] = v * n + b * o + w * h + _ * y, t[1] = v * i + b * l + w * p + _ * m, t[2] = v * s + b * u + w * f + _ * g, t[3] = v * a + b * c + w * d + _ * x, t[4] = (v = r[4]) * n + (b = r[5]) * o + (w = r[6]) * h + (_ = r[7]) * y, t[5] = v * i + b * l + w * p + _ * m, t[6] = v * s + b * u + w * f + _ * g, t[7] = v * a + b * c + w * d + _ * x, t[8] = (v = r[8]) * n + (b = r[9]) * o + (w = r[10]) * h + (_ = r[11]) * y, t[9] = v * i + b * l + w * p + _ * m, t[10] = v * s + b * u + w * f + _ * g, t[11] = v * a + b * c + w * d + _ * x, t[12] = (v = r[12]) * n + (b = r[13]) * o + (w = r[14]) * h + (_ = r[15]) * y, t[13] = v * i + b * l + w * p + _ * m, t[14] = v * s + b * u + w * f + _ * g, t[15] = v * a + b * c + w * d + _ * x, t }, t.M = function (t, e) { const r = {}; for (let n = 0; n < e.length; n++) { const i = e[n]; i in t && (r[i] = t[i]); } return r }, t.N = Gc, t.O = Kc, t.P = l, t.Q = Hc, t.R = Do, t.S = nh, t.T = fs, t.U = f, t.V = d, t.W = X, t.X = M, t.Y = Qc, t.Z = eh, t._ = e, t.a = Q, t.a$ = function () { return new Float64Array(16) }, t.a0 = t => { const e = window.document.createElement("video"); return e.muted = !0, new Promise((r => { e.onloadstart = () => { r(e); }; for (const r of t) { const t = window.document.createElement("source"); st(r) || (e.crossOrigin = "Anonymous"), t.src = r, e.appendChild(t); } })) }, t.a1 = function () { return $++ }, t.a2 = ra, t.a3 = Cc, t.a4 = Yn, t.a5 = lo, t.a6 = oh, t.a7 = function (t) { const e = {}; if (t.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, ((t, r, n, i) => { const s = n || i; return e[r] = !s || s.toLowerCase(), "" })), e["max-age"]) { const t = parseInt(e["max-age"], 10); isNaN(t) ? delete e["max-age"] : e["max-age"] = t; } return e }, t.a8 = function (t) { return Math.log(t) / Math.LN2 }, t.a9 = function (t) { var e = t[0], r = t[1]; return e * e + r * r }, t.aA = Cs, t.aB = _l, t.aC = fa, t.aD = Pa, t.aE = ka, t.aF = 85.051129, t.aG = function (t) { return Math.pow(2, t) }, t.aH = Yc, t.aI = T, t.aJ = Y, t.aK = Wc, t.aL = function (t, e, r) { return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t }, t.aM = function (t, e, r) { return t[0] = e[0] + r[0], t[1] = e[1] + r[1], t[2] = e[2] + r[2], t }, t.aN = function (t) { var e = new g(3); return e[0] = t[0], e[1] = t[1], e[2] = t[2], e }, t.aO = function (t, e, r) { return t[0] = e[0] * r[0], t[1] = e[1] * r[1], t[2] = e[2] * r[2], t[3] = e[3] * r[3], t }, t.aP = function (t, e, r) { return t[0] = e[0] - r[0], t[1] = e[1] - r[1], t[2] = e[2] - r[2], t }, t.aQ = function (t, e) { var r = e[0], n = e[1], i = e[2], s = r * r + n * n + i * i; return s > 0 && (s = 1 / Math.sqrt(s)), t[0] = e[0] * s, t[1] = e[1] * s, t[2] = e[2] * s, t }, t.aR = function (t, e, r) { var n = e[0], i = e[1], s = e[2], a = r[0], o = r[1], l = r[2]; return t[0] = i * l - s * o, t[1] = s * a - n * l, t[2] = n * o - i * a, t }, t.aS = function (t, e) { return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] }, t.aT = rh, t.aU = ih, t.aV = function (t, e, r, n, i) { var s, a = 1 / Math.tan(e / 2); return t[0] = a / r, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != i && i !== 1 / 0 ? (t[10] = (i + n) * (s = 1 / (n - i)), t[14] = 2 * i * n * s) : (t[10] = -1, t[14] = -2 * n), t }, t.aW = function (t) { var e = new g(16); return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e }, t.aX = function (t, e, r) { var n = Math.sin(r), i = Math.cos(r), s = e[0], a = e[1], o = e[2], l = e[3], u = e[4], c = e[5], h = e[6], p = e[7]; return e !== t && (t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = s * i + u * n, t[1] = a * i + c * n, t[2] = o * i + h * n, t[3] = l * i + p * n, t[4] = u * i - s * n, t[5] = c * i - a * n, t[6] = h * i - o * n, t[7] = p * i - l * n, t }, t.aY = function (t, e, r) { var n = Math.sin(r), i = Math.cos(r), s = e[4], a = e[5], o = e[6], l = e[7], u = e[8], c = e[9], h = e[10], p = e[11]; return e !== t && (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[4] = s * i + u * n, t[5] = a * i + c * n, t[6] = o * i + h * n, t[7] = l * i + p * n, t[8] = u * i - s * n, t[9] = c * i - a * n, t[10] = h * i - o * n, t[11] = p * i - l * n, t }, t.aZ = function () { const t = new Float32Array(16); return v(t), t }, t.a_ = function () { const t = new Float64Array(16); return v(t), t }, t.aa = function (t) { return t * Math.PI / 180 }, t.ab = E, t.ac = function (t, e) { const r = []; for (const n in t) n in e || r.push(n); return r }, t.ad = A, t.ae = function (t) { return Math.hypot(t[0], t[1]) }, t.af = function (t) { return t[0] = 0, t[1] = 0, t }, t.ag = function (t, e, r) { return t[0] = e[0] * r, t[1] = e[1] * r, t }, t.ah = function (t, e) { let r = 0, n = 0; if ("constant" === t.kind) n = t.layoutSize; else if ("source" !== t.kind) { const { interpolationType: i, minZoom: s, maxZoom: a } = t, o = i ? E(Qe.interpolationFactor(i, e, s, a), 0, 1) : 0; "camera" === t.kind ? n = er.number(t.minSize, t.maxSize, o) : r = o; } return { uSizeT: r, uSize: n } }, t.aj = function (t, { uSize: e, uSizeT: r }, { lowerSize: n, upperSize: i }) { return "source" === t.kind ? n / vc : "composite" === t.kind ? er.number(n / vc, i / vc, r) : e }, t.ak = Mc, t.al = _, t.am = function (t, e, r, n) { const i = e.y - t.y, s = e.x - t.x, a = n.y - r.y, o = n.x - r.x, u = a * s - o * i; if (0 === u) return null; const c = (o * (t.y - r.y) - a * (t.x - r.x)) / u; return new l(t.x + c * s, t.y + c * i) }, t.an = function (t, e) { var r = e[0], n = e[1], i = e[2], s = e[3], a = e[4], o = e[5], l = e[6], u = e[7], c = e[8], h = e[9], p = e[10], f = e[11], d = e[12], y = e[13], m = e[14], g = e[15], x = r * o - n * a, v = r * l - i * a, b = r * u - s * a, w = n * l - i * o, _ = n * u - s * o, S = i * u - s * l, A = c * y - h * d, k = c * m - p * d, M = c * g - f * d, I = h * m - p * y, z = h * g - f * y, P = p * g - f * m, C = x * P - v * z + b * I + w * M - _ * k + S * A; return C ? (t[0] = (o * P - l * z + u * I) * (C = 1 / C), t[1] = (i * z - n * P - s * I) * C, t[2] = (y * S - m * _ + g * w) * C, t[3] = (p * _ - h * S - f * w) * C, t[4] = (l * M - a * P - u * k) * C, t[5] = (r * P - i * M + s * k) * C, t[6] = (m * b - d * S - g * v) * C, t[7] = (c * S - p * b + f * v) * C, t[8] = (a * z - o * M + u * A) * C, t[9] = (n * M - r * z - s * A) * C, t[10] = (d * _ - y * b + g * x) * C, t[11] = (h * b - c * _ - f * x) * C, t[12] = (o * k - a * I - l * A) * C, t[13] = (r * I - n * k + i * A) * C, t[14] = (y * v - d * w - m * x) * C, t[15] = (c * w - h * v + p * x) * C, t) : null }, t.ao = ph, t.ap = po, t.aq = v, t.ar = function (t) { let e = 1 / 0, r = 1 / 0, n = -1 / 0, i = -1 / 0; for (const s of t) e = Math.min(e, s.x), r = Math.min(r, s.y), n = Math.max(n, s.x), i = Math.max(i, s.y); return [e, r, n, i] }, t.as = Tu, t.at = I, t.au = function (t, e, r, n, i = !1) { if (!r[0] && !r[1]) return [0, 0]; const s = i ? "map" === n ? -t.bearingInRadians : 0 : "viewport" === n ? t.bearingInRadians : 0; if (s) { const t = Math.sin(s), e = Math.cos(s); r = [r[0] * e - r[1] * t, r[0] * t + r[1] * e]; } return [i ? r[0] : I(e, r[0], t.zoom), i ? r[1] : I(e, r[1], t.zoom)] }, t.aw = _c, t.ax = Lh, t.ay = lc, t.az = Uh, t.b = G, t.b$ = t => "line" === t.type, t.b0 = function (t, e, r) { const n = new Float64Array(4); return function (t, e, r, n) { var i = .5 * Math.PI / 180; e *= i, r *= i, n *= i; var s = Math.sin(e), a = Math.cos(e), o = Math.sin(r), l = Math.cos(r), u = Math.sin(n), c = Math.cos(n); t[0] = s * l * c - a * o * u, t[1] = a * o * c + s * l * u, t[2] = a * l * u - s * o * c, t[3] = a * l * c + s * o * u; }(n, t, e - 90, r), n }, t.b1 = function (t, e, r, n) { var i, s, a, o, l, u = e[0], c = e[1], h = e[2], p = e[3], f = r[0], d = r[1], y = r[2], g = r[3]; return (s = u * f + c * d + h * y + p * g) < 0 && (s = -s, f = -f, d = -d, y = -y, g = -g), 1 - s > m ? (i = Math.acos(s), a = Math.sin(i), o = Math.sin((1 - n) * i) / a, l = Math.sin(n * i) / a) : (o = 1 - n, l = n), t[0] = o * u + l * f, t[1] = o * c + l * d, t[2] = o * h + l * y, t[3] = o * p + l * g, t }, t.b2 = function (t) { const e = new Float64Array(9); var r, n, i, s, a, o, l, u, c, h, p, f, d, y, m, g, x, v; h = (i = (n = t)[0]) * (l = i + i), p = (s = n[1]) * l, d = (a = n[2]) * l, y = a * (u = s + s), g = (o = n[3]) * l, x = o * u, v = o * (c = a + a), (r = e)[0] = 1 - (f = s * u) - (m = a * c), r[3] = p - v, r[6] = d + x, r[1] = p + v, r[4] = 1 - h - m, r[7] = y - g, r[2] = d - x, r[5] = y + g, r[8] = 1 - h - f; const b = Y(-Math.asin(E(e[2], -1, 1))); let w, _; return Math.hypot(e[5], e[8]) < .001 ? (w = 0, _ = -Y(Math.atan2(e[3], e[4]))) : (w = Y(0 === e[5] && 0 === e[8] ? 0 : Math.atan2(e[5], e[8])), _ = Y(0 === e[1] && 0 === e[0] ? 0 : Math.atan2(e[1], e[0]))), { roll: w, pitch: b + 90, bearing: _ } }, t.b3 = function (t, e) { return t.roll == e.roll && t.pitch == e.pitch && t.bearing == e.bearing }, t.b4 = ye, t.b5 = Ga, t.b6 = Sl, t.b7 = Al, t.b8 = wl, t.b9 = P, t.bA = L, t.bB = O, t.bC = class extends qa { constructor(t, e) { super(t, e), this.current = 0; } set(t) { this.current !== t && (this.current = t, this.gl.uniform1i(this.location, t)); } }, t.bD = class extends qa { constructor(t, e) { super(t, e), this.current = Ka; } set(t) { if (t[12] !== this.current[12] || t[0] !== this.current[0]) return this.current = t, void this.gl.uniformMatrix4fv(this.location, !1, t); for (let e = 1; e < 16; e++)if (t[e] !== this.current[e]) { this.current = t, this.gl.uniformMatrix4fv(this.location, !1, t); break } } }, t.bE = Za, t.bF = Xa, t.bG = class extends qa { constructor(t, e) { super(t, e), this.current = [0, 0, 0]; } set(t) { t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] || (this.current = t, this.gl.uniform3f(this.location, t[0], t[1], t[2])); } }, t.bH = class extends qa { constructor(t, e) { super(t, e), this.current = [0, 0]; } set(t) { t[0] === this.current[0] && t[1] === this.current[1] || (this.current = t, this.gl.uniform2f(this.location, t[0], t[1])); } }, t.bI = x, t.bJ = function (t, e) { var r = Math.sin(e), n = Math.cos(e); return t[0] = n, t[1] = r, t[2] = 0, t[3] = -r, t[4] = n, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t }, t.bK = function (t, e, r) { var n = e[0], i = e[1], s = e[2]; return t[0] = n * r[0] + i * r[3] + s * r[6], t[1] = n * r[1] + i * r[4] + s * r[7], t[2] = n * r[2] + i * r[5] + s * r[8], t }, t.bL = function (t, e, r, n, i, s, a) { var o = 1 / (e - r), l = 1 / (n - i), u = 1 / (s - a); return t[0] = -2 * o, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * l, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * u, t[11] = 0, t[12] = (e + r) * o, t[13] = (i + n) * l, t[14] = (a + s) * u, t[15] = 1, t }, t.bM = class extends qs { }, t.bN = zu, t.bO = class extends Zs { }, t.bP = jo, t.bQ = function (t) { return t <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t) / Math.LN2)) }, t.bR = Ro, t.bS = function (t, e, r) { var n = e[0], i = e[1], s = e[2], a = r[3] * n + r[7] * i + r[11] * s + r[15]; return t[0] = (r[0] * n + r[4] * i + r[8] * s + r[12]) / (a = a || 1), t[1] = (r[1] * n + r[5] * i + r[9] * s + r[13]) / a, t[2] = (r[2] * n + r[6] * i + r[10] * s + r[14]) / a, t }, t.bT = class extends Ts { }, t.bU = class extends Qs { }, t.bV = function (t, e) { return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] && t[4] === e[4] && t[5] === e[5] && t[6] === e[6] && t[7] === e[7] && t[8] === e[8] && t[9] === e[9] && t[10] === e[10] && t[11] === e[11] && t[12] === e[12] && t[13] === e[13] && t[14] === e[14] && t[15] === e[15] }, t.bW = function (t, e) { var r = t[0], n = t[1], i = t[2], s = t[3], a = t[4], o = t[5], l = t[6], u = t[7], c = t[8], h = t[9], p = t[10], f = t[11], d = t[12], y = t[13], g = t[14], x = t[15], v = e[0], b = e[1], w = e[2], _ = e[3], S = e[4], A = e[5], k = e[6], M = e[7], I = e[8], z = e[9], P = e[10], C = e[11], B = e[12], V = e[13], E = e[14], T = e[15]; return Math.abs(r - v) <= m * Math.max(1, Math.abs(r), Math.abs(v)) && Math.abs(n - b) <= m * Math.max(1, Math.abs(n), Math.abs(b)) && Math.abs(i - w) <= m * Math.max(1, Math.abs(i), Math.abs(w)) && Math.abs(s - _) <= m * Math.max(1, Math.abs(s), Math.abs(_)) && Math.abs(a - S) <= m * Math.max(1, Math.abs(a), Math.abs(S)) && Math.abs(o - A) <= m * Math.max(1, Math.abs(o), Math.abs(A)) && Math.abs(l - k) <= m * Math.max(1, Math.abs(l), Math.abs(k)) && Math.abs(u - M) <= m * Math.max(1, Math.abs(u), Math.abs(M)) && Math.abs(c - I) <= m * Math.max(1, Math.abs(c), Math.abs(I)) && Math.abs(h - z) <= m * Math.max(1, Math.abs(h), Math.abs(z)) && Math.abs(p - P) <= m * Math.max(1, Math.abs(p), Math.abs(P)) && Math.abs(f - C) <= m * Math.max(1, Math.abs(f), Math.abs(C)) && Math.abs(d - B) <= m * Math.max(1, Math.abs(d), Math.abs(B)) && Math.abs(y - V) <= m * Math.max(1, Math.abs(y), Math.abs(V)) && Math.abs(g - E) <= m * Math.max(1, Math.abs(g), Math.abs(E)) && Math.abs(x - T) <= m * Math.max(1, Math.abs(x), Math.abs(T)) }, t.bX = function (t, e) { return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t }, t.bY = t => "symbol" === t.type, t.bZ = t => "circle" === t.type, t.b_ = t => "heatmap" === t.type, t.ba = C, t.bb = ke, t.bc = function (t, e, r, n, i) { return P(n, i, E((t - e) / (r - e), 0, 1)) }, t.bd = z, t.be = function () { return new Float64Array(4) }, t.bf = function () { return new Float64Array(3) }, t.bg = function (t, e, r, n) { var i = [], s = []; return i[0] = e[0] - r[0], i[1] = e[1] - r[1], i[2] = e[2] - r[2], s[0] = i[0] * Math.cos(n) - i[1] * Math.sin(n), s[1] = i[0] * Math.sin(n) + i[1] * Math.cos(n), s[2] = i[2], t[0] = s[0] + r[0], t[1] = s[1] + r[1], t[2] = s[2] + r[2], t }, t.bh = function (t, e, r, n) { var i = [], s = []; return i[0] = e[0] - r[0], i[1] = e[1] - r[1], i[2] = e[2] - r[2], s[0] = i[0], s[1] = i[1] * Math.cos(n) - i[2] * Math.sin(n), s[2] = i[1] * Math.sin(n) + i[2] * Math.cos(n), t[0] = s[0] + r[0], t[1] = s[1] + r[1], t[2] = s[2] + r[2], t }, t.bi = function (t, e, r, n) { var i = [], s = []; return i[0] = e[0] - r[0], i[1] = e[1] - r[1], i[2] = e[2] - r[2], s[0] = i[2] * Math.sin(n) + i[0] * Math.cos(n), s[1] = i[1], s[2] = i[2] * Math.cos(n) - i[0] * Math.sin(n), t[0] = s[0] + r[0], t[1] = s[1] + r[1], t[2] = s[2] + r[2], t }, t.bj = function (t, e, r) { var n = Math.sin(r), i = Math.cos(r), s = e[0], a = e[1], o = e[2], l = e[3], u = e[8], c = e[9], h = e[10], p = e[11]; return e !== t && (t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = s * i - u * n, t[1] = a * i - c * n, t[2] = o * i - h * n, t[3] = l * i - p * n, t[8] = s * n + u * i, t[9] = a * n + c * i, t[10] = o * n + h * i, t[11] = l * n + p * i, t }, t.bk = function (t, e) { const r = z(t, 360), n = z(e, 360), i = n - r, s = n > r ? i - 360 : i + 360; return Math.abs(i) < Math.abs(s) ? i : s }, t.bl = function (t) { return t[0] = 0, t[1] = 0, t[2] = 0, t }, t.bm = function (t, e, r, n) { const i = Math.sqrt(t * t + e * e), s = Math.sqrt(r * r + n * n); t /= i, e /= i, r /= s, n /= s; const a = Math.acos(t * r + e * n); return -e * r + t * n > 0 ? a : -a }, t.bn = function (t, e) { return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] }, t.bo = qc, t.bp = function (t, e) { const r = z(t, 2 * Math.PI), n = z(e, 2 * Math.PI); return Math.min(Math.abs(r - n), Math.abs(r - n + 2 * Math.PI), Math.abs(r - n - 2 * Math.PI)) }, t.bq = function (t) { return Math.hypot(t[0], t[1], t[2]) }, t.br = function () { const t = {}, e = ht.$version; for (const r in ht.$root) { const n = ht.$root[r]; if (n.required) { let i = null; i = "version" === r ? e : "array" === n.type ? [] : {}, null != i && (t[r] = i); } } return t }, t.bs = Hi, t.bt = nt, t.bu = function (t) { t = t.slice(); const e = Object.create(null); for (let r = 0; r < t.length; r++)e[t[r].id] = t[r]; for (let r = 0; r < t.length; r++)"ref" in t[r] && (t[r] = ft(t[r], e[t[r].ref])); return t }, t.bv = function (t) { if ("custom" === t.type) return new Nc(t); switch (t.type) { case "background": return new Oc(t); case "circle": return new Co(t); case "fill": return new Fl(t); case "fill-extrusion": return new au(t); case "heatmap": return new No(t); case "hillshade": return new Go(t); case "line": return new _u(t); case "raster": return new jc(t); case "symbol": return new Fc(t) } }, t.bw = D, t.bx = function (t, e) { if (!t) return [{ command: "setStyle", args: [e] }]; let r = []; try { if (!dt(t.version, e.version)) return [{ command: "setStyle", args: [e] }]; dt(t.center, e.center) || r.push({ command: "setCenter", args: [e.center] }), dt(t.centerAltitude, e.centerAltitude) || r.push({ command: "setCenterAltitude", args: [e.centerAltitude] }), dt(t.zoom, e.zoom) || r.push({ command: "setZoom", args: [e.zoom] }), dt(t.bearing, e.bearing) || r.push({ command: "setBearing", args: [e.bearing] }), dt(t.pitch, e.pitch) || r.push({ command: "setPitch", args: [e.pitch] }), dt(t.roll, e.roll) || r.push({ command: "setRoll", args: [e.roll] }), dt(t.sprite, e.sprite) || r.push({ command: "setSprite", args: [e.sprite] }), dt(t.glyphs, e.glyphs) || r.push({ command: "setGlyphs", args: [e.glyphs] }), dt(t.transition, e.transition) || r.push({ command: "setTransition", args: [e.transition] }), dt(t.light, e.light) || r.push({ command: "setLight", args: [e.light] }), dt(t.terrain, e.terrain) || r.push({ command: "setTerrain", args: [e.terrain] }), dt(t.sky, e.sky) || r.push({ command: "setSky", args: [e.sky] }), dt(t.projection, e.projection) || r.push({ command: "setProjection", args: [e.projection] }); const n = {}, i = []; !function (t, e, r, n) { let i; for (i in e = e || {}, t = t || {}) Object.prototype.hasOwnProperty.call(t, i) && (Object.prototype.hasOwnProperty.call(e, i) || gt(i, r, n)); for (i in e) Object.prototype.hasOwnProperty.call(e, i) && (Object.prototype.hasOwnProperty.call(t, i) ? dt(t[i], e[i]) || ("geojson" === t[i].type && "geojson" === e[i].type && vt(t, e, i) ? yt(r, { command: "setGeoJSONSourceData", args: [i, e[i].data] }) : xt(i, e, r, n)) : mt(i, e, r)); }(t.sources, e.sources, i, n); const s = []; t.layers && t.layers.forEach((t => { "source" in t && n[t.source] ? r.push({ command: "removeLayer", args: [t.id] }) : s.push(t); })), r = r.concat(i), function (t, e, r) { e = e || []; const n = (t = t || []).map(wt), i = e.map(wt), s = t.reduce(_t, {}), a = e.reduce(_t, {}), o = n.slice(), l = Object.create(null); let u, c, h, p, f; for (let t = 0, e = 0; t < n.length; t++)u = n[t], Object.prototype.hasOwnProperty.call(a, u) ? e++ : (yt(r, { command: "removeLayer", args: [u] }), o.splice(o.indexOf(u, e), 1)); for (let t = 0, e = 0; t < i.length; t++)u = i[i.length - 1 - t], o[o.length - 1 - t] !== u && (Object.prototype.hasOwnProperty.call(s, u) ? (yt(r, { command: "removeLayer", args: [u] }), o.splice(o.lastIndexOf(u, o.length - e), 1)) : e++, p = o[o.length - t], yt(r, { command: "addLayer", args: [a[u], p] }), o.splice(o.length - t, 0, u), l[u] = !0); for (let t = 0; t < i.length; t++)if (u = i[t], c = s[u], h = a[u], !l[u] && !dt(c, h)) if (dt(c.source, h.source) && dt(c["source-layer"], h["source-layer"]) && dt(c.type, h.type)) { for (f in bt(c.layout, h.layout, r, u, null, "setLayoutProperty"), bt(c.paint, h.paint, r, u, null, "setPaintProperty"), dt(c.filter, h.filter) || yt(r, { command: "setFilter", args: [u, h.filter] }), dt(c.minzoom, h.minzoom) && dt(c.maxzoom, h.maxzoom) || yt(r, { command: "setLayerZoomRange", args: [u, h.minzoom, h.maxzoom] }), c) Object.prototype.hasOwnProperty.call(c, f) && "layout" !== f && "paint" !== f && "filter" !== f && "metadata" !== f && "minzoom" !== f && "maxzoom" !== f && (0 === f.indexOf("paint.") ? bt(c[f], h[f], r, u, f.slice(6), "setPaintProperty") : dt(c[f], h[f]) || yt(r, { command: "setLayerProperty", args: [u, f, h[f]] })); for (f in h) Object.prototype.hasOwnProperty.call(h, f) && !Object.prototype.hasOwnProperty.call(c, f) && "layout" !== f && "paint" !== f && "filter" !== f && "metadata" !== f && "minzoom" !== f && "maxzoom" !== f && (0 === f.indexOf("paint.") ? bt(c[f], h[f], r, u, f.slice(6), "setPaintProperty") : dt(c[f], h[f]) || yt(r, { command: "setLayerProperty", args: [u, f, h[f]] })); } else yt(r, { command: "removeLayer", args: [u] }), p = o[o.lastIndexOf(u) + 1], yt(r, { command: "addLayer", args: [h, p] }); }(s, e.layers, r); } catch (t) { console.warn("Unable to compute style diff:", t), r = [{ command: "setStyle", args: [e] }]; } return r }, t.by = function (t) { const e = [], r = t.id; return void 0 === r && e.push({ message: `layers.${r}: missing required property "id"` }), void 0 === t.render && e.push({ message: `layers.${r}: missing required method "render"` }), t.renderingMode && "2d" !== t.renderingMode && "3d" !== t.renderingMode && e.push({ message: `layers.${r}: property "renderingMode" must be either "2d" or "3d"` }), e }, t.bz = function t(e, r) { if (Array.isArray(e)) { if (!Array.isArray(r) || e.length !== r.length) return !1; for (let n = 0; n < e.length; n++)if (!t(e[n], r[n])) return !1; return !0 } if ("object" == typeof e && null !== e && null !== r) { if ("object" != typeof r) return !1; if (Object.keys(e).length !== Object.keys(r).length) return !1; for (const n in e) if (!t(e[n], r[n])) return !1; return !0 } return e === r }, t.c = W, t.c0 = t => "fill" === t.type, t.c1 = t => "fill-extrusion" === t.type, t.c2 = t => "hillshade" === t.type, t.c3 = t => "raster" === t.type, t.c4 = t => "background" === t.type, t.c5 = t => "custom" === t.type, t.c6 = B, t.c7 = function (t, e, r) { const n = k(e.x - r.x, e.y - r.y), i = k(t.x - r.x, t.y - r.y); var s, a; return Y(Math.atan2(n[0] * i[1] - n[1] * i[0], (s = n)[0] * (a = i)[0] + s[1] * a[1])) }, t.c8 = V, t.c9 = function (t, e, r) { var n = e[0], i = e[1]; return t[0] = r[0] * n + r[4] * i + r[12], t[1] = r[1] * n + r[5] * i + r[13], t }, t.cA = Lu, t.cB = Nn, t.cC = us, t.ca = function (t, e) { const { x: r, y: n } = Qc.fromLngLat(e); return !(t < 0 || t > 25 || n < 0 || n >= 1 || r < 0 || r >= 1) }, t.cb = function (t, e) { return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = e[1], t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = e[2], t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t }, t.cc = class extends Es { }, t.cd = ep, t.cf = function (t) { return t.message === J }, t.cg = rt, t.ch = function (t, e) { Q.REGISTERED_PROTOCOLS[t] = e; }, t.ci = function (t) { delete Q.REGISTERED_PROTOCOLS[t]; }, t.cj = function (t, e) { const r = {}; for (let n = 0; n < t.length; n++) { const i = e && e[t[n].id] || si(t[n]); e && (e[t[n].id] = i); let s = r[i]; s || (s = r[i] = []), s.push(t[n]); } const n = []; for (const t in r) n.push(r[t]); return n }, t.ck = Ui, t.cl = ah, t.cm = lh, t.cn = Xu, t.co = function (e) { e.bucket.createArrays(), e.bucket.tilePixelRatio = M / (512 * e.bucket.overscaling), e.bucket.compareText = {}, e.bucket.iconsNeedLinear = !1; const r = e.bucket.layers[0], n = r.layout, i = r._unevaluatedLayout._values, s = { layoutIconSize: i["icon-size"].possiblyEvaluate(new cs(e.bucket.zoom + 1), e.canonical), layoutTextSize: i["text-size"].possiblyEvaluate(new cs(e.bucket.zoom + 1), e.canonical), textMaxSize: i["text-size"].possiblyEvaluate(new cs(18)) }; if ("composite" === e.bucket.textSizeData.kind) { const { minZoom: t, maxZoom: r } = e.bucket.textSizeData; s.compositeTextSizes = [i["text-size"].possiblyEvaluate(new cs(t), e.canonical), i["text-size"].possiblyEvaluate(new cs(r), e.canonical)]; } if ("composite" === e.bucket.iconSizeData.kind) { const { minZoom: t, maxZoom: r } = e.bucket.iconSizeData; s.compositeIconSizes = [i["icon-size"].possiblyEvaluate(new cs(t), e.canonical), i["icon-size"].possiblyEvaluate(new cs(r), e.canonical)]; } const a = n.get("text-line-height") * Tu, o = "viewport" !== n.get("text-rotation-alignment") && "point" !== n.get("symbol-placement"), l = n.get("text-keep-upright"), u = n.get("text-size"); for (const i of e.bucket.features) { const c = n.get("text-font").evaluate(i, {}, e.canonical).join(","), h = u.evaluate(i, {}, e.canonical), p = s.layoutTextSize.evaluate(i, {}, e.canonical), f = s.layoutIconSize.evaluate(i, {}, e.canonical), d = { horizontal: {}, vertical: void 0 }, y = i.text; let m, g = [0, 0]; if (y) { const s = y.toString(), u = n.get("text-letter-spacing").evaluate(i, {}, e.canonical) * Tu, f = Wi(s) ? u : 0, m = n.get("text-anchor").evaluate(i, {}, e.canonical), x = $h(r, i, e.canonical); if (!x) { const t = n.get("text-radial-offset").evaluate(i, {}, e.canonical); g = t ? Fh(m, [t * Tu, Th]) : n.get("text-offset").evaluate(i, {}, e.canonical).map((t => t * Tu)); } let v = o ? "center" : n.get("text-justify").evaluate(i, {}, e.canonical); const b = "point" === n.get("symbol-placement") ? n.get("text-max-width").evaluate(i, {}, e.canonical) * Tu : 1 / 0, w = () => { e.bucket.allowVerticalPlacement && Ji(s) && (d.vertical = Wu(y, e.glyphMap, e.glyphPositions, e.imagePositions, c, b, a, m, "left", f, g, t.ai.vertical, !0, p, h)); }; if (!o && x) { const r = new Set; if ("auto" === v) for (let t = 0; t < x.values.length; t += 2)r.add(Lh(x.values[t])); else r.add(v); let n = !1; for (const i of r) if (!d.horizontal[i]) if (n) d.horizontal[i] = d.horizontal[0]; else { const r = Wu(y, e.glyphMap, e.glyphPositions, e.imagePositions, c, b, a, "center", i, f, g, t.ai.horizontal, !1, p, h); r && (d.horizontal[i] = r, n = 1 === r.positionedLines.length); } w(); } else { "auto" === v && (v = Lh(m)); const r = Wu(y, e.glyphMap, e.glyphPositions, e.imagePositions, c, b, a, m, v, f, g, t.ai.horizontal, !1, p, h); r && (d.horizontal[v] = r), w(), Ji(s) && o && l && (d.vertical = Wu(y, e.glyphMap, e.glyphPositions, e.imagePositions, c, b, a, m, v, f, g, t.ai.vertical, !1, p, h)); } } let x = !1; if (i.icon && i.icon.name) { const t = e.imageMap[i.icon.name]; t && (m = yc(e.imagePositions[i.icon.name], n.get("icon-offset").evaluate(i, {}, e.canonical), n.get("icon-anchor").evaluate(i, {}, e.canonical)), x = !!t.sdf, void 0 === e.bucket.sdfIcons ? e.bucket.sdfIcons = x : e.bucket.sdfIcons !== x && j("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (t.pixelRatio !== e.bucket.pixelRatio || 0 !== n.get("icon-rotate").constantOr(1)) && (e.bucket.iconsNeedLinear = !0)); } const v = Rh(d.horizontal) || d.vertical; e.bucket.iconsInText = !!v && v.iconsInText, (v || m) && Oh(e.bucket, i, d, m, e.imageMap, s, p, f, g, x, e.canonical, e.subdivisionGranularity); } e.showCollisionBoxes && e.bucket.generateCollisionDebugBuffers(); }, t.cp = mu, t.cq = Bl, t.cr = tu, t.cs = Yl, t.ct = Ou, t.cu = class { constructor(t) { this._marks = { start: [t.url, "start"].join("#"), end: [t.url, "end"].join("#"), measure: t.url.toString() }, performance.mark(this._marks.start); } finish() { performance.mark(this._marks.end); let t = performance.getEntriesByName(this._marks.measure); return 0 === t.length && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), t = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), t } }, t.cv = function (t, r, n, i, s) { return e(this, void 0, void 0, (function* () { if (d()) try { return yield X(t, r, n, i, s) } catch (t) { } return function (t, e, r, n, i) { const s = t.width, a = t.height; K && H || (K = new OffscreenCanvas(s, a), H = K.getContext("2d", { willReadFrequently: !0 })), K.width = s, K.height = a, H.drawImage(t, 0, 0, s, a); const o = H.getImageData(e, r, n, i); return H.clearRect(0, 0, s, a), o.data }(t, r, n, i, s) })) }, t.cw = sh, t.cx = r, t.cy = s, t.cz = Hl, t.d = t => e(void 0, void 0, void 0, (function* () { if (0 === t.byteLength) return createImageBitmap(new ImageData(1, 1)); const e = new Blob([new Uint8Array(t)], { type: "image/png" }); try { return createImageBitmap(e) } catch (t) { throw new Error(`Could not load image because of ${t.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`) } })), t.e = F, t.f = t => new Promise(((e, r) => { const n = new Image; n.onload = () => { e(n), URL.revokeObjectURL(n.src), n.onload = null, window.requestAnimationFrame((() => { n.src = Z; })); }, n.onerror = () => r(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.")); const i = new Blob([new Uint8Array(t)], { type: "image/png" }); n.src = t.byteLength ? URL.createObjectURL(i) : Z; })), t.g = tt, t.h = (t, e) => it(F(t, { type: "json" }), e), t.i = U, t.j = ut, t.k = lt, t.l = (t, e) => it(F(t, { type: "arrayBuffer" }), e), t.m = it, t.n = function (t) { return new Ou(t).readFields(Ru, []) }, t.o = Oo, t.p = qu, t.q = As, t.r = $i, t.s = st, t.t = Ri, t.u = Fi, t.v = ht, t.w = j, t.x = function ([t, e, r]) { return e += 90, e *= Math.PI / 180, r *= Math.PI / 180, { x: t * Math.cos(e) * Math.sin(r), y: t * Math.sin(e) * Math.sin(r), z: t * Math.cos(r) } }, t.y = er, t.z = cs; }));

            define("worker", ["./shared"], (function (e) { "use strict"; class t { constructor(e) { this.keyCache = {}, e && this.replace(e); } replace(e) { this._layerConfigs = {}, this._layers = {}, this.update(e, []); } update(t, o) { for (const o of t) { this._layerConfigs[o.id] = o; const t = this._layers[o.id] = e.bv(o); t._featureFilter = e.a4(t.filter), this.keyCache[o.id] && delete this.keyCache[o.id]; } for (const e of o) delete this.keyCache[e], delete this._layerConfigs[e], delete this._layers[e]; this.familiesBySource = {}; const i = e.cj(Object.values(this._layerConfigs), this.keyCache); for (const e of i) { const t = e.map((e => this._layers[e.id])), o = t[0]; if ("none" === o.visibility) continue; const i = o.source || ""; let r = this.familiesBySource[i]; r || (r = this.familiesBySource[i] = {}); const s = o.sourceLayer || "_geojsonTileLayer"; let n = r[s]; n || (n = r[s] = []), n.push(t); } } } class o { constructor(t) { const o = {}, i = []; for (const e in t) { const r = t[e], s = o[e] = {}; for (const e in r) { const t = r[+e]; if (!t || 0 === t.bitmap.width || 0 === t.bitmap.height) continue; const o = { x: 0, y: 0, w: t.bitmap.width + 2, h: t.bitmap.height + 2 }; i.push(o), s[e] = { rect: o, metrics: t.metrics }; } } const { w: r, h: s } = e.p(i), n = new e.o({ width: r || 1, height: s || 1 }); for (const i in t) { const r = t[i]; for (const t in r) { const s = r[+t]; if (!s || 0 === s.bitmap.width || 0 === s.bitmap.height) continue; const a = o[i][t].rect; e.o.copy(s.bitmap, n, { x: 0, y: 0 }, { x: a.x + 1, y: a.y + 1 }, s.bitmap); } } this.image = n, this.positions = o; } } e.ck("GlyphAtlas", o); class i { constructor(t) { this.tileID = new e.S(t.tileID.overscaledZ, t.tileID.wrap, t.tileID.canonical.z, t.tileID.canonical.x, t.tileID.canonical.y), this.uid = t.uid, this.zoom = t.zoom, this.pixelRatio = t.pixelRatio, this.tileSize = t.tileSize, this.source = t.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t.showCollisionBoxes, this.collectResourceTiming = !!t.collectResourceTiming, this.returnDependencies = !!t.returnDependencies, this.promoteId = t.promoteId, this.inFlightDependencies = []; } parse(t, i, s, n, a) { return e._(this, void 0, void 0, (function* () { this.status = "parsing", this.data = t, this.collisionBoxArray = new e.a2; const l = new e.cl(Object.keys(t.layers).sort()), c = new e.cm(this.tileID, this.promoteId); c.bucketLayerIDs = []; const u = {}, h = { featureIndex: c, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: s, subdivisionGranularity: a }, d = i.familiesBySource[this.source]; for (const o in d) { const i = t.layers[o]; if (!i) continue; 1 === i.version && e.w(`Vector tile source "${this.source}" layer "${o}" does not use vector tile spec v2 and therefore may have some rendering errors.`); const n = l.encode(o), a = []; for (let e = 0; e < i.length; e++) { const t = i.feature(e), r = c.getId(t, o); a.push({ feature: t, id: r, index: e, sourceLayerIndex: n }); } for (const t of d[o]) { const o = t[0]; o.source !== this.source && e.w(`layer.source = ${o.source} does not equal this.source = ${this.source}`), o.minzoom && this.zoom < Math.floor(o.minzoom) || o.maxzoom && this.zoom >= o.maxzoom || "none" !== o.visibility && (r(t, this.zoom, s), (u[o.id] = o.createBucket({ index: c.bucketLayerIDs.length, layers: t, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: n, sourceID: this.source })).populate(a, h, this.tileID.canonical), c.bucketLayerIDs.push(t.map((e => e.id)))); } } const f = e.bA(h.glyphDependencies, (e => Object.keys(e).map(Number))); this.inFlightDependencies.forEach((e => null == e ? void 0 : e.abort())), this.inFlightDependencies = []; let g = Promise.resolve({}); if (Object.keys(f).length) { const e = new AbortController; this.inFlightDependencies.push(e), g = n.sendAsync({ type: "GG", data: { stacks: f, source: this.source, tileID: this.tileID, type: "glyphs" } }, e); } const p = Object.keys(h.iconDependencies); let m = Promise.resolve({}); if (p.length) { const e = new AbortController; this.inFlightDependencies.push(e), m = n.sendAsync({ type: "GI", data: { icons: p, source: this.source, tileID: this.tileID, type: "icons" } }, e); } const y = Object.keys(h.patternDependencies); let v = Promise.resolve({}); if (y.length) { const e = new AbortController; this.inFlightDependencies.push(e), v = n.sendAsync({ type: "GI", data: { icons: y, source: this.source, tileID: this.tileID, type: "patterns" } }, e); } const [w, x, _] = yield Promise.all([g, m, v]), b = new o(w), M = new e.cn(x, _); for (const t in u) { const o = u[t]; o instanceof e.a3 ? (r(o.layers, this.zoom, s), e.co({ bucket: o, glyphMap: w, glyphPositions: b.positions, imageMap: x, imagePositions: M.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical, subdivisionGranularity: h.subdivisionGranularity })) : o.hasPattern && (o instanceof e.cp || o instanceof e.cq || o instanceof e.cr) && (r(o.layers, this.zoom, s), o.addFeatures(h, this.tileID.canonical, M.patternPositions)); } return this.status = "done", { buckets: Object.values(u).filter((e => !e.isEmpty())), featureIndex: c, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: b.image, imageAtlas: M, glyphMap: this.returnDependencies ? w : null, iconMap: this.returnDependencies ? x : null, glyphPositions: this.returnDependencies ? b.positions : null } })) } } function r(t, o, i) { const r = new e.z(o); for (const e of t) e.recalculate(r, i); } class s { constructor(e, t, o) { this.actor = e, this.layerIndex = t, this.availableImages = o, this.fetching = {}, this.loading = {}, this.loaded = {}; } loadVectorTile(t, o) { return e._(this, void 0, void 0, (function* () { const i = yield e.l(t.request, o); try { return { vectorTile: new e.cs.VectorTile(new e.ct(i.data)), rawData: i.data, cacheControl: i.cacheControl, expires: i.expires } } catch (e) { const o = new Uint8Array(i.data); let r = `Unable to parse the tile at ${t.request.url}, `; throw r += 31 === o[0] && 139 === o[1] ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${e.message}`, new Error(r) } })) } loadTile(t) { return e._(this, void 0, void 0, (function* () { const o = t.uid, r = !!(t && t.request && t.request.collectResourceTiming) && new e.cu(t.request), s = new i(t); this.loading[o] = s; const n = new AbortController; s.abort = n; try { const i = yield this.loadVectorTile(t, n); if (delete this.loading[o], !i) return null; const a = i.rawData, l = {}; i.expires && (l.expires = i.expires), i.cacheControl && (l.cacheControl = i.cacheControl); const c = {}; if (r) { const e = r.finish(); e && (c.resourceTiming = JSON.parse(JSON.stringify(e))); } s.vectorTile = i.vectorTile; const u = s.parse(i.vectorTile, this.layerIndex, this.availableImages, this.actor, t.subdivisionGranularity); this.loaded[o] = s, this.fetching[o] = { rawTileData: a, cacheControl: l, resourceTiming: c }; try { const t = yield u; return e.e({ rawTileData: a.slice(0) }, t, l, c) } finally { delete this.fetching[o]; } } catch (e) { throw delete this.loading[o], s.status = "done", this.loaded[o] = s, e } })) } reloadTile(t) { return e._(this, void 0, void 0, (function* () { const o = t.uid; if (!this.loaded || !this.loaded[o]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed"); const i = this.loaded[o]; if (i.showCollisionBoxes = t.showCollisionBoxes, "parsing" === i.status) { const r = yield i.parse(i.vectorTile, this.layerIndex, this.availableImages, this.actor, t.subdivisionGranularity); let s; if (this.fetching[o]) { const { rawTileData: t, cacheControl: i, resourceTiming: n } = this.fetching[o]; delete this.fetching[o], s = e.e({ rawTileData: t.slice(0) }, r, i, n); } else s = r; return s } if ("done" === i.status && i.vectorTile) return i.parse(i.vectorTile, this.layerIndex, this.availableImages, this.actor, t.subdivisionGranularity) })) } abortTile(t) { return e._(this, void 0, void 0, (function* () { const e = this.loading, o = t.uid; e && e[o] && e[o].abort && (e[o].abort.abort(), delete e[o]); })) } removeTile(t) { return e._(this, void 0, void 0, (function* () { this.loaded && this.loaded[t.uid] && delete this.loaded[t.uid]; })) } } class n { constructor() { this.loaded = {}; } loadTile(t) { return e._(this, void 0, void 0, (function* () { const { uid: o, encoding: i, rawImageData: r, redFactor: s, greenFactor: n, blueFactor: a, baseShift: l } = t, c = r.width + 2, u = r.height + 2, h = e.b(r) ? new e.R({ width: c, height: u }, yield e.cv(r, -1, -1, c, u)) : r, d = new e.cw(o, h, i, s, n, a, l); return this.loaded = this.loaded || {}, this.loaded[o] = d, d })) } removeTile(e) { const t = this.loaded, o = e.uid; t && t[o] && delete t[o]; } } var a, l, c = function () { if (l) return a; function e(e, o) { if (0 !== e.length) { t(e[0], o); for (var i = 1; i < e.length; i++)t(e[i], !o); } } function t(e, t) { for (var o = 0, i = 0, r = 0, s = e.length, n = s - 1; r < s; n = r++) { var a = (e[r][0] - e[n][0]) * (e[n][1] + e[r][1]), l = o + a; i += Math.abs(o) >= Math.abs(a) ? o - l + a : a - l + o, o = l; } o + i >= 0 != !!t && e.reverse(); } return l = 1, a = function t(o, i) { var r, s = o && o.type; if ("FeatureCollection" === s) for (r = 0; r < o.features.length; r++)t(o.features[r], i); else if ("GeometryCollection" === s) for (r = 0; r < o.geometries.length; r++)t(o.geometries[r], i); else if ("Feature" === s) t(o.geometry, i); else if ("Polygon" === s) e(o.coordinates, i); else if ("MultiPolygon" === s) for (r = 0; r < o.coordinates.length; r++)e(o.coordinates[r], i); return o } }(), u = e.cx(c); const h = e.cs.VectorTileFeature.prototype.toGeoJSON; class d { constructor(t) { this._feature = t, this.extent = e.X, this.type = t.type, this.properties = t.tags, "id" in t && !isNaN(t.id) && (this.id = parseInt(t.id, 10)); } loadGeometry() { if (1 === this._feature.type) { const t = []; for (const o of this._feature.geometry) t.push([new e.P(o[0], o[1])]); return t } { const t = []; for (const o of this._feature.geometry) { const i = []; for (const t of o) i.push(new e.P(t[0], t[1])); t.push(i); } return t } } toGeoJSON(e, t, o) { return h.call(this, e, t, o) } } class f { constructor(t) { this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e.X, this.length = t.length, this._features = t; } feature(e) { return new d(this._features[e]) } } var g, p, m, y = { exports: {} }, v = function () { if (m) return y.exports; m = 1; var t = e.cA(), o = function () { if (p) return g; p = 1; var t = e.cy(), o = e.cz().VectorTileFeature; function i(e, t) { this.options = t || {}, this.features = e, this.length = e.length; } function r(e, t) { this.id = "number" == typeof e.id ? e.id : void 0, this.type = e.type, this.rawGeometry = 1 === e.type ? [e.geometry] : e.geometry, this.properties = e.tags, this.extent = t || 4096; } return g = i, i.prototype.feature = function (e) { return new r(this.features[e], this.options.extent) }, r.prototype.loadGeometry = function () { var e = this.rawGeometry; this.geometry = []; for (var o = 0; o < e.length; o++) { for (var i = e[o], r = [], s = 0; s < i.length; s++)r.push(new t(i[s][0], i[s][1])); this.geometry.push(r); } return this.geometry }, r.prototype.bbox = function () { this.geometry || this.loadGeometry(); for (var e = this.geometry, t = 1 / 0, o = -1 / 0, i = 1 / 0, r = -1 / 0, s = 0; s < e.length; s++)for (var n = e[s], a = 0; a < n.length; a++) { var l = n[a]; t = Math.min(t, l.x), o = Math.max(o, l.x), i = Math.min(i, l.y), r = Math.max(r, l.y); } return [t, i, o, r] }, r.prototype.toGeoJSON = o.prototype.toGeoJSON, g }(); function i(e) { var o = new t; return function (e, t) { for (var o in e.layers) t.writeMessage(3, r, e.layers[o]); }(e, o), o.finish() } function r(e, t) { var o; t.writeVarintField(15, e.version || 1), t.writeStringField(1, e.name || ""), t.writeVarintField(5, e.extent || 4096); var i = { keys: [], values: [], keycache: {}, valuecache: {} }; for (o = 0; o < e.length; o++)i.feature = e.feature(o), t.writeMessage(2, s, i); var r = i.keys; for (o = 0; o < r.length; o++)t.writeStringField(3, r[o]); var n = i.values; for (o = 0; o < n.length; o++)t.writeMessage(4, u, n[o]); } function s(e, t) { var o = e.feature; void 0 !== o.id && t.writeVarintField(1, o.id), t.writeMessage(2, n, e), t.writeVarintField(3, o.type), t.writeMessage(4, c, o); } function n(e, t) { var o = e.feature, i = e.keys, r = e.values, s = e.keycache, n = e.valuecache; for (var a in o.properties) { var l = o.properties[a], c = s[a]; if (null !== l) { void 0 === c && (i.push(a), s[a] = c = i.length - 1), t.writeVarint(c); var u = typeof l; "string" !== u && "boolean" !== u && "number" !== u && (l = JSON.stringify(l)); var h = u + ":" + l, d = n[h]; void 0 === d && (r.push(l), n[h] = d = r.length - 1), t.writeVarint(d); } } } function a(e, t) { return (t << 3) + (7 & e) } function l(e) { return e << 1 ^ e >> 31 } function c(e, t) { for (var o = e.loadGeometry(), i = e.type, r = 0, s = 0, n = o.length, c = 0; c < n; c++) { var u = o[c], h = 1; 1 === i && (h = u.length), t.writeVarint(a(1, h)); for (var d = 3 === i ? u.length - 1 : u.length, f = 0; f < d; f++) { 1 === f && 1 !== i && t.writeVarint(a(2, d - 1)); var g = u[f].x - r, p = u[f].y - s; t.writeVarint(l(g)), t.writeVarint(l(p)), r += g, s += p; } 3 === i && t.writeVarint(a(7, 1)); } } function u(e, t) { var o = typeof e; "string" === o ? t.writeStringField(1, e) : "boolean" === o ? t.writeBooleanField(7, e) : "number" === o && (e % 1 != 0 ? t.writeDoubleField(3, e) : e < 0 ? t.writeSVarintField(6, e) : t.writeVarintField(5, e)); } return y.exports = i, y.exports.fromVectorTileJs = i, y.exports.fromGeojsonVt = function (e, t) { t = t || {}; var r = {}; for (var s in e) r[s] = new o(e[s].features, t), r[s].name = s, r[s].version = t.version, r[s].extent = t.extent; return i({ layers: r }) }, y.exports.GeoJSONWrapper = o, y.exports }(), w = e.cx(v); const x = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: e => e }, _ = Math.fround || (b = new Float32Array(1), e => (b[0] = +e, b[0])); var b; const M = 3, S = 5, I = 6; class P { constructor(e) { this.options = Object.assign(Object.create(x), e), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = []; } load(e) { const { log: t, minZoom: o, maxZoom: i } = this.options; t && console.time("total time"); const r = `prepare ${e.length} points`; t && console.time(r), this.points = e; const s = []; for (let t = 0; t < e.length; t++) { const o = e[t]; if (!o.geometry) continue; const [i, r] = o.geometry.coordinates, n = _(D(i)), a = _(C(r)); s.push(n, a, 1 / 0, t, -1, 1), this.options.reduce && s.push(0); } let n = this.trees[i + 1] = this._createTree(s); t && console.timeEnd(r); for (let e = i; e >= o; e--) { const o = +Date.now(); n = this.trees[e] = this._createTree(this._cluster(n, e)), t && console.log("z%d: %d clusters in %dms", e, n.numItems, +Date.now() - o); } return t && console.timeEnd("total time"), this } getClusters(e, t) { let o = ((e[0] + 180) % 360 + 360) % 360 - 180; const i = Math.max(-90, Math.min(90, e[1])); let r = 180 === e[2] ? 180 : ((e[2] + 180) % 360 + 360) % 360 - 180; const s = Math.max(-90, Math.min(90, e[3])); if (e[2] - e[0] >= 360) o = -180, r = 180; else if (o > r) { const e = this.getClusters([o, i, 180, s], t), n = this.getClusters([-180, i, r, s], t); return e.concat(n) } const n = this.trees[this._limitZoom(t)], a = n.range(D(o), C(s), D(r), C(i)), l = n.data, c = []; for (const e of a) { const t = this.stride * e; c.push(l[t + S] > 1 ? k(l, t, this.clusterProps) : this.points[l[t + M]]); } return c } getChildren(e) { const t = this._getOriginId(e), o = this._getOriginZoom(e), i = "No cluster with the specified id.", r = this.trees[o]; if (!r) throw new Error(i); const s = r.data; if (t * this.stride >= s.length) throw new Error(i); const n = this.options.radius / (this.options.extent * Math.pow(2, o - 1)), a = r.within(s[t * this.stride], s[t * this.stride + 1], n), l = []; for (const t of a) { const o = t * this.stride; s[o + 4] === e && l.push(s[o + S] > 1 ? k(s, o, this.clusterProps) : this.points[s[o + M]]); } if (0 === l.length) throw new Error(i); return l } getLeaves(e, t, o) { const i = []; return this._appendLeaves(i, e, t = t || 10, o = o || 0, 0), i } getTile(e, t, o) { const i = this.trees[this._limitZoom(e)], r = Math.pow(2, e), { extent: s, radius: n } = this.options, a = n / s, l = (o - a) / r, c = (o + 1 + a) / r, u = { features: [] }; return this._addTileFeatures(i.range((t - a) / r, l, (t + 1 + a) / r, c), i.data, t, o, r, u), 0 === t && this._addTileFeatures(i.range(1 - a / r, l, 1, c), i.data, r, o, r, u), t === r - 1 && this._addTileFeatures(i.range(0, l, a / r, c), i.data, -1, o, r, u), u.features.length ? u : null } getClusterExpansionZoom(e) { let t = this._getOriginZoom(e) - 1; for (; t <= this.options.maxZoom;) { const o = this.getChildren(e); if (t++, 1 !== o.length) break; e = o[0].properties.cluster_id; } return t } _appendLeaves(e, t, o, i, r) { const s = this.getChildren(t); for (const t of s) { const s = t.properties; if (s && s.cluster ? r + s.point_count <= i ? r += s.point_count : r = this._appendLeaves(e, s.cluster_id, o, i, r) : r < i ? r++ : e.push(t), e.length === o) break } return r } _createTree(t) { const o = new e.az(t.length / this.stride | 0, this.options.nodeSize, Float32Array); for (let e = 0; e < t.length; e += this.stride)o.add(t[e], t[e + 1]); return o.finish(), o.data = t, o } _addTileFeatures(e, t, o, i, r, s) { for (const n of e) { const e = n * this.stride, a = t[e + S] > 1; let l, c, u; if (a) l = T(t, e, this.clusterProps), c = t[e], u = t[e + 1]; else { const o = this.points[t[e + M]]; l = o.properties; const [i, r] = o.geometry.coordinates; c = D(i), u = C(r); } const h = { type: 1, geometry: [[Math.round(this.options.extent * (c * r - o)), Math.round(this.options.extent * (u * r - i))]], tags: l }; let d; d = a || this.options.generateId ? t[e + M] : this.points[t[e + M]].id, void 0 !== d && (h.id = d), s.features.push(h); } } _limitZoom(e) { return Math.max(this.options.minZoom, Math.min(Math.floor(+e), this.options.maxZoom + 1)) } _cluster(e, t) { const { radius: o, extent: i, reduce: r, minPoints: s } = this.options, n = o / (i * Math.pow(2, t)), a = e.data, l = [], c = this.stride; for (let o = 0; o < a.length; o += c) { if (a[o + 2] <= t) continue; a[o + 2] = t; const i = a[o], u = a[o + 1], h = e.within(a[o], a[o + 1], n), d = a[o + S]; let f = d; for (const e of h) { const o = e * c; a[o + 2] > t && (f += a[o + S]); } if (f > d && f >= s) { let e, s = i * d, n = u * d, g = -1; const p = ((o / c | 0) << 5) + (t + 1) + this.points.length; for (const i of h) { const l = i * c; if (a[l + 2] <= t) continue; a[l + 2] = t; const u = a[l + S]; s += a[l] * u, n += a[l + 1] * u, a[l + 4] = p, r && (e || (e = this._map(a, o, !0), g = this.clusterProps.length, this.clusterProps.push(e)), r(e, this._map(a, l))); } a[o + 4] = p, l.push(s / f, n / f, 1 / 0, p, -1, f), r && l.push(g); } else { for (let e = 0; e < c; e++)l.push(a[o + e]); if (f > 1) for (const e of h) { const o = e * c; if (!(a[o + 2] <= t)) { a[o + 2] = t; for (let e = 0; e < c; e++)l.push(a[o + e]); } } } } return l } _getOriginId(e) { return e - this.points.length >> 5 } _getOriginZoom(e) { return (e - this.points.length) % 32 } _map(e, t, o) { if (e[t + S] > 1) { const i = this.clusterProps[e[t + I]]; return o ? Object.assign({}, i) : i } const i = this.points[e[t + M]].properties, r = this.options.map(i); return o && r === i ? Object.assign({}, r) : r } } function k(e, t, o) { return { type: "Feature", id: e[t + M], properties: T(e, t, o), geometry: { type: "Point", coordinates: [(i = e[t], 360 * (i - .5)), O(e[t + 1])] } }; var i; } function T(e, t, o) { const i = e[t + S], r = i >= 1e4 ? `${Math.round(i / 1e3)}k` : i >= 1e3 ? Math.round(i / 100) / 10 + "k" : i, s = e[t + I], n = -1 === s ? {} : Object.assign({}, o[s]); return Object.assign(n, { cluster: !0, cluster_id: e[t + M], point_count: i, point_count_abbreviated: r }) } function D(e) { return e / 360 + .5 } function C(e) { const t = Math.sin(e * Math.PI / 180), o = .5 - .25 * Math.log((1 + t) / (1 - t)) / Math.PI; return o < 0 ? 0 : o > 1 ? 1 : o } function O(e) { const t = (180 - 360 * e) * Math.PI / 180; return 360 * Math.atan(Math.exp(t)) / Math.PI - 90 } function L(e, t, o, i) { let r = i; const s = t + (o - t >> 1); let n, a = o - t; const l = e[t], c = e[t + 1], u = e[o], h = e[o + 1]; for (let i = t + 3; i < o; i += 3) { const t = F(e[i], e[i + 1], l, c, u, h); if (t > r) n = i, r = t; else if (t === r) { const e = Math.abs(i - s); e < a && (n = i, a = e); } } r > i && (n - t > 3 && L(e, t, n, i), e[n + 2] = r, o - n > 3 && L(e, n, o, i)); } function F(e, t, o, i, r, s) { let n = r - o, a = s - i; if (0 !== n || 0 !== a) { const l = ((e - o) * n + (t - i) * a) / (n * n + a * a); l > 1 ? (o = r, i = s) : l > 0 && (o += n * l, i += a * l); } return n = e - o, a = t - i, n * n + a * a } function z(e, t, o, i) { const r = { id: null == e ? null : e, type: t, geometry: o, tags: i, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 }; if ("Point" === t || "MultiPoint" === t || "LineString" === t) G(r, o); else if ("Polygon" === t) G(r, o[0]); else if ("MultiLineString" === t) for (const e of o) G(r, e); else if ("MultiPolygon" === t) for (const e of o) G(r, e[0]); return r } function G(e, t) { for (let o = 0; o < t.length; o += 3)e.minX = Math.min(e.minX, t[o]), e.minY = Math.min(e.minY, t[o + 1]), e.maxX = Math.max(e.maxX, t[o]), e.maxY = Math.max(e.maxY, t[o + 1]); } function A(e, t, o, i) { if (!t.geometry) return; const r = t.geometry.coordinates; if (r && 0 === r.length) return; const s = t.geometry.type, n = Math.pow(o.tolerance / ((1 << o.maxZoom) * o.extent), 2); let a = [], l = t.id; if (o.promoteId ? l = t.properties[o.promoteId] : o.generateId && (l = i || 0), "Point" === s) j(r, a); else if ("MultiPoint" === s) for (const e of r) j(e, a); else if ("LineString" === s) E(r, a, n, !1); else if ("MultiLineString" === s) { if (o.lineMetrics) { for (const o of r) a = [], E(o, a, n, !1), e.push(z(l, "LineString", a, t.properties)); return } Z(r, a, n, !1); } else if ("Polygon" === s) Z(r, a, n, !0); else { if ("MultiPolygon" !== s) { if ("GeometryCollection" === s) { for (const r of t.geometry.geometries) A(e, { id: l, geometry: r, properties: t.properties }, o, i); return } throw new Error("Input data is not a valid GeoJSON object.") } for (const e of r) { const t = []; Z(e, t, n, !0), a.push(t); } } e.push(z(l, s, a, t.properties)); } function j(e, t) { t.push(N(e[0]), J(e[1]), 0); } function E(e, t, o, i) { let r, s, n = 0; for (let o = 0; o < e.length; o++) { const a = N(e[o][0]), l = J(e[o][1]); t.push(a, l, 0), o > 0 && (n += i ? (r * l - a * s) / 2 : Math.sqrt(Math.pow(a - r, 2) + Math.pow(l - s, 2))), r = a, s = l; } const a = t.length - 3; t[2] = 1, L(t, 0, a, o), t[a + 2] = 1, t.size = Math.abs(n), t.start = 0, t.end = t.size; } function Z(e, t, o, i) { for (let r = 0; r < e.length; r++) { const s = []; E(e[r], s, o, i), t.push(s); } } function N(e) { return e / 360 + .5 } function J(e) { const t = Math.sin(e * Math.PI / 180), o = .5 - .25 * Math.log((1 + t) / (1 - t)) / Math.PI; return o < 0 ? 0 : o > 1 ? 1 : o } function W(e, t, o, i, r, s, n, a) { if (i /= t, s >= (o /= t) && n < i) return e; if (n < o || s >= i) return null; const l = []; for (const t of e) { const e = t.geometry; let s = t.type; const n = 0 === r ? t.minX : t.minY, c = 0 === r ? t.maxX : t.maxY; if (n >= o && c < i) { l.push(t); continue } if (c < o || n >= i) continue; let u = []; if ("Point" === s || "MultiPoint" === s) R(e, u, o, i, r); else if ("LineString" === s) Y(e, u, o, i, r, !1, a.lineMetrics); else if ("MultiLineString" === s) X(e, u, o, i, r, !1); else if ("Polygon" === s) X(e, u, o, i, r, !0); else if ("MultiPolygon" === s) for (const t of e) { const e = []; X(t, e, o, i, r, !0), e.length && u.push(e); } if (u.length) { if (a.lineMetrics && "LineString" === s) { for (const e of u) l.push(z(t.id, s, e, t.tags)); continue } "LineString" !== s && "MultiLineString" !== s || (1 === u.length ? (s = "LineString", u = u[0]) : s = "MultiLineString"), "Point" !== s && "MultiPoint" !== s || (s = 3 === u.length ? "Point" : "MultiPoint"), l.push(z(t.id, s, u, t.tags)); } } return l.length ? l : null } function R(e, t, o, i, r) { for (let s = 0; s < e.length; s += 3) { const n = e[s + r]; n >= o && n <= i && q(t, e[s], e[s + 1], e[s + 2]); } } function Y(e, t, o, i, r, s, n) { let a = V(e); const l = 0 === r ? B : H; let c, u, h = e.start; for (let d = 0; d < e.length - 3; d += 3) { const f = e[d], g = e[d + 1], p = e[d + 2], m = e[d + 3], y = e[d + 4], v = 0 === r ? f : g, w = 0 === r ? m : y; let x = !1; n && (c = Math.sqrt(Math.pow(f - m, 2) + Math.pow(g - y, 2))), v < o ? w > o && (u = l(a, f, g, m, y, o), n && (a.start = h + c * u)) : v > i ? w < i && (u = l(a, f, g, m, y, i), n && (a.start = h + c * u)) : q(a, f, g, p), w < o && v >= o && (u = l(a, f, g, m, y, o), x = !0), w > i && v <= i && (u = l(a, f, g, m, y, i), x = !0), !s && x && (n && (a.end = h + c * u), t.push(a), a = V(e)), n && (h += c); } let d = e.length - 3; const f = e[d], g = e[d + 1], p = 0 === r ? f : g; p >= o && p <= i && q(a, f, g, e[d + 2]), d = a.length - 3, s && d >= 3 && (a[d] !== a[0] || a[d + 1] !== a[1]) && q(a, a[0], a[1], a[2]), a.length && t.push(a); } function V(e) { const t = []; return t.size = e.size, t.start = e.start, t.end = e.end, t } function X(e, t, o, i, r, s) { for (const n of e) Y(n, t, o, i, r, s, !1); } function q(e, t, o, i) { e.push(t, o, i); } function B(e, t, o, i, r, s) { const n = (s - t) / (i - t); return q(e, s, o + (r - o) * n, 1), n } function H(e, t, o, i, r, s) { const n = (s - o) / (r - o); return q(e, t + (i - t) * n, s, 1), n } function $(e, t) { const o = []; for (let i = 0; i < e.length; i++) { const r = e[i], s = r.type; let n; if ("Point" === s || "MultiPoint" === s || "LineString" === s) n = U(r.geometry, t); else if ("MultiLineString" === s || "Polygon" === s) { n = []; for (const e of r.geometry) n.push(U(e, t)); } else if ("MultiPolygon" === s) { n = []; for (const e of r.geometry) { const o = []; for (const i of e) o.push(U(i, t)); n.push(o); } } o.push(z(r.id, s, n, r.tags)); } return o } function U(e, t) { const o = []; o.size = e.size, void 0 !== e.start && (o.start = e.start, o.end = e.end); for (let i = 0; i < e.length; i += 3)o.push(e[i] + t, e[i + 1], e[i + 2]); return o } function K(e, t) { if (e.transformed) return e; const o = 1 << e.z, i = e.x, r = e.y; for (const s of e.features) { const e = s.geometry, n = s.type; if (s.geometry = [], 1 === n) for (let n = 0; n < e.length; n += 2)s.geometry.push(Q(e[n], e[n + 1], t, o, i, r)); else for (let n = 0; n < e.length; n++) { const a = []; for (let s = 0; s < e[n].length; s += 2)a.push(Q(e[n][s], e[n][s + 1], t, o, i, r)); s.geometry.push(a); } } return e.transformed = !0, e } function Q(e, t, o, i, r, s) { return [Math.round(o * (e * i - r)), Math.round(o * (t * i - s))] } function ee(e, t, o, i, r) { const s = t === r.maxZoom ? 0 : r.tolerance / ((1 << t) * r.extent), n = { features: [], numPoints: 0, numSimplified: 0, numFeatures: e.length, source: null, x: o, y: i, z: t, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 }; for (const t of e) te(n, t, s, r); return n } function te(e, t, o, i) { const r = t.geometry, s = t.type, n = []; if (e.minX = Math.min(e.minX, t.minX), e.minY = Math.min(e.minY, t.minY), e.maxX = Math.max(e.maxX, t.maxX), e.maxY = Math.max(e.maxY, t.maxY), "Point" === s || "MultiPoint" === s) for (let t = 0; t < r.length; t += 3)n.push(r[t], r[t + 1]), e.numPoints++, e.numSimplified++; else if ("LineString" === s) oe(n, r, e, o, !1, !1); else if ("MultiLineString" === s || "Polygon" === s) for (let t = 0; t < r.length; t++)oe(n, r[t], e, o, "Polygon" === s, 0 === t); else if ("MultiPolygon" === s) for (let t = 0; t < r.length; t++) { const i = r[t]; for (let t = 0; t < i.length; t++)oe(n, i[t], e, o, !0, 0 === t); } if (n.length) { let o = t.tags || null; if ("LineString" === s && i.lineMetrics) { o = {}; for (const e in t.tags) o[e] = t.tags[e]; o.mapbox_clip_start = r.start / r.size, o.mapbox_clip_end = r.end / r.size; } const a = { geometry: n, type: "Polygon" === s || "MultiPolygon" === s ? 3 : "LineString" === s || "MultiLineString" === s ? 2 : 1, tags: o }; null !== t.id && (a.id = t.id), e.features.push(a); } } function oe(e, t, o, i, r, s) { const n = i * i; if (i > 0 && t.size < (r ? n : i)) return void (o.numPoints += t.length / 3); const a = []; for (let e = 0; e < t.length; e += 3)(0 === i || t[e + 2] > n) && (o.numSimplified++, a.push(t[e], t[e + 1])), o.numPoints++; r && function (e, t) { let o = 0; for (let t = 0, i = e.length, r = i - 2; t < i; r = t, t += 2)o += (e[t] - e[r]) * (e[t + 1] + e[r + 1]); if (o > 0 === t) for (let t = 0, o = e.length; t < o / 2; t += 2) { const i = e[t], r = e[t + 1]; e[t] = e[o - 2 - t], e[t + 1] = e[o - 1 - t], e[o - 2 - t] = i, e[o - 1 - t] = r; } }(a, s), e.push(a); } const ie = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 }; class re { constructor(e, t) { const o = (t = this.options = function (e, t) { for (const o in t) e[o] = t[o]; return e }(Object.create(ie), t)).debug; if (o && console.time("preprocess data"), t.maxZoom < 0 || t.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range"); if (t.promoteId && t.generateId) throw new Error("promoteId and generateId cannot be used together."); let i = function (e, t) { const o = []; if ("FeatureCollection" === e.type) for (let i = 0; i < e.features.length; i++)A(o, e.features[i], t, i); else A(o, "Feature" === e.type ? e : { geometry: e }, t); return o }(e, t); this.tiles = {}, this.tileCoords = [], o && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t.indexMaxZoom, t.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), i = function (e, t) { const o = t.buffer / t.extent; let i = e; const r = W(e, 1, -1 - o, o, 0, -1, 2, t), s = W(e, 1, 1 - o, 2 + o, 0, -1, 2, t); return (r || s) && (i = W(e, 1, -o, 1 + o, 0, -1, 2, t) || [], r && (i = $(r, 1).concat(i)), s && (i = i.concat($(s, -1)))), i }(i, t), i.length && this.splitTile(i, 0, 0, 0), o && (i.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats))); } splitTile(e, t, o, i, r, s, n) { const a = [e, t, o, i], l = this.options, c = l.debug; for (; a.length;) { i = a.pop(), o = a.pop(), t = a.pop(), e = a.pop(); const u = 1 << t, h = se(t, o, i); let d = this.tiles[h]; if (!d && (c > 1 && console.time("creation"), d = this.tiles[h] = ee(e, t, o, i, l), this.tileCoords.push({ z: t, x: o, y: i }), c)) { c > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t, o, i, d.numFeatures, d.numPoints, d.numSimplified), console.timeEnd("creation")); const e = `z${t}`; this.stats[e] = (this.stats[e] || 0) + 1, this.total++; } if (d.source = e, null == r) { if (t === l.indexMaxZoom || d.numPoints <= l.indexMaxPoints) continue } else { if (t === l.maxZoom || t === r) continue; if (null != r) { const e = r - t; if (o !== s >> e || i !== n >> e) continue } } if (d.source = null, 0 === e.length) continue; c > 1 && console.time("clipping"); const f = .5 * l.buffer / l.extent, g = .5 - f, p = .5 + f, m = 1 + f; let y = null, v = null, w = null, x = null, _ = W(e, u, o - f, o + p, 0, d.minX, d.maxX, l), b = W(e, u, o + g, o + m, 0, d.minX, d.maxX, l); e = null, _ && (y = W(_, u, i - f, i + p, 1, d.minY, d.maxY, l), v = W(_, u, i + g, i + m, 1, d.minY, d.maxY, l), _ = null), b && (w = W(b, u, i - f, i + p, 1, d.minY, d.maxY, l), x = W(b, u, i + g, i + m, 1, d.minY, d.maxY, l), b = null), c > 1 && console.timeEnd("clipping"), a.push(y || [], t + 1, 2 * o, 2 * i), a.push(v || [], t + 1, 2 * o, 2 * i + 1), a.push(w || [], t + 1, 2 * o + 1, 2 * i), a.push(x || [], t + 1, 2 * o + 1, 2 * i + 1); } } getTile(e, t, o) { e = +e, t = +t, o = +o; const i = this.options, { extent: r, debug: s } = i; if (e < 0 || e > 24) return null; const n = 1 << e, a = se(e, t = t + n & n - 1, o); if (this.tiles[a]) return K(this.tiles[a], r); s > 1 && console.log("drilling down to z%d-%d-%d", e, t, o); let l, c = e, u = t, h = o; for (; !l && c > 0;)c--, u >>= 1, h >>= 1, l = this.tiles[se(c, u, h)]; return l && l.source ? (s > 1 && (console.log("found parent tile z%d-%d-%d", c, u, h), console.time("drilling down")), this.splitTile(l.source, c, u, h, e, t, o), s > 1 && console.timeEnd("drilling down"), this.tiles[a] ? K(this.tiles[a], r) : null) : null } } function se(e, t, o) { return 32 * ((1 << e) * o + t) + e } function ne(e, t) { return t ? e.properties[t] : e.id } function ae(e, t) { if (null == e) return !0; if ("Feature" === e.type) return null != ne(e, t); if ("FeatureCollection" === e.type) { const o = new Set; for (const i of e.features) { const e = ne(i, t); if (null == e) return !1; if (o.has(e)) return !1; o.add(e); } return !0 } return !1 } function le(e, t) { const o = new Map; if (null == e); else if ("Feature" === e.type) o.set(ne(e, t), e); else for (const i of e.features) o.set(ne(i, t), i); return o } class ce extends s { constructor() { super(...arguments), this._dataUpdateable = new Map; } loadVectorTile(t, o) { return e._(this, void 0, void 0, (function* () { const e = t.tileID.canonical; if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson"); const o = this._geoJSONIndex.getTile(e.z, e.x, e.y); if (!o) return null; const i = new f(o.features); let r = w(i); return 0 === r.byteOffset && r.byteLength === r.buffer.byteLength || (r = new Uint8Array(r)), { vectorTile: i, rawData: r.buffer } })) } loadData(t) { return e._(this, void 0, void 0, (function* () { var o; null === (o = this._pendingRequest) || void 0 === o || o.abort(); const i = !!(t && t.request && t.request.collectResourceTiming) && new e.cu(t.request); this._pendingRequest = new AbortController; try { this._pendingData = this.loadAndProcessGeoJSON(t, this._pendingRequest), this._geoJSONIndex = t.cluster ? new P(function ({ superclusterOptions: t, clusterProperties: o }) { if (!o || !t) return t; const i = {}, r = {}, s = { accumulated: null, zoom: 0 }, n = { properties: null }, a = Object.keys(o); for (const t of a) { const [s, n] = o[t], a = e.cB(n), l = e.cB("string" == typeof s ? [s, ["accumulated"], ["get", t]] : s); i[t] = a.value, r[t] = l.value; } return t.map = e => { n.properties = e; const t = {}; for (const e of a) t[e] = i[e].evaluate(s, n); return t }, t.reduce = (e, t) => { n.properties = t; for (const t of a) s.accumulated = e[t], e[t] = r[t].evaluate(s, n); }, t }(t)).load((yield this._pendingData).features) : (r = yield this._pendingData, new re(r, t.geojsonVtOptions)), this.loaded = {}; const o = {}; if (i) { const e = i.finish(); e && (o.resourceTiming = {}, o.resourceTiming[t.source] = JSON.parse(JSON.stringify(e))); } return o } catch (t) { if (delete this._pendingRequest, e.cf(t)) return { abandoned: !0 }; throw t } var r; })) } getData() { return e._(this, void 0, void 0, (function* () { return this._pendingData })) } reloadTile(e) { const t = this.loaded; return t && t[e.uid] ? super.reloadTile(e) : this.loadTile(e) } loadAndProcessGeoJSON(t, o) { return e._(this, void 0, void 0, (function* () { let i = yield this.loadGeoJSON(t, o); if (delete this._pendingRequest, "object" != typeof i) throw new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`); if (u(i, !0), t.filter) { const o = e.cB(t.filter, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 }); if ("error" === o.result) throw new Error(o.value.map((e => `${e.key}: ${e.message}`)).join(", ")); const r = i.features.filter((e => o.value.evaluate({ zoom: 0 }, e))); i = { type: "FeatureCollection", features: r }; } return i })) } loadGeoJSON(t, o) { return e._(this, void 0, void 0, (function* () { const { promoteId: i } = t; if (t.request) { const r = yield e.h(t.request, o); return this._dataUpdateable = ae(r.data, i) ? le(r.data, i) : void 0, r.data } if ("string" == typeof t.data) try { const e = JSON.parse(t.data); return this._dataUpdateable = ae(e, i) ? le(e, i) : void 0, e } catch (e) { throw new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`) } if (!t.dataDiff) throw new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`); if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${t.source}`); return function (e, t, o) { var i, r, s, n; if (t.removeAll && e.clear(), t.remove) for (const o of t.remove) e.delete(o); if (t.add) for (const i of t.add) { const t = ne(i, o); null != t && e.set(t, i); } if (t.update) for (const o of t.update) { let t = e.get(o.id); if (null == t) continue; const a = !o.removeAllProperties && ((null === (i = o.removeProperties) || void 0 === i ? void 0 : i.length) > 0 || (null === (r = o.addOrUpdateProperties) || void 0 === r ? void 0 : r.length) > 0); if ((o.newGeometry || o.removeAllProperties || a) && (t = Object.assign({}, t), e.set(o.id, t), a && (t.properties = Object.assign({}, t.properties))), o.newGeometry && (t.geometry = o.newGeometry), o.removeAllProperties) t.properties = {}; else if ((null === (s = o.removeProperties) || void 0 === s ? void 0 : s.length) > 0) for (const e of o.removeProperties) Object.prototype.hasOwnProperty.call(t.properties, e) && delete t.properties[e]; if ((null === (n = o.addOrUpdateProperties) || void 0 === n ? void 0 : n.length) > 0) for (const { key: e, value: i } of o.addOrUpdateProperties) t.properties[e] = i; } }(this._dataUpdateable, t.dataDiff, i), { type: "FeatureCollection", features: Array.from(this._dataUpdateable.values()) } })) } removeSource(t) { return e._(this, void 0, void 0, (function* () { this._pendingRequest && this._pendingRequest.abort(); })) } getClusterExpansionZoom(e) { return this._geoJSONIndex.getClusterExpansionZoom(e.clusterId) } getClusterChildren(e) { return this._geoJSONIndex.getChildren(e.clusterId) } getClusterLeaves(e) { return this._geoJSONIndex.getLeaves(e.clusterId, e.limit, e.offset) } } class ue { constructor(t) { this.self = t, this.actor = new e.F(t), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.self.registerWorkerSource = (e, t) => { if (this.externalWorkerSourceTypes[e]) throw new Error(`Worker source with name "${e}" already registered.`); this.externalWorkerSourceTypes[e] = t; }, this.self.addProtocol = e.ch, this.self.removeProtocol = e.ci, this.self.registerRTLTextPlugin = t => { e.cC.setMethods(t); }, this.actor.registerMessageHandler("LDT", ((e, t) => this._getDEMWorkerSource(e, t.source).loadTile(t))), this.actor.registerMessageHandler("RDT", ((t, o) => e._(this, void 0, void 0, (function* () { this._getDEMWorkerSource(t, o.source).removeTile(o); })))), this.actor.registerMessageHandler("GCEZ", ((t, o) => e._(this, void 0, void 0, (function* () { return this._getWorkerSource(t, o.type, o.source).getClusterExpansionZoom(o) })))), this.actor.registerMessageHandler("GCC", ((t, o) => e._(this, void 0, void 0, (function* () { return this._getWorkerSource(t, o.type, o.source).getClusterChildren(o) })))), this.actor.registerMessageHandler("GCL", ((t, o) => e._(this, void 0, void 0, (function* () { return this._getWorkerSource(t, o.type, o.source).getClusterLeaves(o) })))), this.actor.registerMessageHandler("LD", ((e, t) => this._getWorkerSource(e, t.type, t.source).loadData(t))), this.actor.registerMessageHandler("GD", ((e, t) => this._getWorkerSource(e, t.type, t.source).getData())), this.actor.registerMessageHandler("LT", ((e, t) => this._getWorkerSource(e, t.type, t.source).loadTile(t))), this.actor.registerMessageHandler("RT", ((e, t) => this._getWorkerSource(e, t.type, t.source).reloadTile(t))), this.actor.registerMessageHandler("AT", ((e, t) => this._getWorkerSource(e, t.type, t.source).abortTile(t))), this.actor.registerMessageHandler("RMT", ((e, t) => this._getWorkerSource(e, t.type, t.source).removeTile(t))), this.actor.registerMessageHandler("RS", ((t, o) => e._(this, void 0, void 0, (function* () { if (!this.workerSources[t] || !this.workerSources[t][o.type] || !this.workerSources[t][o.type][o.source]) return; const e = this.workerSources[t][o.type][o.source]; delete this.workerSources[t][o.type][o.source], void 0 !== e.removeSource && e.removeSource(o); })))), this.actor.registerMessageHandler("RM", (t => e._(this, void 0, void 0, (function* () { delete this.layerIndexes[t], delete this.availableImages[t], delete this.workerSources[t], delete this.demWorkerSources[t]; })))), this.actor.registerMessageHandler("SR", ((t, o) => e._(this, void 0, void 0, (function* () { this.referrer = o; })))), this.actor.registerMessageHandler("SRPS", ((e, t) => this._syncRTLPluginState(e, t))), this.actor.registerMessageHandler("IS", ((t, o) => e._(this, void 0, void 0, (function* () { this.self.importScripts(o); })))), this.actor.registerMessageHandler("SI", ((e, t) => this._setImages(e, t))), this.actor.registerMessageHandler("UL", ((t, o) => e._(this, void 0, void 0, (function* () { this._getLayerIndex(t).update(o.layers, o.removedIds); })))), this.actor.registerMessageHandler("SL", ((t, o) => e._(this, void 0, void 0, (function* () { this._getLayerIndex(t).replace(o); })))); } _setImages(t, o) { return e._(this, void 0, void 0, (function* () { this.availableImages[t] = o; for (const e in this.workerSources[t]) { const i = this.workerSources[t][e]; for (const e in i) i[e].availableImages = o; } })) } _syncRTLPluginState(t, o) { return e._(this, void 0, void 0, (function* () { return yield e.cC.syncState(o, this.self.importScripts) })) } _getAvailableImages(e) { let t = this.availableImages[e]; return t || (t = []), t } _getLayerIndex(e) { let o = this.layerIndexes[e]; return o || (o = this.layerIndexes[e] = new t), o } _getWorkerSource(e, t, o) { if (this.workerSources[e] || (this.workerSources[e] = {}), this.workerSources[e][t] || (this.workerSources[e][t] = {}), !this.workerSources[e][t][o]) { const i = { sendAsync: (t, o) => (t.targetMapId = e, this.actor.sendAsync(t, o)) }; switch (t) { case "vector": this.workerSources[e][t][o] = new s(i, this._getLayerIndex(e), this._getAvailableImages(e)); break; case "geojson": this.workerSources[e][t][o] = new ce(i, this._getLayerIndex(e), this._getAvailableImages(e)); break; default: this.workerSources[e][t][o] = new this.externalWorkerSourceTypes[t](i, this._getLayerIndex(e), this._getAvailableImages(e)); } } return this.workerSources[e][t][o] } _getDEMWorkerSource(e, t) { return this.demWorkerSources[e] || (this.demWorkerSources[e] = {}), this.demWorkerSources[e][t] || (this.demWorkerSources[e][t] = new n), this.demWorkerSources[e][t] } } return e.i(self) && (self.worker = new ue(self)), ue }));

            define("index", ["exports", "./shared"], (function (e, t) { "use strict"; var i = "5.1.0"; function r() { var e = new t.A(4); return t.A != Float32Array && (e[1] = 0, e[2] = 0), e[0] = 1, e[3] = 1, e } let o, s; const a = { now: "undefined" != typeof performance && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frame(e, i, r) { const o = requestAnimationFrame(i); e.signal.addEventListener("abort", (() => { cancelAnimationFrame(o), r(t.c()); })); }, frameAsync(e) { return new Promise(((t, i) => { this.frame(e, t, i); })) }, getImageData(e, t = 0) { return this.getImageCanvasContext(e).getImageData(-t, -t, e.width + 2 * t, e.height + 2 * t) }, getImageCanvasContext(e) { const t = window.document.createElement("canvas"), i = t.getContext("2d", { willReadFrequently: !0 }); if (!i) throw new Error("failed to create canvas 2d context"); return t.width = e.width, t.height = e.height, i.drawImage(e, 0, 0, e.width, e.height), i }, resolveURL: e => (o || (o = document.createElement("a")), o.href = e, o.href), hardwareConcurrency: "undefined" != typeof navigator && navigator.hardwareConcurrency || 4, get prefersReducedMotion() { return !!matchMedia && (null == s && (s = matchMedia("(prefers-reduced-motion: reduce)")), s.matches) } }; class n { static testProp(e) { if (!n.docStyle) return e[0]; for (let t = 0; t < e.length; t++)if (e[t] in n.docStyle) return e[t]; return e[0] } static create(e, t, i) { const r = window.document.createElement(e); return void 0 !== t && (r.className = t), i && i.appendChild(r), r } static createNS(e, t) { return window.document.createElementNS(e, t) } static disableDrag() { n.docStyle && n.selectProp && (n.userSelect = n.docStyle[n.selectProp], n.docStyle[n.selectProp] = "none"); } static enableDrag() { n.docStyle && n.selectProp && (n.docStyle[n.selectProp] = n.userSelect); } static setTransform(e, t) { e.style[n.transformProp] = t; } static addEventListener(e, t, i, r = {}) { e.addEventListener(t, i, "passive" in r ? r : r.capture); } static removeEventListener(e, t, i, r = {}) { e.removeEventListener(t, i, "passive" in r ? r : r.capture); } static suppressClickInternal(e) { e.preventDefault(), e.stopPropagation(), window.removeEventListener("click", n.suppressClickInternal, !0); } static suppressClick() { window.addEventListener("click", n.suppressClickInternal, !0), window.setTimeout((() => { window.removeEventListener("click", n.suppressClickInternal, !0); }), 0); } static getScale(e) { const t = e.getBoundingClientRect(); return { x: t.width / e.offsetWidth || 1, y: t.height / e.offsetHeight || 1, boundingClientRect: t } } static getPoint(e, i, r) { const o = i.boundingClientRect; return new t.P((r.clientX - o.left) / i.x - e.clientLeft, (r.clientY - o.top) / i.y - e.clientTop) } static mousePos(e, t) { const i = n.getScale(e); return n.getPoint(e, i, t) } static touchPos(e, t) { const i = [], r = n.getScale(e); for (let o = 0; o < t.length; o++)i.push(n.getPoint(e, r, t[o])); return i } static mouseButton(e) { return e.button } static remove(e) { e.parentNode && e.parentNode.removeChild(e); } static sanitize(e) { const t = (new DOMParser).parseFromString(e, "text/html").body || document.createElement("body"), i = t.querySelectorAll("script"); for (const e of i) e.remove(); return n.clean(t), t.innerHTML } static isPossiblyDangerous(e, t) { const i = t.replace(/\s+/g, "").toLowerCase(); return !(!["src", "href", "xlink:href"].includes(e) || !i.includes("javascript:") && !i.includes("data:")) || !!e.startsWith("on") || void 0 } static clean(e) { const t = e.children; for (const e of t) n.removeAttributes(e), n.clean(e); } static removeAttributes(e) { for (const { name: t, value: i } of e.attributes) n.isPossiblyDangerous(t, i) && e.removeAttribute(t); } } n.docStyle = "undefined" != typeof window && window.document && window.document.documentElement.style, n.selectProp = n.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), n.transformProp = n.testProp(["transform", "WebkitTransform"]); const l = { supported: !1, testSupport: function (e) { !u && h && (d ? _(e) : c = e); } }; let c, h, u = !1, d = !1; function _(e) { const t = e.createTexture(); e.bindTexture(e.TEXTURE_2D, t); try { if (e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, h), e.isContextLost()) return; l.supported = !0; } catch (e) { } e.deleteTexture(t), u = !0; } var p; "undefined" != typeof document && (h = document.createElement("img"), h.onload = () => { c && _(c), c = null, d = !0; }, h.onerror = () => { u = !0, c = null; }, h.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), function (e) { let i, r, o, s; e.resetRequestQueue = () => { i = [], r = 0, o = 0, s = {}; }, e.addThrottleControl = e => { const t = o++; return s[t] = e, t }, e.removeThrottleControl = e => { delete s[e], n(); }, e.getImage = (e, r, o = !0) => new Promise(((s, a) => { l.supported && (e.headers || (e.headers = {}), e.headers.accept = "image/webp,*/*"), t.e(e, { type: "image" }), i.push({ abortController: r, requestParameters: e, supportImageRefresh: o, state: "queued", onError: e => { a(e); }, onSuccess: e => { s(e); } }), n(); })); const a = e => t._(this, void 0, void 0, (function* () { e.state = "running"; const { requestParameters: i, supportImageRefresh: o, onError: s, onSuccess: a, abortController: l } = e, h = !1 === o && !t.i(self) && !t.g(i.url) && (!i.headers || Object.keys(i.headers).reduce(((e, t) => e && "accept" === t), !0)); r++; const u = h ? c(i, l) : t.m(i, l); try { const i = yield u; delete e.abortController, e.state = "completed", i.data instanceof HTMLImageElement || t.b(i.data) ? a(i) : i.data && a({ data: yield (d = i.data, "function" == typeof createImageBitmap ? t.d(d) : t.f(d)), cacheControl: i.cacheControl, expires: i.expires }); } catch (t) { delete e.abortController, s(t); } finally { r--, n(); } var d; })), n = () => { const e = (() => { for (const e of Object.keys(s)) if (s[e]()) return !0; return !1 })() ? t.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : t.a.MAX_PARALLEL_IMAGE_REQUESTS; for (let t = r; t < e && i.length > 0; t++) { const e = i.shift(); e.abortController.signal.aborted ? t-- : a(e); } }, c = (e, i) => new Promise(((r, o) => { const s = new Image, a = e.url, n = e.credentials; n && "include" === n ? s.crossOrigin = "use-credentials" : (n && "same-origin" === n || !t.s(a)) && (s.crossOrigin = "anonymous"), i.signal.addEventListener("abort", (() => { s.src = "", o(t.c()); })), s.fetchPriority = "high", s.onload = () => { s.onerror = s.onload = null, r({ data: s }); }, s.onerror = () => { s.onerror = s.onload = null, i.signal.aborted || o(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.")); }, s.src = a; })); }(p || (p = {})), p.resetRequestQueue(); class m { constructor(e) { this._transformRequestFn = e; } transformRequest(e, t) { return this._transformRequestFn && this._transformRequestFn(e, t) || { url: e } } setTransformRequest(e) { this._transformRequestFn = e; } } function f(e) { const t = []; if ("string" == typeof e) t.push({ id: "default", url: e }); else if (e && e.length > 0) { const i = []; for (const { id: r, url: o } of e) { const e = `${r}${o}`; -1 === i.indexOf(e) && (i.push(e), t.push({ id: r, url: o })); } } return t } function g(e, t, i) { try { const r = new URL(e); return r.pathname += `${t}${i}`, r.toString() } catch (t) { throw new Error(`Invalid sprite URL "${e}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`) } } class v { constructor(e, t, i, r) { this.context = e, this.format = i, this.texture = e.gl.createTexture(), this.update(t, r); } update(e, i, r) { const { width: o, height: s } = e, a = !(this.size && this.size[0] === o && this.size[1] === s || r), { context: n } = this, { gl: l } = n; if (this.useMipmap = Boolean(i && i.useMipmap), l.bindTexture(l.TEXTURE_2D, this.texture), n.pixelStoreUnpackFlipY.set(!1), n.pixelStoreUnpack.set(1), n.pixelStoreUnpackPremultiplyAlpha.set(this.format === l.RGBA && (!i || !1 !== i.premultiply)), a) this.size = [o, s], e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || t.b(e) ? l.texImage2D(l.TEXTURE_2D, 0, this.format, this.format, l.UNSIGNED_BYTE, e) : l.texImage2D(l.TEXTURE_2D, 0, this.format, o, s, 0, this.format, l.UNSIGNED_BYTE, e.data); else { const { x: i, y: a } = r || { x: 0, y: 0 }; e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || t.b(e) ? l.texSubImage2D(l.TEXTURE_2D, 0, i, a, l.RGBA, l.UNSIGNED_BYTE, e) : l.texSubImage2D(l.TEXTURE_2D, 0, i, a, o, s, l.RGBA, l.UNSIGNED_BYTE, e.data); } this.useMipmap && this.isSizePowerOfTwo() && l.generateMipmap(l.TEXTURE_2D); } bind(e, t, i) { const { context: r } = this, { gl: o } = r; o.bindTexture(o.TEXTURE_2D, this.texture), i !== o.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (i = o.LINEAR), e !== this.filter && (o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MAG_FILTER, e), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MIN_FILTER, i || e), this.filter = e), t !== this.wrap && (o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_S, t), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_T, t), this.wrap = t); } isSizePowerOfTwo() { return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0 } destroy() { const { gl: e } = this.context; e.deleteTexture(this.texture), this.texture = null; } } function x(e) { const { userImage: t } = e; return !!(t && t.render && t.render()) && (e.data.replace(new Uint8Array(t.data.buffer)), !0) } class b extends t.E { constructor() { super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new t.R({ width: 1, height: 1 }), this.dirty = !0; } isLoaded() { return this.loaded } setLoaded(e) { if (this.loaded !== e && (this.loaded = e, e)) { for (const { ids: e, promiseResolve: t } of this.requestors) t(this._getImagesForIds(e)); this.requestors = []; } } getImage(e) { const i = this.images[e]; if (i && !i.data && i.spriteData) { const e = i.spriteData; i.data = new t.R({ width: e.width, height: e.height }, e.context.getImageData(e.x, e.y, e.width, e.height).data), i.spriteData = null; } return i } addImage(e, t) { if (this.images[e]) throw new Error(`Image id ${e} already exist, use updateImage instead`); this._validate(e, t) && (this.images[e] = t); } _validate(e, i) { let r = !0; const o = i.data || i.spriteData; return this._validateStretch(i.stretchX, o && o.width) || (this.fire(new t.j(new Error(`Image "${e}" has invalid "stretchX" value`))), r = !1), this._validateStretch(i.stretchY, o && o.height) || (this.fire(new t.j(new Error(`Image "${e}" has invalid "stretchY" value`))), r = !1), this._validateContent(i.content, i) || (this.fire(new t.j(new Error(`Image "${e}" has invalid "content" value`))), r = !1), r } _validateStretch(e, t) { if (!e) return !0; let i = 0; for (const r of e) { if (r[0] < i || r[1] < r[0] || t < r[1]) return !1; i = r[1]; } return !0 } _validateContent(e, t) { if (!e) return !0; if (4 !== e.length) return !1; const i = t.spriteData, r = i && i.width || t.data.width, o = i && i.height || t.data.height; return !(e[0] < 0 || r < e[0] || e[1] < 0 || o < e[1] || e[2] < 0 || r < e[2] || e[3] < 0 || o < e[3] || e[2] < e[0] || e[3] < e[1]) } updateImage(e, t, i = !0) { const r = this.getImage(e); if (i && (r.data.width !== t.data.width || r.data.height !== t.data.height)) throw new Error(`size mismatch between old image (${r.data.width}x${r.data.height}) and new image (${t.data.width}x${t.data.height}).`); t.version = r.version + 1, this.images[e] = t, this.updatedImages[e] = !0; } removeImage(e) { const t = this.images[e]; delete this.images[e], delete this.patterns[e], t.userImage && t.userImage.onRemove && t.userImage.onRemove(); } listImages() { return Object.keys(this.images) } getImages(e) { return new Promise(((t, i) => { let r = !0; if (!this.isLoaded()) for (const t of e) this.images[t] || (r = !1); this.isLoaded() || r ? t(this._getImagesForIds(e)) : this.requestors.push({ ids: e, promiseResolve: t }); })) } _getImagesForIds(e) { const i = {}; for (const r of e) { let e = this.getImage(r); e || (this.fire(new t.k("styleimagemissing", { id: r })), e = this.getImage(r)), e ? i[r] = { data: e.data.clone(), pixelRatio: e.pixelRatio, sdf: e.sdf, version: e.version, stretchX: e.stretchX, stretchY: e.stretchY, content: e.content, textFitWidth: e.textFitWidth, textFitHeight: e.textFitHeight, hasRenderCallback: Boolean(e.userImage && e.userImage.render) } : t.w(`Image "${r}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`); } return i } getPixelSize() { const { width: e, height: t } = this.atlasImage; return { width: e, height: t } } getPattern(e) { const i = this.patterns[e], r = this.getImage(e); if (!r) return null; if (i && i.position.version === r.version) return i.position; if (i) i.position.version = r.version; else { const i = { w: r.data.width + 2, h: r.data.height + 2, x: 0, y: 0 }, o = new t.I(i, r); this.patterns[e] = { bin: i, position: o }; } return this._updatePatternAtlas(), this.patterns[e].position } bind(e) { const t = e.gl; this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new v(e, this.atlasImage, t.RGBA), this.atlasTexture.bind(t.LINEAR, t.CLAMP_TO_EDGE); } _updatePatternAtlas() { const e = []; for (const t in this.patterns) e.push(this.patterns[t].bin); const { w: i, h: r } = t.p(e), o = this.atlasImage; o.resize({ width: i || 1, height: r || 1 }); for (const e in this.patterns) { const { bin: i } = this.patterns[e], r = i.x + 1, s = i.y + 1, a = this.getImage(e).data, n = a.width, l = a.height; t.R.copy(a, o, { x: 0, y: 0 }, { x: r, y: s }, { width: n, height: l }), t.R.copy(a, o, { x: 0, y: l - 1 }, { x: r, y: s - 1 }, { width: n, height: 1 }), t.R.copy(a, o, { x: 0, y: 0 }, { x: r, y: s + l }, { width: n, height: 1 }), t.R.copy(a, o, { x: n - 1, y: 0 }, { x: r - 1, y: s }, { width: 1, height: l }), t.R.copy(a, o, { x: 0, y: 0 }, { x: r + n, y: s }, { width: 1, height: l }); } this.dirty = !0; } beginFrame() { this.callbackDispatchedThisFrame = {}; } dispatchRenderCallbacks(e) { for (const i of e) { if (this.callbackDispatchedThisFrame[i]) continue; this.callbackDispatchedThisFrame[i] = !0; const e = this.getImage(i); e || t.w(`Image with ID: "${i}" was not found`), x(e) && this.updateImage(i, e); } } } const y = 1e20; function w(e, t, i, r, o, s, a, n, l) { for (let c = t; c < t + r; c++)T(e, i * s + c, s, o, a, n, l); for (let c = i; c < i + o; c++)T(e, c * s + t, 1, r, a, n, l); } function T(e, t, i, r, o, s, a) { s[0] = 0, a[0] = -1e20, a[1] = y, o[0] = e[t]; for (let n = 1, l = 0, c = 0; n < r; n++) { o[n] = e[t + n * i]; const r = n * n; do { const e = s[l]; c = (o[n] - o[e] + r - e * e) / (n - e) / 2; } while (c <= a[l] && --l > -1); l++, s[l] = n, a[l] = c, a[l + 1] = y; } for (let n = 0, l = 0; n < r; n++) { for (; a[l + 1] < n;)l++; const r = s[l], c = n - r; e[t + n * i] = o[r] + c * c; } } class P { constructor(e, t) { this.requestManager = e, this.localIdeographFontFamily = t, this.entries = {}; } setURL(e) { this.url = e; } getGlyphs(e) { return t._(this, void 0, void 0, (function* () { const t = []; for (const i in e) for (const r of e[i]) t.push(this._getAndCacheGlyphsPromise(i, r)); const i = yield Promise.all(t), r = {}; for (const { stack: e, id: t, glyph: o } of i) r[e] || (r[e] = {}), r[e][t] = o && { id: o.id, bitmap: o.bitmap.clone(), metrics: o.metrics }; return r })) } _getAndCacheGlyphsPromise(e, i) { return t._(this, void 0, void 0, (function* () { let t = this.entries[e]; t || (t = this.entries[e] = { glyphs: {}, requests: {}, ranges: {} }); let r = t.glyphs[i]; if (void 0 !== r) return { stack: e, id: i, glyph: r }; if (r = this._tinySDF(t, e, i), r) return t.glyphs[i] = r, { stack: e, id: i, glyph: r }; const o = Math.floor(i / 256); if (256 * o > 65535) throw new Error("glyphs > 65535 not supported"); if (t.ranges[o]) return { stack: e, id: i, glyph: r }; if (!this.url) throw new Error("glyphsUrl is not set"); if (!t.requests[o]) { const i = P.loadGlyphRange(e, o, this.url, this.requestManager); t.requests[o] = i; } const s = yield t.requests[o]; for (const e in s) this._doesCharSupportLocalGlyph(+e) || (t.glyphs[+e] = s[+e]); return t.ranges[o] = !0, { stack: e, id: i, glyph: s[i] || null } })) } _doesCharSupportLocalGlyph(e) { return !!this.localIdeographFontFamily && /\p{Ideo}|\p{sc=Hang}|\p{sc=Hira}|\p{sc=Kana}/u.test(String.fromCodePoint(e)) } _tinySDF(e, i, r) { const o = this.localIdeographFontFamily; if (!o) return; if (!this._doesCharSupportLocalGlyph(r)) return; let s = e.tinySDF; if (!s) { let t = "400"; /bold/i.test(i) ? t = "900" : /medium/i.test(i) ? t = "500" : /light/i.test(i) && (t = "200"), s = e.tinySDF = new P.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: .25, fontFamily: o, fontWeight: t }); } const a = s.draw(String.fromCharCode(r)); return { id: r, bitmap: new t.o({ width: a.width || 60, height: a.height || 60 }, a.data), metrics: { width: a.glyphWidth / 2 || 24, height: a.glyphHeight / 2 || 24, left: a.glyphLeft / 2 + .5 || 0, top: a.glyphTop / 2 - 27.5 || -8, advance: a.glyphAdvance / 2 || 24, isDoubleResolution: !0 } } } } P.loadGlyphRange = function (e, i, r, o) { return t._(this, void 0, void 0, (function* () { const s = 256 * i, a = s + 255, n = o.transformRequest(r.replace("{fontstack}", e).replace("{range}", `${s}-${a}`), "Glyphs"), l = yield t.l(n, new AbortController); if (!l || !l.data) throw new Error(`Could not load glyph range. range: ${i}, ${s}-${a}`); const c = {}; for (const e of t.n(l.data)) c[e.id] = e; return c })) }, P.TinySDF = class { constructor({ fontSize: e = 24, buffer: t = 3, radius: i = 8, cutoff: r = .25, fontFamily: o = "sans-serif", fontWeight: s = "normal", fontStyle: a = "normal" } = {}) { this.buffer = t, this.cutoff = r, this.radius = i; const n = this.size = e + 4 * t, l = this._createCanvas(n), c = this.ctx = l.getContext("2d", { willReadFrequently: !0 }); c.font = `${a} ${s} ${e}px ${o}`, c.textBaseline = "alphabetic", c.textAlign = "left", c.fillStyle = "black", this.gridOuter = new Float64Array(n * n), this.gridInner = new Float64Array(n * n), this.f = new Float64Array(n), this.z = new Float64Array(n + 1), this.v = new Uint16Array(n); } _createCanvas(e) { const t = document.createElement("canvas"); return t.width = t.height = e, t } draw(e) { const { width: t, actualBoundingBoxAscent: i, actualBoundingBoxDescent: r, actualBoundingBoxLeft: o, actualBoundingBoxRight: s } = this.ctx.measureText(e), a = Math.ceil(i), n = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(s - o))), l = Math.min(this.size - this.buffer, a + Math.ceil(r)), c = n + 2 * this.buffer, h = l + 2 * this.buffer, u = Math.max(c * h, 0), d = new Uint8ClampedArray(u), _ = { data: d, width: c, height: h, glyphWidth: n, glyphHeight: l, glyphTop: a, glyphLeft: 0, glyphAdvance: t }; if (0 === n || 0 === l) return _; const { ctx: p, buffer: m, gridInner: f, gridOuter: g } = this; p.clearRect(m, m, n, l), p.fillText(e, m, m + a); const v = p.getImageData(m, m, n, l); g.fill(y, 0, u), f.fill(0, 0, u); for (let e = 0; e < l; e++)for (let t = 0; t < n; t++) { const i = v.data[4 * (e * n + t) + 3] / 255; if (0 === i) continue; const r = (e + m) * c + t + m; if (1 === i) g[r] = 0, f[r] = y; else { const e = .5 - i; g[r] = e > 0 ? e * e : 0, f[r] = e < 0 ? e * e : 0; } } w(g, 0, 0, c, h, c, this.f, this.v, this.z), w(f, m, m, n, l, c, this.f, this.v, this.z); for (let e = 0; e < u; e++) { const t = Math.sqrt(g[e]) - Math.sqrt(f[e]); d[e] = Math.round(255 - 255 * (t / this.radius + this.cutoff)); } return _ } }; class C { constructor() { this.specification = t.v.light.position; } possiblyEvaluate(e, i) { return t.x(e.expression.evaluate(i)) } interpolate(e, i, r) { return { x: t.y.number(e.x, i.x, r), y: t.y.number(e.y, i.y, r), z: t.y.number(e.z, i.z, r) } } } let I; class E extends t.E { constructor(e) { super(), I = I || new t.q({ anchor: new t.D(t.v.light.anchor), position: new C, color: new t.D(t.v.light.color), intensity: new t.D(t.v.light.intensity) }), this._transitionable = new t.T(I), this.setLight(e), this._transitioning = this._transitionable.untransitioned(); } getLight() { return this._transitionable.serialize() } setLight(e, i = {}) { if (!this._validate(t.r, e, i)) for (const t in e) { const i = e[t]; t.endsWith("-transition") ? this._transitionable.setTransition(t.slice(0, -11), i) : this._transitionable.setValue(t, i); } } updateTransitions(e) { this._transitioning = this._transitionable.transitioned(e, this._transitioning); } hasTransition() { return this._transitioning.hasTransition() } recalculate(e) { this.properties = this._transitioning.possiblyEvaluate(e); } _validate(e, i, r) { return (!r || !1 !== r.validate) && t.t(this, e.call(t.u, { value: i, style: { glyphs: !0, sprite: !0 }, styleSpec: t.v })) } } const M = new t.q({ "sky-color": new t.D(t.v.sky["sky-color"]), "horizon-color": new t.D(t.v.sky["horizon-color"]), "fog-color": new t.D(t.v.sky["fog-color"]), "fog-ground-blend": new t.D(t.v.sky["fog-ground-blend"]), "horizon-fog-blend": new t.D(t.v.sky["horizon-fog-blend"]), "sky-horizon-blend": new t.D(t.v.sky["sky-horizon-blend"]), "atmosphere-blend": new t.D(t.v.sky["atmosphere-blend"]) }); class S extends t.E { constructor(e) { super(), this._transitionable = new t.T(M), this.setSky(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new t.z(0)); } setSky(e, i = {}) { if (!this._validate(t.B, e, i)) { e || (e = { "sky-color": "transparent", "horizon-color": "transparent", "fog-color": "transparent", "fog-ground-blend": 1, "atmosphere-blend": 0 }); for (const t in e) { const i = e[t]; t.endsWith("-transition") ? this._transitionable.setTransition(t.slice(0, -11), i) : this._transitionable.setValue(t, i); } } } getSky() { return this._transitionable.serialize() } updateTransitions(e) { this._transitioning = this._transitionable.transitioned(e, this._transitioning); } hasTransition() { return this._transitioning.hasTransition() } recalculate(e) { this.properties = this._transitioning.possiblyEvaluate(e); } _validate(e, i, r = {}) { return !1 !== (null == r ? void 0 : r.validate) && t.t(this, e.call(t.u, t.e({ value: i, style: { glyphs: !0, sprite: !0 }, styleSpec: t.v }))) } calculateFogBlendOpacity(e) { return e < 60 ? 0 : e < 70 ? (e - 60) / 10 : 1 } } class R { constructor(e, t) { this.width = e, this.height = t, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {}; } getDash(e, t) { const i = e.join(",") + String(t); return this.dashEntry[i] || (this.dashEntry[i] = this.addDash(e, t)), this.dashEntry[i] } getDashRanges(e, t, i) { const r = []; let o = e.length % 2 == 1 ? -e[e.length - 1] * i : 0, s = e[0] * i, a = !0; r.push({ left: o, right: s, isDash: a, zeroLength: 0 === e[0] }); let n = e[0]; for (let t = 1; t < e.length; t++) { a = !a; const l = e[t]; o = n * i, n += l, s = n * i, r.push({ left: o, right: s, isDash: a, zeroLength: 0 === l }); } return r } addRoundDash(e, t, i) { const r = t / 2; for (let t = -i; t <= i; t++) { const o = this.width * (this.nextRow + i + t); let s = 0, a = e[s]; for (let n = 0; n < this.width; n++) { n / a.right > 1 && (a = e[++s]); const l = Math.abs(n - a.left), c = Math.abs(n - a.right), h = Math.min(l, c); let u; const d = t / i * (r + 1); if (a.isDash) { const e = r - Math.abs(d); u = Math.sqrt(h * h + e * e); } else u = r - Math.sqrt(h * h + d * d); this.data[o + n] = Math.max(0, Math.min(255, u + 128)); } } } addRegularDash(e) { for (let t = e.length - 1; t >= 0; --t) { const i = e[t], r = e[t + 1]; i.zeroLength ? e.splice(t, 1) : r && r.isDash === i.isDash && (r.left = i.left, e.splice(t, 1)); } const t = e[0], i = e[e.length - 1]; t.isDash === i.isDash && (t.left = i.left - this.width, i.right = t.right + this.width); const r = this.width * this.nextRow; let o = 0, s = e[o]; for (let t = 0; t < this.width; t++) { t / s.right > 1 && (s = e[++o]); const i = Math.abs(t - s.left), a = Math.abs(t - s.right), n = Math.min(i, a); this.data[r + t] = Math.max(0, Math.min(255, (s.isDash ? n : -n) + 128)); } } addDash(e, i) { const r = i ? 7 : 0, o = 2 * r + 1; if (this.nextRow + o > this.height) return t.w("LineAtlas out of space"), null; let s = 0; for (let t = 0; t < e.length; t++)s += e[t]; if (0 !== s) { const t = this.width / s, o = this.getDashRanges(e, this.width, t); i ? this.addRoundDash(o, t, r) : this.addRegularDash(o); } const a = { y: (this.nextRow + r + .5) / this.height, height: 2 * r / this.height, width: s }; return this.nextRow += o, this.dirty = !0, a } bind(e) { const t = e.gl; this.texture ? (t.bindTexture(t.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, this.width, this.height, t.ALPHA, t.UNSIGNED_BYTE, this.data))) : (this.texture = t.createTexture(), t.bindTexture(t.TEXTURE_2D, this.texture), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.REPEAT), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.REPEAT), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texImage2D(t.TEXTURE_2D, 0, t.ALPHA, this.width, this.height, 0, t.ALPHA, t.UNSIGNED_BYTE, this.data)); } } const D = "maplibre_preloaded_worker_pool"; class z { constructor() { this.active = {}; } acquire(e) { if (!this.workers) for (this.workers = []; this.workers.length < z.workerCount;)this.workers.push(new Worker(t.a.WORKER_URL)); return this.active[e] = !0, this.workers.slice() } release(e) { delete this.active[e], 0 === this.numActive() && (this.workers.forEach((e => { e.terminate(); })), this.workers = null); } isPreloaded() { return !!this.active[D] } numActive() { return Object.keys(this.active).length } } const A = Math.floor(a.hardwareConcurrency / 2); let L, k; function F() { return L || (L = new z), L } z.workerCount = t.C(globalThis) ? Math.max(Math.min(A, 3), 1) : 1; class B { constructor(e, i) { this.workerPool = e, this.actors = [], this.currentActor = 0, this.id = i; const r = this.workerPool.acquire(i); for (let e = 0; e < r.length; e++) { const o = new t.F(r[e], i); o.name = `Worker ${e}`, this.actors.push(o); } if (!this.actors.length) throw new Error("No actors found") } broadcast(e, t) { const i = []; for (const r of this.actors) i.push(r.sendAsync({ type: e, data: t })); return Promise.all(i) } getActor() { return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor] } remove(e = !0) { this.actors.forEach((e => { e.remove(); })), this.actors = [], e && this.workerPool.release(this.id); } registerMessageHandler(e, t) { for (const i of this.actors) i.registerMessageHandler(e, t); } } function j() { return k || (k = new B(F(), t.G), k.registerMessageHandler("GR", ((e, i, r) => t.m(i, r)))), k } function O(e, i) { const r = t.H(); return t.J(r, r, [1, 1, 0]), t.K(r, r, [.5 * e.width, .5 * e.height, 1]), e.calculatePosMatrix ? t.L(r, r, e.calculatePosMatrix(i.toUnwrapped())) : r } function N(e, t, i, r, o, s) { var a; const n = function (e, t, i) { if (e) for (const r of e) { const e = t[r]; if (e && e.source === i && "fill-extrusion" === e.type) return !0 } else for (const e in t) { const r = t[e]; if (r.source === i && "fill-extrusion" === r.type) return !0 } return !1 }(null !== (a = null == o ? void 0 : o.layers) && void 0 !== a ? a : null, t, e.id), l = s.maxPitchScaleFactor(), c = e.tilesIn(r, l, n); c.sort(Z); const h = []; for (const r of c) h.push({ wrappedTileID: r.tileID.wrapped().key, queryResults: r.tile.queryRenderedFeatures(t, i, e._state, r.queryGeometry, r.cameraQueryGeometry, r.scale, o, s, l, O(e.transform, r.tileID)) }); return function (e, t) { for (const i in e) for (const r of e[i]) G(r, t); return e }(function (e) { const t = {}, i = {}; for (const r of e) { const e = r.queryResults, o = r.wrappedTileID, s = i[o] = i[o] || {}; for (const i in e) { const r = e[i], o = s[i] = s[i] || {}, a = t[i] = t[i] || []; for (const e of r) o[e.featureIndex] || (o[e.featureIndex] = !0, a.push(e)); } } return t }(h), e) } function Z(e, t) { const i = e.tileID, r = t.tileID; return i.overscaledZ - r.overscaledZ || i.canonical.y - r.canonical.y || i.wrap - r.wrap || i.canonical.x - r.canonical.x } function G(e, t) { const i = e.feature, r = t.getFeatureState(i.layer["source-layer"], i.id); i.source = i.layer.source, i.layer["source-layer"] && (i.sourceLayer = i.layer["source-layer"]), i.state = r; } function U(e, i, r) { return t._(this, void 0, void 0, (function* () { let o = e; if (e.url ? o = (yield t.h(i.transformRequest(e.url, "Source"), r)).data : yield a.frameAsync(r), !o) return null; const s = t.M(t.e(o, e), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]); return "vector_layers" in o && o.vector_layers && (s.vectorLayerIds = o.vector_layers.map((e => e.id))), s })) } class V { constructor(e, t) { e && (t ? this.setSouthWest(e).setNorthEast(t) : Array.isArray(e) && (4 === e.length ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]) : this.setSouthWest(e[0]).setNorthEast(e[1]))); } setNorthEast(e) { return this._ne = e instanceof t.N ? new t.N(e.lng, e.lat) : t.N.convert(e), this } setSouthWest(e) { return this._sw = e instanceof t.N ? new t.N(e.lng, e.lat) : t.N.convert(e), this } extend(e) { const i = this._sw, r = this._ne; let o, s; if (e instanceof t.N) o = e, s = e; else { if (!(e instanceof V)) return Array.isArray(e) ? 4 === e.length || e.every(Array.isArray) ? this.extend(V.convert(e)) : this.extend(t.N.convert(e)) : e && ("lng" in e || "lon" in e) && "lat" in e ? this.extend(t.N.convert(e)) : this; if (o = e._sw, s = e._ne, !o || !s) return this } return i || r ? (i.lng = Math.min(o.lng, i.lng), i.lat = Math.min(o.lat, i.lat), r.lng = Math.max(s.lng, r.lng), r.lat = Math.max(s.lat, r.lat)) : (this._sw = new t.N(o.lng, o.lat), this._ne = new t.N(s.lng, s.lat)), this } getCenter() { return new t.N((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2) } getSouthWest() { return this._sw } getNorthEast() { return this._ne } getNorthWest() { return new t.N(this.getWest(), this.getNorth()) } getSouthEast() { return new t.N(this.getEast(), this.getSouth()) } getWest() { return this._sw.lng } getSouth() { return this._sw.lat } getEast() { return this._ne.lng } getNorth() { return this._ne.lat } toArray() { return [this._sw.toArray(), this._ne.toArray()] } toString() { return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})` } isEmpty() { return !(this._sw && this._ne) } contains(e) { const { lng: i, lat: r } = t.N.convert(e); let o = this._sw.lng <= i && i <= this._ne.lng; return this._sw.lng > this._ne.lng && (o = this._sw.lng >= i && i >= this._ne.lng), this._sw.lat <= r && r <= this._ne.lat && o } static convert(e) { return e instanceof V ? e : e ? new V(e) : e } static fromLngLat(e, i = 0) { const r = 360 * i / 40075017, o = r / Math.cos(Math.PI / 180 * e.lat); return new V(new t.N(e.lng - o, e.lat - r), new t.N(e.lng + o, e.lat + r)) } adjustAntiMeridian() { const e = new t.N(this._sw.lng, this._sw.lat), i = new t.N(this._ne.lng, this._ne.lat); return new V(e, e.lng > i.lng ? new t.N(i.lng + 360, i.lat) : i) } } class q { constructor(e, t, i) { this.bounds = V.convert(this.validateBounds(e)), this.minzoom = t || 0, this.maxzoom = i || 24; } validateBounds(e) { return Array.isArray(e) && 4 === e.length ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90] } contains(e) { const i = Math.pow(2, e.z), r = Math.floor(t.O(this.bounds.getWest()) * i), o = Math.floor(t.Q(this.bounds.getNorth()) * i), s = Math.ceil(t.O(this.bounds.getEast()) * i), a = Math.ceil(t.Q(this.bounds.getSouth()) * i); return e.x >= r && e.x < s && e.y >= o && e.y < a } } class H extends t.E { constructor(e, i, r, o) { if (super(), this.id = e, this.dispatcher = r, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, t.e(this, t.M(i, ["url", "scheme", "tileSize", "promoteId"])), this._options = t.e({ type: "vector" }, i), this._collectResourceTiming = i.collectResourceTiming, 512 !== this.tileSize) throw new Error("vector tile sources must have a tileSize of 512"); this.setEventedParent(o); } load() { return t._(this, void 0, void 0, (function* () { this._loaded = !1, this.fire(new t.k("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController; try { const e = yield U(this._options, this.map._requestManager, this._tileJSONRequest); this._tileJSONRequest = null, this._loaded = !0, this.map.style.sourceCaches[this.id].clearTiles(), e && (t.e(this, e), e.bounds && (this.tileBounds = new q(e.bounds, this.minzoom, this.maxzoom)), this.fire(new t.k("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new t.k("data", { dataType: "source", sourceDataType: "content" }))); } catch (e) { this._tileJSONRequest = null, this.fire(new t.j(e)); } })) } loaded() { return this._loaded } hasTile(e) { return !this.tileBounds || this.tileBounds.contains(e.canonical) } onAdd(e) { this.map = e, this.load(); } setSourceProperty(e) { this._tileJSONRequest && this._tileJSONRequest.abort(), e(), this.load(); } setTiles(e) { return this.setSourceProperty((() => { this._options.tiles = e; })), this } setUrl(e) { return this.setSourceProperty((() => { this.url = e, this._options.url = e; })), this } onRemove() { this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null); } serialize() { return t.e({}, this._options) } loadTile(e) { return t._(this, void 0, void 0, (function* () { const t = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), i = { request: this.map._requestManager.transformRequest(t, "Tile"), uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, tileSize: this.tileSize * e.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity }; i.request.collectResourceTiming = this._collectResourceTiming; let r = "RT"; if (e.actor && "expired" !== e.state) { if ("loading" === e.state) return new Promise(((t, i) => { e.reloadPromise = { resolve: t, reject: i }; })) } else e.actor = this.dispatcher.getActor(), r = "LT"; e.abortController = new AbortController; try { const t = yield e.actor.sendAsync({ type: r, data: i }, e.abortController); if (delete e.abortController, e.aborted) return; this._afterTileLoadWorkerResponse(e, t); } catch (t) { if (delete e.abortController, e.aborted) return; if (t && 404 !== t.status) throw t; this._afterTileLoadWorkerResponse(e, null); } })) } _afterTileLoadWorkerResponse(e, t) { if (t && t.resourceTiming && (e.resourceTiming = t.resourceTiming), t && this.map._refreshExpiredTiles && e.setExpiryData(t), e.loadVectorData(t, this.map.painter), e.reloadPromise) { const t = e.reloadPromise; e.reloadPromise = null, this.loadTile(e).then(t.resolve).catch(t.reject); } } abortTile(e) { return t._(this, void 0, void 0, (function* () { e.abortController && (e.abortController.abort(), delete e.abortController), e.actor && (yield e.actor.sendAsync({ type: "AT", data: { uid: e.uid, type: this.type, source: this.id } })); })) } unloadTile(e) { return t._(this, void 0, void 0, (function* () { e.unloadVectorData(), e.actor && (yield e.actor.sendAsync({ type: "RMT", data: { uid: e.uid, type: this.type, source: this.id } })); })) } hasTransition() { return !1 } } class W extends t.E { constructor(e, i, r, o) { super(), this.id = e, this.dispatcher = r, this.setEventedParent(o), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = t.e({ type: "raster" }, i), t.e(this, t.M(i, ["url", "scheme", "tileSize"])); } load() { return t._(this, arguments, void 0, (function* (e = !1) { this._loaded = !1, this.fire(new t.k("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController; try { const i = yield U(this._options, this.map._requestManager, this._tileJSONRequest); this._tileJSONRequest = null, this._loaded = !0, i && (t.e(this, i), i.bounds && (this.tileBounds = new q(i.bounds, this.minzoom, this.maxzoom)), this.fire(new t.k("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new t.k("data", { dataType: "source", sourceDataType: "content", sourceDataChanged: e }))); } catch (e) { this._tileJSONRequest = null, this.fire(new t.j(e)); } })) } loaded() { return this._loaded } onAdd(e) { this.map = e, this.load(); } onRemove() { this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null); } setSourceProperty(e) { this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e(), this.load(!0); } setTiles(e) { return this.setSourceProperty((() => { this._options.tiles = e; })), this } setUrl(e) { return this.setSourceProperty((() => { this.url = e, this._options.url = e; })), this } serialize() { return t.e({}, this._options) } hasTile(e) { return !this.tileBounds || this.tileBounds.contains(e.canonical) } loadTile(e) { return t._(this, void 0, void 0, (function* () { const t = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme); e.abortController = new AbortController; try { const i = yield p.getImage(this.map._requestManager.transformRequest(t, "Tile"), e.abortController, this.map._refreshExpiredTiles); if (delete e.abortController, e.aborted) return void (e.state = "unloaded"); if (i && i.data) { this.map._refreshExpiredTiles && i.cacheControl && i.expires && e.setExpiryData({ cacheControl: i.cacheControl, expires: i.expires }); const t = this.map.painter.context, r = t.gl, o = i.data; e.texture = this.map.painter.getTileTexture(o.width), e.texture ? e.texture.update(o, { useMipmap: !0 }) : (e.texture = new v(t, o, r.RGBA, { useMipmap: !0 }), e.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE, r.LINEAR_MIPMAP_NEAREST)), e.state = "loaded"; } } catch (t) { if (delete e.abortController, e.aborted) e.state = "unloaded"; else if (t) throw e.state = "errored", t } })) } abortTile(e) { return t._(this, void 0, void 0, (function* () { e.abortController && (e.abortController.abort(), delete e.abortController); })) } unloadTile(e) { return t._(this, void 0, void 0, (function* () { e.texture && this.map.painter.saveTileTexture(e.texture); })) } hasTransition() { return !1 } } class X extends W { constructor(e, i, r, o) { super(e, i, r, o), this.type = "raster-dem", this.maxzoom = 22, this._options = t.e({ type: "raster-dem" }, i), this.encoding = i.encoding || "mapbox", this.redFactor = i.redFactor, this.greenFactor = i.greenFactor, this.blueFactor = i.blueFactor, this.baseShift = i.baseShift; } loadTile(e) { return t._(this, void 0, void 0, (function* () { const i = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), r = this.map._requestManager.transformRequest(i, "Tile"); e.neighboringTiles = this._getNeighboringTiles(e.tileID), e.abortController = new AbortController; try { const i = yield p.getImage(r, e.abortController, this.map._refreshExpiredTiles); if (delete e.abortController, e.aborted) return void (e.state = "unloaded"); if (i && i.data) { const r = i.data; this.map._refreshExpiredTiles && i.cacheControl && i.expires && e.setExpiryData({ cacheControl: i.cacheControl, expires: i.expires }); const o = t.b(r) && t.U() ? r : yield this.readImageNow(r), s = { type: this.type, uid: e.uid, source: this.id, rawImageData: o, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift }; if (!e.actor || "expired" === e.state) { e.actor = this.dispatcher.getActor(); const t = yield e.actor.sendAsync({ type: "LDT", data: s }); e.dem = t, e.needsHillshadePrepare = !0, e.needsTerrainPrepare = !0, e.state = "loaded"; } } } catch (t) { if (delete e.abortController, e.aborted) e.state = "unloaded"; else if (t) throw e.state = "errored", t } })) } readImageNow(e) { return t._(this, void 0, void 0, (function* () { if ("undefined" != typeof VideoFrame && t.V()) { const i = e.width + 2, r = e.height + 2; try { return new t.R({ width: i, height: r }, yield t.W(e, -1, -1, i, r)) } catch (e) { } } return a.getImageData(e, 1) })) } _getNeighboringTiles(e) { const i = e.canonical, r = Math.pow(2, i.z), o = (i.x - 1 + r) % r, s = 0 === i.x ? e.wrap - 1 : e.wrap, a = (i.x + 1 + r) % r, n = i.x + 1 === r ? e.wrap + 1 : e.wrap, l = {}; return l[new t.S(e.overscaledZ, s, i.z, o, i.y).key] = { backfilled: !1 }, l[new t.S(e.overscaledZ, n, i.z, a, i.y).key] = { backfilled: !1 }, i.y > 0 && (l[new t.S(e.overscaledZ, s, i.z, o, i.y - 1).key] = { backfilled: !1 }, l[new t.S(e.overscaledZ, e.wrap, i.z, i.x, i.y - 1).key] = { backfilled: !1 }, l[new t.S(e.overscaledZ, n, i.z, a, i.y - 1).key] = { backfilled: !1 }), i.y + 1 < r && (l[new t.S(e.overscaledZ, s, i.z, o, i.y + 1).key] = { backfilled: !1 }, l[new t.S(e.overscaledZ, e.wrap, i.z, i.x, i.y + 1).key] = { backfilled: !1 }, l[new t.S(e.overscaledZ, n, i.z, a, i.y + 1).key] = { backfilled: !1 }), l } unloadTile(e) { return t._(this, void 0, void 0, (function* () { e.demTexture && this.map.painter.saveTileTexture(e.demTexture), e.fbo && (e.fbo.destroy(), delete e.fbo), e.dem && delete e.dem, delete e.neighboringTiles, e.state = "unloaded", e.actor && (yield e.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: e.uid, source: this.id } })); })) } } class $ extends t.E { constructor(e, i, r, o) { super(), this.id = e, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._pendingLoads = 0, this.actor = r.getActor(), this.setEventedParent(o), this._data = i.data, this._options = t.e({}, i), this._collectResourceTiming = i.collectResourceTiming, void 0 !== i.maxzoom && (this.maxzoom = i.maxzoom), i.type && (this.type = i.type), i.attribution && (this.attribution = i.attribution), this.promoteId = i.promoteId, void 0 !== i.clusterMaxZoom && this.maxzoom <= i.clusterMaxZoom && t.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${i.clusterMaxZoom}".`), this.workerOptions = t.e({ source: this.id, cluster: i.cluster || !1, geojsonVtOptions: { buffer: this._pixelsToTileUnits(void 0 !== i.buffer ? i.buffer : 128), tolerance: this._pixelsToTileUnits(void 0 !== i.tolerance ? i.tolerance : .375), extent: t.X, maxZoom: this.maxzoom, lineMetrics: i.lineMetrics || !1, generateId: i.generateId || !1 }, superclusterOptions: { maxZoom: void 0 !== i.clusterMaxZoom ? i.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, i.clusterMinPoints || 2), extent: t.X, radius: this._pixelsToTileUnits(i.clusterRadius || 50), log: !1, generateId: i.generateId || !1 }, clusterProperties: i.clusterProperties, filter: i.filter }, i.workerOptions), "string" == typeof this.promoteId && (this.workerOptions.promoteId = this.promoteId); } _pixelsToTileUnits(e) { return e * (t.X / this.tileSize) } load() { return t._(this, void 0, void 0, (function* () { yield this._updateWorkerData(); })) } onAdd(e) { this.map = e, this.load(); } setData(e) { return this._data = e, this._updateWorkerData(), this } updateData(e) { return this._updateWorkerData(e), this } getData() { return t._(this, void 0, void 0, (function* () { const e = t.e({ type: this.type }, this.workerOptions); return this.actor.sendAsync({ type: "GD", data: e }) })) } setClusterOptions(e) { return this.workerOptions.cluster = e.cluster, e && (void 0 !== e.clusterRadius && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(e.clusterRadius)), void 0 !== e.clusterMaxZoom && (this.workerOptions.superclusterOptions.maxZoom = e.clusterMaxZoom)), this._updateWorkerData(), this } getClusterExpansionZoom(e) { return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: e, source: this.id } }) } getClusterChildren(e) { return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: e, source: this.id } }) } getClusterLeaves(e, t, i) { return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: e, limit: t, offset: i } }) } _updateWorkerData(e) { return t._(this, void 0, void 0, (function* () { const i = t.e({ type: this.type }, this.workerOptions); e ? i.dataDiff = e : "string" == typeof this._data ? (i.request = this.map._requestManager.transformRequest(a.resolveURL(this._data), "Source"), i.request.collectResourceTiming = this._collectResourceTiming) : i.data = JSON.stringify(this._data), this._pendingLoads++, this.fire(new t.k("dataloading", { dataType: "source" })); try { const e = yield this.actor.sendAsync({ type: "LD", data: i }); if (this._pendingLoads--, this._removed || e.abandoned) return void this.fire(new t.k("dataabort", { dataType: "source" })); let r = null; e.resourceTiming && e.resourceTiming[this.id] && (r = e.resourceTiming[this.id].slice(0)); const o = { dataType: "source" }; this._collectResourceTiming && r && r.length > 0 && t.e(o, { resourceTiming: r }), this.fire(new t.k("data", Object.assign(Object.assign({}, o), { sourceDataType: "metadata" }))), this.fire(new t.k("data", Object.assign(Object.assign({}, o), { sourceDataType: "content" }))); } catch (e) { if (this._pendingLoads--, this._removed) return void this.fire(new t.k("dataabort", { dataType: "source" })); this.fire(new t.j(e)); } })) } loaded() { return 0 === this._pendingLoads } loadTile(e) { return t._(this, void 0, void 0, (function* () { const t = e.actor ? "RT" : "LT"; e.actor = this.actor; const i = { type: this.type, uid: e.uid, tileID: e.tileID, zoom: e.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity }; e.abortController = new AbortController; const r = yield this.actor.sendAsync({ type: t, data: i }, e.abortController); delete e.abortController, e.unloadVectorData(), e.aborted || e.loadVectorData(r, this.map.painter, "RT" === t); })) } abortTile(e) { return t._(this, void 0, void 0, (function* () { e.abortController && (e.abortController.abort(), delete e.abortController), e.aborted = !0; })) } unloadTile(e) { return t._(this, void 0, void 0, (function* () { e.unloadVectorData(), yield this.actor.sendAsync({ type: "RMT", data: { uid: e.uid, type: this.type, source: this.id } }); })) } onRemove() { this._removed = !0, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } }); } serialize() { return t.e({}, this._options, { type: this.type, data: this._data }) } hasTransition() { return !1 } } class K extends t.E { constructor(e, t, i, r) { super(), this.flippedWindingOrder = !1, this.id = e, this.dispatcher = i, this.coordinates = t.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(r), this.options = t; } load(e) { return t._(this, void 0, void 0, (function* () { this._loaded = !1, this.fire(new t.k("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController; try { const t = yield p.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request); this._request = null, this._loaded = !0, t && t.data && (this.image = t.data, e && (this.coordinates = e), this._finishLoading()); } catch (e) { this._request = null, this._loaded = !0, this.fire(new t.j(e)); } })) } loaded() { return this._loaded } updateImage(e) { return e.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = e.url, this.load(e.coordinates).finally((() => { this.texture = null; })), this) : this } _finishLoading() { this.map && (this.setCoordinates(this.coordinates), this.fire(new t.k("data", { dataType: "source", sourceDataType: "metadata" }))); } onAdd(e) { this.map = e, this.load(); } onRemove() { this._request && (this._request.abort(), this._request = null); } setCoordinates(e) { this.coordinates = e; const i = e.map(t.Y.fromLngLat); var r; return this.tileID = function (e) { let i = 1 / 0, r = 1 / 0, o = -1 / 0, s = -1 / 0; for (const t of e) i = Math.min(i, t.x), r = Math.min(r, t.y), o = Math.max(o, t.x), s = Math.max(s, t.y); const a = Math.max(o - i, s - r), n = Math.max(0, Math.floor(-Math.log(a) / Math.LN2)), l = Math.pow(2, n); return new t.Z(n, Math.floor((i + o) / 2 * l), Math.floor((r + s) / 2 * l)) }(i), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = i.map((e => this.tileID.getTilePoint(e)._round())), this.flippedWindingOrder = ((r = this.tileCoords)[1].x - r[0].x) * (r[2].y - r[0].y) - (r[1].y - r[0].y) * (r[2].x - r[0].x) < 0, this.fire(new t.k("data", { dataType: "source", sourceDataType: "content" })), this } prepare() { if (0 === Object.keys(this.tiles).length || !this.image) return; const e = this.map.painter.context, i = e.gl; this.texture || (this.texture = new v(e, this.image, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE)); let r = !1; for (const e in this.tiles) { const t = this.tiles[e]; "loaded" !== t.state && (t.state = "loaded", t.texture = this.texture, r = !0); } r && this.fire(new t.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id })); } loadTile(e) { return t._(this, void 0, void 0, (function* () { this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e, e.buckets = {}) : e.state = "errored"; })) } serialize() { return { type: "image", url: this.options.url, coordinates: this.coordinates } } hasTransition() { return !1 } } class Y extends K { constructor(e, t, i, r) { super(e, t, i, r), this.roundZoom = !0, this.type = "video", this.options = t; } load() { return t._(this, void 0, void 0, (function* () { this._loaded = !1; const e = this.options; this.urls = []; for (const t of e.urls) this.urls.push(this.map._requestManager.transformRequest(t, "Source").url); try { const e = yield t.a0(this.urls); if (this._loaded = !0, !e) return; this.video = e, this.video.loop = !0, this.video.addEventListener("playing", (() => { this.map.triggerRepaint(); })), this.map && this.video.play(), this._finishLoading(); } catch (e) { this.fire(new t.j(e)); } })) } pause() { this.video && this.video.pause(); } play() { this.video && this.video.play(); } seek(e) { if (this.video) { const i = this.video.seekable; e < i.start(0) || e > i.end(0) ? this.fire(new t.j(new t.$(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i.start(0)} and ${i.end(0)}-second mark.`))) : this.video.currentTime = e; } } getVideo() { return this.video } onAdd(e) { this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates))); } prepare() { if (0 === Object.keys(this.tiles).length || this.video.readyState < 2) return; const e = this.map.painter.context, i = e.gl; this.texture ? this.video.paused || (this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, i.RGBA, i.UNSIGNED_BYTE, this.video)) : (this.texture = new v(e, this.video, i.RGBA), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE)); let r = !1; for (const e in this.tiles) { const t = this.tiles[e]; "loaded" !== t.state && (t.state = "loaded", t.texture = this.texture, r = !0); } r && this.fire(new t.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id })); } serialize() { return { type: "video", urls: this.urls, coordinates: this.coordinates } } hasTransition() { return this.video && !this.video.paused } } class J extends K { constructor(e, i, r, o) { super(e, i, r, o), i.coordinates ? Array.isArray(i.coordinates) && 4 === i.coordinates.length && !i.coordinates.some((e => !Array.isArray(e) || 2 !== e.length || e.some((e => "number" != typeof e)))) || this.fire(new t.j(new t.$(`sources.${e}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new t.j(new t.$(`sources.${e}`, null, 'missing required property "coordinates"'))), i.animate && "boolean" != typeof i.animate && this.fire(new t.j(new t.$(`sources.${e}`, null, 'optional "animate" property must be a boolean value'))), i.canvas ? "string" == typeof i.canvas || i.canvas instanceof HTMLCanvasElement || this.fire(new t.j(new t.$(`sources.${e}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new t.j(new t.$(`sources.${e}`, null, 'missing required property "canvas"'))), this.options = i, this.animate = void 0 === i.animate || i.animate; } load() { return t._(this, void 0, void 0, (function* () { this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new t.j(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function () { this._playing = !0, this.map.triggerRepaint(); }, this.pause = function () { this._playing && (this.prepare(), this._playing = !1); }, this._finishLoading()); })) } getCanvas() { return this.canvas } onAdd(e) { this.map = e, this.load(), this.canvas && this.animate && this.play(); } onRemove() { this.pause(); } prepare() { let e = !1; if (this.canvas.width !== this.width && (this.width = this.canvas.width, e = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, e = !0), this._hasInvalidDimensions()) return; if (0 === Object.keys(this.tiles).length) return; const i = this.map.painter.context, r = i.gl; this.texture ? (e || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new v(i, this.canvas, r.RGBA, { premultiply: !0 }); let o = !1; for (const e in this.tiles) { const t = this.tiles[e]; "loaded" !== t.state && (t.state = "loaded", t.texture = this.texture, o = !0); } o && this.fire(new t.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id })); } serialize() { return { type: "canvas", coordinates: this.coordinates } } hasTransition() { return this._playing } _hasInvalidDimensions() { for (const e of [this.canvas.width, this.canvas.height]) if (isNaN(e) || e <= 0) return !0; return !1 } } const Q = {}, ee = e => { switch (e) { case "geojson": return $; case "image": return K; case "raster": return W; case "raster-dem": return X; case "vector": return H; case "video": return Y; case "canvas": return J }return Q[e] }, te = "RTLPluginLoaded"; class ie extends t.E { constructor() { super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = j(); } _syncState(e) { return this.status = e, this.dispatcher.broadcast("SRPS", { pluginStatus: e, pluginURL: this.url }).catch((e => { throw this.status = "error", e })) } getRTLTextPluginStatus() { return this.status } clearRTLTextPlugin() { this.status = "unavailable", this.url = null; } setRTLTextPlugin(e) { return t._(this, arguments, void 0, (function* (e, t = !1) { if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times."); if (this.url = a.resolveURL(e), !this.url) throw new Error(`requested url ${e} is invalid`); if ("unavailable" === this.status) { if (!t) return this._requestImport(); this.status = "deferred", this._syncState(this.status); } else if ("requested" === this.status) return this._requestImport() })) } _requestImport() { return t._(this, void 0, void 0, (function* () { yield this._syncState("loading"), this.status = "loaded", this.fire(new t.k(te)); })) } lazyLoad() { "unavailable" === this.status ? this.status = "requested" : "deferred" === this.status && this._requestImport(); } } let re = null; function oe() { return re || (re = new ie), re } class se { constructor(e, i) { this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = e, this.uid = t.a1(), this.uses = 0, this.tileSize = i, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading"; } registerFadeDuration(e) { const t = e + this.timeAdded; t < this.fadeEndTime || (this.fadeEndTime = t); } wasRequested() { return "errored" === this.state || "loaded" === this.state || "reloading" === this.state } clearTextures(e) { this.demTexture && e.saveTileTexture(this.demTexture), this.demTexture = null; } loadVectorData(e, i, r) { if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e) { e.featureIndex && (this.latestFeatureIndex = e.featureIndex, e.rawTileData ? (this.latestRawTileData = e.rawTileData, this.latestFeatureIndex.rawTileData = e.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e.collisionBoxArray, this.buckets = function (e, t) { const i = {}; if (!t) return i; for (const r of e) { const e = r.layerIds.map((e => t.getLayer(e))).filter(Boolean); if (0 !== e.length) { r.layers = e, r.stateDependentLayerIds && (r.stateDependentLayers = r.stateDependentLayerIds.map((t => e.filter((e => e.id === t))[0]))); for (const t of e) i[t.id] = r; } } return i }(e.buckets, null == i ? void 0 : i.style), this.hasSymbolBuckets = !1; for (const e in this.buckets) { const i = this.buckets[e]; if (i instanceof t.a3) { if (this.hasSymbolBuckets = !0, !r) break; i.justReloaded = !0; } } if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const e in this.buckets) { const i = this.buckets[e]; if (i instanceof t.a3 && i.hasRTLText) { this.hasRTLText = !0, oe().lazyLoad(); break } } this.queryPadding = 0; for (const e in this.buckets) { const t = this.buckets[e]; this.queryPadding = Math.max(this.queryPadding, i.style.getLayer(e).queryRadius(t)); } e.imageAtlas && (this.imageAtlas = e.imageAtlas), e.glyphAtlasImage && (this.glyphAtlasImage = e.glyphAtlasImage); } else this.collisionBoxArray = new t.a2; } unloadVectorData() { for (const e in this.buckets) this.buckets[e].destroy(); this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded"; } getBucket(e) { return this.buckets[e.id] } upload(e) { for (const t in this.buckets) { const i = this.buckets[t]; i.uploadPending() && i.upload(e); } const t = e.gl; this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new v(e, this.imageAtlas.image, t.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new v(e, this.glyphAtlasImage, t.ALPHA), this.glyphAtlasImage = null); } prepare(e) { this.imageAtlas && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture); } queryRenderedFeatures(e, t, i, r, o, s, a, n, l, c) { return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: r, cameraQueryGeometry: o, scale: s, tileSize: this.tileSize, pixelPosMatrix: c, transform: n, params: a, queryPadding: this.queryPadding * l }, e, t, i) : {} } querySourceFeatures(e, i) { const r = this.latestFeatureIndex; if (!r || !r.rawTileData) return; const o = r.loadVTLayers(), s = i && i.sourceLayer ? i.sourceLayer : "", a = o._geojsonTileLayer || o[s]; if (!a) return; const n = t.a4(i && i.filter), { z: l, x: c, y: h } = this.tileID.canonical, u = { z: l, x: c, y: h }; for (let i = 0; i < a.length; i++) { const o = a.feature(i); if (n.needGeometry) { const e = t.a5(o, !0); if (!n.filter(new t.z(this.tileID.overscaledZ), e, this.tileID.canonical)) continue } else if (!n.filter(new t.z(this.tileID.overscaledZ), o)) continue; const d = r.getId(o, s), _ = new t.a6(o, l, c, h, d); _.tile = u, e.push(_); } } hasData() { return "loaded" === this.state || "reloading" === this.state || "expired" === this.state } patternsLoaded() { return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length } setExpiryData(e) { const i = this.expirationTime; if (e.cacheControl) { const i = t.a7(e.cacheControl); i["max-age"] && (this.expirationTime = Date.now() + 1e3 * i["max-age"]); } else e.expires && (this.expirationTime = new Date(e.expires).getTime()); if (this.expirationTime) { const e = Date.now(); let t = !1; if (this.expirationTime > e) t = !1; else if (i) if (this.expirationTime < i) t = !0; else { const r = this.expirationTime - i; r ? this.expirationTime = e + Math.max(r, 3e4) : t = !0; } else t = !0; t ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0; } } getExpiryTimeout() { if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (new Date).getTime(), Math.pow(2, 31) - 1) } setFeatureState(e, t) { if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(e).length) return; const i = this.latestFeatureIndex.loadVTLayers(); for (const r in this.buckets) { if (!t.style.hasLayer(r)) continue; const o = this.buckets[r], s = o.layers[0].sourceLayer || "_geojsonTileLayer", a = i[s], n = e[s]; if (!a || !n || 0 === Object.keys(n).length) continue; o.update(n, a, this.imageAtlas && this.imageAtlas.patternPositions || {}); const l = t && t.style && t.style.getLayer(r); l && (this.queryPadding = Math.max(this.queryPadding, l.queryRadius(o))); } } holdingForFade() { return void 0 !== this.symbolFadeHoldUntil } symbolFadeFinished() { return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < a.now() } clearFadeHold() { this.symbolFadeHoldUntil = void 0; } setHoldDuration(e) { this.symbolFadeHoldUntil = a.now() + e; } setDependencies(e, t) { const i = {}; for (const e of t) i[e] = !0; this.dependencies[e] = i; } hasDependency(e, t) { for (const i of e) { const e = this.dependencies[i]; if (e) for (const i of t) if (e[i]) return !0 } return !1 } } class ae { constructor(e, t) { this.max = e, this.onRemove = t, this.reset(); } reset() { for (const e in this.data) for (const t of this.data[e]) t.timeout && clearTimeout(t.timeout), this.onRemove(t.value); return this.data = {}, this.order = [], this } add(e, t, i) { const r = e.wrapped().key; void 0 === this.data[r] && (this.data[r] = []); const o = { value: t, timeout: void 0 }; if (void 0 !== i && (o.timeout = setTimeout((() => { this.remove(e, o); }), i)), this.data[r].push(o), this.order.push(r), this.order.length > this.max) { const e = this._getAndRemoveByKey(this.order[0]); e && this.onRemove(e); } return this } has(e) { return e.wrapped().key in this.data } getAndRemove(e) { return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null } _getAndRemoveByKey(e) { const t = this.data[e].shift(); return t.timeout && clearTimeout(t.timeout), 0 === this.data[e].length && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), t.value } getByKey(e) { const t = this.data[e]; return t ? t[0].value : null } get(e) { return this.has(e) ? this.data[e.wrapped().key][0].value : null } remove(e, t) { if (!this.has(e)) return this; const i = e.wrapped().key, r = void 0 === t ? 0 : this.data[i].indexOf(t), o = this.data[i][r]; return this.data[i].splice(r, 1), o.timeout && clearTimeout(o.timeout), 0 === this.data[i].length && delete this.data[i], this.onRemove(o.value), this.order.splice(this.order.indexOf(i), 1), this } setMaxSize(e) { for (this.max = e; this.order.length > this.max;) { const e = this._getAndRemoveByKey(this.order[0]); e && this.onRemove(e); } return this } filter(e) { const t = []; for (const i in this.data) for (const r of this.data[i]) e(r.value) || t.push(r); for (const e of t) this.remove(e.value.tileID, e); } } class ne { constructor() { this.state = {}, this.stateChanges = {}, this.deletedStates = {}; } updateState(e, i, r) { const o = String(i); if (this.stateChanges[e] = this.stateChanges[e] || {}, this.stateChanges[e][o] = this.stateChanges[e][o] || {}, t.e(this.stateChanges[e][o], r), null === this.deletedStates[e]) { this.deletedStates[e] = {}; for (const t in this.state[e]) t !== o && (this.deletedStates[e][t] = null); } else if (this.deletedStates[e] && null === this.deletedStates[e][o]) { this.deletedStates[e][o] = {}; for (const t in this.state[e][o]) r[t] || (this.deletedStates[e][o][t] = null); } else for (const t in r) this.deletedStates[e] && this.deletedStates[e][o] && null === this.deletedStates[e][o][t] && delete this.deletedStates[e][o][t]; } removeFeatureState(e, t, i) { if (null === this.deletedStates[e]) return; const r = String(t); if (this.deletedStates[e] = this.deletedStates[e] || {}, i && void 0 !== t) null !== this.deletedStates[e][r] && (this.deletedStates[e][r] = this.deletedStates[e][r] || {}, this.deletedStates[e][r][i] = null); else if (void 0 !== t) if (this.stateChanges[e] && this.stateChanges[e][r]) for (i in this.deletedStates[e][r] = {}, this.stateChanges[e][r]) this.deletedStates[e][r][i] = null; else this.deletedStates[e][r] = null; else this.deletedStates[e] = null; } getState(e, i) { const r = String(i), o = t.e({}, (this.state[e] || {})[r], (this.stateChanges[e] || {})[r]); if (null === this.deletedStates[e]) return {}; if (this.deletedStates[e]) { const t = this.deletedStates[e][i]; if (null === t) return {}; for (const e in t) delete o[e]; } return o } initializeTileState(e, t) { e.setFeatureState(this.state, t); } coalesceChanges(e, i) { const r = {}; for (const e in this.stateChanges) { this.state[e] = this.state[e] || {}; const i = {}; for (const r in this.stateChanges[e]) this.state[e][r] || (this.state[e][r] = {}), t.e(this.state[e][r], this.stateChanges[e][r]), i[r] = this.state[e][r]; r[e] = i; } for (const e in this.deletedStates) { this.state[e] = this.state[e] || {}; const i = {}; if (null === this.deletedStates[e]) for (const t in this.state[e]) i[t] = {}, this.state[e][t] = {}; else for (const t in this.deletedStates[e]) { if (null === this.deletedStates[e][t]) this.state[e][t] = {}; else for (const i of Object.keys(this.deletedStates[e][t])) delete this.state[e][t][i]; i[t] = this.state[e][t]; } r[e] = r[e] || {}, t.e(r[e], i); } if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(r).length) for (const t in e) e[t].setFeatureState(r, i); } } function le(e, t, i) { const r = t.intersectsFrustum(e); if (!i) return r; const o = t.intersectsPlane(i); return 0 === r || 0 === o ? 0 : 2 === r && 2 === o ? 2 : 1 } function ce(e, i, r, o, s) { let a = e; const n = Math.atan(i / r), l = Math.hypot(i, r); return a = e + t.a8(o / l / Math.max(.5, Math.cos(t.aa(s / 2)))), a += 1 * t.a8(Math.cos(n)) / 2, a += t.ab(e - a, -0, 0), a } function he(e, i) { const r = (i.roundZoom ? Math.round : Math.floor)(e.zoom + t.a8(e.tileSize / i.tileSize)); return Math.max(0, r) } function ue(e, i) { const r = e.getCameraFrustum(), o = e.getClippingPlane(), s = e.screenPointToMercatorCoordinate(e.getCameraPoint()), a = t.Y.fromLngLat(e.center, e.elevation); s.z = a.z + Math.cos(e.pitchInRadians) * e.cameraToCenterDistance / e.worldSize; const n = e.getCoveringTilesDetailsProvider(), l = n.allowVariableZoom(e, i), c = he(e, i), h = i.minzoom || 0, u = void 0 !== i.maxzoom ? i.maxzoom : e.maxZoom, d = Math.min(Math.max(0, c), u), _ = Math.pow(2, d), p = [_ * s.x, _ * s.y, 0], m = [_ * a.x, _ * a.y, 0], f = Math.hypot(a.x - s.x, a.y - s.y), g = Math.abs(a.z - s.z), v = Math.hypot(f, g), x = e => ({ zoom: 0, x: 0, y: 0, wrap: e, fullyVisible: !1 }), b = [], y = []; if (e.renderWorldCopies && n.allowWorldCopies()) for (let e = 1; e <= 3; e++)b.push(x(-e)), b.push(x(e)); for (b.push(x(0)); b.length > 0;) { const _ = b.pop(), f = _.x, x = _.y; let w = _.fullyVisible; const T = { x: f, y: x, z: _.zoom }, P = n.getTileAABB(T, _.wrap, e.elevation, i); if (!w) { const e = le(r, P, o); if (0 === e) continue; w = 2 === e; } const C = n.distanceToTile2d(s.x, s.y, T, P); let I = c; l && (I = (i.calculateTileZoom || ce)(e.zoom + t.a8(e.tileSize / i.tileSize), C, g, v, e.fov)), I = (i.roundZoom ? Math.round : Math.floor)(I), I = Math.max(0, I); const E = Math.min(I, u); if (_.wrap = n.getWrap(a, T, _.wrap), _.zoom >= E) { if (_.zoom < h) continue; const e = d - _.zoom, r = p[0] - .5 - (f << e), o = p[1] - .5 - (x << e), s = i.reparseOverscaled ? Math.max(_.zoom, I) : _.zoom; y.push({ tileID: new t.S(_.zoom === u ? s : _.zoom, _.wrap, _.zoom, f, x), distanceSq: t.a9([m[0] - .5 - f, m[1] - .5 - x]), tileDistanceToCamera: Math.sqrt(r * r + o * o) }); } else for (let e = 0; e < 4; e++)b.push({ zoom: _.zoom + 1, x: (f << 1) + e % 2, y: (x << 1) + (e >> 1), wrap: _.wrap, fullyVisible: w }); } return y.sort(((e, t) => e.distanceSq - t.distanceSq)).map((e => e.tileID)) } class de extends t.E { constructor(e, t, i) { super(), this.id = e, this.dispatcher = i, this.on("data", (e => this._dataHandler(e))), this.on("dataloading", (() => { this._sourceErrored = !1; })), this.on("error", (() => { this._sourceErrored = this._source.loaded(); })), this._source = ((e, t, i, r) => { const o = new (ee(t.type))(e, t, i, r); if (o.id !== e) throw new Error(`Expected Source id to be ${e} instead of ${o.id}`); return o })(e, t, i, this), this._tiles = {}, this._cache = new ae(0, (e => this._unloadTile(e))), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new ne, this._didEmitContent = !1, this._updated = !1; } onAdd(e) { this.map = e, this._maxTileCacheSize = e ? e._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e ? e._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e); } onRemove(e) { this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e); } loaded() { if (this._sourceErrored) return !0; if (!this._sourceLoaded) return !1; if (!this._source.loaded()) return !1; if (!(void 0 === this.used && void 0 === this.usedForTerrain || this.used || this.usedForTerrain)) return !0; if (!this._updated) return !1; for (const e in this._tiles) { const t = this._tiles[e]; if ("loaded" !== t.state && "errored" !== t.state) return !1 } return !0 } getSource() { return this._source } pause() { this._paused = !0; } resume() { if (!this._paused) return; const e = this._shouldReloadOnResume; this._paused = !1, this._shouldReloadOnResume = !1, e && this.reload(), this.transform && this.update(this.transform, this.terrain); } _loadTile(e, i, r) { return t._(this, void 0, void 0, (function* () { try { yield this._source.loadTile(e), this._tileLoaded(e, i, r); } catch (i) { e.state = "errored", 404 !== i.status ? this._source.fire(new t.j(i, { tile: e })) : this.update(this.transform, this.terrain); } })) } _unloadTile(e) { this._source.unloadTile && this._source.unloadTile(e); } _abortTile(e) { this._source.abortTile && this._source.abortTile(e), this._source.fire(new t.k("dataabort", { tile: e, coord: e.tileID, dataType: "source" })); } serialize() { return this._source.serialize() } prepare(e) { this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null); for (const t in this._tiles) { const i = this._tiles[t]; i.upload(e), i.prepare(this.map.style.imageManager); } } getIds() { return Object.values(this._tiles).map((e => e.tileID)).sort(_e).map((e => e.key)) } getRenderableIds(e) { const i = []; for (const t in this._tiles) this._isIdRenderable(t, e) && i.push(this._tiles[t]); return e ? i.sort(((e, i) => { const r = e.tileID, o = i.tileID, s = new t.P(r.canonical.x, r.canonical.y)._rotate(-this.transform.bearingInRadians), a = new t.P(o.canonical.x, o.canonical.y)._rotate(-this.transform.bearingInRadians); return r.overscaledZ - o.overscaledZ || a.y - s.y || a.x - s.x })).map((e => e.tileID.key)) : i.map((e => e.tileID)).sort(_e).map((e => e.key)) } hasRenderableParent(e) { const t = this.findLoadedParent(e, 0); return !!t && this._isIdRenderable(t.tileID.key) } _isIdRenderable(e, t) { return this._tiles[e] && this._tiles[e].hasData() && !this._coveredTiles[e] && (t || !this._tiles[e].holdingForFade()) } reload(e) { if (this._paused) this._shouldReloadOnResume = !0; else { this._cache.reset(); for (const t in this._tiles) (e || "errored" !== this._tiles[t].state) && this._reloadTile(t, "reloading"); } } _reloadTile(e, i) { return t._(this, void 0, void 0, (function* () { const t = this._tiles[e]; t && ("loading" !== t.state && (t.state = i), yield this._loadTile(t, e, i)); })) } _tileLoaded(e, i, r) { e.timeAdded = a.now(), "expired" === r && (e.refreshedUponExpiration = !0), this._setTileReloadTimer(i, e), "raster-dem" === this.getSource().type && e.dem && this._backfillDEM(e), this._state.initializeTileState(e, this.map ? this.map.painter : null), e.aborted || this._source.fire(new t.k("data", { dataType: "source", tile: e, coord: e.tileID })); } _backfillDEM(e) { const t = this.getRenderableIds(); for (let r = 0; r < t.length; r++) { const o = t[r]; if (e.neighboringTiles && e.neighboringTiles[o]) { const t = this.getTileByID(o); i(e, t), i(t, e); } } function i(e, t) { e.needsHillshadePrepare = !0, e.needsTerrainPrepare = !0; let i = t.tileID.canonical.x - e.tileID.canonical.x; const r = t.tileID.canonical.y - e.tileID.canonical.y, o = Math.pow(2, e.tileID.canonical.z), s = t.tileID.key; 0 === i && 0 === r || Math.abs(r) > 1 || (Math.abs(i) > 1 && (1 === Math.abs(i + o) ? i += o : 1 === Math.abs(i - o) && (i -= o)), t.dem && e.dem && (e.dem.backfillBorder(t.dem, i, r), e.neighboringTiles && e.neighboringTiles[s] && (e.neighboringTiles[s].backfilled = !0))); } } getTile(e) { return this.getTileByID(e.key) } getTileByID(e) { return this._tiles[e] } _retainLoadedChildren(e, t, i, r) { for (const o in this._tiles) { let s = this._tiles[o]; if (r[o] || !s.hasData() || s.tileID.overscaledZ <= t || s.tileID.overscaledZ > i) continue; let a = s.tileID; for (; s && s.tileID.overscaledZ > t + 1;) { const e = s.tileID.scaledTo(s.tileID.overscaledZ - 1); s = this._tiles[e.key], s && s.hasData() && (a = e); } let n = a; for (; n.overscaledZ > t;)if (n = n.scaledTo(n.overscaledZ - 1), e[n.key] || e[n.canonical.key]) { r[a.key] = a; break } } } findLoadedParent(e, t) { if (e.key in this._loadedParentTiles) { const i = this._loadedParentTiles[e.key]; return i && i.tileID.overscaledZ >= t ? i : null } for (let i = e.overscaledZ - 1; i >= t; i--) { const t = e.scaledTo(i), r = this._getLoadedTile(t); if (r) return r } } findLoadedSibling(e) { return this._getLoadedTile(e) } _getLoadedTile(e) { const t = this._tiles[e.key]; return t && t.hasData() ? t : this._cache.getByKey(e.wrapped().key) } updateCacheSize(e) { const i = Math.ceil(e.width / this._source.tileSize) + 1, r = Math.ceil(e.height / this._source.tileSize) + 1, o = Math.floor(i * r * (null === this._maxTileCacheZoomLevels ? t.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), s = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, o) : o; this._cache.setMaxSize(s); } handleWrapJump(e) { const t = Math.round((e - (void 0 === this._prevLng ? e : this._prevLng)) / 360); if (this._prevLng = e, t) { const e = {}; for (const i in this._tiles) { const r = this._tiles[i]; r.tileID = r.tileID.unwrapTo(r.tileID.wrap + t), e[r.tileID.key] = r; } this._tiles = e; for (const e in this._timers) clearTimeout(this._timers[e]), delete this._timers[e]; for (const e in this._tiles) this._setTileReloadTimer(e, this._tiles[e]); } } _updateCoveredAndRetainedTiles(e, t, i, r, o, s) { const n = {}, l = {}, c = Object.keys(e), h = a.now(); for (const i of c) { const r = e[i], o = this._tiles[i]; if (!o || 0 !== o.fadeEndTime && o.fadeEndTime <= h) continue; const s = this.findLoadedParent(r, t), a = this.findLoadedSibling(r), c = s || a || null; c && (this._addTile(c.tileID), n[c.tileID.key] = c.tileID), l[i] = r; } this._retainLoadedChildren(l, r, i, e); for (const t in n) e[t] || (this._coveredTiles[t] = !0, e[t] = n[t]); if (s) { const t = {}, i = {}; for (const e of o) this._tiles[e.key].hasData() ? t[e.key] = e : i[e.key] = e; for (const r in i) { const o = i[r].children(this._source.maxzoom); this._tiles[o[0].key] && this._tiles[o[1].key] && this._tiles[o[2].key] && this._tiles[o[3].key] && (t[o[0].key] = e[o[0].key] = o[0], t[o[1].key] = e[o[1].key] = o[1], t[o[2].key] = e[o[2].key] = o[2], t[o[3].key] = e[o[3].key] = o[3], delete i[r]); } for (const r in i) { const o = i[r], s = this.findLoadedParent(o, this._source.minzoom), a = this.findLoadedSibling(o), n = s || a || null; if (n) { t[n.tileID.key] = e[n.tileID.key] = n.tileID; for (const e in t) t[e].isChildOf(n.tileID) && delete t[e]; } } for (const e in this._tiles) t[e] || (this._coveredTiles[e] = !0); } } update(e, i) { if (!this._sourceLoaded || this._paused) return; let r; this.transform = e, this.terrain = i, this.updateCacheSize(e), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? r = e.getVisibleUnwrappedCoordinates(this._source.tileID).map((e => new t.S(e.canonical.z, e.wrap, e.canonical.z, e.canonical.x, e.canonical.y))) : (r = ue(e, { tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: i, calculateTileZoom: this._source.calculateTileZoom }), this._source.hasTile && (r = r.filter((e => this._source.hasTile(e))))) : r = []; const o = he(e, this._source), s = Math.max(o - de.maxOverzooming, this._source.minzoom), a = Math.max(o + de.maxUnderzooming, this._source.minzoom); if (this.usedForTerrain) { const e = {}; for (const t of r) if (t.canonical.z > this._source.minzoom) { const i = t.scaledTo(t.canonical.z - 1); e[i.key] = i; const r = t.scaledTo(Math.max(this._source.minzoom, Math.min(t.canonical.z, 5))); e[r.key] = r; } r = r.concat(Object.values(e)); } const n = 0 === r.length && !this._updated && this._didEmitContent; this._updated = !0, n && this.fire(new t.k("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id })); const l = this._updateRetainedTiles(r, o); pe(this._source.type) && this._updateCoveredAndRetainedTiles(l, s, a, o, r, i); for (const e in l) this._tiles[e].clearFadeHold(); const c = t.ac(this._tiles, l); for (const e of c) { const t = this._tiles[e]; t.hasSymbolBuckets && !t.holdingForFade() ? t.setHoldDuration(this.map._fadeDuration) : t.hasSymbolBuckets && !t.symbolFadeFinished() || this._removeTile(e); } this._updateLoadedParentTileCache(), this._updateLoadedSiblingTileCache(); } releaseSymbolFadeTiles() { for (const e in this._tiles) this._tiles[e].holdingForFade() && this._removeTile(e); } _updateRetainedTiles(e, t) { var i; const r = {}, o = {}, s = Math.max(t - de.maxOverzooming, this._source.minzoom), a = Math.max(t + de.maxUnderzooming, this._source.minzoom), n = {}; for (const i of e) { const e = this._addTile(i); r[i.key] = i, e.hasData() || t < this._source.maxzoom && (n[i.key] = i); } this._retainLoadedChildren(n, t, a, r); for (const a of e) { let e = this._tiles[a.key]; if (e.hasData()) continue; if (t + 1 > this._source.maxzoom) { const e = a.children(this._source.maxzoom)[0], t = this.getTile(e); if (t && t.hasData()) { r[e.key] = e; continue } } else { const e = a.children(this._source.maxzoom); if (r[e[0].key] && r[e[1].key] && r[e[2].key] && r[e[3].key]) continue } let n = e.wasRequested(); for (let t = a.overscaledZ - 1; t >= s; --t) { const s = a.scaledTo(t); if (o[s.key]) break; if (o[s.key] = !0, e = this.getTile(s), !e && n && (e = this._addTile(s)), e) { const t = e.hasData(); if ((t || !(null === (i = this.map) || void 0 === i ? void 0 : i.cancelPendingTileRequestsWhileZooming) || n) && (r[s.key] = s), n = e.wasRequested(), t) break } } } return r } _updateLoadedParentTileCache() { this._loadedParentTiles = {}; for (const e in this._tiles) { const t = []; let i, r = this._tiles[e].tileID; for (; r.overscaledZ > 0;) { if (r.key in this._loadedParentTiles) { i = this._loadedParentTiles[r.key]; break } t.push(r.key); const e = r.scaledTo(r.overscaledZ - 1); if (i = this._getLoadedTile(e), i) break; r = e; } for (const e of t) this._loadedParentTiles[e] = i; } } _updateLoadedSiblingTileCache() { this._loadedSiblingTiles = {}; for (const e in this._tiles) { const t = this._tiles[e].tileID, i = this._getLoadedTile(t); this._loadedSiblingTiles[t.key] = i; } } _addTile(e) { let i = this._tiles[e.key]; if (i) return i; i = this._cache.getAndRemove(e), i && (this._setTileReloadTimer(e.key, i), i.tileID = e, this._state.initializeTileState(i, this.map ? this.map.painter : null), this._cacheTimers[e.key] && (clearTimeout(this._cacheTimers[e.key]), delete this._cacheTimers[e.key], this._setTileReloadTimer(e.key, i))); const r = i; return i || (i = new se(e, this._source.tileSize * e.overscaleFactor()), this._loadTile(i, e.key, i.state)), i.uses++, this._tiles[e.key] = i, r || this._source.fire(new t.k("dataloading", { tile: i, coord: i.tileID, dataType: "source" })), i } _setTileReloadTimer(e, t) { e in this._timers && (clearTimeout(this._timers[e]), delete this._timers[e]); const i = t.getExpiryTimeout(); i && (this._timers[e] = setTimeout((() => { this._reloadTile(e, "expired"), delete this._timers[e]; }), i)); } _removeTile(e) { const t = this._tiles[e]; t && (t.uses--, delete this._tiles[e], this._timers[e] && (clearTimeout(this._timers[e]), delete this._timers[e]), t.uses > 0 || (t.hasData() && "reloading" !== t.state ? this._cache.add(t.tileID, t, t.getExpiryTimeout()) : (t.aborted = !0, this._abortTile(t), this._unloadTile(t)))); } _dataHandler(e) { const t = e.sourceDataType; "source" === e.dataType && "metadata" === t && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && "source" === e.dataType && "content" === t && (this.reload(e.sourceDataChanged), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0); } clearTiles() { this._shouldReloadOnResume = !1, this._paused = !1; for (const e in this._tiles) this._removeTile(e); this._cache.reset(); } tilesIn(e, i, r) { const o = [], s = this.transform; if (!s) return o; const a = r ? s.getCameraQueryGeometry(e) : e, n = e.map((e => s.screenPointToMercatorCoordinate(e, this.terrain))), l = a.map((e => s.screenPointToMercatorCoordinate(e, this.terrain))), c = this.getIds(); let h = 1 / 0, u = 1 / 0, d = -1 / 0, _ = -1 / 0; for (const e of l) h = Math.min(h, e.x), u = Math.min(u, e.y), d = Math.max(d, e.x), _ = Math.max(_, e.y); for (let e = 0; e < c.length; e++) { const r = this._tiles[c[e]]; if (r.holdingForFade()) continue; const a = r.tileID, p = Math.pow(2, s.zoom - r.tileID.overscaledZ), m = i * r.queryPadding * t.X / r.tileSize / p, f = [a.getTilePoint(new t.Y(h, u)), a.getTilePoint(new t.Y(d, _))]; if (f[0].x - m < t.X && f[0].y - m < t.X && f[1].x + m >= 0 && f[1].y + m >= 0) { const e = n.map((e => a.getTilePoint(e))), t = l.map((e => a.getTilePoint(e))); o.push({ tile: r, tileID: a, queryGeometry: e, cameraQueryGeometry: t, scale: p }); } } return o } getVisibleCoordinates(e) { const t = this.getRenderableIds(e).map((e => this._tiles[e].tileID)); return this.transform && this.transform.populateCache(t), t } hasTransition() { if (this._source.hasTransition()) return !0; if (pe(this._source.type)) { const e = a.now(); for (const t in this._tiles) if (this._tiles[t].fadeEndTime >= e) return !0 } return !1 } setFeatureState(e, t, i) { this._state.updateState(e = e || "_geojsonTileLayer", t, i); } removeFeatureState(e, t, i) { this._state.removeFeatureState(e = e || "_geojsonTileLayer", t, i); } getFeatureState(e, t) { return this._state.getState(e = e || "_geojsonTileLayer", t) } setDependencies(e, t, i) { const r = this._tiles[e]; r && r.setDependencies(t, i); } reloadTilesForDependencies(e, t) { for (const i in this._tiles) this._tiles[i].hasDependency(e, t) && this._reloadTile(i, "reloading"); this._cache.filter((i => !i.hasDependency(e, t))); } } function _e(e, t) { const i = Math.abs(2 * e.wrap) - +(e.wrap < 0), r = Math.abs(2 * t.wrap) - +(t.wrap < 0); return e.overscaledZ - t.overscaledZ || r - i || t.canonical.y - e.canonical.y || t.canonical.x - e.canonical.x } function pe(e) { return "raster" === e || "image" === e || "video" === e } de.maxOverzooming = 10, de.maxUnderzooming = 3; class me { constructor(e, t) { this.reset(e, t); } reset(e, t) { this.points = e || [], this._distances = [0]; for (let e = 1; e < this.points.length; e++)this._distances[e] = this._distances[e - 1] + this.points[e].dist(this.points[e - 1]); this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding; } lerp(e) { if (1 === this.points.length) return this.points[0]; e = t.ab(e, 0, 1); let i = 1, r = this._distances[i]; const o = e * this.paddedLength + this.padding; for (; r < o && i < this._distances.length;)r = this._distances[++i]; const s = i - 1, a = this._distances[s], n = r - a, l = n > 0 ? (o - a) / n : 0; return this.points[s].mult(1 - l).add(this.points[i].mult(l)) } } function fe(e, t) { let i = !0; return "always" === e || "never" !== e && "never" !== t || (i = !1), i } class ge { constructor(e, t, i) { const r = this.boxCells = [], o = this.circleCells = []; this.xCellCount = Math.ceil(e / i), this.yCellCount = Math.ceil(t / i); for (let e = 0; e < this.xCellCount * this.yCellCount; e++)r.push([]), o.push([]); this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = t, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / t, this.boxUid = 0, this.circleUid = 0; } keysLength() { return this.boxKeys.length + this.circleKeys.length } insert(e, t, i, r, o) { this._forEachCell(t, i, r, o, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(t), this.bboxes.push(i), this.bboxes.push(r), this.bboxes.push(o); } insertCircle(e, t, i, r) { this._forEachCell(t - r, i - r, t + r, i + r, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(t), this.circles.push(i), this.circles.push(r); } _insertBoxCell(e, t, i, r, o, s) { this.boxCells[o].push(s); } _insertCircleCell(e, t, i, r, o, s) { this.circleCells[o].push(s); } _query(e, t, i, r, o, s, a) { if (i < 0 || e > this.width || r < 0 || t > this.height) return []; const n = []; if (e <= 0 && t <= 0 && this.width <= i && this.height <= r) { if (o) return [{ key: null, x1: e, y1: t, x2: i, y2: r }]; for (let e = 0; e < this.boxKeys.length; e++)n.push({ key: this.boxKeys[e], x1: this.bboxes[4 * e], y1: this.bboxes[4 * e + 1], x2: this.bboxes[4 * e + 2], y2: this.bboxes[4 * e + 3] }); for (let e = 0; e < this.circleKeys.length; e++) { const t = this.circles[3 * e], i = this.circles[3 * e + 1], r = this.circles[3 * e + 2]; n.push({ key: this.circleKeys[e], x1: t - r, y1: i - r, x2: t + r, y2: i + r }); } } else this._forEachCell(e, t, i, r, this._queryCell, n, { hitTest: o, overlapMode: s, seenUids: { box: {}, circle: {} } }, a); return n } query(e, t, i, r) { return this._query(e, t, i, r, !1, null) } hitTest(e, t, i, r, o, s) { return this._query(e, t, i, r, !0, o, s).length > 0 } hitTestCircle(e, t, i, r, o) { const s = e - i, a = e + i, n = t - i, l = t + i; if (a < 0 || s > this.width || l < 0 || n > this.height) return !1; const c = []; return this._forEachCell(s, n, a, l, this._queryCellCircle, c, { hitTest: !0, overlapMode: r, circle: { x: e, y: t, radius: i }, seenUids: { box: {}, circle: {} } }, o), c.length > 0 } _queryCell(e, t, i, r, o, s, a, n) { const { seenUids: l, hitTest: c, overlapMode: h } = a, u = this.boxCells[o]; if (null !== u) { const o = this.bboxes; for (const a of u) if (!l.box[a]) { l.box[a] = !0; const u = 4 * a, d = this.boxKeys[a]; if (e <= o[u + 2] && t <= o[u + 3] && i >= o[u + 0] && r >= o[u + 1] && (!n || n(d)) && (!c || !fe(h, d.overlapMode)) && (s.push({ key: d, x1: o[u], y1: o[u + 1], x2: o[u + 2], y2: o[u + 3] }), c)) return !0 } } const d = this.circleCells[o]; if (null !== d) { const o = this.circles; for (const a of d) if (!l.circle[a]) { l.circle[a] = !0; const u = 3 * a, d = this.circleKeys[a]; if (this._circleAndRectCollide(o[u], o[u + 1], o[u + 2], e, t, i, r) && (!n || n(d)) && (!c || !fe(h, d.overlapMode))) { const e = o[u], t = o[u + 1], i = o[u + 2]; if (s.push({ key: d, x1: e - i, y1: t - i, x2: e + i, y2: t + i }), c) return !0 } } } return !1 } _queryCellCircle(e, t, i, r, o, s, a, n) { const { circle: l, seenUids: c, overlapMode: h } = a, u = this.boxCells[o]; if (null !== u) { const e = this.bboxes; for (const t of u) if (!c.box[t]) { c.box[t] = !0; const i = 4 * t, r = this.boxKeys[t]; if (this._circleAndRectCollide(l.x, l.y, l.radius, e[i + 0], e[i + 1], e[i + 2], e[i + 3]) && (!n || n(r)) && !fe(h, r.overlapMode)) return s.push(!0), !0 } } const d = this.circleCells[o]; if (null !== d) { const e = this.circles; for (const t of d) if (!c.circle[t]) { c.circle[t] = !0; const i = 3 * t, r = this.circleKeys[t]; if (this._circlesCollide(e[i], e[i + 1], e[i + 2], l.x, l.y, l.radius) && (!n || n(r)) && !fe(h, r.overlapMode)) return s.push(!0), !0 } } } _forEachCell(e, t, i, r, o, s, a, n) { const l = this._convertToXCellCoord(e), c = this._convertToYCellCoord(t), h = this._convertToXCellCoord(i), u = this._convertToYCellCoord(r); for (let d = l; d <= h; d++)for (let l = c; l <= u; l++)if (o.call(this, e, t, i, r, this.xCellCount * l + d, s, a, n)) return } _convertToXCellCoord(e) { return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale))) } _convertToYCellCoord(e) { return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale))) } _circlesCollide(e, t, i, r, o, s) { const a = r - e, n = o - t, l = i + s; return l * l > a * a + n * n } _circleAndRectCollide(e, t, i, r, o, s, a) { const n = (s - r) / 2, l = Math.abs(e - (r + n)); if (l > n + i) return !1; const c = (a - o) / 2, h = Math.abs(t - (o + c)); if (h > c + i) return !1; if (l <= n || h <= c) return !0; const u = l - n, d = h - c; return u * u + d * d <= i * i } } function ve(e, i, o) { const s = t.H(); if (!e) { const { vecSouth: e, vecEast: t } = be(i), o = r(); o[0] = t[0], o[1] = t[1], o[2] = e[0], o[3] = e[1], a = o, (d = (l = (n = o)[0]) * (u = n[3]) - (h = n[2]) * (c = n[1])) && (a[0] = u * (d = 1 / d), a[1] = -c * d, a[2] = -h * d, a[3] = l * d), s[0] = o[0], s[1] = o[1], s[4] = o[2], s[5] = o[3]; } var a, n, l, c, h, u, d; return t.K(s, s, [1 / o, 1 / o, 1]), s } function xe(e, i, r, o) { if (e) { const e = t.H(); if (!i) { const { vecSouth: t, vecEast: i } = be(r); e[0] = i[0], e[1] = i[1], e[4] = t[0], e[5] = t[1]; } return t.K(e, e, [o, o, 1]), e } return r.pixelsToClipSpaceMatrix } function be(e) { const i = Math.cos(e.rollInRadians), r = Math.sin(e.rollInRadians), o = Math.cos(e.pitchInRadians), s = Math.cos(e.bearingInRadians), a = Math.sin(e.bearingInRadians), n = t.ad(); n[0] = -s * o * r - a * i, n[1] = -a * o * r + s * i; const l = t.ae(n); l < 1e-9 ? t.af(n) : t.ag(n, n, 1 / l); const c = t.ad(); c[0] = s * o * i - a * r, c[1] = a * o * i + s * r; const h = t.ae(c); return h < 1e-9 ? t.af(c) : t.ag(c, c, 1 / h), { vecEast: c, vecSouth: n } } function ye(e, i, r, o) { let s; o ? (s = [e, i, o(e, i), 1], t.al(s, s, r)) : (s = [e, i, 0, 1], je(s, s, r)); const a = s[3]; return { point: new t.P(s[0] / a, s[1] / a), signedDistanceFromCamera: a, isOccluded: !1 } } function we(e, t) { return .5 + e / t * .5 } function Te(e, t) { return e.x >= -t[0] && e.x <= t[0] && e.y >= -t[1] && e.y <= t[1] } function Pe(e, i, r, o, s, a, n, l, c, h, u, d, _) { const p = r ? e.textSizeData : e.iconSizeData, m = t.ah(p, i.transform.zoom), f = [256 / i.width * 2 + 1, 256 / i.height * 2 + 1], g = r ? e.text.dynamicLayoutVertexArray : e.icon.dynamicLayoutVertexArray; g.clear(); const v = e.lineVertexArray, x = r ? e.text.placedSymbolArray : e.icon.placedSymbolArray, b = i.transform.width / i.transform.height; let y = !1; for (let r = 0; r < x.length; r++) { const w = x.get(r); if (w.hidden || w.writingMode === t.ai.vertical && !y) { Be(w.numGlyphs, g); continue } y = !1; const T = new t.P(w.anchorX, w.anchorY), P = { getElevation: _, pitchedLabelPlaneMatrix: o, lineVertexArray: v, pitchWithMap: a, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, transform: i.transform, tileAnchorPoint: T, unwrappedTileID: c, width: h, height: u, translation: d }, C = ze(w.anchorX, w.anchorY, P); if (!Te(C.point, f)) { Be(w.numGlyphs, g); continue } const I = we(i.transform.cameraToCenterDistance, C.signedDistanceFromCamera), E = t.aj(p, m, w), M = a ? E * i.transform.getPitchedTextCorrection(w.anchorX, w.anchorY, c) / I : E * I, S = Ee({ projectionContext: P, pitchedLabelPlaneMatrixInverse: s, symbol: w, fontSize: M, flip: !1, keepUpright: n, glyphOffsetArray: e.glyphOffsetArray, dynamicLayoutVertexArray: g, aspectRatio: b, rotateToLine: l }); y = S.useVertical, (S.notEnoughRoom || y || S.needsFlipping && Ee({ projectionContext: P, pitchedLabelPlaneMatrixInverse: s, symbol: w, fontSize: M, flip: !0, keepUpright: n, glyphOffsetArray: e.glyphOffsetArray, dynamicLayoutVertexArray: g, aspectRatio: b, rotateToLine: l }).notEnoughRoom) && Be(w.numGlyphs, g); } r ? e.text.dynamicLayoutVertexBuffer.updateData(g) : e.icon.dynamicLayoutVertexBuffer.updateData(g); } function Ce(e, t, i, r, o, s, a, n) { const l = s.glyphStartIndex + s.numGlyphs, c = s.lineStartIndex, h = s.lineStartIndex + s.lineLength, u = t.getoffsetX(s.glyphStartIndex), d = t.getoffsetX(l - 1), _ = ke(e * u, i, r, o, s.segment, c, h, n, a); if (!_) return null; const p = ke(e * d, i, r, o, s.segment, c, h, n, a); return p ? n.projectionCache.anyProjectionOccluded ? null : { first: _, last: p } : null } function Ie(e, i, r, o) { return e === t.ai.horizontal && Math.abs(r.y - i.y) > Math.abs(r.x - i.x) * o ? { useVertical: !0 } : (e === t.ai.vertical ? i.y < r.y : i.x > r.x) ? { needsFlipping: !0 } : null } function Ee(e) { const { projectionContext: i, pitchedLabelPlaneMatrixInverse: r, symbol: o, fontSize: s, flip: a, keepUpright: n, glyphOffsetArray: l, dynamicLayoutVertexArray: c, aspectRatio: h, rotateToLine: u } = e, d = s / 24, _ = o.lineOffsetX * d, p = o.lineOffsetY * d; let m; if (o.numGlyphs > 1) { const e = o.glyphStartIndex + o.numGlyphs, t = o.lineStartIndex, s = o.lineStartIndex + o.lineLength, c = Ce(d, l, _, p, a, o, u, i); if (!c) return { notEnoughRoom: !0 }; const f = De(c.first.point.x, c.first.point.y, i, r), g = De(c.last.point.x, c.last.point.y, i, r); if (n && !a) { const e = Ie(o.writingMode, f, g, h); if (e) return e } m = [c.first]; for (let r = o.glyphStartIndex + 1; r < e - 1; r++)m.push(ke(d * l.getoffsetX(r), _, p, a, o.segment, t, s, i, u)); m.push(c.last); } else { if (n && !a) { const e = Re(i.tileAnchorPoint.x, i.tileAnchorPoint.y, i).point, s = o.lineStartIndex + o.segment + 1, a = new t.P(i.lineVertexArray.getx(s), i.lineVertexArray.gety(s)), n = Re(a.x, a.y, i), l = n.signedDistanceFromCamera > 0 ? n.point : Me(i.tileAnchorPoint, a, e, 1, i), c = De(e.x, e.y, i, r), u = De(l.x, l.y, i, r), d = Ie(o.writingMode, c, u, h); if (d) return d } const e = ke(d * l.getoffsetX(o.glyphStartIndex), _, p, a, o.segment, o.lineStartIndex, o.lineStartIndex + o.lineLength, i, u); if (!e || i.projectionCache.anyProjectionOccluded) return { notEnoughRoom: !0 }; m = [e]; } for (const e of m) t.ak(c, e.point, e.angle); return {} } function Me(e, t, i, r, o) { const s = e.add(e.sub(t)._unit()), a = Re(s.x, s.y, o).point, n = i.sub(a); return i.add(n._mult(r / n.mag())) } function Se(e, i, r) { const o = i.projectionCache; if (o.projections[e]) return o.projections[e]; const s = new t.P(i.lineVertexArray.getx(e), i.lineVertexArray.gety(e)), a = Re(s.x, s.y, i); if (a.signedDistanceFromCamera > 0) return o.projections[e] = a.point, o.anyProjectionOccluded = o.anyProjectionOccluded || a.isOccluded, a.point; const n = e - r.direction; return Me(0 === r.distanceFromAnchor ? i.tileAnchorPoint : new t.P(i.lineVertexArray.getx(n), i.lineVertexArray.gety(n)), s, r.previousVertex, r.absOffsetX - r.distanceFromAnchor + 1, i) } function Re(e, t, i) { const r = e + i.translation[0], o = t + i.translation[1]; let s; return i.pitchWithMap ? (s = ye(r, o, i.pitchedLabelPlaneMatrix, i.getElevation), s.isOccluded = !1) : (s = i.transform.projectTileCoordinates(r, o, i.unwrappedTileID, i.getElevation), s.point.x = (.5 * s.point.x + .5) * i.width, s.point.y = (.5 * -s.point.y + .5) * i.height), s } function De(e, i, r, o) { if (r.pitchWithMap) { const s = [e, i, 0, 1]; return t.al(s, s, o), r.transform.projectTileCoordinates(s[0] / s[3], s[1] / s[3], r.unwrappedTileID, r.getElevation).point } return { x: e / r.width * 2 - 1, y: i / r.height * 2 - 1 } } function ze(e, t, i) { return i.transform.projectTileCoordinates(e, t, i.unwrappedTileID, i.getElevation) } function Ae(e, t, i) { return e._unit()._perp()._mult(t * i) } function Le(e, i, r, o, s, a, n, l, c) { if (l.projectionCache.offsets[e]) return l.projectionCache.offsets[e]; const h = r.add(i); if (e + c.direction < o || e + c.direction >= s) return l.projectionCache.offsets[e] = h, h; const u = Se(e + c.direction, l, c), d = Ae(u.sub(r), n, c.direction), _ = r.add(d), p = u.add(d); return l.projectionCache.offsets[e] = t.am(a, h, _, p) || h, l.projectionCache.offsets[e] } function ke(e, t, i, r, o, s, a, n, l) { const c = r ? e - t : e + t; let h = c > 0 ? 1 : -1, u = 0; r && (h *= -1, u = Math.PI), h < 0 && (u += Math.PI); let d, _ = h > 0 ? s + o : s + o + 1; n.projectionCache.cachedAnchorPoint ? d = n.projectionCache.cachedAnchorPoint : (d = Re(n.tileAnchorPoint.x, n.tileAnchorPoint.y, n).point, n.projectionCache.cachedAnchorPoint = d); let p, m, f = d, g = d, v = 0, x = 0; const b = Math.abs(c), y = []; let w; for (; v + x <= b;) { if (_ += h, _ < s || _ >= a) return null; v += x, g = f, m = p; const e = { absOffsetX: b, direction: h, distanceFromAnchor: v, previousVertex: g }; if (f = Se(_, n, e), 0 === i) y.push(g), w = f.sub(g); else { let t; const r = f.sub(g); t = 0 === r.mag() ? Ae(Se(_ + h, n, e).sub(f), i, h) : Ae(r, i, h), m || (m = g.add(t)), p = Le(_, t, f, s, a, m, i, n, e), y.push(m), w = p.sub(m); } x = w.mag(); } const T = w._mult((b - v) / x)._add(m || g), P = u + Math.atan2(f.y - g.y, f.x - g.x); return y.push(T), { point: T, angle: l ? P : 0, path: y } } const Fe = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]); function Be(e, t) { for (let i = 0; i < e; i++) { const e = t.length; t.resize(e + 4), t.float32.set(Fe, 3 * e); } } function je(e, t, i) { const r = t[0], o = t[1]; return e[0] = i[0] * r + i[4] * o + i[12], e[1] = i[1] * r + i[5] * o + i[13], e[3] = i[3] * r + i[7] * o + i[15], e } const Oe = 100; class Ne { constructor(e, t = new ge(e.width + 200, e.height + 200, 25), i = new ge(e.width + 200, e.height + 200, 25)) { this.transform = e, this.grid = t, this.ignoredGrid = i, this.pitchFactor = Math.cos(e.pitch * Math.PI / 180) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + Oe, this.screenBottomBoundary = e.height + Oe, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.perspectiveRatioCutoff = .6; } placeCollisionBox(e, t, i, r, o, s, a, n, l, c, h, u) { const d = this.projectAndGetPerspectiveRatio(e.anchorPointX + n[0], e.anchorPointY + n[1], o, c, u), _ = i * d.perspectiveRatio; let p; if (s || a) p = this._projectCollisionBox(e, _, r, o, s, a, n, d, c, h, u); else { const t = d.x + (h ? h.x * _ : 0), i = d.y + (h ? h.y * _ : 0); p = { allPointsOccluded: !1, box: [t + e.x1 * _, i + e.y1 * _, t + e.x2 * _, i + e.y2 * _] }; } const [m, f, g, v] = p.box, x = s ? p.allPointsOccluded : d.isOccluded; let b = x; return b || (b = d.perspectiveRatio < this.perspectiveRatioCutoff), b || (b = !this.isInsideGrid(m, f, g, v)), b || "always" !== t && this.grid.hitTest(m, f, g, v, t, l) ? { box: [m, f, g, v], placeable: !1, offscreen: !1, occluded: x } : { box: [m, f, g, v], placeable: !0, offscreen: this.isOffscreen(m, f, g, v), occluded: x } } placeCollisionCircles(e, i, r, o, s, a, n, l, c, h, u, d, _, p) { const m = [], f = new t.P(i.anchorX, i.anchorY), g = this.getPerspectiveRatio(f.x, f.y, a, p), v = (c ? s * this.transform.getPitchedTextCorrection(i.anchorX, i.anchorY, a) / g : s * g) / t.as, x = { getElevation: p, pitchedLabelPlaneMatrix: n, lineVertexArray: r, pitchWithMap: c, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, transform: this.transform, tileAnchorPoint: f, unwrappedTileID: a, width: this.transform.width, height: this.transform.height, translation: _ }, b = Ce(v, o, i.lineOffsetX * v, i.lineOffsetY * v, !1, i, !1, x); let y = !1, w = !1, T = !0; if (b) { const i = .5 * u * g + d, r = new t.P(-100, -100), o = new t.P(this.screenRightBoundary, this.screenBottomBoundary), s = new me, a = b.first, n = b.last; let _ = []; for (let e = a.path.length - 1; e >= 1; e--)_.push(a.path[e]); for (let e = 1; e < n.path.length; e++)_.push(n.path[e]); const p = 2.5 * i; if (c) { const e = this.projectPathToScreenSpace(_, x); _ = e.some((e => e.signedDistanceFromCamera <= 0)) ? [] : e.map((e => e.point)); } let f = []; if (_.length > 0) { const e = _[0].clone(), i = _[0].clone(); for (let t = 1; t < _.length; t++)e.x = Math.min(e.x, _[t].x), e.y = Math.min(e.y, _[t].y), i.x = Math.max(i.x, _[t].x), i.y = Math.max(i.y, _[t].y); f = e.x >= r.x && i.x <= o.x && e.y >= r.y && i.y <= o.y ? [_] : i.x < r.x || e.x > o.x || i.y < r.y || e.y > o.y ? [] : t.ao([_], r.x, r.y, o.x, o.y); } for (const t of f) { s.reset(t, .25 * i); let r = 0; r = s.length <= .5 * i ? 1 : Math.ceil(s.paddedLength / p) + 1; for (let t = 0; t < r; t++) { const o = t / Math.max(r - 1, 1), a = s.lerp(o), n = a.x + Oe, c = a.y + Oe; m.push(n, c, i, 0); const u = n - i, d = c - i, _ = n + i, p = c + i; if (T = T && this.isOffscreen(u, d, _, p), w = w || this.isInsideGrid(u, d, _, p), "always" !== e && this.grid.hitTestCircle(n, c, i, e, h) && (y = !0, !l)) return { circles: [], offscreen: !1, collisionDetected: y } } } } return { circles: !l && y || !w || g < this.perspectiveRatioCutoff ? [] : m, offscreen: T, collisionDetected: y } } projectPathToScreenSpace(e, i) { const r = function (e, i) { const r = t.H(); return t.an(r, i.pitchedLabelPlaneMatrix), e.map((e => { const t = ye(e.x, e.y, r, i.getElevation), o = i.transform.projectTileCoordinates(t.point.x, t.point.y, i.unwrappedTileID, i.getElevation); return o.point.x = (.5 * o.point.x + .5) * i.width, o.point.y = (.5 * -o.point.y + .5) * i.height, o })) }(e, i); return function (e) { let t = 0, i = 0, r = 0, o = 0; for (let s = 0; s < e.length; s++)e[s].isOccluded ? (r = s + 1, o = 0) : (o++, o > i && (i = o, t = r)); return e.slice(t, t + i) }(r) } queryRenderedSymbols(e) { if (0 === e.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {}; const i = []; let r = 1 / 0, o = 1 / 0, s = -1 / 0, a = -1 / 0; for (const n of e) { const e = new t.P(n.x + Oe, n.y + Oe); r = Math.min(r, e.x), o = Math.min(o, e.y), s = Math.max(s, e.x), a = Math.max(a, e.y), i.push(e); } const n = this.grid.query(r, o, s, a).concat(this.ignoredGrid.query(r, o, s, a)), l = {}, c = {}; for (const e of n) { const r = e.key; if (void 0 === l[r.bucketInstanceId] && (l[r.bucketInstanceId] = {}), l[r.bucketInstanceId][r.featureIndex]) continue; const o = [new t.P(e.x1, e.y1), new t.P(e.x2, e.y1), new t.P(e.x2, e.y2), new t.P(e.x1, e.y2)]; t.ap(i, o) && (l[r.bucketInstanceId][r.featureIndex] = !0, void 0 === c[r.bucketInstanceId] && (c[r.bucketInstanceId] = []), c[r.bucketInstanceId].push(r.featureIndex)); } return c } insertCollisionBox(e, t, i, r, o, s) { (i ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: r, featureIndex: o, collisionGroupID: s, overlapMode: t }, e[0], e[1], e[2], e[3]); } insertCollisionCircles(e, t, i, r, o, s) { const a = i ? this.ignoredGrid : this.grid, n = { bucketInstanceId: r, featureIndex: o, collisionGroupID: s, overlapMode: t }; for (let t = 0; t < e.length; t += 4)a.insertCircle(n, e[t], e[t + 1], e[t + 2]); } projectAndGetPerspectiveRatio(e, i, r, o, s) { if (s) { let r; o ? (r = [e, i, o(e, i), 1], t.al(r, r, s)) : (r = [e, i, 0, 1], je(r, r, s)); const a = r[3]; return { x: (r[0] / a + 1) / 2 * this.transform.width + Oe, y: (-r[1] / a + 1) / 2 * this.transform.height + Oe, perspectiveRatio: .5 + this.transform.cameraToCenterDistance / a * .5, isOccluded: !1, signedDistanceFromCamera: a } } { const t = this.transform.projectTileCoordinates(e, i, r, o); return { x: (t.point.x + 1) / 2 * this.transform.width + Oe, y: (1 - t.point.y) / 2 * this.transform.height + Oe, perspectiveRatio: .5 + this.transform.cameraToCenterDistance / t.signedDistanceFromCamera * .5, isOccluded: t.isOccluded, signedDistanceFromCamera: t.signedDistanceFromCamera } } } getPerspectiveRatio(e, t, i, r) { const o = this.transform.projectTileCoordinates(e, t, i, r); return .5 + this.transform.cameraToCenterDistance / o.signedDistanceFromCamera * .5 } isOffscreen(e, t, i, r) { return i < Oe || e >= this.screenRightBoundary || r < Oe || t > this.screenBottomBoundary } isInsideGrid(e, t, i, r) { return i >= 0 && e < this.gridRightBoundary && r >= 0 && t < this.gridBottomBoundary } getViewportMatrix() { const e = t.aq([]); return t.J(e, e, [-100, -100, 0]), e } _projectCollisionBox(e, i, r, o, s, a, n, l, c, h, u) { let d = 1, _ = 0, p = 0, m = 1; const f = e.anchorPointX + n[0], g = e.anchorPointY + n[1]; if (a && !s) { const e = this.projectAndGetPerspectiveRatio(f + 1, g, o, c, u), t = e.x - l.x, i = Math.atan((e.y - l.y) / t) + (t < 0 ? Math.PI : 0), r = Math.sin(i), s = Math.cos(i); d = s, _ = r, p = -r, m = s; } else if (!a && s) { const e = be(this.transform); d = e.vecEast[0], _ = e.vecEast[1], p = e.vecSouth[0], m = e.vecSouth[1]; } let v = l.x, x = l.y, b = i; s && (v = f, x = g, b = Math.pow(2, -(this.transform.zoom - r.overscaledZ)), b *= this.transform.getPitchedTextCorrection(f, g, o), h || (b *= t.ab(.5 + l.signedDistanceFromCamera / this.transform.cameraToCenterDistance * .5, 0, 4))), h && (v += d * h.x * b + p * h.y * b, x += _ * h.x * b + m * h.y * b); const y = e.x1 * b, w = e.x2 * b, T = (y + w) / 2, P = e.y1 * b, C = e.y2 * b, I = (P + C) / 2, E = [{ offsetX: y, offsetY: P }, { offsetX: T, offsetY: P }, { offsetX: w, offsetY: P }, { offsetX: w, offsetY: I }, { offsetX: w, offsetY: C }, { offsetX: T, offsetY: C }, { offsetX: y, offsetY: C }, { offsetX: y, offsetY: I }]; let M = []; for (const { offsetX: e, offsetY: i } of E) M.push(new t.P(v + d * e + p * i, x + _ * e + m * i)); let S = !1; if (s) { const e = M.map((e => this.projectAndGetPerspectiveRatio(e.x, e.y, o, c, u))); S = e.some((e => !e.isOccluded)), M = e.map((e => new t.P(e.x, e.y))); } else S = !0; return { box: t.ar(M), allPointsOccluded: !S } } } class Ze { constructor(e, t, i, r) { this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? t : -t))) : r && i ? 1 : 0, this.placed = i; } isHidden() { return 0 === this.opacity && !this.placed } } class Ge { constructor(e, t, i, r, o) { this.text = new Ze(e ? e.text : null, t, i, o), this.icon = new Ze(e ? e.icon : null, t, r, o); } isHidden() { return this.text.isHidden() && this.icon.isHidden() } } class Ue { constructor(e, t, i) { this.text = e, this.icon = t, this.skipFade = i; } } class Ve { constructor(e, t, i, r, o) { this.bucketInstanceId = e, this.featureIndex = t, this.sourceLayerIndex = i, this.bucketIndex = r, this.tileID = o; } } class qe { constructor(e) { this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {}; } get(e) { if (this.crossSourceCollisions) return { ID: 0, predicate: null }; if (!this.collisionGroups[e]) { const t = ++this.maxGroupID; this.collisionGroups[e] = { ID: t, predicate: e => e.collisionGroupID === t }; } return this.collisionGroups[e] } } function He(e, i, r, o, s) { const { horizontalAlign: a, verticalAlign: n } = t.ay(e); return new t.P(-(a - .5) * i + o[0] * s, -(n - .5) * r + o[1] * s) } class We { constructor(e, t, i, r, o) { this.transform = e.clone(), this.terrain = t, this.collisionIndex = new Ne(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = i, this.retainedQueryData = {}, this.collisionGroups = new qe(r), this.collisionCircleArrays = {}, this.collisionBoxArrays = new Map, this.prevPlacement = o, o && (o.prevPlacement = void 0), this.placedOrientations = {}; } _getTerrainElevationFunc(e) { const t = this.terrain; return t ? (i, r) => t.getElevation(e, i, r) : null } getBucketParts(e, i, r, o) { const s = r.getBucket(i), a = r.latestFeatureIndex; if (!s || !a || i.id !== s.layerIds[0]) return; const n = r.collisionBoxArray, l = s.layers[0].layout, c = s.layers[0].paint, h = Math.pow(2, this.transform.zoom - r.tileID.overscaledZ), u = r.tileSize / t.X, d = r.tileID.toUnwrapped(), _ = "map" === l.get("text-rotation-alignment"), p = t.at(r, 1, this.transform.zoom), m = t.au(this.collisionIndex.transform, r, c.get("text-translate"), c.get("text-translate-anchor")), f = t.au(this.collisionIndex.transform, r, c.get("icon-translate"), c.get("icon-translate-anchor")), g = ve(_, this.transform, p); this.retainedQueryData[s.bucketInstanceId] = new Ve(s.bucketInstanceId, a, s.sourceLayerIndex, s.index, r.tileID); const v = { bucket: s, layout: l, translationText: m, translationIcon: f, unwrappedTileID: d, pitchedLabelPlaneMatrix: g, scale: h, textPixelRatio: u, holdingForFade: r.holdingForFade(), collisionBoxArray: n, partiallyEvaluatedTextSize: t.ah(s.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(s.sourceID) }; if (o) for (const t of s.sortKeyRanges) { const { sortKey: i, symbolInstanceStart: r, symbolInstanceEnd: o } = t; e.push({ sortKey: i, symbolInstanceStart: r, symbolInstanceEnd: o, parameters: v }); } else e.push({ symbolInstanceStart: 0, symbolInstanceEnd: s.symbolInstances.length, parameters: v }); } attemptAnchorPlacement(e, i, r, o, s, a, n, l, c, h, u, d, _, p, m, f, g, v, x, b) { const y = t.av[e.textAnchor], w = [e.textOffset0, e.textOffset1], T = He(y, r, o, w, s), P = this.collisionIndex.placeCollisionBox(i, d, l, c, h, n, a, f, u.predicate, x, T, b); if ((!v || this.collisionIndex.placeCollisionBox(v, d, l, c, h, n, a, g, u.predicate, x, T, b).placeable) && P.placeable) { let e; if (this.prevPlacement && this.prevPlacement.variableOffsets[_.crossTileID] && this.prevPlacement.placements[_.crossTileID] && this.prevPlacement.placements[_.crossTileID].text && (e = this.prevPlacement.variableOffsets[_.crossTileID].anchor), 0 === _.crossTileID) throw new Error("symbolInstance.crossTileID can't be 0"); return this.variableOffsets[_.crossTileID] = { textOffset: w, width: r, height: o, anchor: y, textBoxScale: s, prevAnchor: e }, this.markUsedJustification(p, y, _, m), p.allowVerticalPlacement && (this.markUsedOrientation(p, m, _), this.placedOrientations[_.crossTileID] = m), { shift: T, placedGlyphBoxes: P } } } placeLayerBucketPart(e, i, r) { const { bucket: o, layout: s, translationText: a, translationIcon: n, unwrappedTileID: l, pitchedLabelPlaneMatrix: c, textPixelRatio: h, holdingForFade: u, collisionBoxArray: d, partiallyEvaluatedTextSize: _, collisionGroup: p } = e.parameters, m = s.get("text-optional"), f = s.get("icon-optional"), g = t.aw(s, "text-overlap", "text-allow-overlap"), v = "always" === g, x = t.aw(s, "icon-overlap", "icon-allow-overlap"), b = "always" === x, y = "map" === s.get("text-rotation-alignment"), w = "map" === s.get("text-pitch-alignment"), T = "none" !== s.get("icon-text-fit"), P = "viewport-y" === s.get("symbol-z-order"), C = v && (b || !o.hasIconData() || f), I = b && (v || !o.hasTextData() || m); !o.collisionArrays && d && o.deserializeCollisionBoxes(d); const E = this.retainedQueryData[o.bucketInstanceId].tileID, M = this._getTerrainElevationFunc(E), S = this.transform.getFastPathSimpleProjectionMatrix(E), R = (e, d, b) => { var P, R; if (i[e.crossTileID]) return; if (u) return void (this.placements[e.crossTileID] = new Ue(!1, !1, !1)); let D = !1, z = !1, A = !0, L = null, k = { box: null, placeable: !1, offscreen: null, occluded: !1 }, F = { box: null, placeable: !1, offscreen: null }, B = null, j = null, O = null, N = 0, Z = 0, G = 0; d.textFeatureIndex ? N = d.textFeatureIndex : e.useRuntimeCollisionCircles && (N = e.featureIndex), d.verticalTextFeatureIndex && (Z = d.verticalTextFeatureIndex); const U = d.textBox; if (U) { const i = i => { let r = t.ai.horizontal; if (o.allowVerticalPlacement && !i && this.prevPlacement) { const t = this.prevPlacement.placedOrientations[e.crossTileID]; t && (this.placedOrientations[e.crossTileID] = t, r = t, this.markUsedOrientation(o, r, e)); } return r }, s = (i, r) => { if (o.allowVerticalPlacement && e.numVerticalGlyphVertices > 0 && d.verticalTextBox) { for (const e of o.writingModes) if (e === t.ai.vertical ? (k = r(), F = k) : k = i(), k && k.placeable) break } else k = i(); }, c = e.textAnchorOffsetStartIndex, u = e.textAnchorOffsetEndIndex; if (u === c) { const r = (t, i) => { const r = this.collisionIndex.placeCollisionBox(t, g, h, E, l, w, y, a, p.predicate, M, void 0, S); return r && r.placeable && (this.markUsedOrientation(o, i, e), this.placedOrientations[e.crossTileID] = i), r }; s((() => r(U, t.ai.horizontal)), (() => { const i = d.verticalTextBox; return o.allowVerticalPlacement && e.numVerticalGlyphVertices > 0 && i ? r(i, t.ai.vertical) : { box: null, offscreen: null } })), i(k && k.placeable); } else { let _ = t.av[null === (R = null === (P = this.prevPlacement) || void 0 === P ? void 0 : P.variableOffsets[e.crossTileID]) || void 0 === R ? void 0 : R.anchor]; const m = (t, i, s) => { const d = t.x2 - t.x1, m = t.y2 - t.y1, f = e.textBoxScale, v = T && "never" === x ? i : null; let b = null, P = "never" === g ? 1 : 2, C = "never"; _ && P++; for (let i = 0; i < P; i++) { for (let i = c; i < u; i++) { const r = o.textAnchorOffsets.get(i); if (_ && r.textAnchor !== _) continue; const c = this.attemptAnchorPlacement(r, t, d, m, f, y, w, h, E, l, p, C, e, o, s, a, n, v, M); if (c && (b = c.placedGlyphBoxes, b && b.placeable)) return D = !0, L = c.shift, b } _ ? _ = null : C = g; } return r && !b && (b = { box: this.collisionIndex.placeCollisionBox(U, "always", h, E, l, w, y, a, p.predicate, M, void 0, S).box, offscreen: !1, placeable: !1, occluded: !1 }), b }; s((() => m(U, d.iconBox, t.ai.horizontal)), (() => { const i = d.verticalTextBox; return o.allowVerticalPlacement && (!k || !k.placeable) && e.numVerticalGlyphVertices > 0 && i ? m(i, d.verticalIconBox, t.ai.vertical) : { box: null, occluded: !0, offscreen: null } })), k && (D = k.placeable, A = k.offscreen); const f = i(k && k.placeable); if (!D && this.prevPlacement) { const t = this.prevPlacement.variableOffsets[e.crossTileID]; t && (this.variableOffsets[e.crossTileID] = t, this.markUsedJustification(o, t.anchor, e, f)); } } } if (B = k, D = B && B.placeable, A = B && B.offscreen, e.useRuntimeCollisionCircles) { const i = o.text.placedSymbolArray.get(e.centerJustifiedTextSymbolIndex), n = t.aj(o.textSizeData, _, i), h = s.get("text-padding"); j = this.collisionIndex.placeCollisionCircles(g, i, o.lineVertexArray, o.glyphOffsetArray, n, l, c, r, w, p.predicate, e.collisionCircleDiameter, h, a, M), j.circles.length && j.collisionDetected && !r && t.w("Collisions detected, but collision boxes are not shown"), D = v || j.circles.length > 0 && !j.collisionDetected, A = A && j.offscreen; } if (d.iconFeatureIndex && (G = d.iconFeatureIndex), d.iconBox) { const e = e => this.collisionIndex.placeCollisionBox(e, x, h, E, l, w, y, n, p.predicate, M, T && L ? L : void 0, S); F && F.placeable && d.verticalIconBox ? (O = e(d.verticalIconBox), z = O.placeable) : (O = e(d.iconBox), z = O.placeable), A = A && O.offscreen; } const V = m || 0 === e.numHorizontalGlyphVertices && 0 === e.numVerticalGlyphVertices, q = f || 0 === e.numIconVertices; V || q ? q ? V || (z = z && D) : D = z && D : z = D = z && D; const H = z && O.placeable; if (D && B.placeable && this.collisionIndex.insertCollisionBox(B.box, g, s.get("text-ignore-placement"), o.bucketInstanceId, F && F.placeable && Z ? Z : N, p.ID), H && this.collisionIndex.insertCollisionBox(O.box, x, s.get("icon-ignore-placement"), o.bucketInstanceId, G, p.ID), j && D && this.collisionIndex.insertCollisionCircles(j.circles, g, s.get("text-ignore-placement"), o.bucketInstanceId, N, p.ID), r && this.storeCollisionData(o.bucketInstanceId, b, d, B, O, j), 0 === e.crossTileID) throw new Error("symbolInstance.crossTileID can't be 0"); if (0 === o.bucketInstanceId) throw new Error("bucket.bucketInstanceId can't be 0"); this.placements[e.crossTileID] = new Ue((D || C) && !(null == B ? void 0 : B.occluded), (z || I) && !(null == O ? void 0 : O.occluded), A || o.justReloaded), i[e.crossTileID] = !0; }; if (P) { if (0 !== e.symbolInstanceStart) throw new Error("bucket.bucketInstanceId should be 0"); const t = o.getSortedSymbolIndexes(-this.transform.bearingInRadians); for (let e = t.length - 1; e >= 0; --e) { const i = t[e]; R(o.symbolInstances.get(i), o.collisionArrays[i], i); } } else for (let t = e.symbolInstanceStart; t < e.symbolInstanceEnd; t++)R(o.symbolInstances.get(t), o.collisionArrays[t], t); o.justReloaded = !1; } storeCollisionData(e, t, i, r, o, s) { if (i.textBox || i.iconBox) { let s, a; this.collisionBoxArrays.has(e) ? s = this.collisionBoxArrays.get(e) : (s = new Map, this.collisionBoxArrays.set(e, s)), s.has(t) ? a = s.get(t) : (a = { text: null, icon: null }, s.set(t, a)), i.textBox && (a.text = r.box), i.iconBox && (a.icon = o.box); } if (s) { let t = this.collisionCircleArrays[e]; void 0 === t && (t = this.collisionCircleArrays[e] = []); for (let e = 0; e < s.circles.length; e += 4)t.push(s.circles[e + 0] - Oe), t.push(s.circles[e + 1] - Oe), t.push(s.circles[e + 2]), t.push(s.collisionDetected ? 1 : 0); } } markUsedJustification(e, i, r, o) { let s; s = o === t.ai.vertical ? r.verticalPlacedTextSymbolIndex : { left: r.leftJustifiedTextSymbolIndex, center: r.centerJustifiedTextSymbolIndex, right: r.rightJustifiedTextSymbolIndex }[t.ax(i)]; const a = [r.leftJustifiedTextSymbolIndex, r.centerJustifiedTextSymbolIndex, r.rightJustifiedTextSymbolIndex, r.verticalPlacedTextSymbolIndex]; for (const t of a) t >= 0 && (e.text.placedSymbolArray.get(t).crossTileID = s >= 0 && t !== s ? 0 : r.crossTileID); } markUsedOrientation(e, i, r) { const o = i === t.ai.horizontal || i === t.ai.horizontalOnly ? i : 0, s = i === t.ai.vertical ? i : 0, a = [r.leftJustifiedTextSymbolIndex, r.centerJustifiedTextSymbolIndex, r.rightJustifiedTextSymbolIndex]; for (const t of a) e.text.placedSymbolArray.get(t).placedOrientation = o; r.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(r.verticalPlacedTextSymbolIndex).placedOrientation = s); } commit(e) { this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom; const t = this.prevPlacement; let i = !1; this.prevZoomAdjustment = t ? t.zoomAdjustment(this.transform.zoom) : 0; const r = t ? t.symbolFadeChange(e) : 1, o = t ? t.opacities : {}, s = t ? t.variableOffsets : {}, a = t ? t.placedOrientations : {}; for (const e in this.placements) { const t = this.placements[e], s = o[e]; s ? (this.opacities[e] = new Ge(s, r, t.text, t.icon), i = i || t.text !== s.text.placed || t.icon !== s.icon.placed) : (this.opacities[e] = new Ge(null, r, t.text, t.icon, t.skipFade), i = i || t.text || t.icon); } for (const e in o) { const t = o[e]; if (!this.opacities[e]) { const o = new Ge(t, r, !1, !1); o.isHidden() || (this.opacities[e] = o, i = i || t.text.placed || t.icon.placed); } } for (const e in s) this.variableOffsets[e] || !this.opacities[e] || this.opacities[e].isHidden() || (this.variableOffsets[e] = s[e]); for (const e in a) this.placedOrientations[e] || !this.opacities[e] || this.opacities[e].isHidden() || (this.placedOrientations[e] = a[e]); if (t && void 0 === t.lastPlacementChangeTime) throw new Error("Last placement time for previous placement is not defined"); i ? this.lastPlacementChangeTime = e : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t ? t.lastPlacementChangeTime : e); } updateLayerOpacities(e, t) { const i = {}; for (const r of t) { const t = r.getBucket(e); t && r.latestFeatureIndex && e.id === t.layerIds[0] && this.updateBucketOpacities(t, r.tileID, i, r.collisionBoxArray); } } updateBucketOpacities(e, i, r, o) { e.hasTextData() && (e.text.opacityVertexArray.clear(), e.text.hasVisibleVertices = !1), e.hasIconData() && (e.icon.opacityVertexArray.clear(), e.icon.hasVisibleVertices = !1), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear(); const s = e.layers[0], a = s.layout, n = new Ge(null, 0, !1, !1, !0), l = a.get("text-allow-overlap"), c = a.get("icon-allow-overlap"), h = s._unevaluatedLayout.hasValue("text-variable-anchor") || s._unevaluatedLayout.hasValue("text-variable-anchor-offset"), u = "map" === a.get("text-rotation-alignment"), d = "map" === a.get("text-pitch-alignment"), _ = "none" !== a.get("icon-text-fit"), p = new Ge(null, 0, l && (c || !e.hasIconData() || a.get("icon-optional")), c && (l || !e.hasTextData() || a.get("text-optional")), !0); !e.collisionArrays && o && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(o); const m = (e, t, i) => { for (let r = 0; r < t / 4; r++)e.opacityVertexArray.emplaceBack(i); e.hasVisibleVertices = e.hasVisibleVertices || i !== rt; }, f = this.collisionBoxArrays.get(e.bucketInstanceId); for (let i = 0; i < e.symbolInstances.length; i++) { const o = e.symbolInstances.get(i), { numHorizontalGlyphVertices: s, numVerticalGlyphVertices: a, crossTileID: l } = o; let c = this.opacities[l]; r[l] ? c = n : c || (c = p, this.opacities[l] = c), r[l] = !0; const g = o.numIconVertices > 0, v = this.placedOrientations[o.crossTileID], x = v === t.ai.vertical, b = v === t.ai.horizontal || v === t.ai.horizontalOnly; if (s > 0 || a > 0) { const t = it(c.text); m(e.text, s, x ? rt : t), m(e.text, a, b ? rt : t); const i = c.text.isHidden();[o.rightJustifiedTextSymbolIndex, o.centerJustifiedTextSymbolIndex, o.leftJustifiedTextSymbolIndex].forEach((t => { t >= 0 && (e.text.placedSymbolArray.get(t).hidden = i || x ? 1 : 0); })), o.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(o.verticalPlacedTextSymbolIndex).hidden = i || b ? 1 : 0); const r = this.variableOffsets[o.crossTileID]; r && this.markUsedJustification(e, r.anchor, o, v); const n = this.placedOrientations[o.crossTileID]; n && (this.markUsedJustification(e, "left", o, n), this.markUsedOrientation(e, n, o)); } if (g) { const t = it(c.icon), i = !(_ && o.verticalPlacedIconSymbolIndex && x); o.placedIconSymbolIndex >= 0 && (m(e.icon, o.numIconVertices, i ? t : rt), e.icon.placedSymbolArray.get(o.placedIconSymbolIndex).hidden = c.icon.isHidden()), o.verticalPlacedIconSymbolIndex >= 0 && (m(e.icon, o.numVerticalIconVertices, i ? rt : t), e.icon.placedSymbolArray.get(o.verticalPlacedIconSymbolIndex).hidden = c.icon.isHidden()); } const y = f && f.has(i) ? f.get(i) : { text: null, icon: null }; if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) { const r = e.collisionArrays[i]; if (r) { let i = new t.P(0, 0); if (r.textBox || r.verticalTextBox) { let t = !0; if (h) { const e = this.variableOffsets[l]; e ? (i = He(e.anchor, e.width, e.height, e.textOffset, e.textBoxScale), u && i._rotate(d ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : t = !1; } if (r.textBox || r.verticalTextBox) { let o; r.textBox && (o = x), r.verticalTextBox && (o = b), Xe(e.textCollisionBox.collisionVertexArray, c.text.placed, !t || o, y.text, i.x, i.y); } } if (r.iconBox || r.verticalIconBox) { const t = Boolean(!b && r.verticalIconBox); let o; r.iconBox && (o = t), r.verticalIconBox && (o = !t), Xe(e.iconCollisionBox.collisionVertexArray, c.icon.placed, o, y.icon, _ ? i.x : 0, _ ? i.y : 0); } } } } if (e.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder), e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray), e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray), e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray), e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray), e.text.opacityVertexArray.length !== e.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e.text.layoutVertexArray.length}) / 4`); if (e.icon.opacityVertexArray.length !== e.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e.icon.layoutVertexArray.length}) / 4`); e.bucketInstanceId in this.collisionCircleArrays && (e.collisionCircleArray = this.collisionCircleArrays[e.bucketInstanceId], delete this.collisionCircleArrays[e.bucketInstanceId]); } symbolFadeChange(e) { return 0 === this.fadeDuration ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment } zoomAdjustment(e) { return Math.max(0, (this.transform.zoom - e) / 1.5) } hasTransitions(e) { return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration } stillRecent(e, t) { const i = this.zoomAtLastRecencyCheck === t ? 1 - this.zoomAdjustment(t) : 1; return this.zoomAtLastRecencyCheck = t, this.commitTime + this.fadeDuration * i > e } setStale() { this.stale = !0; } } function Xe(e, t, i, r, o, s) { r && 0 !== r.length || (r = [0, 0, 0, 0]); const a = r[0] - Oe, n = r[1] - Oe, l = r[2] - Oe, c = r[3] - Oe; e.emplaceBack(t ? 1 : 0, i ? 1 : 0, o || 0, s || 0, a, n), e.emplaceBack(t ? 1 : 0, i ? 1 : 0, o || 0, s || 0, l, n), e.emplaceBack(t ? 1 : 0, i ? 1 : 0, o || 0, s || 0, l, c), e.emplaceBack(t ? 1 : 0, i ? 1 : 0, o || 0, s || 0, a, c); } const $e = Math.pow(2, 25), Ke = Math.pow(2, 24), Ye = Math.pow(2, 17), Je = Math.pow(2, 16), Qe = Math.pow(2, 9), et = Math.pow(2, 8), tt = Math.pow(2, 1); function it(e) { if (0 === e.opacity && !e.placed) return 0; if (1 === e.opacity && e.placed) return 4294967295; const t = e.placed ? 1 : 0, i = Math.floor(127 * e.opacity); return i * $e + t * Ke + i * Ye + t * Je + i * Qe + t * et + i * tt + t } const rt = 0; class ot { constructor(e) { this._sortAcrossTiles = "viewport-y" !== e.layout.get("symbol-z-order") && !e.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = []; } continuePlacement(e, t, i, r, o) { const s = this._bucketParts; for (; this._currentTileIndex < e.length;)if (t.getBucketParts(s, r, e[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, o()) return !0; for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, s.sort(((e, t) => e.sortKey - t.sortKey))); this._currentPartIndex < s.length;)if (t.placeLayerBucketPart(s[this._currentPartIndex], this._seenCrossTileIDs, i), this._currentPartIndex++, o()) return !0; return !1 } } class st { constructor(e, t, i, r, o, s, a, n) { this.placement = new We(e, t, s, a, n), this._currentPlacementIndex = i.length - 1, this._forceFullPlacement = r, this._showCollisionBoxes = o, this._done = !1; } isDone() { return this._done } continuePlacement(e, t, i) { const r = a.now(), o = () => !this._forceFullPlacement && a.now() - r > 2; for (; this._currentPlacementIndex >= 0;) { const r = t[e[this._currentPlacementIndex]], s = this.placement.collisionIndex.transform.zoom; if ("symbol" === r.type && (!r.minzoom || r.minzoom <= s) && (!r.maxzoom || r.maxzoom > s)) { if (this._inProgressLayer || (this._inProgressLayer = new ot(r)), this._inProgressLayer.continuePlacement(i[r.source], this.placement, this._showCollisionBoxes, r, o)) return; delete this._inProgressLayer; } this._currentPlacementIndex--; } this._done = !0; } commit(e) { return this.placement.commit(e), this.placement } } const at = 512 / t.X / 2; class nt { constructor(e, i, r) { this.tileID = e, this.bucketInstanceId = r, this._symbolsByKey = {}; const o = new Map; for (let e = 0; e < i.length; e++) { const t = i.get(e), r = t.key, s = o.get(r); s ? s.push(t) : o.set(r, [t]); } for (const [e, i] of o) { const r = { positions: i.map((e => ({ x: Math.floor(e.anchorX * at), y: Math.floor(e.anchorY * at) }))), crossTileIDs: i.map((e => e.crossTileID)) }; if (r.positions.length > 128) { const e = new t.az(r.positions.length, 16, Uint16Array); for (const { x: t, y: i } of r.positions) e.add(t, i); e.finish(), delete r.positions, r.index = e; } this._symbolsByKey[e] = r; } } getScaledCoordinates(e, i) { const { x: r, y: o, z: s } = this.tileID.canonical, { x: a, y: n, z: l } = i.canonical, c = at / Math.pow(2, l - s), h = (n * t.X + e.anchorY) * c, u = o * t.X * at; return { x: Math.floor((a * t.X + e.anchorX) * c - r * t.X * at), y: Math.floor(h - u) } } findMatches(e, t, i) { const r = this.tileID.canonical.z < t.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - t.canonical.z); for (let o = 0; o < e.length; o++) { const s = e.get(o); if (s.crossTileID) continue; const a = this._symbolsByKey[s.key]; if (!a) continue; const n = this.getScaledCoordinates(s, t); if (a.index) { const e = a.index.range(n.x - r, n.y - r, n.x + r, n.y + r).sort(); for (const t of e) { const e = a.crossTileIDs[t]; if (!i[e]) { i[e] = !0, s.crossTileID = e; break } } } else if (a.positions) for (let e = 0; e < a.positions.length; e++) { const t = a.positions[e], o = a.crossTileIDs[e]; if (Math.abs(t.x - n.x) <= r && Math.abs(t.y - n.y) <= r && !i[o]) { i[o] = !0, s.crossTileID = o; break } } } } getCrossTileIDsLists() { return Object.values(this._symbolsByKey).map((({ crossTileIDs: e }) => e)) } } class lt { constructor() { this.maxCrossTileID = 0; } generate() { return ++this.maxCrossTileID } } class ct { constructor() { this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0; } handleWrapJump(e) { const t = Math.round((e - this.lng) / 360); if (0 !== t) for (const e in this.indexes) { const i = this.indexes[e], r = {}; for (const e in i) { const o = i[e]; o.tileID = o.tileID.unwrapTo(o.tileID.wrap + t), r[o.tileID.key] = o; } this.indexes[e] = r; } this.lng = e; } addBucket(e, t, i) { if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) { if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === t.bucketInstanceId) return !1; this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key]); } for (let e = 0; e < t.symbolInstances.length; e++)t.symbolInstances.get(e).crossTileID = 0; this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {}); const r = this.usedCrossTileIDs[e.overscaledZ]; for (const i in this.indexes) { const o = this.indexes[i]; if (Number(i) > e.overscaledZ) for (const i in o) { const s = o[i]; s.tileID.isChildOf(e) && s.findMatches(t.symbolInstances, e, r); } else { const s = o[e.scaledTo(Number(i)).key]; s && s.findMatches(t.symbolInstances, e, r); } } for (let e = 0; e < t.symbolInstances.length; e++) { const o = t.symbolInstances.get(e); o.crossTileID || (o.crossTileID = i.generate(), r[o.crossTileID] = !0); } return void 0 === this.indexes[e.overscaledZ] && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new nt(e, t.symbolInstances, t.bucketInstanceId), !0 } removeBucketCrossTileIDs(e, t) { for (const i of t.getCrossTileIDsLists()) for (const t of i) delete this.usedCrossTileIDs[e][t]; } removeStaleBuckets(e) { let t = !1; for (const i in this.indexes) { const r = this.indexes[i]; for (const o in r) e[r[o].bucketInstanceId] || (this.removeBucketCrossTileIDs(i, r[o]), delete r[o], t = !0); } return t } } class ht { constructor() { this.layerIndexes = {}, this.crossTileIDs = new lt, this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {}; } addLayer(e, t, i) { let r = this.layerIndexes[e.id]; void 0 === r && (r = this.layerIndexes[e.id] = new ct); let o = !1; const s = {}; r.handleWrapJump(i); for (const i of t) { const t = i.getBucket(e); t && e.id === t.layerIds[0] && (t.bucketInstanceId || (t.bucketInstanceId = ++this.maxBucketInstanceId), r.addBucket(i.tileID, t, this.crossTileIDs) && (o = !0), s[t.bucketInstanceId] = !0); } return r.removeStaleBuckets(s) && (o = !0), o } pruneUnusedLayers(e) { const t = {}; e.forEach((e => { t[e] = !0; })); for (const e in this.layerIndexes) t[e] || delete this.layerIndexes[e]; } } var ut = "void main() {fragColor=vec4(1.0);}"; const dt = { prelude: _t("#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nout highp vec4 fragColor;", "#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c\n);}\n#ifdef TERRAIN3D\nuniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;\n#endif\nconst highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {\n#ifdef TERRAIN3D\nhighp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));\n#else\nreturn 1.0;\n#endif\n}float calculate_visibility(vec4 pos) {\n#ifdef TERRAIN3D\nvec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;\n#else\nreturn 1.0;\n#endif\n}float ele(vec2 pos) {\n#ifdef TERRAIN3D\nvec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;\n#else\nreturn 0.0;\n#endif\n}float get_elevation(vec2 pos) {\n#ifdef TERRAIN3D\n#ifdef GLOBE\nif ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}\n#endif\nvec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;\n#else\nreturn 0.0;\n#endif\n}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;"), projectionMercator: _t("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"), projectionGlobe: _t("", "#define GLOBE_RADIUS 6371008.8\nuniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos\n);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); \nif (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len\n);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}"), background: _t("uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), backgroundPattern: _t("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: _t("in vec3 v_data;in float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {\n#ifdef GLOBE\nvec3 center_vector=projectToSphere(circle_center);\n#endif\nfloat angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {\n#ifdef GLOBE\nvec4 projected_center=interpolateProjection(circle_center,center_vector,ele);\n#else\nvec4 projected_center=projectTileWithElevation(circle_center,ele);\n#endif\ncorner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}\n#ifdef GLOBE\nvec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);\n#else\ngl_Position=projectTileWithElevation(corner_position,ele);\n#endif\n} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}"), clippingMask: _t(ut, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), heatmap: _t("uniform highp float u_intensity;in vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);\n#ifdef GLOBE\nvec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);\n#else\ngl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));\n#endif\n}"), heatmapTexture: _t("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(0.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: _t("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: _t("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: _t("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"), depth: _t(ut, "in vec2 a_pos;void main() {\n#ifdef GLOBE\ngl_Position=projectTileFor3D(a_pos,0.0);\n#else\ngl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);\n#endif\n}"), fill: _t("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nfragColor=color*opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_fill_translate;in vec2 a_pos;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=projectTile(a_pos+u_fill_translate,a_pos);}"), fillOutline: _t("in vec2 v_pos;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n}"), fillOutlinePattern: _t("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n}"), fillPattern: _t("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}"), fillExtrusion: _t("in vec4 v_color;void main() {fragColor=v_color;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;\n#ifdef TERRAIN3D\nin vec2 a_centroid;\n#endif\nout vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 normal=a_normal_ed.xyz;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;\n#ifdef GLOBE\nvec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);\n#else\ngl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);\n#endif\nfloat colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);\n#ifdef GLOBE\nmat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);\n#endif\ndirectional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}"), fillExtrusionPattern: _t("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;\n#ifdef TERRAIN3D\nin vec2 a_centroid;\n#endif\n#ifdef GLOBE\nout vec3 v_sphere_pos;\n#endif\nout vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;\n#ifdef GLOBE\nvec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);\n#else\ngl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);\n#endif\nvec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\n? a_pos\n: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}"), hillshadePrepare: _t("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));fragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: _t("uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;\n#define PI 3.141592653589793\nvoid main() {vec4 pixel=texture(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), line: _t("uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"), lineGradient: _t("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"), linePattern: _t("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nin vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}"), lineSDF: _t("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nin vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}"), raster: _t("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;\n#ifdef GLOBE\nif (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}\n#endif\nv_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), symbolIcon: _t("uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;\n#ifdef GLOBE\nif(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}\n#endif\nvec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}"), symbolSDF: _t("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;\n#ifdef GLOBE\nif(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}\n#endif\nvec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}"), symbolTextAndIcon: _t("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;\n#ifdef GLOBE\nif(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}\n#endif\nvec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}"), terrain: _t("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"), terrainDepth: _t("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"), terrainCoords: _t("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"), projectionErrorMeasurement: _t("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"), atmosphere: _t("in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758\n);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}", "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"), sky: _t("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}") }; function _t(e, t) { const i = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, r = t.match(/in ([\w]+) ([\w]+)/g), o = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), s = t.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), a = s ? s.concat(o) : o, n = {}; return { fragmentSource: e = e.replace(i, ((e, t, i, r, o) => (n[o] = !0, "define" === t ? `\n#ifndef HAS_UNIFORM_u_${o}\nin ${i} ${r} ${o};\n#else\nuniform ${i} ${r} u_${o};\n#endif\n` : `\n#ifdef HAS_UNIFORM_u_${o}\n    ${i} ${r} ${o} = u_${o};\n#endif\n`))), vertexSource: t = t.replace(i, ((e, t, i, r, o) => { const s = "float" === r ? "vec2" : "vec4", a = o.match(/color/) ? "color" : s; return n[o] ? "define" === t ? `\n#ifndef HAS_UNIFORM_u_${o}\nuniform lowp float u_${o}_t;\nin ${i} ${s} a_${o};\nout ${i} ${r} ${o};\n#else\nuniform ${i} ${r} u_${o};\n#endif\n` : "vec4" === a ? `\n#ifndef HAS_UNIFORM_u_${o}\n    ${o} = a_${o};\n#else\n    ${i} ${r} ${o} = u_${o};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${o}\n    ${o} = unpack_mix_${a}(a_${o}, u_${o}_t);\n#else\n    ${i} ${r} ${o} = u_${o};\n#endif\n` : "define" === t ? `\n#ifndef HAS_UNIFORM_u_${o}\nuniform lowp float u_${o}_t;\nin ${i} ${s} a_${o};\n#else\nuniform ${i} ${r} u_${o};\n#endif\n` : "vec4" === a ? `\n#ifndef HAS_UNIFORM_u_${o}\n    ${i} ${r} ${o} = a_${o};\n#else\n    ${i} ${r} ${o} = u_${o};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${o}\n    ${i} ${r} ${o} = unpack_mix_${a}(a_${o}, u_${o}_t);\n#else\n    ${i} ${r} ${o} = u_${o};\n#endif\n` })), staticAttributes: r, staticUniforms: a } } class pt { constructor(e, t, i) { this.vertexBuffer = e, this.indexBuffer = t, this.segments = i; } destroy() { this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null; } } var mt = t.aA([{ name: "a_pos", type: "Int16", components: 2 }]); const ft = "#define PROJECTION_MERCATOR", gt = "mercator"; class vt { constructor() { this._cachedMesh = null; } get name() { return "mercator" } get useSubdivision() { return !1 } get shaderVariantName() { return gt } get shaderDefine() { return ft } get shaderPreludeCode() { return dt.projectionMercator } get vertexShaderPreludeCode() { return dt.projectionMercator.vertexSource } get subdivisionGranularity() { return t.aB.noSubdivision } get useGlobeControls() { return !1 } get transitionState() { return 0 } get latitudeErrorCorrectionRadians() { return 0 } destroy() { } updateGPUdependent(e) { } getMeshFromTileID(e, i, r, o, s) { if (this._cachedMesh) return this._cachedMesh; const a = new t.aC; a.emplaceBack(0, 0), a.emplaceBack(t.X, 0), a.emplaceBack(0, t.X), a.emplaceBack(t.X, t.X); const n = e.createVertexBuffer(a, mt.members), l = t.aD.simpleSegment(0, 0, 4, 2), c = new t.aE; c.emplaceBack(1, 0, 2), c.emplaceBack(1, 2, 3); const h = e.createIndexBuffer(c); return this._cachedMesh = new pt(n, h, l), this._cachedMesh } recalculate() { } hasTransition() { return !1 } setErrorQueryLatitudeDegrees(e) { } } function xt(e, i) { const r = t.ab(i.lat, -85.051129, t.aF); return new t.P(t.O(i.lng) * e, t.Q(r) * e) } function bt(e, i) { return new t.Y(i.x / e, i.y / e).toLngLat() } function yt(e) { return e.cameraToCenterDistance * Math.min(.85 * Math.tan(t.aa(90 - e.pitch)), Math.tan(t.aa(89.25 - e.pitch))) } function wt(e, i) { const r = e.canonical, o = i / t.aG(r.z), s = r.x + Math.pow(2, r.z) * e.wrap, a = t.aq(new Float64Array(16)); return t.J(a, a, [s * o, r.y * o, 0]), t.K(a, a, [o / t.X, o / t.X, 1]), a } function Tt(e, i, r, o, s) { const a = t.Y.fromLngLat(e, i), n = s * t.aH(1, e.lat), l = n * Math.cos(t.aa(r)), c = Math.sqrt(n * n - l * l), h = c * Math.sin(t.aa(-o)), u = c * Math.cos(t.aa(-o)); return new t.Y(a.x + h, a.y + u, a.z + l) } class Pt { constructor(e = 0, t = 0, i = 0, r = 0) { if (isNaN(e) || e < 0 || isNaN(t) || t < 0 || isNaN(i) || i < 0 || isNaN(r) || r < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers"); this.top = e, this.bottom = t, this.left = i, this.right = r; } interpolate(e, i, r) { return null != i.top && null != e.top && (this.top = t.y.number(e.top, i.top, r)), null != i.bottom && null != e.bottom && (this.bottom = t.y.number(e.bottom, i.bottom, r)), null != i.left && null != e.left && (this.left = t.y.number(e.left, i.left, r)), null != i.right && null != e.right && (this.right = t.y.number(e.right, i.right, r)), this } getCenter(e, i) { const r = t.ab((this.left + e - this.right) / 2, 0, e), o = t.ab((this.top + i - this.bottom) / 2, 0, i); return new t.P(r, o) } equals(e) { return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right } clone() { return new Pt(this.top, this.bottom, this.left, this.right) } toJSON() { return { top: this.top, bottom: this.bottom, left: this.left, right: this.right } } } function Ct(e, t) { if (!e.renderWorldCopies || e.lngRange) return; const i = t.lng - e.center.lng; t.lng += i > 180 ? -360 : i < -180 ? 360 : 0; } function It(e) { return Math.max(0, Math.floor(e)) } class Et { constructor(e, i, r, o, s, a) { this._callbacks = e, this._tileSize = 512, this._renderWorldCopies = void 0 === a || !!a, this._minZoom = i || 0, this._maxZoom = r || 22, this._minPitch = null == o ? 0 : o, this._maxPitch = null == s ? 60 : s, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new t.N(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = It(this._zoom), this._scale = t.aG(this._zoom), this._bearingInRadians = 0, this._fovInRadians = .6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = !0, this._edgeInsets = new Pt, this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = !0; } apply(e, i, r) { this._latRange = e.latRange, this._lngRange = e.lngRange, this._width = e.width, this._height = e.height, this._center = e.center, this._elevation = e.elevation, this._minElevationForCurrentTile = e.minElevationForCurrentTile, this._zoom = e.zoom, this._tileZoom = It(this._zoom), this._scale = t.aG(this._zoom), this._bearingInRadians = e.bearingInRadians, this._fovInRadians = e.fovInRadians, this._pitchInRadians = e.pitchInRadians, this._rollInRadians = e.rollInRadians, this._unmodified = e.unmodified, this._edgeInsets = new Pt(e.padding.top, e.padding.bottom, e.padding.left, e.padding.right), this._minZoom = e.minZoom, this._maxZoom = e.maxZoom, this._minPitch = e.minPitch, this._maxPitch = e.maxPitch, this._renderWorldCopies = e.renderWorldCopies, this._cameraToCenterDistance = e.cameraToCenterDistance, this._nearZ = e.nearZ, this._farZ = e.farZ, this._autoCalculateNearFarZ = !r && e.autoCalculateNearFarZ, i && this._constrain(), this._calcMatrices(); } get pixelsToClipSpaceMatrix() { return this._pixelsToClipSpaceMatrix } get clipSpaceToPixelsMatrix() { return this._clipSpaceToPixelsMatrix } get minElevationForCurrentTile() { return this._minElevationForCurrentTile } setMinElevationForCurrentTile(e) { this._minElevationForCurrentTile = e; } get tileSize() { return this._tileSize } get tileZoom() { return this._tileZoom } get scale() { return this._scale } get width() { return this._width } get height() { return this._height } get bearingInRadians() { return this._bearingInRadians } get lngRange() { return this._lngRange } get latRange() { return this._latRange } get pixelsToGLUnits() { return this._pixelsToGLUnits } get minZoom() { return this._minZoom } setMinZoom(e) { this._minZoom !== e && (this._minZoom = e, this.setZoom(this.getConstrained(this._center, this.zoom).zoom)); } get maxZoom() { return this._maxZoom } setMaxZoom(e) { this._maxZoom !== e && (this._maxZoom = e, this.setZoom(this.getConstrained(this._center, this.zoom).zoom)); } get minPitch() { return this._minPitch } setMinPitch(e) { this._minPitch !== e && (this._minPitch = e, this.setPitch(Math.max(this.pitch, e))); } get maxPitch() { return this._maxPitch } setMaxPitch(e) { this._maxPitch !== e && (this._maxPitch = e, this.setPitch(Math.min(this.pitch, e))); } get renderWorldCopies() { return this._renderWorldCopies } setRenderWorldCopies(e) { void 0 === e ? e = !0 : null === e && (e = !1), this._renderWorldCopies = e; } get worldSize() { return this._tileSize * this._scale } get centerOffset() { return this.centerPoint._sub(this.size._div(2)) } get size() { return new t.P(this._width, this._height) } get bearing() { return this._bearingInRadians / Math.PI * 180 } setBearing(e) { const i = t.aI(e, -180, 180) * Math.PI / 180; var o, s, a, n, l, c, h, u, d; this._bearingInRadians !== i && (this._unmodified = !1, this._bearingInRadians = i, this._calcMatrices(), this._rotationMatrix = r(), o = this._rotationMatrix, a = -this._bearingInRadians, n = (s = this._rotationMatrix)[0], l = s[1], c = s[2], h = s[3], u = Math.sin(a), d = Math.cos(a), o[0] = n * d + c * u, o[1] = l * d + h * u, o[2] = n * -u + c * d, o[3] = l * -u + h * d); } get rotationMatrix() { return this._rotationMatrix } get pitchInRadians() { return this._pitchInRadians } get pitch() { return this._pitchInRadians / Math.PI * 180 } setPitch(e) { const i = t.ab(e, this.minPitch, this.maxPitch) / 180 * Math.PI; this._pitchInRadians !== i && (this._unmodified = !1, this._pitchInRadians = i, this._calcMatrices()); } get rollInRadians() { return this._rollInRadians } get roll() { return this._rollInRadians / Math.PI * 180 } setRoll(e) { const t = e / 180 * Math.PI; this._rollInRadians !== t && (this._unmodified = !1, this._rollInRadians = t, this._calcMatrices()); } get fovInRadians() { return this._fovInRadians } get fov() { return t.aJ(this._fovInRadians) } setFov(e) { e = t.ab(e, .1, 150), this.fov !== e && (this._unmodified = !1, this._fovInRadians = t.aa(e), this._calcMatrices()); } get zoom() { return this._zoom } setZoom(e) { const i = this.getConstrained(this._center, e).zoom; this._zoom !== i && (this._unmodified = !1, this._zoom = i, this._tileZoom = Math.max(0, Math.floor(i)), this._scale = t.aG(i), this._constrain(), this._calcMatrices()); } get center() { return this._center } setCenter(e) { e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1, this._center = e, this._constrain(), this._calcMatrices()); } get elevation() { return this._elevation } setElevation(e) { e !== this._elevation && (this._elevation = e, this._constrain(), this._calcMatrices()); } get padding() { return this._edgeInsets.toJSON() } setPadding(e) { this._edgeInsets.equals(e) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices()); } get centerPoint() { return this._edgeInsets.getCenter(this._width, this._height) } get pixelsPerMeter() { return this._pixelPerMeter } get unmodified() { return this._unmodified } get cameraToCenterDistance() { return this._cameraToCenterDistance } get nearZ() { return this._nearZ } get farZ() { return this._farZ } get autoCalculateNearFarZ() { return this._autoCalculateNearFarZ } overrideNearFarZ(e, t) { this._autoCalculateNearFarZ = !1, this._nearZ = e, this._farZ = t, this._calcMatrices(); } clearNearFarZOverride() { this._autoCalculateNearFarZ = !0, this._calcMatrices(); } isPaddingEqual(e) { return this._edgeInsets.equals(e) } interpolatePadding(e, t, i) { this._unmodified = !1, this._edgeInsets.interpolate(e, t, i), this._constrain(), this._calcMatrices(); } resize(e, t, i = !0) { this._width = e, this._height = t, i && this._constrain(), this._calcMatrices(); } getMaxBounds() { return this._latRange && 2 === this._latRange.length && this._lngRange && 2 === this._lngRange.length ? new V([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null } setMaxBounds(e) { e ? (this._lngRange = [e.getWest(), e.getEast()], this._latRange = [e.getSouth(), e.getNorth()], this._constrain()) : (this._lngRange = null, this._latRange = [-85.051129, t.aF]); } getConstrained(e, t) { return this._callbacks.getConstrained(e, t) } getCameraQueryGeometry(e, i) { if (1 === i.length) return [i[0], e]; { let r = e.x, o = e.y, s = e.x, a = e.y; for (const e of i) r = Math.min(r, e.x), o = Math.min(o, e.y), s = Math.max(s, e.x), a = Math.max(a, e.y); return [new t.P(r, o), new t.P(s, o), new t.P(s, a), new t.P(r, a), new t.P(r, o)] } } _constrain() { if (!this.center || !this._width || !this._height || this._constraining) return; this._constraining = !0; const e = this._unmodified, { center: t, zoom: i } = this.getConstrained(this.center, this.zoom); this.setCenter(t), this.setZoom(i), this._unmodified = e, this._constraining = !1; } _calcMatrices() { if (this._width && this._height) { this._pixelsToGLUnits = [2 / this._width, -2 / this._height]; let e = t.aq(new Float64Array(16)); t.K(e, e, [this._width / 2, -this._height / 2, 1]), t.J(e, e, [1, -1, 0]), this._clipSpaceToPixelsMatrix = e, e = t.aq(new Float64Array(16)), t.K(e, e, [1, -1, 1]), t.J(e, e, [-1, -1, 0]), t.K(e, e, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = e, this._cameraToCenterDistance = .5 / Math.tan(this.fovInRadians / 2) * this._height; } this._callbacks.calcMatrices(); } calculateCenterFromCameraLngLatAlt(e, i, r, o) { const s = void 0 !== r ? r : this.bearing, a = o = void 0 !== o ? o : this.pitch, n = t.Y.fromLngLat(e, i), l = -Math.cos(t.aa(a)), c = Math.sin(t.aa(a)), h = c * Math.sin(t.aa(s)), u = -c * Math.cos(t.aa(s)); let d = this.elevation; const _ = i - d; let p; l * _ >= 0 || Math.abs(l) < .1 ? (p = 1e4, d = i + p * l) : p = -_ / l; let m, f, g = t.aK(1, n.y), v = 0; do { if (v += 1, v > 10) break; f = p / g, m = new t.Y(n.x + h * f, n.y + u * f), g = 1 / m.meterInMercatorCoordinateUnits(); } while (Math.abs(p - f * g) > 1e-12); return { center: m.toLngLat(), elevation: d, zoom: t.a8(this.height / 2 / Math.tan(this.fovInRadians / 2) / f / this.tileSize) } } recalculateZoomAndCenter(e) { if (this.elevation - e == 0) return; const i = t.aH(1, this.center.lat) * this.worldSize, r = this.cameraToCenterDistance / i, o = t.Y.fromLngLat(this.center, this.elevation), s = Tt(this.center, this.elevation, this.pitch, this.bearing, r); this._elevation = e; const a = this.calculateCenterFromCameraLngLatAlt(s.toLngLat(), t.aK(s.z, o.y), this.bearing, this.pitch); this._elevation = a.elevation, this._center = a.center, this.setZoom(a.zoom); } getCameraPoint() { const e = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1); return this.centerPoint.add(new t.P(e * Math.sin(this.rollInRadians), e * Math.cos(this.rollInRadians))) } getCameraAltitude() { return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation } getCameraLngLat() { const e = t.aH(1, this.center.lat) * this.worldSize; return Tt(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / e).toLngLat() } getMercatorTileCoordinates(e) { if (!e) return [0, 0, 1, 1]; const i = e.canonical.z >= 0 ? 1 << e.canonical.z : Math.pow(2, e.canonical.z); return [e.canonical.x / i, e.canonical.y / i, 1 / i / t.X, 1 / i / t.X] } } class Mt { constructor(e, i) { this.min = e, this.max = i, this.center = t.aL([], t.aM([], this.min, this.max), .5); } quadrant(e) { const i = [e % 2 == 0, e < 2], r = t.aN(this.min), o = t.aN(this.max); for (let e = 0; e < i.length; e++)r[e] = i[e] ? this.min[e] : this.center[e], o[e] = i[e] ? this.center[e] : this.max[e]; return o[2] = this.max[2], new Mt(r, o) } distanceX(e) { return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0] } distanceY(e) { return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1] } intersectsFrustum(e) { let t = !0; for (let i = 0; i < e.planes.length; i++) { const r = this.intersectsPlane(e.planes[i]); if (0 === r) return 0; 1 === r && (t = !1); } return t ? 2 : e.aabb.min[0] > this.max[0] || e.aabb.min[1] > this.max[1] || e.aabb.min[2] > this.max[2] || e.aabb.max[0] < this.min[0] || e.aabb.max[1] < this.min[1] || e.aabb.max[2] < this.min[2] ? 0 : 1 } intersectsPlane(e) { let t = e[3], i = e[3]; for (let r = 0; r < 3; r++)e[r] > 0 ? (t += e[r] * this.min[r], i += e[r] * this.max[r]) : (i += e[r] * this.min[r], t += e[r] * this.max[r]); return t >= 0 ? 2 : i < 0 ? 0 : 1 } } class St { distanceToTile2d(e, t, i, r) { const o = r.distanceX([e, t]), s = r.distanceY([e, t]); return Math.hypot(o, s) } getWrap(e, t, i) { return i } getTileAABB(e, i, r, o) { var s, a; let n = r, l = r; if (o.terrain) { const c = new t.S(e.z, i, e.z, e.x, e.y), h = o.terrain.getMinMaxElevation(c); n = null !== (s = h.minElevation) && void 0 !== s ? s : r, l = null !== (a = h.maxElevation) && void 0 !== a ? a : r; } const c = 1 << e.z; return new Mt([i + e.x / c, e.y / c, n], [i + (e.x + 1) / c, (e.y + 1) / c, l]) } allowVariableZoom(e, i) { const r = e.fov * (Math.abs(Math.cos(e.rollInRadians)) * e.height + Math.abs(Math.sin(e.rollInRadians)) * e.width) / e.height, o = t.ab(78.5 - r / 2, 0, 60); return !!i.terrain || e.pitch > o || e.padding.top >= .1 } allowWorldCopies() { return !0 } recalculateCache() { } } class Rt { constructor(e, t, i) { this.points = e, this.planes = t, this.aabb = i; } static fromInvProjectionMatrix(e, i = 1, r = 0) { const o = Math.pow(2, r), s = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((r => { const s = 1 / (r = t.al([], r, e))[3] / i * o; return t.aO(r, r, [s, s, 1 / r[3], s]) })), a = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((e => { const i = t.aP([], s[e[0]], s[e[1]]), r = t.aP([], s[e[2]], s[e[1]]), o = t.aQ([], t.aR([], i, r)), a = -t.aS(o, s[e[1]]); return o.concat(a) })), n = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY], l = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY]; for (const e of s) for (let t = 0; t < 3; t++)n[t] = Math.min(n[t], e[t]), l[t] = Math.max(l[t], e[t]); return new Rt(s, a, new Mt(n, l)) } } class Dt { get pixelsToClipSpaceMatrix() { return this._helper.pixelsToClipSpaceMatrix } get clipSpaceToPixelsMatrix() { return this._helper.clipSpaceToPixelsMatrix } get pixelsToGLUnits() { return this._helper.pixelsToGLUnits } get centerOffset() { return this._helper.centerOffset } get size() { return this._helper.size } get rotationMatrix() { return this._helper.rotationMatrix } get centerPoint() { return this._helper.centerPoint } get pixelsPerMeter() { return this._helper.pixelsPerMeter } setMinZoom(e) { this._helper.setMinZoom(e); } setMaxZoom(e) { this._helper.setMaxZoom(e); } setMinPitch(e) { this._helper.setMinPitch(e); } setMaxPitch(e) { this._helper.setMaxPitch(e); } setRenderWorldCopies(e) { this._helper.setRenderWorldCopies(e); } setBearing(e) { this._helper.setBearing(e); } setPitch(e) { this._helper.setPitch(e); } setRoll(e) { this._helper.setRoll(e); } setFov(e) { this._helper.setFov(e); } setZoom(e) { this._helper.setZoom(e); } setCenter(e) { this._helper.setCenter(e); } setElevation(e) { this._helper.setElevation(e); } setMinElevationForCurrentTile(e) { this._helper.setMinElevationForCurrentTile(e); } setPadding(e) { this._helper.setPadding(e); } interpolatePadding(e, t, i) { return this._helper.interpolatePadding(e, t, i) } isPaddingEqual(e) { return this._helper.isPaddingEqual(e) } resize(e, t, i = !0) { this._helper.resize(e, t, i); } getMaxBounds() { return this._helper.getMaxBounds() } setMaxBounds(e) { this._helper.setMaxBounds(e); } overrideNearFarZ(e, t) { this._helper.overrideNearFarZ(e, t); } clearNearFarZOverride() { this._helper.clearNearFarZOverride(); } getCameraQueryGeometry(e) { return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e) } get tileSize() { return this._helper.tileSize } get tileZoom() { return this._helper.tileZoom } get scale() { return this._helper.scale } get worldSize() { return this._helper.worldSize } get width() { return this._helper.width } get height() { return this._helper.height } get lngRange() { return this._helper.lngRange } get latRange() { return this._helper.latRange } get minZoom() { return this._helper.minZoom } get maxZoom() { return this._helper.maxZoom } get zoom() { return this._helper.zoom } get center() { return this._helper.center } get minPitch() { return this._helper.minPitch } get maxPitch() { return this._helper.maxPitch } get pitch() { return this._helper.pitch } get pitchInRadians() { return this._helper.pitchInRadians } get roll() { return this._helper.roll } get rollInRadians() { return this._helper.rollInRadians } get bearing() { return this._helper.bearing } get bearingInRadians() { return this._helper.bearingInRadians } get fov() { return this._helper.fov } get fovInRadians() { return this._helper.fovInRadians } get elevation() { return this._helper.elevation } get minElevationForCurrentTile() { return this._helper.minElevationForCurrentTile } get padding() { return this._helper.padding } get unmodified() { return this._helper.unmodified } get renderWorldCopies() { return this._helper.renderWorldCopies } get cameraToCenterDistance() { return this._helper.cameraToCenterDistance } get nearZ() { return this._helper.nearZ } get farZ() { return this._helper.farZ } get autoCalculateNearFarZ() { return this._helper.autoCalculateNearFarZ } setTransitionState(e, t) { } constructor(e, t, i, r, o) { this._posMatrixCache = new Map, this._alignedPosMatrixCache = new Map, this._fogMatrixCacheF32 = new Map, this._helper = new Et({ calcMatrices: () => { this._calcMatrices(); }, getConstrained: (e, t) => this.getConstrained(e, t) }, e, t, i, r, o), this._coveringTilesDetailsProvider = new St; } clone() { const e = new Dt; return e.apply(this), e } apply(e, t, i) { this._helper.apply(e, t, i); } get cameraPosition() { return this._cameraPosition } get projectionMatrix() { return this._projectionMatrix } get modelViewProjectionMatrix() { return this._viewProjMatrix } get inverseProjectionMatrix() { return this._invProjMatrix } get mercatorMatrix() { return this._mercatorMatrix } getVisibleUnwrappedCoordinates(e) { const i = [new t.aT(0, e)]; if (this._helper._renderWorldCopies) { const r = this.screenPointToMercatorCoordinate(new t.P(0, 0)), o = this.screenPointToMercatorCoordinate(new t.P(this._helper._width, 0)), s = this.screenPointToMercatorCoordinate(new t.P(this._helper._width, this._helper._height)), a = this.screenPointToMercatorCoordinate(new t.P(0, this._helper._height)), n = Math.floor(Math.min(r.x, o.x, s.x, a.x)), l = Math.floor(Math.max(r.x, o.x, s.x, a.x)), c = 1; for (let r = n - c; r <= l + c; r++)0 !== r && i.push(new t.aT(r, e)); } return i } getCameraFrustum() { return Rt.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize) } getClippingPlane() { return null } getCoveringTilesDetailsProvider() { return this._coveringTilesDetailsProvider } recalculateZoomAndCenter(e) { const t = this.screenPointToLocation(this.centerPoint, e), i = e ? e.getElevationForLngLatZoom(t, this._helper._tileZoom) : 0; this._helper.recalculateZoomAndCenter(i); } setLocationAtPoint(e, i) { const r = t.aH(this.elevation, this.center.lat), o = this.screenPointToMercatorCoordinateAtZ(i, r), s = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, r), a = t.Y.fromLngLat(e), n = new t.Y(a.x - (o.x - s.x), a.y - (o.y - s.y)); this.setCenter(null == n ? void 0 : n.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap()); } locationToScreenPoint(e, i) { return i ? this.coordinatePoint(t.Y.fromLngLat(e), i.getElevationForLngLatZoom(e, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(t.Y.fromLngLat(e)) } screenPointToLocation(e, t) { var i; return null === (i = this.screenPointToMercatorCoordinate(e, t)) || void 0 === i ? void 0 : i.toLngLat() } screenPointToMercatorCoordinate(e, t) { if (t) { const i = t.pointCoordinate(e); if (null != i) return i } return this.screenPointToMercatorCoordinateAtZ(e) } screenPointToMercatorCoordinateAtZ(e, i) { const r = i || 0, o = [e.x, e.y, 0, 1], s = [e.x, e.y, 1, 1]; t.al(o, o, this._pixelMatrixInverse), t.al(s, s, this._pixelMatrixInverse); const a = o[3], n = s[3], l = o[1] / a, c = s[1] / n, h = o[2] / a, u = s[2] / n, d = h === u ? 0 : (r - h) / (u - h); return new t.Y(t.y.number(o[0] / a, s[0] / n, d) / this.worldSize, t.y.number(l, c, d) / this.worldSize, r) } coordinatePoint(e, i = 0, r = this._pixelMatrix) { const o = [e.x * this.worldSize, e.y * this.worldSize, i, 1]; return t.al(o, o, r), new t.P(o[0] / o[3], o[1] / o[3]) } getBounds() { const e = Math.max(0, this._helper._height / 2 - yt(this)); return (new V).extend(this.screenPointToLocation(new t.P(0, e))).extend(this.screenPointToLocation(new t.P(this._helper._width, e))).extend(this.screenPointToLocation(new t.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new t.P(0, this._helper._height))) } isPointOnMapSurface(e, t) { return t ? null != t.pointCoordinate(e) : e.y > this.height / 2 - yt(this) } calculatePosMatrix(e, i = !1, r) { var o; const s = null !== (o = e.key) && void 0 !== o ? o : t.aU(e.wrap, e.canonical.z, e.canonical.z, e.canonical.x, e.canonical.y), a = i ? this._alignedPosMatrixCache : this._posMatrixCache; if (a.has(s)) { const e = a.get(s); return r ? e.f32 : e.f64 } const n = wt(e, this.worldSize); t.L(n, i ? this._alignedProjMatrix : this._viewProjMatrix, n); const l = { f64: n, f32: new Float32Array(n) }; return a.set(s, l), r ? l.f32 : l.f64 } calculateFogMatrix(e) { const i = e.key, r = this._fogMatrixCacheF32; if (r.has(i)) return r.get(i); const o = wt(e, this.worldSize); return t.L(o, this._fogMatrix, o), r.set(i, new Float32Array(o)), r.get(i) } getConstrained(e, i) { i = t.ab(+i, this.minZoom, this.maxZoom); const r = { center: new t.N(e.lng, e.lat), zoom: i }; let o = this._helper._lngRange; this._helper._renderWorldCopies || null !== o || (o = [-179.9999999999, 180 - 1e-10]); const s = this.tileSize * t.aG(r.zoom); let a = 0, n = s, l = 0, c = s, h = 0, u = 0; const { x: d, y: _ } = this.size; if (this._helper._latRange) { const e = this._helper._latRange; a = t.Q(e[1]) * s, n = t.Q(e[0]) * s, n - a < _ && (h = _ / (n - a)); } o && (l = t.aI(t.O(o[0]) * s, 0, s), c = t.aI(t.O(o[1]) * s, 0, s), c < l && (c += s), c - l < d && (u = d / (c - l))); const { x: p, y: m } = xt(s, e); let f, g; const v = Math.max(u || 0, h || 0); if (v) { const e = new t.P(u ? (c + l) / 2 : p, h ? (n + a) / 2 : m); return r.center = bt(s, e).wrap(), r.zoom += t.a8(v), r } if (this._helper._latRange) { const e = _ / 2; m - e < a && (g = a + e), m + e > n && (g = n - e); } if (o) { const e = (l + c) / 2; let i = p; this._helper._renderWorldCopies && (i = t.aI(p, e - s / 2, e + s / 2)); const r = d / 2; i - r < l && (f = l + r), i + r > c && (f = c - r); } if (void 0 !== f || void 0 !== g) { const e = new t.P(null != f ? f : p, null != g ? g : m); r.center = bt(s, e).wrap(); } return r } calculateCenterFromCameraLngLatAlt(e, t, i, r) { return this._helper.calculateCenterFromCameraLngLatAlt(e, t, i, r) } _calculateNearFarZIfNeeded(e, i, r) { if (!this._helper.autoCalculateNearFarZ) return; const o = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100), s = e - o * this._helper._pixelPerMeter / Math.cos(i), a = o < 0 ? s : e, n = Math.PI / 2 + this.pitchInRadians, l = t.aa(this.fov) * (Math.abs(Math.cos(t.aa(this.roll))) * this.height + Math.abs(Math.sin(t.aa(this.roll))) * this.width) / this.height * (.5 + r.y / this.height), c = Math.sin(l) * a / Math.sin(t.ab(Math.PI - n - l, .01, Math.PI - .01)), h = yt(this), u = Math.atan(h / this._helper.cameraToCenterDistance), d = t.aa(.75), _ = u > d ? 2 * u * (.5 + r.y / (2 * h)) : d, p = Math.sin(_) * a / Math.sin(t.ab(Math.PI - n - _, .01, Math.PI - .01)), m = Math.min(c, p); this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - i) * m + a), this._helper._nearZ = this._helper._height / 50; } _calcMatrices() { if (!this._helper._height) return; const e = this.centerOffset, i = xt(this.worldSize, this.center), r = i.x, o = i.y; this._helper._pixelPerMeter = t.aH(1, this.center.lat) * this.worldSize; const s = t.aa(Math.min(this.pitch, 89.25)), a = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(s)); let n; this._calculateNearFarZIfNeeded(a, s, e), n = new Float64Array(16), t.aV(n, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), t.an(this._invProjMatrix, n), n[8] = 2 * -e.x / this._helper._width, n[9] = 2 * e.y / this._helper._height, this._projectionMatrix = t.aW(n), t.K(n, n, [1, -1, 1]), t.J(n, n, [0, 0, -this._helper.cameraToCenterDistance]), t.aX(n, n, -this.rollInRadians), t.aY(n, n, this.pitchInRadians), t.aX(n, n, -this.bearingInRadians), t.J(n, n, [-r, -o, 0]), this._mercatorMatrix = t.K([], n, [this.worldSize, this.worldSize, this.worldSize]), t.K(n, n, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = t.L(new Float64Array(16), this.clipSpaceToPixelsMatrix, n), t.J(n, n, [0, 0, -this.elevation]), this._viewProjMatrix = n, this._invViewProjMatrix = t.an([], n); const l = [0, 0, -1, 1]; t.al(l, l, this._invViewProjMatrix), this._cameraPosition = [l[0] / l[3], l[1] / l[3], l[2] / l[3]], this._fogMatrix = new Float64Array(16), t.aV(this._fogMatrix, this.fovInRadians, this.width / this.height, a, this._helper._farZ), this._fogMatrix[8] = 2 * -e.x / this.width, this._fogMatrix[9] = 2 * e.y / this.height, t.K(this._fogMatrix, this._fogMatrix, [1, -1, 1]), t.J(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), t.aX(this._fogMatrix, this._fogMatrix, -this.rollInRadians), t.aY(this._fogMatrix, this._fogMatrix, this.pitchInRadians), t.aX(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), t.J(this._fogMatrix, this._fogMatrix, [-r, -o, 0]), t.K(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), t.J(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = t.L(new Float64Array(16), this.clipSpaceToPixelsMatrix, n); const c = this._helper._width % 2 / 2, h = this._helper._height % 2 / 2, u = Math.cos(this.bearingInRadians), d = Math.sin(-this.bearingInRadians), _ = r - Math.round(r) + u * c + d * h, p = o - Math.round(o) + u * h + d * c, m = new Float64Array(n); if (t.J(m, m, [_ > .5 ? _ - 1 : _, p > .5 ? p - 1 : p, 0]), this._alignedProjMatrix = m, n = t.an(new Float64Array(16), this._pixelMatrix), !n) throw new Error("failed to invert matrix"); this._pixelMatrixInverse = n, this._clearMatrixCaches(); } _clearMatrixCaches() { this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear(); } maxPitchScaleFactor() { if (!this._pixelMatrixInverse) return 1; const e = this.screenPointToMercatorCoordinate(new t.P(0, 0)), i = [e.x * this.worldSize, e.y * this.worldSize, 0, 1]; return t.al(i, i, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance } getCameraPoint() { return this._helper.getCameraPoint() } getCameraAltitude() { return this._helper.getCameraAltitude() } getCameraLngLat() { const e = t.aH(1, this.center.lat) * this.worldSize; return Tt(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / e).toLngLat() } lngLatToCameraDepth(e, i) { const r = t.Y.fromLngLat(e), o = [r.x * this.worldSize, r.y * this.worldSize, i, 1]; return t.al(o, o, this._viewProjMatrix), o[2] / o[3] } getProjectionData(e) { const { overscaledTileID: i, aligned: r, applyTerrainMatrix: o } = e, s = this._helper.getMercatorTileCoordinates(i), a = i ? this.calculatePosMatrix(i, r, !0) : null; let n; return n = i && i.terrainRttPosMatrix32f && o ? i.terrainRttPosMatrix32f : a || t.aZ(), { mainMatrix: n, tileMercatorCoords: s, clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: n } } isLocationOccluded(e) { return !1 } getPixelScale() { return 1 } getCircleRadiusCorrection() { return 1 } getPitchedTextCorrection(e, t, i) { return 1 } transformLightDirection(e) { return t.aN(e) } getRayDirectionFromPixel(e) { throw new Error("Not implemented.") } projectTileCoordinates(e, i, r, o) { const s = this.calculatePosMatrix(r); let a; o ? (a = [e, i, o(e, i), 1], t.al(a, a, s)) : (a = [e, i, 0, 1], je(a, a, s)); const n = a[3]; return { point: new t.P(a[0] / n, a[1] / n), signedDistanceFromCamera: n, isOccluded: !1 } } populateCache(e) { for (const t of e) this.calculatePosMatrix(t); } getMatrixForModel(e, i) { const r = t.Y.fromLngLat(e, i), o = r.meterInMercatorCoordinateUnits(), s = t.a_(); return t.J(s, s, [r.x, r.y, r.z]), t.aX(s, s, Math.PI), t.aY(s, s, Math.PI / 2), t.K(s, s, [-o, o, o]), s } getProjectionDataForCustomLayer(e = !0) { const i = new t.S(0, 0, 0, 0, 0), r = this.getProjectionData({ overscaledTileID: i, applyGlobeMatrix: e }), o = wt(i, this.worldSize); t.L(o, this._viewProjMatrix, o), r.tileMercatorCoords = [0, 0, 1, 1]; const s = [t.X, t.X, this.worldSize / this._helper.pixelsPerMeter], a = t.a$(); return t.K(a, o, s), r.fallbackMatrix = a, r.mainMatrix = a, r } getFastPathSimpleProjectionMatrix(e) { return this.calculatePosMatrix(e) } } function zt() { t.w("Map cannot fit within canvas with the given bounds, padding, and/or offset."); } function At(e) { if (e.useSlerp) if (e.k < 1) { const i = t.b0(e.startEulerAngles.roll, e.startEulerAngles.pitch, e.startEulerAngles.bearing), r = t.b0(e.endEulerAngles.roll, e.endEulerAngles.pitch, e.endEulerAngles.bearing), o = new Float64Array(4); t.b1(o, i, r, e.k); const s = t.b2(o); e.tr.setRoll(s.roll), e.tr.setPitch(s.pitch), e.tr.setBearing(s.bearing); } else e.tr.setRoll(e.endEulerAngles.roll), e.tr.setPitch(e.endEulerAngles.pitch), e.tr.setBearing(e.endEulerAngles.bearing); else e.tr.setRoll(t.y.number(e.startEulerAngles.roll, e.endEulerAngles.roll, e.k)), e.tr.setPitch(t.y.number(e.startEulerAngles.pitch, e.endEulerAngles.pitch, e.k)), e.tr.setBearing(t.y.number(e.startEulerAngles.bearing, e.endEulerAngles.bearing, e.k)); } function Lt(e, i, r, o, s) { const a = s.padding, n = xt(s.worldSize, r.getNorthWest()), l = xt(s.worldSize, r.getNorthEast()), c = xt(s.worldSize, r.getSouthEast()), h = xt(s.worldSize, r.getSouthWest()), u = t.aa(-o), d = n.rotate(u), _ = l.rotate(u), p = c.rotate(u), m = h.rotate(u), f = new t.P(Math.max(d.x, _.x, m.x, p.x), Math.max(d.y, _.y, m.y, p.y)), g = new t.P(Math.min(d.x, _.x, m.x, p.x), Math.min(d.y, _.y, m.y, p.y)), v = f.sub(g), x = (s.width - (a.left + a.right + i.left + i.right)) / v.x, b = (s.height - (a.top + a.bottom + i.top + i.bottom)) / v.y; if (b < 0 || x < 0) return void zt(); const y = Math.min(t.a8(s.scale * Math.min(x, b)), e.maxZoom), w = t.P.convert(e.offset), T = new t.P((i.left - i.right) / 2, (i.top - i.bottom) / 2).rotate(t.aa(o)), P = w.add(T).mult(s.scale / t.aG(y)); return { center: bt(s.worldSize, n.add(c).div(2).sub(P)), zoom: y, bearing: o } } class kt { get useGlobeControls() { return !1 } handlePanInertia(e, t) { return { easingOffset: e, easingCenter: t.center } } handleMapControlsRollPitchBearingZoom(e, t) { e.bearingDelta && t.setBearing(t.bearing + e.bearingDelta), e.pitchDelta && t.setPitch(t.pitch + e.pitchDelta), e.rollDelta && t.setRoll(t.roll + e.rollDelta), e.zoomDelta && t.setZoom(t.zoom + e.zoomDelta); } handleMapControlsPan(e, t, i) { e.around.distSqr(t.centerPoint) < .01 || t.setLocationAtPoint(i, e.around); } cameraForBoxAndBearing(e, t, i, r, o) { return Lt(e, t, i, r, o) } handleJumpToCenterZoom(e, i) { e.zoom !== (void 0 !== i.zoom ? +i.zoom : e.zoom) && e.setZoom(+i.zoom), void 0 !== i.center && e.setCenter(t.N.convert(i.center)); } handleEaseTo(e, i) { const r = e.zoom, o = e.padding, s = { roll: e.roll, pitch: e.pitch, bearing: e.bearing }, a = { roll: void 0 === i.roll ? e.roll : i.roll, pitch: void 0 === i.pitch ? e.pitch : i.pitch, bearing: void 0 === i.bearing ? e.bearing : i.bearing }, n = void 0 !== i.zoom, l = !e.isPaddingEqual(i.padding); let c = !1; const h = n ? +i.zoom : e.zoom; let u = e.centerPoint.add(i.offsetAsPoint); const d = e.screenPointToLocation(u), { center: _, zoom: p } = e.getConstrained(t.N.convert(i.center || d), null != h ? h : r); Ct(e, _); const m = xt(e.worldSize, d), f = xt(e.worldSize, _).sub(m), g = t.aG(p - r); return c = p !== r, { easeFunc: n => { if (c && e.setZoom(t.y.number(r, p, n)), t.b3(s, a) || At({ startEulerAngles: s, endEulerAngles: a, tr: e, k: n, useSlerp: s.roll != a.roll }), l && (e.interpolatePadding(o, i.padding, n), u = e.centerPoint.add(i.offsetAsPoint)), i.around) e.setLocationAtPoint(i.around, i.aroundPoint); else { const i = t.aG(e.zoom - r), o = p > r ? Math.min(2, g) : Math.max(.5, g), s = Math.pow(o, 1 - n), a = bt(e.worldSize, m.add(f.mult(n * s)).mult(i)); e.setLocationAtPoint(e.renderWorldCopies ? a.wrap() : a, u); } }, isZooming: c, elevationCenter: _ } } handleFlyTo(e, i) { const r = void 0 !== i.zoom, o = e.zoom, s = e.getConstrained(t.N.convert(i.center || i.locationAtOffset), r ? +i.zoom : o), a = s.center, n = s.zoom; Ct(e, a); const l = xt(e.worldSize, i.locationAtOffset), c = xt(e.worldSize, a).sub(l), h = c.mag(), u = t.aG(n - o); let d; if (void 0 !== i.minZoom) { const r = Math.min(+i.minZoom, o, n), s = e.getConstrained(a, r).zoom; d = t.aG(s - o); } return { easeFunc: (i, r, s, h) => { e.setZoom(1 === i ? n : o + t.a8(r)); const u = 1 === i ? a : bt(e.worldSize, l.add(c.mult(s)).mult(r)); e.setLocationAtPoint(e.renderWorldCopies ? u.wrap() : u, h); }, scaleOfZoom: u, targetCenter: a, scaleOfMinZoom: d, pixelPathLength: h } } } class Ft { constructor(e, t, i) { this.blendFunction = e, this.blendColor = t, this.mask = i; } } Ft.Replace = [1, 0], Ft.disabled = new Ft(Ft.Replace, t.b4.transparent, [!1, !1, !1, !1]), Ft.unblended = new Ft(Ft.Replace, t.b4.transparent, [!0, !0, !0, !0]), Ft.alphaBlended = new Ft([1, 771], t.b4.transparent, [!0, !0, !0, !0]); const Bt = 2305; class jt { constructor(e, t, i) { this.enable = e, this.mode = t, this.frontFace = i; } } jt.disabled = new jt(!1, 1029, Bt), jt.backCCW = new jt(!0, 1029, Bt), jt.frontCCW = new jt(!0, 1028, Bt); class Ot { constructor(e, t, i) { this.func = e, this.mask = t, this.range = i; } } Ot.ReadOnly = !1, Ot.ReadWrite = !0, Ot.disabled = new Ot(519, Ot.ReadOnly, [0, 1]); const Nt = 7680; class Zt { constructor(e, t, i, r, o, s) { this.test = e, this.ref = t, this.mask = i, this.fail = r, this.depthFail = o, this.pass = s; } } Zt.disabled = new Zt({ func: 519, mask: 0 }, 0, 0, Nt, Nt, Nt); const Gt = new WeakMap; function Ut(e) { var t; if (Gt.has(e)) return Gt.get(e); { const i = null === (t = e.getParameter(e.VERSION)) || void 0 === t ? void 0 : t.startsWith("WebGL 2.0"); return Gt.set(e, i), i } } class Vt { get awaitingQuery() { return !!this._readbackQueue } constructor(e) { this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = e; const i = e.context, r = i.gl; this._texFormat = r.RGBA, this._texType = r.UNSIGNED_BYTE; const o = new t.aC; o.emplaceBack(-1, -1), o.emplaceBack(2, -1), o.emplaceBack(-1, 2); const s = new t.aE; s.emplaceBack(0, 1, 2), this._fullscreenTriangle = new pt(i.createVertexBuffer(o, mt.members), i.createIndexBuffer(s), t.aD.simpleSegment(0, 0, o.length, s.length)), this._resultBuffer = new Uint8Array(4), i.activeTexture.set(r.TEXTURE1); const a = r.createTexture(); r.bindTexture(r.TEXTURE_2D, a), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.NEAREST), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.NEAREST), r.texImage2D(r.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = i.createFramebuffer(this._texWidth, this._texHeight, !1, !1), this._fbo.colorAttachment.set(a), Ut(r) && (this._pbo = r.createBuffer(), r.bindBuffer(r.PIXEL_PACK_BUFFER, this._pbo), r.bufferData(r.PIXEL_PACK_BUFFER, 4, r.STREAM_READ), r.bindBuffer(r.PIXEL_PACK_BUFFER, null)); } destroy() { const e = this._cachedRenderContext.context.gl; this._fullscreenTriangle.destroy(), this._fbo.destroy(), e.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null; } updateErrorLoop(e, t) { const i = this._updateCount; return this._readbackQueue ? i >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : i >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(e, t), this._updateCount++, this._measuredError } _bindFramebuffer() { const e = this._cachedRenderContext.context, t = e.gl; e.activeTexture.set(t.TEXTURE1), t.bindTexture(t.TEXTURE_2D, this._fbo.colorAttachment.get()), e.bindFramebuffer.set(this._fbo.framebuffer); } _renderErrorTexture(e, i) { const r = this._cachedRenderContext.context, o = r.gl; if (this._bindFramebuffer(), r.viewport.set([0, 0, this._texWidth, this._texHeight]), r.clear({ color: t.b4.transparent }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(r, o.TRIANGLES, Ot.disabled, Zt.disabled, Ft.unblended, jt.disabled, ((e, t) => ({ u_input: e, u_output_expected: t }))(e, i), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && Ut(o)) { o.bindBuffer(o.PIXEL_PACK_BUFFER, this._pbo), o.readBuffer(o.COLOR_ATTACHMENT0), o.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), o.bindBuffer(o.PIXEL_PACK_BUFFER, null); const e = o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE, 0); o.flush(), this._readbackQueue = { frameNumberIssued: this._updateCount, sync: e }; } else this._readbackQueue = { frameNumberIssued: this._updateCount, sync: null }; } _tryReadback() { const e = this._cachedRenderContext.context.gl; if (this._pbo && this._readbackQueue && Ut(e)) { const i = e.clientWaitSync(this._readbackQueue.sync, 0, 0); if (i === e.WAIT_FAILED) return t.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void (this._lastReadbackFrame = this._updateCount); if (i === e.TIMEOUT_EXPIRED) return; e.bindBuffer(e.PIXEL_PACK_BUFFER, this._pbo), e.getBufferSubData(e.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), e.bindBuffer(e.PIXEL_PACK_BUFFER, null); } else this._bindFramebuffer(), e.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer); this._readbackQueue = null, this._measuredError = Vt._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount; } static _parseRGBA8float(e) { let t = 0; return t += e[0] / 256, t += e[1] / 65536, t += e[2] / 16777216, e[3] < 127 && (t = -t), t / 128 } } const qt = t.X / 128; function Ht(e, i) { const r = void 0 !== e.granularity ? Math.max(e.granularity, 1) : 1, o = r + (e.generateBorders ? 2 : 0), s = r + (e.extendToNorthPole || e.generateBorders ? 1 : 0) + (e.extendToSouthPole || e.generateBorders ? 1 : 0), a = o + 1, n = s + 1, l = e.generateBorders ? -1 : 0, c = e.generateBorders || e.extendToNorthPole ? -1 : 0, h = r + (e.generateBorders ? 1 : 0), u = r + (e.generateBorders || e.extendToSouthPole ? 1 : 0), d = a * n, _ = o * s * 6, p = a * n > 65536; if (p && "16bit" === i) throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices."); const m = p || "32bit" === i, f = new Int16Array(2 * d); let g = 0; for (let i = c; i <= u; i++)for (let o = l; o <= h; o++) { let s = o / r * t.X; -1 === o && (s = -64), o === r + 1 && (s = t.X + qt); let a = i / r * t.X; -1 === i && (a = e.extendToNorthPole ? t.b6 : -64), i === r + 1 && (a = e.extendToSouthPole ? t.b7 : t.X + qt), f[g++] = s, f[g++] = a; } const v = m ? new Uint32Array(_) : new Uint16Array(_); let x = 0; for (let e = 0; e < s; e++)for (let t = 0; t < o; t++) { const i = t + 1 + e * a, r = t + (e + 1) * a, o = t + 1 + (e + 1) * a; v[x++] = t + e * a, v[x++] = r, v[x++] = i, v[x++] = i, v[x++] = r, v[x++] = o; } return { vertices: f.buffer.slice(0), indices: v.buffer.slice(0), uses32bitIndices: m } } const Wt = new t.aB({ fill: new t.b8(128, 2), line: new t.b8(512, 0), tile: new t.b8(128, 32), stencil: new t.b8(128, 1), circle: 3 }); class Xt { constructor() { this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3; } get name() { return "vertical-perspective" } get transitionState() { return 1 } get useSubdivision() { return !0 } get shaderVariantName() { return "globe" } get shaderDefine() { return "#define GLOBE" } get shaderPreludeCode() { return dt.projectionGlobe } get vertexShaderPreludeCode() { return dt.projectionMercator.vertexSource } get subdivisionGranularity() { return Wt } get useGlobeControls() { return !0 } get latitudeErrorCorrectionRadians() { return this._errorCorrectionUsable } destroy() { this._errorMeasurement && this._errorMeasurement.destroy(); } updateGPUdependent(e) { this._errorMeasurement || (this._errorMeasurement = new Vt(e)); const i = t.Q(this._errorQueryLatitudeDegrees), r = 2 * Math.atan(Math.exp(Math.PI - i * Math.PI * 2)) - .5 * Math.PI, o = this._errorMeasurement.updateErrorLoop(i, r), s = a.now(); o !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = o, this._errorMeasurementLastChangeTime = s); const n = Math.min(Math.max((s - this._errorMeasurementLastChangeTime) / 1e3 / .5, 0), 1); this._errorCorrectionUsable = t.b9(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, t.ba(n)); } _getMeshKey(e) { return `${e.granularity.toString(36)}_${e.generateBorders ? "b" : ""}${e.extendToNorthPole ? "n" : ""}${e.extendToSouthPole ? "s" : ""}` } getMeshFromTileID(e, t, i, r, o) { const s = ("stencil" === o ? Wt.stencil : Wt.tile).getGranularityForZoomLevel(t.z); return this._getMesh(e, { granularity: s, generateBorders: i, extendToNorthPole: 0 === t.y && r, extendToSouthPole: t.y === (1 << t.z) - 1 && r }) } _getMesh(e, i) { const r = this._getMeshKey(i); if (r in this._tileMeshCache) return this._tileMeshCache[r]; const o = function (e, i) { const r = Ht(i, "16bit"), o = t.aC.deserialize({ arrayBuffer: r.vertices, length: r.vertices.byteLength / 2 / 2 }), s = t.aE.deserialize({ arrayBuffer: r.indices, length: r.indices.byteLength / 2 / 3 }); return new pt(e.createVertexBuffer(o, mt.members), e.createIndexBuffer(s), t.aD.simpleSegment(0, 0, o.length, s.length)) }(e, i); return this._tileMeshCache[r] = o, o } recalculate(e) { } hasTransition() { const e = a.now(); let t = !1; return t = t || (e - this._errorMeasurementLastChangeTime) / 1e3 < .7, t = t || this._errorMeasurement && this._errorMeasurement.awaitingQuery, t } setErrorQueryLatitudeDegrees(e) { this._errorQueryLatitudeDegrees = e; } } const $t = new t.q({ type: new t.D(t.v.projection.type) }); class Kt extends t.E { constructor(e) { super(), this._transitionable = new t.T($t), this.setProjection(e), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new t.z(0)), this._mercatorProjection = new vt, this._verticalPerspectiveProjection = new Xt; } get transitionState() { const e = this.properties.get("type"); if ("string" == typeof e && "mercator" === e) return 0; if ("string" == typeof e && "vertical-perspective" === e) return 1; if (e instanceof t.bb) { if ("vertical-perspective" === e.from && "mercator" === e.to) return 1 - e.transition; if ("mercator" === e.from && "vertical-perspective" === e.to) return e.transition } return 1 } get useGlobeRendering() { return this.transitionState > 0 } get latitudeErrorCorrectionRadians() { return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians } get currentProjection() { return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection } get name() { return "globe" } get useSubdivision() { return this.currentProjection.useSubdivision } get shaderVariantName() { return this.currentProjection.shaderVariantName } get shaderDefine() { return this.currentProjection.shaderDefine } get shaderPreludeCode() { return this.currentProjection.shaderPreludeCode } get vertexShaderPreludeCode() { return this.currentProjection.vertexShaderPreludeCode } get subdivisionGranularity() { return this.currentProjection.subdivisionGranularity } get useGlobeControls() { return this.transitionState > 0 } destroy() { this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy(); } updateGPUdependent(e) { this._mercatorProjection.updateGPUdependent(e), this._verticalPerspectiveProjection.updateGPUdependent(e); } getMeshFromTileID(e, t, i, r, o) { return this.currentProjection.getMeshFromTileID(e, t, i, r, o) } setProjection(e) { this._transitionable.setValue("type", (null == e ? void 0 : e.type) || "mercator"); } updateTransitions(e) { this._transitioning = this._transitionable.transitioned(e, this._transitioning); } hasTransition() { return this._transitioning.hasTransition() || this.currentProjection.hasTransition() } recalculate(e) { this.properties = this._transitioning.possiblyEvaluate(e); } setErrorQueryLatitudeDegrees(e) { this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(e), this._mercatorProjection.setErrorQueryLatitudeDegrees(e); } } function Yt(e) { const t = ei(e.worldSize, e.center.lat); return 2 * Math.PI * t } function Jt(e, i, r, o, s) { const a = 1 / (1 << s), n = i / t.X * a + o * a, l = t.bd((e / t.X * a + r * a) * Math.PI * 2 + Math.PI, 2 * Math.PI), c = 2 * Math.atan(Math.exp(Math.PI - n * Math.PI * 2)) - .5 * Math.PI, h = Math.cos(c), u = new Float64Array(3); return u[0] = Math.sin(l) * h, u[1] = Math.sin(c), u[2] = Math.cos(l) * h, u } function Qt(e) { return function (e, t) { const i = Math.cos(t), r = new Float64Array(3); return r[0] = Math.sin(e) * i, r[1] = Math.sin(t), r[2] = Math.cos(e) * i, r }(e.lng * Math.PI / 180, e.lat * Math.PI / 180) } function ei(e, t) { return e / (2 * Math.PI) / Math.cos(t * Math.PI / 180) } function ti(e) { const i = Math.asin(e[1]) / Math.PI * 180, r = Math.sqrt(e[0] * e[0] + e[2] * e[2]); if (r > 1e-6) { const o = e[0] / r, s = Math.acos(e[2] / r), a = (o > 0 ? s : -s) / Math.PI * 180; return new t.N(t.aI(a, -180, 180), i) } return new t.N(0, i) } function ii(e) { return Math.cos(e * Math.PI / 180) } function ri(e, i) { const r = ii(e), o = ii(i); return t.a8(o / r) } function oi(e, i) { const r = e.rotate(i.bearingInRadians), o = i.zoom + ri(i.center.lat, 0), s = t.b9(1 / ii(i.center.lat), 1 / ii(Math.min(Math.abs(i.center.lat), 60)), t.bc(o, 7, 3, 0, 1)), a = 360 / Yt({ worldSize: i.worldSize, center: { lat: i.center.lat } }); return new t.N(i.center.lng - r.x * a * s, t.ab(i.center.lat + r.y * a, -85.051129, t.aF)) } function si(e) { const t = .5 * e, i = Math.sin(t), r = Math.cos(t); return Math.log(i + r) - Math.log(r - i) } function ai(e, i, r, o) { const s = e.lat + r * o; if (Math.abs(r) > 1) { const a = (Math.sign(e.lat + r) !== Math.sign(e.lat) ? -Math.abs(e.lat) : Math.abs(e.lat)) * Math.PI / 180, n = Math.abs(e.lat + r) * Math.PI / 180, l = si(a + o * (n - a)), c = si(a), h = si(n); return new t.N(e.lng + i * ((l - c) / (h - c)), s) } return new t.N(e.lng + i * o, s) } class ni { constructor(e) { this._cachePrevious = new Map, this._cache = new Map, this._hadAnyChanges = !1, this._aabbFactory = e; } recalculateCache() { if (!this._hadAnyChanges) return; const e = this._cachePrevious; this._cachePrevious = this._cache, this._cache = e, this._cache.clear(), this._hadAnyChanges = !1; } getTileAABB(e, t, i, r) { const o = `${e.z}_${e.x}_${e.y}`, s = this._cache.get(o); if (s) return s; const a = this._cachePrevious.get(o); if (a) return this._cache.set(o, a), a; const n = this._aabbFactory(e, t, i, r); return this._cache.set(o, n), this._hadAnyChanges = !0, n } } function li(e, t, i) { const r = e - t; return r < 0 ? -r : Math.max(0, r - i) } function ci(e, t, i, r, o) { const s = e - i; let a; return a = s < 0 ? Math.min(-s, 1 + s - o) : s > 1 ? Math.min(Math.max(s - o, 0), 1 - s) : 0, Math.max(a, li(t, r, o)) } class hi { constructor() { this._aabbCache = new ni(this._computeTileAABB); } recalculateCache() { this._aabbCache.recalculateCache(); } distanceToTile2d(e, t, i, r) { const o = 1 << i.z, s = 1 / o, a = i.x / o, n = i.y / o; let l = 2; return l = Math.min(l, ci(e, t, a, n, s)), l = Math.min(l, ci(e, t, a + .5, -n - s, s)), l = Math.min(l, ci(e, t, a + .5, 2 - n - s, s)), l } getWrap(e, t, i) { const r = 1 << t.z, o = 1 / r, s = t.x / r, a = li(e.x, s, o), n = li(e.x, s - 1, o), l = li(e.x, s + 1, o), c = Math.min(a, n, l); return c === l ? 1 : c === n ? -1 : 0 } allowVariableZoom(e, t) { return he(e, t) > 4 } allowWorldCopies() { return !1 } getTileAABB(e, t, i, r) { return this._aabbCache.getTileAABB(e, t, i, r) } _computeTileAABB(e, i, r, o) { if (e.z <= 0) return new Mt([-1, -1, -1], [1, 1, 1]); if (1 === e.z) return new Mt([0 === e.x ? -1 : 0, 0 === e.y ? 0 : -1, -1], [0 === e.x ? 0 : 1, 0 === e.y ? 1 : 0, 1]); { const i = [Jt(0, 0, e.x, e.y, e.z), Jt(t.X, 0, e.x, e.y, e.z), Jt(t.X, t.X, e.x, e.y, e.z), Jt(0, t.X, e.x, e.y, e.z)], r = [1, 1, 1], o = [-1, -1, -1]; for (const e of i) for (let t = 0; t < 3; t++)r[t] = Math.min(r[t], e[t]), o[t] = Math.max(o[t], e[t]); if (0 === e.y || e.y === (1 << e.z) - 1) { const t = [0, 0 === e.y ? 1 : -1, 0]; for (let e = 0; e < 3; e++)r[e] = Math.min(r[e], t[e]), o[e] = Math.max(o[e], t[e]); } return new Mt(r, o) } } } class ui { get pixelsToClipSpaceMatrix() { return this._helper.pixelsToClipSpaceMatrix } get clipSpaceToPixelsMatrix() { return this._helper.clipSpaceToPixelsMatrix } get pixelsToGLUnits() { return this._helper.pixelsToGLUnits } get centerOffset() { return this._helper.centerOffset } get size() { return this._helper.size } get rotationMatrix() { return this._helper.rotationMatrix } get centerPoint() { return this._helper.centerPoint } get pixelsPerMeter() { return this._helper.pixelsPerMeter } setMinZoom(e) { this._helper.setMinZoom(e); } setMaxZoom(e) { this._helper.setMaxZoom(e); } setMinPitch(e) { this._helper.setMinPitch(e); } setMaxPitch(e) { this._helper.setMaxPitch(e); } setRenderWorldCopies(e) { this._helper.setRenderWorldCopies(e); } setBearing(e) { this._helper.setBearing(e); } setPitch(e) { this._helper.setPitch(e); } setRoll(e) { this._helper.setRoll(e); } setFov(e) { this._helper.setFov(e); } setZoom(e) { this._helper.setZoom(e); } setCenter(e) { this._helper.setCenter(e); } setElevation(e) { this._helper.setElevation(e); } setMinElevationForCurrentTile(e) { this._helper.setMinElevationForCurrentTile(e); } setPadding(e) { this._helper.setPadding(e); } interpolatePadding(e, t, i) { return this._helper.interpolatePadding(e, t, i) } isPaddingEqual(e) { return this._helper.isPaddingEqual(e) } resize(e, t) { this._helper.resize(e, t); } getMaxBounds() { return this._helper.getMaxBounds() } setMaxBounds(e) { this._helper.setMaxBounds(e); } overrideNearFarZ(e, t) { this._helper.overrideNearFarZ(e, t); } clearNearFarZOverride() { this._helper.clearNearFarZOverride(); } getCameraQueryGeometry(e) { return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e) } get tileSize() { return this._helper.tileSize } get tileZoom() { return this._helper.tileZoom } get scale() { return this._helper.scale } get worldSize() { return this._helper.worldSize } get width() { return this._helper.width } get height() { return this._helper.height } get lngRange() { return this._helper.lngRange } get latRange() { return this._helper.latRange } get minZoom() { return this._helper.minZoom } get maxZoom() { return this._helper.maxZoom } get zoom() { return this._helper.zoom } get center() { return this._helper.center } get minPitch() { return this._helper.minPitch } get maxPitch() { return this._helper.maxPitch } get pitch() { return this._helper.pitch } get pitchInRadians() { return this._helper.pitchInRadians } get roll() { return this._helper.roll } get rollInRadians() { return this._helper.rollInRadians } get bearing() { return this._helper.bearing } get bearingInRadians() { return this._helper.bearingInRadians } get fov() { return this._helper.fov } get fovInRadians() { return this._helper.fovInRadians } get elevation() { return this._helper.elevation } get minElevationForCurrentTile() { return this._helper.minElevationForCurrentTile } get padding() { return this._helper.padding } get unmodified() { return this._helper.unmodified } get renderWorldCopies() { return this._helper.renderWorldCopies } get nearZ() { return this._helper.nearZ } get farZ() { return this._helper.farZ } get autoCalculateNearFarZ() { return this._helper.autoCalculateNearFarZ } setTransitionState(e) { } constructor() { this._cachedClippingPlane = t.be(), this._projectionMatrix = t.a_(), this._globeViewProjMatrix32f = t.aZ(), this._globeViewProjMatrixNoCorrection = t.a_(), this._globeViewProjMatrixNoCorrectionInverted = t.a_(), this._globeProjMatrixInverted = t.a_(), this._cameraPosition = t.bf(), this._globeLatitudeErrorCorrectionRadians = 0, this._helper = new Et({ calcMatrices: () => { this._calcMatrices(); }, getConstrained: (e, t) => this.getConstrained(e, t) }), this._coveringTilesDetailsProvider = new hi; } clone() { const e = new ui; return e.apply(this), e } apply(e, t) { this._globeLatitudeErrorCorrectionRadians = t || 0, this._helper.apply(e); } get projectionMatrix() { return this._projectionMatrix } get modelViewProjectionMatrix() { return this._globeViewProjMatrixNoCorrection } get inverseProjectionMatrix() { return this._globeProjMatrixInverted } get cameraPosition() { const e = t.bf(); return e[0] = this._cameraPosition[0], e[1] = this._cameraPosition[1], e[2] = this._cameraPosition[2], e } get cameraToCenterDistance() { return this._helper.cameraToCenterDistance } getProjectionData(e) { const { overscaledTileID: t, applyGlobeMatrix: i } = e, r = this._helper.getMercatorTileCoordinates(t); return { mainMatrix: this._globeViewProjMatrix32f, tileMercatorCoords: r, clippingPlane: this._cachedClippingPlane, projectionTransition: i ? 1 : 0, fallbackMatrix: this._globeViewProjMatrix32f } } _computeClippingPlane(e) { const i = this.pitchInRadians, r = this.cameraToCenterDistance / e, o = Math.sin(i) * r, s = Math.cos(i) * r + 1, a = 1 / Math.sqrt(o * o + s * s) * 1; let n = -o, l = s; const c = Math.sqrt(n * n + l * l); n /= c, l /= c; const h = [0, n, l]; return t.bg(h, h, [0, 0, 0], -this.bearingInRadians), t.bh(h, h, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), t.bi(h, h, [0, 0, 0], this.center.lng * Math.PI / 180), t.aL(h, h, .25), [...h, .25 * -a] } isLocationOccluded(e) { return !this.isSurfacePointVisible(Qt(e)) } transformLightDirection(e) { const i = this._helper._center.lng * Math.PI / 180, r = this._helper._center.lat * Math.PI / 180, o = Math.cos(r), s = [Math.sin(i) * o, Math.sin(r), Math.cos(i) * o], a = [s[2], 0, -s[0]], n = [0, 0, 0]; t.aR(n, a, s), t.aQ(a, a), t.aQ(n, n); const l = [0, 0, 0]; return t.aQ(l, [a[0] * e[0] + n[0] * e[1] + s[0] * e[2], a[1] * e[0] + n[1] * e[1] + s[1] * e[2], a[2] * e[0] + n[2] * e[1] + s[2] * e[2]]), l } getPixelScale() { return 1 / Math.cos(this._helper._center.lat * Math.PI / 180) } getCircleRadiusCorrection() { return Math.cos(this._helper._center.lat * Math.PI / 180) } getPitchedTextCorrection(e, i, r) { const o = function (e, i, r) { const o = 1 / (1 << r.z); return new t.Y(e / t.X * o + r.x * o, i / t.X * o + r.y * o) }(e, i, r.canonical), s = (a = o.y, [t.bd(o.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - a * Math.PI * 2)) - .5 * Math.PI]); var a; return this.getCircleRadiusCorrection() / Math.cos(s[1]) } projectTileCoordinates(e, i, r, o) { const s = r.canonical, a = Jt(e, i, s.x, s.y, s.z), n = 1 + (o ? o(e, i) : 0) / t.bo, l = [a[0] * n, a[1] * n, a[2] * n, 1]; t.al(l, l, this._globeViewProjMatrixNoCorrection); const c = this._cachedClippingPlane, h = c[0] * a[0] + c[1] * a[1] + c[2] * a[2] + c[3] < 0; return { point: new t.P(l[0] / l[3], l[1] / l[3]), signedDistanceFromCamera: l[3], isOccluded: h } } _calcMatrices() { if (!this._helper._width || !this._helper._height) return; const e = ei(this.worldSize, this.center.lat), i = t.a$(), r = t.a$(); this._helper.autoCalculateNearFarZ && (this._helper._nearZ = .5, this._helper._farZ = this.cameraToCenterDistance + 2 * e), t.aV(i, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ); const o = this.centerOffset; i[8] = 2 * -o.x / this._helper._width, i[9] = 2 * o.y / this._helper._height, this._projectionMatrix = t.aW(i), this._globeProjMatrixInverted = t.a$(), t.an(this._globeProjMatrixInverted, i), t.J(i, i, [0, 0, -this.cameraToCenterDistance]), t.aX(i, i, this.rollInRadians), t.aY(i, i, -this.pitchInRadians), t.aX(i, i, this.bearingInRadians), t.J(i, i, [0, 0, -e]); const s = t.bf(); s[0] = e, s[1] = e, s[2] = e, t.aY(r, i, this.center.lat * Math.PI / 180), t.bj(r, r, -this.center.lng * Math.PI / 180), t.K(r, r, s), this._globeViewProjMatrixNoCorrection = r, t.aY(i, i, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), t.bj(i, i, -this.center.lng * Math.PI / 180), t.K(i, i, s), this._globeViewProjMatrix32f = new Float32Array(i), this._globeViewProjMatrixNoCorrectionInverted = t.a$(), t.an(this._globeViewProjMatrixNoCorrectionInverted, r); const a = t.bf(); this._cameraPosition = t.bf(), this._cameraPosition[2] = this.cameraToCenterDistance / e, t.bg(this._cameraPosition, this._cameraPosition, a, -this.rollInRadians), t.bh(this._cameraPosition, this._cameraPosition, a, this.pitchInRadians), t.bg(this._cameraPosition, this._cameraPosition, a, -this.bearingInRadians), t.aM(this._cameraPosition, this._cameraPosition, [0, 0, 1]), t.bh(this._cameraPosition, this._cameraPosition, a, -this.center.lat * Math.PI / 180), t.bi(this._cameraPosition, this._cameraPosition, a, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(e); const n = t.aW(this._globeViewProjMatrixNoCorrectionInverted); t.K(n, n, [1, 1, -1]), this._cachedFrustum = Rt.fromInvProjectionMatrix(n); } calculateFogMatrix(e) { t.w("calculateFogMatrix is not supported on globe projection."); const i = t.a$(); return t.aq(i), i } getVisibleUnwrappedCoordinates(e) { return [new t.aT(0, e)] } getCameraFrustum() { return this._cachedFrustum } getClippingPlane() { return this._cachedClippingPlane } getCoveringTilesDetailsProvider() { return this._coveringTilesDetailsProvider } recalculateZoomAndCenter(e) { e && t.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0); } maxPitchScaleFactor() { return 1 } getCameraPoint() { return this._helper.getCameraPoint() } getCameraAltitude() { return this._helper.getCameraAltitude() } getCameraLngLat() { return this._helper.getCameraLngLat() } lngLatToCameraDepth(e, i) { if (!this._globeViewProjMatrixNoCorrection) return 1; const r = Qt(e); t.aL(r, r, 1 + i / t.bo); const o = t.be(); return t.al(o, [r[0], r[1], r[2], 1], this._globeViewProjMatrixNoCorrection), o[2] / o[3] } populateCache(e) { } getBounds() { const e = .5 * this.width, i = .5 * this.height, r = [new t.P(0, 0), new t.P(e, 0), new t.P(this.width, 0), new t.P(this.width, i), new t.P(this.width, this.height), new t.P(e, this.height), new t.P(0, this.height), new t.P(0, i)], o = []; for (const e of r) o.push(this.unprojectScreenPoint(e)); let s = 0, a = 0, n = 0, l = 0; const c = this.center; for (const e of o) { const i = t.bk(c.lng, e.lng), r = t.bk(c.lat, e.lat); i < a && (a = i), i > s && (s = i), r < l && (l = r), r > n && (n = r); } const h = [c.lng + a, c.lat + l, c.lng + s, c.lat + n]; return this.isSurfacePointOnScreen([0, 1, 0]) && (h[3] = 90, h[0] = -180, h[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (h[1] = -90, h[0] = -180, h[2] = 180), new V(h) } getConstrained(e, i) { const r = t.ab(e.lat, -85.051129, t.aF), o = t.ab(+i, this.minZoom + ri(0, r), this.maxZoom); return { center: new t.N(e.lng, r), zoom: o } } calculateCenterFromCameraLngLatAlt(e, t, i, r) { return this._helper.calculateCenterFromCameraLngLatAlt(e, t, i, r) } setLocationAtPoint(e, i) { const r = Qt(this.unprojectScreenPoint(i)), o = Qt(e), s = t.bf(); t.bl(s); const a = t.bf(); t.bi(a, r, s, -this.center.lng * Math.PI / 180), t.bh(a, a, s, this.center.lat * Math.PI / 180); const n = o[0] * o[0] + o[2] * o[2], l = a[0] * a[0]; if (n < l) return; const c = Math.sqrt(n - l), h = -c, u = t.bm(o[0], o[2], a[0], c), d = t.bm(o[0], o[2], a[0], h), _ = t.bf(); t.bi(_, o, s, -u); const p = t.bm(_[1], _[2], a[1], a[2]), m = t.bf(); t.bi(m, o, s, -d); const f = t.bm(m[1], m[2], a[1], a[2]), g = .5 * Math.PI, v = p >= -g && p <= g, x = f >= -g && f <= g; let b, y; if (v && x) { const e = this.center.lng * Math.PI / 180, i = this.center.lat * Math.PI / 180; t.bp(u, e) + t.bp(p, i) < t.bp(d, e) + t.bp(f, i) ? (b = u, y = p) : (b = d, y = f); } else if (v) b = u, y = p; else { if (!x) return; b = d, y = f; } const w = b / Math.PI * 180, T = y / Math.PI * 180, P = this.center.lat; this.setCenter(new t.N(w, t.ab(T, -90, 90))), this.setZoom(this.zoom + ri(P, this.center.lat)); } locationToScreenPoint(e, i) { const r = Qt(e); if (i) { const o = i.getElevationForLngLatZoom(e, this._helper._tileZoom); t.aL(r, r, 1 + o / t.bo); } return this._projectSurfacePointToScreen(r) } _projectSurfacePointToScreen(e) { const i = t.be(); return t.al(i, [...e, 1], this._globeViewProjMatrixNoCorrection), i[0] /= i[3], i[1] /= i[3], new t.P((.5 * i[0] + .5) * this.width, (.5 * -i[1] + .5) * this.height) } screenPointToMercatorCoordinate(e, i) { if (i) { const t = i.pointCoordinate(e); if (t) return t } return t.Y.fromLngLat(this.unprojectScreenPoint(e)) } screenPointToLocation(e, t) { var i; return null === (i = this.screenPointToMercatorCoordinate(e, t)) || void 0 === i ? void 0 : i.toLngLat() } isPointOnMapSurface(e, t) { const i = this._cameraPosition, r = this.getRayDirectionFromPixel(e); return !!this.rayPlanetIntersection(i, r) } getRayDirectionFromPixel(e) { const i = t.be(); i[0] = e.x / this.width * 2 - 1, i[1] = -1 * (e.y / this.height * 2 - 1), i[2] = 1, i[3] = 1, t.al(i, i, this._globeViewProjMatrixNoCorrectionInverted), i[0] /= i[3], i[1] /= i[3], i[2] /= i[3]; const r = t.bf(); r[0] = i[0] - this._cameraPosition[0], r[1] = i[1] - this._cameraPosition[1], r[2] = i[2] - this._cameraPosition[2]; const o = t.bf(); return t.aQ(o, r), o } isSurfacePointVisible(e) { const t = this._cachedClippingPlane; return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] >= 0 } isSurfacePointOnScreen(e) { if (!this.isSurfacePointVisible(e)) return !1; const i = t.be(); return t.al(i, [...e, 1], this._globeViewProjMatrixNoCorrection), i[0] /= i[3], i[1] /= i[3], i[2] /= i[3], i[0] > -1 && i[0] < 1 && i[1] > -1 && i[1] < 1 && i[2] > -1 && i[2] < 1 } rayPlanetIntersection(e, i) { const r = t.aS(e, i), o = t.bf(), s = t.bf(); t.aL(s, i, r), t.aP(o, e, s); const a = 1 - t.aS(o, o); if (a < 0) return null; const n = t.aS(e, e) - 1, l = -r + (r < 0 ? 1 : -1) * Math.sqrt(a), c = n / l, h = l; return { tMin: Math.min(c, h), tMax: Math.max(c, h) } } unprojectScreenPoint(e) { const i = this._cameraPosition, r = this.getRayDirectionFromPixel(e), o = this.rayPlanetIntersection(i, r); if (o) { const e = t.bf(); t.aM(e, i, [r[0] * o.tMin, r[1] * o.tMin, r[2] * o.tMin]); const s = t.bf(); return t.aQ(s, e), ti(s) } const s = this._cachedClippingPlane[0] * r[0] + this._cachedClippingPlane[1] * r[1] + this._cachedClippingPlane[2] * r[2], a = -t.bn(this._cachedClippingPlane, i) / s, n = t.bf(); if (a > 0) t.aM(n, i, [r[0] * a, r[1] * a, r[2] * a]); else { const e = t.bf(); t.aM(e, i, [2 * r[0], 2 * r[1], 2 * r[2]]); const o = t.bn(this._cachedClippingPlane, e); t.aP(n, e, [this._cachedClippingPlane[0] * o, this._cachedClippingPlane[1] * o, this._cachedClippingPlane[2] * o]); } const l = t.bf(); return t.aQ(l, n), ti(l) } getMatrixForModel(e, i) { const r = t.N.convert(e), o = 1 / t.bo, s = t.a_(); return t.bj(s, s, r.lng / 180 * Math.PI), t.aY(s, s, -r.lat / 180 * Math.PI), t.J(s, s, [0, 0, 1 + i / t.bo]), t.aY(s, s, .5 * Math.PI), t.K(s, s, [o, o, o]), s } getProjectionDataForCustomLayer(e = !0) { const i = this.getProjectionData({ overscaledTileID: new t.S(0, 0, 0, 0, 0), applyGlobeMatrix: e }); return i.tileMercatorCoords = [0, 0, 1, 1], i } getFastPathSimpleProjectionMatrix(e) { } } class di { get pixelsToClipSpaceMatrix() { return this._helper.pixelsToClipSpaceMatrix } get clipSpaceToPixelsMatrix() { return this._helper.clipSpaceToPixelsMatrix } get pixelsToGLUnits() { return this._helper.pixelsToGLUnits } get centerOffset() { return this._helper.centerOffset } get size() { return this._helper.size } get rotationMatrix() { return this._helper.rotationMatrix } get centerPoint() { return this._helper.centerPoint } get pixelsPerMeter() { return this._helper.pixelsPerMeter } setMinZoom(e) { this._helper.setMinZoom(e); } setMaxZoom(e) { this._helper.setMaxZoom(e); } setMinPitch(e) { this._helper.setMinPitch(e); } setMaxPitch(e) { this._helper.setMaxPitch(e); } setRenderWorldCopies(e) { this._helper.setRenderWorldCopies(e); } setBearing(e) { this._helper.setBearing(e); } setPitch(e) { this._helper.setPitch(e); } setRoll(e) { this._helper.setRoll(e); } setFov(e) { this._helper.setFov(e); } setZoom(e) { this._helper.setZoom(e); } setCenter(e) { this._helper.setCenter(e); } setElevation(e) { this._helper.setElevation(e); } setMinElevationForCurrentTile(e) { this._helper.setMinElevationForCurrentTile(e); } setPadding(e) { this._helper.setPadding(e); } interpolatePadding(e, t, i) { return this._helper.interpolatePadding(e, t, i) } isPaddingEqual(e) { return this._helper.isPaddingEqual(e) } resize(e, t, i = !0) { this._helper.resize(e, t, i); } getMaxBounds() { return this._helper.getMaxBounds() } setMaxBounds(e) { this._helper.setMaxBounds(e); } overrideNearFarZ(e, t) { this._helper.overrideNearFarZ(e, t); } clearNearFarZOverride() { this._helper.clearNearFarZOverride(); } getCameraQueryGeometry(e) { return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e) } get tileSize() { return this._helper.tileSize } get tileZoom() { return this._helper.tileZoom } get scale() { return this._helper.scale } get worldSize() { return this._helper.worldSize } get width() { return this._helper.width } get height() { return this._helper.height } get lngRange() { return this._helper.lngRange } get latRange() { return this._helper.latRange } get minZoom() { return this._helper.minZoom } get maxZoom() { return this._helper.maxZoom } get zoom() { return this._helper.zoom } get center() { return this._helper.center } get minPitch() { return this._helper.minPitch } get maxPitch() { return this._helper.maxPitch } get pitch() { return this._helper.pitch } get pitchInRadians() { return this._helper.pitchInRadians } get roll() { return this._helper.roll } get rollInRadians() { return this._helper.rollInRadians } get bearing() { return this._helper.bearing } get bearingInRadians() { return this._helper.bearingInRadians } get fov() { return this._helper.fov } get fovInRadians() { return this._helper.fovInRadians } get elevation() { return this._helper.elevation } get minElevationForCurrentTile() { return this._helper.minElevationForCurrentTile } get padding() { return this._helper.padding } get unmodified() { return this._helper.unmodified } get renderWorldCopies() { return this._helper.renderWorldCopies } get cameraToCenterDistance() { return this._helper.cameraToCenterDistance } get nearZ() { return this._helper.nearZ } get farZ() { return this._helper.farZ } get autoCalculateNearFarZ() { return this._helper.autoCalculateNearFarZ } get isGlobeRendering() { return this._globeness > 0 } setTransitionState(e, t) { this._globeness = e, this._globeLatitudeErrorCorrectionRadians = t, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().recalculateCache(), this._mercatorTransform.getCoveringTilesDetailsProvider().recalculateCache(); } get currentTransform() { return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform } constructor() { this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this._helper = new Et({ calcMatrices: () => { this._calcMatrices(); }, getConstrained: (e, t) => this.getConstrained(e, t) }), this._globeness = 1, this._mercatorTransform = new Dt, this._verticalPerspectiveTransform = new ui; } clone() { const e = new di; return e._globeness = this._globeness, e._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, e.apply(this), e } apply(e) { this._helper.apply(e), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians); } get projectionMatrix() { return this.currentTransform.projectionMatrix } get modelViewProjectionMatrix() { return this.currentTransform.modelViewProjectionMatrix } get inverseProjectionMatrix() { return this.currentTransform.inverseProjectionMatrix } get cameraPosition() { return this.currentTransform.cameraPosition } getProjectionData(e) { const t = this._mercatorTransform.getProjectionData(e), i = this._verticalPerspectiveTransform.getProjectionData(e); return { mainMatrix: this.isGlobeRendering ? i.mainMatrix : t.mainMatrix, clippingPlane: i.clippingPlane, tileMercatorCoords: i.tileMercatorCoords, projectionTransition: e.applyGlobeMatrix ? this._globeness : 0, fallbackMatrix: t.fallbackMatrix } } isLocationOccluded(e) { return this.currentTransform.isLocationOccluded(e) } transformLightDirection(e) { return this.currentTransform.transformLightDirection(e) } getPixelScale() { return t.b9(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness) } getCircleRadiusCorrection() { return t.b9(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness) } getPitchedTextCorrection(e, i, r) { const o = this._mercatorTransform.getPitchedTextCorrection(e, i, r), s = this._verticalPerspectiveTransform.getPitchedTextCorrection(e, i, r); return t.b9(o, s, this._globeness) } projectTileCoordinates(e, t, i, r) { return this.currentTransform.projectTileCoordinates(e, t, i, r) } _calcMatrices() { this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, !0, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ); } calculateFogMatrix(e) { return this.currentTransform.calculateFogMatrix(e) } getVisibleUnwrappedCoordinates(e) { return this.currentTransform.getVisibleUnwrappedCoordinates(e) } getCameraFrustum() { return this.currentTransform.getCameraFrustum() } getClippingPlane() { return this.currentTransform.getClippingPlane() } getCoveringTilesDetailsProvider() { return this.currentTransform.getCoveringTilesDetailsProvider() } recalculateZoomAndCenter(e) { this._mercatorTransform.recalculateZoomAndCenter(e), this._verticalPerspectiveTransform.recalculateZoomAndCenter(e); } maxPitchScaleFactor() { return this._mercatorTransform.maxPitchScaleFactor() } getCameraPoint() { return this._helper.getCameraPoint() } getCameraAltitude() { return this._helper.getCameraAltitude() } getCameraLngLat() { return this._helper.getCameraLngLat() } lngLatToCameraDepth(e, t) { return this.currentTransform.lngLatToCameraDepth(e, t) } populateCache(e) { this._mercatorTransform.populateCache(e), this._verticalPerspectiveTransform.populateCache(e); } getBounds() { return this.currentTransform.getBounds() } getConstrained(e, t) { return this.currentTransform.getConstrained(e, t) } calculateCenterFromCameraLngLatAlt(e, t, i, r) { return this._helper.calculateCenterFromCameraLngLatAlt(e, t, i, r) } setLocationAtPoint(e, t) { if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(e, t), void this.apply(this._mercatorTransform); this._verticalPerspectiveTransform.setLocationAtPoint(e, t), this.apply(this._verticalPerspectiveTransform); } locationToScreenPoint(e, t) { return this.currentTransform.locationToScreenPoint(e, t) } screenPointToMercatorCoordinate(e, t) { return this.currentTransform.screenPointToMercatorCoordinate(e, t) } screenPointToLocation(e, t) { return this.currentTransform.screenPointToLocation(e, t) } isPointOnMapSurface(e, t) { return this.currentTransform.isPointOnMapSurface(e, t) } getRayDirectionFromPixel(e) { return this._verticalPerspectiveTransform.getRayDirectionFromPixel(e) } getMatrixForModel(e, t) { return this.currentTransform.getMatrixForModel(e, t) } getProjectionDataForCustomLayer(e = !0) { const t = this._mercatorTransform.getProjectionDataForCustomLayer(e); if (!this.isGlobeRendering) return t; const i = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(e); return i.fallbackMatrix = t.mainMatrix, i } getFastPathSimpleProjectionMatrix(e) { return this.currentTransform.getFastPathSimpleProjectionMatrix(e) } } class _i { get useGlobeControls() { return !0 } handlePanInertia(e, i) { const r = oi(e, i); return Math.abs(r.lng - i.center.lng) > 180 && (r.lng = i.center.lng + 179.5 * Math.sign(r.lng - i.center.lng)), { easingCenter: r, easingOffset: new t.P(0, 0) } } handleMapControlsRollPitchBearingZoom(e, i) { const r = e.around, o = i.screenPointToLocation(r); e.bearingDelta && i.setBearing(i.bearing + e.bearingDelta), e.pitchDelta && i.setPitch(i.pitch + e.pitchDelta), e.rollDelta && i.setRoll(i.roll + e.rollDelta); const s = i.zoom; e.zoomDelta && i.setZoom(i.zoom + e.zoomDelta); const a = i.zoom - s; if (0 === a) return; const n = t.bk(i.center.lng, o.lng), l = n / (Math.abs(n / 180) + 1), c = t.bk(i.center.lat, o.lat), h = i.getRayDirectionFromPixel(r), u = i.cameraPosition, d = -1 * t.aS(u, h), _ = t.bf(); t.aM(_, u, [h[0] * d, h[1] * d, h[2] * d]); const p = t.bq(_) - 1, m = Math.exp(.5 * -Math.max(p - .3, 0)), f = ei(i.worldSize, i.center.lat) / Math.min(i.width, i.height), g = t.bc(f, .9, .5, 1, .25), v = (1 - t.aG(-a)) * Math.min(m, g), x = i.center.lat, b = i.zoom, y = new t.N(i.center.lng + l * v, t.ab(i.center.lat + c * v, -85.051129, t.aF)); i.setLocationAtPoint(o, r); const w = i.center, T = t.bc(Math.abs(n), 45, 85, 0, 1), P = t.bc(f, .75, .35, 0, 1), C = Math.pow(Math.max(T, P), .25), I = t.bk(w.lng, y.lng), E = t.bk(w.lat, y.lat); i.setCenter(new t.N(w.lng + I * C, w.lat + E * C).wrap()), i.setZoom(b + ri(x, i.center.lat)); } handleMapControlsPan(e, t, i) { if (!e.panDelta) return; const r = t.center.lat, o = t.zoom; t.setCenter(oi(e.panDelta, t).wrap()), t.setZoom(o + ri(r, t.center.lat)); } cameraForBoxAndBearing(e, i, r, o, s) { const a = Lt(e, i, r, o, s), n = i.left / s.width * 2 - 1, l = (s.width - i.right) / s.width * 2 - 1, c = i.top / s.height * -2 + 1, h = (s.height - i.bottom) / s.height * -2 + 1, u = t.bk(r.getWest(), r.getEast()) < 0, d = u ? r.getEast() : r.getWest(), _ = u ? r.getWest() : r.getEast(), p = Math.max(r.getNorth(), r.getSouth()), m = Math.min(r.getNorth(), r.getSouth()), f = d + .5 * t.bk(d, _), g = p + .5 * t.bk(p, m), v = s.clone(); v.setCenter(a.center), v.setBearing(a.bearing), v.setPitch(0), v.setRoll(0), v.setZoom(a.zoom); const x = v.modelViewProjectionMatrix, b = [Qt(r.getNorthWest()), Qt(r.getNorthEast()), Qt(r.getSouthWest()), Qt(r.getSouthEast()), Qt(new t.N(_, g)), Qt(new t.N(d, g)), Qt(new t.N(f, p)), Qt(new t.N(f, m))], y = Qt(a.center); let w = Number.POSITIVE_INFINITY; for (const e of b) n < 0 && (w = _i.getLesserNonNegativeNonNull(w, _i.solveVectorScale(e, y, x, "x", n))), l > 0 && (w = _i.getLesserNonNegativeNonNull(w, _i.solveVectorScale(e, y, x, "x", l))), c > 0 && (w = _i.getLesserNonNegativeNonNull(w, _i.solveVectorScale(e, y, x, "y", c))), h < 0 && (w = _i.getLesserNonNegativeNonNull(w, _i.solveVectorScale(e, y, x, "y", h))); if (Number.isFinite(w) && 0 !== w) return a.zoom = v.zoom + t.a8(w), a; zt(); } handleJumpToCenterZoom(e, i) { const r = e.center.lat, o = e.getConstrained(i.center ? t.N.convert(i.center) : e.center, e.zoom).center; e.setCenter(o.wrap()); const s = void 0 !== i.zoom ? +i.zoom : e.zoom + ri(r, o.lat); e.zoom !== s && e.setZoom(s); } handleEaseTo(e, i) { const r = e.zoom, o = e.center, s = e.padding, a = { roll: e.roll, pitch: e.pitch, bearing: e.bearing }, n = { roll: void 0 === i.roll ? e.roll : i.roll, pitch: void 0 === i.pitch ? e.pitch : i.pitch, bearing: void 0 === i.bearing ? e.bearing : i.bearing }, l = void 0 !== i.zoom, c = !e.isPaddingEqual(i.padding); let h = !1; const u = i.center ? t.N.convert(i.center) : o, d = e.getConstrained(u, r).center; Ct(e, d); const _ = e.clone(); _.setCenter(d), _.setZoom(l ? +i.zoom : r + ri(o.lat, u.lat)), _.setBearing(i.bearing); const p = new t.P(t.ab(e.centerPoint.x + i.offsetAsPoint.x, 0, e.width), t.ab(e.centerPoint.y + i.offsetAsPoint.y, 0, e.height)); _.setLocationAtPoint(d, p); const m = (i.offset && i.offsetAsPoint.mag()) > 0 ? _.center : d, f = l ? +i.zoom : r + ri(o.lat, m.lat), g = r + ri(o.lat, 0), v = f + ri(m.lat, 0), x = t.bk(o.lng, m.lng), b = t.bk(o.lat, m.lat), y = t.aG(v - g); return h = f !== r, { easeFunc: r => { if (t.b3(a, n) || At({ startEulerAngles: a, endEulerAngles: n, tr: e, k: r, useSlerp: a.roll != n.roll }), c && e.interpolatePadding(s, i.padding, r), i.around) t.w("Easing around a point is not supported under globe projection."), e.setLocationAtPoint(i.around, i.aroundPoint); else { const t = v > g ? Math.min(2, y) : Math.max(.5, y), i = Math.pow(t, 1 - r), s = ai(o, x, b, r * i); e.setCenter(s.wrap()); } if (h) { const i = t.y.number(g, v, r) + ri(0, e.center.lat); e.setZoom(i); } }, isZooming: h, elevationCenter: m } } handleFlyTo(e, i) { const r = void 0 !== i.zoom, o = e.center, s = e.zoom, a = !e.isPaddingEqual(i.padding), n = e.getConstrained(t.N.convert(i.center || i.locationAtOffset), s).center, l = r ? +i.zoom : e.zoom + ri(e.center.lat, n.lat), c = e.clone(); c.setCenter(n), a && c.setPadding(i.padding), c.setZoom(l), c.setBearing(i.bearing); const h = new t.P(t.ab(e.centerPoint.x + i.offsetAsPoint.x, 0, e.width), t.ab(e.centerPoint.y + i.offsetAsPoint.y, 0, e.height)); c.setLocationAtPoint(n, h); const u = c.center; Ct(e, u); const d = function (e, i, r) { const o = Qt(i), s = Qt(r), a = t.aS(o, s), n = Math.acos(a), l = Yt(e); return n / (2 * Math.PI) * l }(e, o, u), _ = s + ri(o.lat, 0), p = l + ri(u.lat, 0), m = t.aG(p - _); let f; if ("number" == typeof i.minZoom) { const r = +i.minZoom + ri(u.lat, 0), o = Math.min(r, _, p) + ri(0, u.lat), s = e.getConstrained(u, o).zoom + ri(u.lat, 0); f = t.aG(s - _); } const g = t.bk(o.lng, u.lng), v = t.bk(o.lat, u.lat); return { easeFunc: (i, r, s, a) => { const n = ai(o, g, v, s), c = 1 === i ? u : n; e.setCenter(c.wrap()); const h = _ + t.a8(r); e.setZoom(1 === i ? l : h + ri(0, c.lat)); }, scaleOfZoom: m, targetCenter: u, scaleOfMinZoom: f, pixelPathLength: d } } static solveVectorScale(e, t, i, r, o) { const s = "x" === r ? [i[0], i[4], i[8], i[12]] : [i[1], i[5], i[9], i[13]], a = [i[3], i[7], i[11], i[15]], n = e[0] * s[0] + e[1] * s[1] + e[2] * s[2], l = e[0] * a[0] + e[1] * a[1] + e[2] * a[2], c = t[0] * s[0] + t[1] * s[1] + t[2] * s[2], h = t[0] * a[0] + t[1] * a[1] + t[2] * a[2]; return c + o * l === n + o * h || a[3] * (n - c) + s[3] * (h - l) + n * h == c * l ? null : (c + s[3] - o * h - o * a[3]) / (c - n - o * h + o * l) } static getLesserNonNegativeNonNull(e, t) { return null !== t && t >= 0 && t < e ? t : e } } class pi { constructor(e) { this._globe = e, this._mercatorCameraHelper = new kt, this._verticalPerspectiveCameraHelper = new _i; } get useGlobeControls() { return this._globe.useGlobeRendering } get currentHelper() { return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper } handlePanInertia(e, t) { return this.currentHelper.handlePanInertia(e, t) } handleMapControlsRollPitchBearingZoom(e, t) { return this.currentHelper.handleMapControlsRollPitchBearingZoom(e, t) } handleMapControlsPan(e, t, i) { this.currentHelper.handleMapControlsPan(e, t, i); } cameraForBoxAndBearing(e, t, i, r, o) { return this.currentHelper.cameraForBoxAndBearing(e, t, i, r, o) } handleJumpToCenterZoom(e, t) { this.currentHelper.handleJumpToCenterZoom(e, t); } handleEaseTo(e, t) { return this.currentHelper.handleEaseTo(e, t) } handleFlyTo(e, t) { return this.currentHelper.handleFlyTo(e, t) } } const mi = (e, i) => t.t(e, i && i.filter((e => "source.canvas" !== e.identifier))), fi = t.br(); class gi extends t.E { constructor(e, i = {}) { super(), this._rtlPluginLoaded = () => { for (const e in this.sourceCaches) { const t = this.sourceCaches[e].getSource().type; "vector" !== t && "geojson" !== t || this.sourceCaches[e].reload(); } }, this.map = e, this.dispatcher = new B(F(), e._getMapId()), this.dispatcher.registerMessageHandler("GG", ((e, t) => this.getGlyphs(e, t))), this.dispatcher.registerMessageHandler("GI", ((e, t) => this.getImages(e, t))), this.imageManager = new b, this.imageManager.setEventedParent(this), this.glyphManager = new P(e._requestManager, i.localIdeographFontFamily), this.lineAtlas = new R(256, 512), this.crossTileSymbolIndex = new ht, this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new t.bs, this._loaded = !1, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("SR", t.bt()), oe().on(te, this._rtlPluginLoaded), this.on("data", (e => { if ("source" !== e.dataType || "metadata" !== e.sourceDataType) return; const t = this.sourceCaches[e.sourceId]; if (!t) return; const i = t.getSource(); if (i && i.vectorLayerIds) for (const e in this._layers) { const t = this._layers[e]; t.source === i.id && this._validateLayer(t); } })); } loadURL(e, i = {}, r) { this.fire(new t.k("dataloading", { dataType: "style" })), i.validate = "boolean" != typeof i.validate || i.validate; const o = this.map._requestManager.transformRequest(e, "Style"); this._loadStyleRequest = new AbortController; const s = this._loadStyleRequest; t.h(o, this._loadStyleRequest).then((e => { this._loadStyleRequest = null, this._load(e.data, i, r); })).catch((e => { this._loadStyleRequest = null, e && !s.signal.aborted && this.fire(new t.j(e)); })); } loadJSON(e, i = {}, r) { this.fire(new t.k("dataloading", { dataType: "style" })), this._frameRequest = new AbortController, a.frameAsync(this._frameRequest).then((() => { this._frameRequest = null, i.validate = !1 !== i.validate, this._load(e, i, r); })).catch((() => { })); } loadEmpty() { this.fire(new t.k("dataloading", { dataType: "style" })), this._load(fi, { validate: !1 }); } _load(e, i, r) { var o, s; const a = i.transformStyle ? i.transformStyle(r, e) : e; if (!i.validate || !mi(this, t.u(a))) { this._loaded = !0, this.stylesheet = a; for (const e in a.sources) this.addSource(e, a.sources[e], { validate: !1 }); a.sprite ? this._loadSprite(a.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(a.glyphs), this._createLayers(), this.light = new E(this.stylesheet.light), this._setProjectionInternal((null === (o = this.stylesheet.projection) || void 0 === o ? void 0 : o.type) || "mercator"), this.sky = new S(this.stylesheet.sky), this.map.setTerrain(null !== (s = this.stylesheet.terrain) && void 0 !== s ? s : null), this.fire(new t.k("data", { dataType: "style" })), this.fire(new t.k("style.load")); } } _createLayers() { const e = t.bu(this.stylesheet.layers); this.dispatcher.broadcast("SL", e), this._order = e.map((e => e.id)), this._layers = {}, this._serializedLayers = null; for (const i of e) { const e = t.bv(i); e.setEventedParent(this, { layer: { id: i.id } }), this._layers[i.id] = e; } } _loadSprite(e, i = !1, r = void 0) { let o; this.imageManager.setLoaded(!1), this._spriteRequest = new AbortController, function (e, i, r, o) { return t._(this, void 0, void 0, (function* () { const s = f(e), n = r > 1 ? "@2x" : "", l = {}, c = {}; for (const { id: e, url: r } of s) { const s = i.transformRequest(g(r, n, ".json"), "SpriteJSON"); l[e] = t.h(s, o); const a = i.transformRequest(g(r, n, ".png"), "SpriteImage"); c[e] = p.getImage(a, o); } return yield Promise.all([...Object.values(l), ...Object.values(c)]), function (e, i) { return t._(this, void 0, void 0, (function* () { const t = {}; for (const r in e) { t[r] = {}; const o = a.getImageCanvasContext((yield i[r]).data), s = (yield e[r]).data; for (const e in s) { const { width: i, height: a, x: n, y: l, sdf: c, pixelRatio: h, stretchX: u, stretchY: d, content: _, textFitWidth: p, textFitHeight: m } = s[e]; t[r][e] = { data: null, pixelRatio: h, sdf: c, stretchX: u, stretchY: d, content: _, textFitWidth: p, textFitHeight: m, spriteData: { width: i, height: a, x: n, y: l, context: o } }; } } return t })) }(l, c) })) }(e, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((e => { if (this._spriteRequest = null, e) for (const t in e) { this._spritesImagesIds[t] = []; const r = this._spritesImagesIds[t] ? this._spritesImagesIds[t].filter((t => !(t in e))) : []; for (const e of r) this.imageManager.removeImage(e), this._changedImages[e] = !0; for (const r in e[t]) { const o = "default" === t ? r : `${t}:${r}`; this._spritesImagesIds[t].push(o), o in this.imageManager.images ? this.imageManager.updateImage(o, e[t][r], !1) : this.imageManager.addImage(o, e[t][r]), i && (this._changedImages[o] = !0); } } })).catch((e => { this._spriteRequest = null, o = e, this.fire(new t.j(o)); })).finally((() => { this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), i && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.k("data", { dataType: "style" })), r && r(o); })); } _unloadSprite() { for (const e of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(e), this._changedImages[e] = !0; this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.k("data", { dataType: "style" })); } _validateLayer(e) { const i = this.sourceCaches[e.source]; if (!i) return; const r = e.sourceLayer; if (!r) return; const o = i.getSource(); ("geojson" === o.type || o.vectorLayerIds && -1 === o.vectorLayerIds.indexOf(r)) && this.fire(new t.j(new Error(`Source layer "${r}" does not exist on source "${o.id}" as specified by style layer "${e.id}".`))); } loaded() { if (!this._loaded) return !1; if (Object.keys(this._updatedSources).length) return !1; for (const e in this.sourceCaches) if (!this.sourceCaches[e].loaded()) return !1; return !!this.imageManager.isLoaded() } _serializeByIds(e, i = !1) { const r = this._serializedAllLayers(); if (!e || 0 === e.length) return Object.values(i ? t.bw(r) : r); const o = []; for (const s of e) if (r[s]) { const e = i ? t.bw(r[s]) : r[s]; o.push(e); } return o } _serializedAllLayers() { let e = this._serializedLayers; if (e) return e; e = this._serializedLayers = {}; const t = Object.keys(this._layers); for (const i of t) { const t = this._layers[i]; "custom" !== t.type && (e[i] = t.serialize()); } return e } hasTransitions() { var e, t, i; if (null === (e = this.light) || void 0 === e ? void 0 : e.hasTransition()) return !0; if (null === (t = this.sky) || void 0 === t ? void 0 : t.hasTransition()) return !0; if (null === (i = this.projection) || void 0 === i ? void 0 : i.hasTransition()) return !0; for (const e in this.sourceCaches) if (this.sourceCaches[e].hasTransition()) return !0; for (const e in this._layers) if (this._layers[e].hasTransition()) return !0; return !1 } _checkLoaded() { if (!this._loaded) throw new Error("Style is not done loading.") } update(e) { if (!this._loaded) return; const i = this._changed; if (i) { const t = Object.keys(this._updatedLayers), i = Object.keys(this._removedLayers); (t.length || i.length) && this._updateWorkerLayers(t, i); for (const e in this._updatedSources) { const t = this._updatedSources[e]; if ("reload" === t) this._reloadSource(e); else { if ("clear" !== t) throw new Error(`Invalid action ${t}`); this._clearSource(e); } } this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs(); for (const t in this._updatedPaintProps) this._layers[t].updateTransitions(e); this.light.updateTransitions(e), this.sky.updateTransitions(e), this._resetUpdates(); } const r = {}; for (const e in this.sourceCaches) { const t = this.sourceCaches[e]; r[e] = t.used, t.used = !1; } for (const t of this._order) { const i = this._layers[t]; i.recalculate(e, this._availableImages), !i.isHidden(e.zoom) && i.source && (this.sourceCaches[i.source].used = !0); } for (const e in r) { const i = this.sourceCaches[e]; !!r[e] != !!i.used && i.fire(new t.k("data", { sourceDataType: "visibility", dataType: "source", sourceId: e })); } this.light.recalculate(e), this.sky.recalculate(e), this.projection.recalculate(e), this.z = e.zoom, i && this.fire(new t.k("data", { dataType: "style" })); } _updateTilesForChangedImages() { const e = Object.keys(this._changedImages); if (e.length) { for (const t in this.sourceCaches) this.sourceCaches[t].reloadTilesForDependencies(["icons", "patterns"], e); this._changedImages = {}; } } _updateTilesForChangedGlyphs() { if (this._glyphsDidChange) { for (const e in this.sourceCaches) this.sourceCaches[e].reloadTilesForDependencies(["glyphs"], [""]); this._glyphsDidChange = !1; } } _updateWorkerLayers(e, t) { this.dispatcher.broadcast("UL", { layers: this._serializeByIds(e, !1), removedIds: t }); } _resetUpdates() { this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1; } setState(e, i = {}) { var r; this._checkLoaded(); const o = this.serialize(); if (e = i.transformStyle ? i.transformStyle(o, e) : e, (null === (r = i.validate) || void 0 === r || r) && mi(this, t.u(e))) return !1; (e = t.bw(e)).layers = t.bu(e.layers); const s = t.bx(o, e), a = this._getOperationsToPerform(s); if (a.unimplemented.length > 0) throw new Error(`Unimplemented: ${a.unimplemented.join(", ")}.`); if (0 === a.operations.length) return !1; for (const e of a.operations) e(); return this.stylesheet = e, this._serializedLayers = null, !0 } _getOperationsToPerform(e) { const t = [], i = []; for (const r of e) switch (r.command) { case "setCenter": case "setZoom": case "setBearing": case "setPitch": case "setRoll": continue; case "addLayer": t.push((() => this.addLayer.apply(this, r.args))); break; case "removeLayer": t.push((() => this.removeLayer.apply(this, r.args))); break; case "setPaintProperty": t.push((() => this.setPaintProperty.apply(this, r.args))); break; case "setLayoutProperty": t.push((() => this.setLayoutProperty.apply(this, r.args))); break; case "setFilter": t.push((() => this.setFilter.apply(this, r.args))); break; case "addSource": t.push((() => this.addSource.apply(this, r.args))); break; case "removeSource": t.push((() => this.removeSource.apply(this, r.args))); break; case "setLayerZoomRange": t.push((() => this.setLayerZoomRange.apply(this, r.args))); break; case "setLight": t.push((() => this.setLight.apply(this, r.args))); break; case "setGeoJSONSourceData": t.push((() => this.setGeoJSONSourceData.apply(this, r.args))); break; case "setGlyphs": t.push((() => this.setGlyphs.apply(this, r.args))); break; case "setSprite": t.push((() => this.setSprite.apply(this, r.args))); break; case "setTerrain": t.push((() => this.map.setTerrain.apply(this, r.args))); break; case "setSky": t.push((() => this.setSky.apply(this, r.args))); break; case "setProjection": this.setProjection.apply(this, r.args); break; case "setTransition": t.push((() => { })); break; default: i.push(r.command); }return { operations: t, unimplemented: i } } addImage(e, i) { if (this.getImage(e)) return this.fire(new t.j(new Error(`An image named "${e}" already exists.`))); this.imageManager.addImage(e, i), this._afterImageUpdated(e); } updateImage(e, t) { this.imageManager.updateImage(e, t); } getImage(e) { return this.imageManager.getImage(e) } removeImage(e) { if (!this.getImage(e)) return this.fire(new t.j(new Error(`An image named "${e}" does not exist.`))); this.imageManager.removeImage(e), this._afterImageUpdated(e); } _afterImageUpdated(e) { this._availableImages = this.imageManager.listImages(), this._changedImages[e] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.k("data", { dataType: "style" })); } listImages() { return this._checkLoaded(), this.imageManager.listImages() } addSource(e, i, r = {}) { if (this._checkLoaded(), void 0 !== this.sourceCaches[e]) throw new Error(`Source "${e}" already exists.`); if (!i.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i).join(", ")}.`); if (["vector", "raster", "geojson", "video", "image"].indexOf(i.type) >= 0 && this._validate(t.u.source, `sources.${e}`, i, null, r)) return; this.map && this.map._collectResourceTiming && (i.collectResourceTiming = !0); const o = this.sourceCaches[e] = new de(e, i, this.dispatcher); o.style = this, o.setEventedParent(this, (() => ({ isSourceLoaded: o.loaded(), source: o.serialize(), sourceId: e }))), o.onAdd(this.map), this._changed = !0; } removeSource(e) { if (this._checkLoaded(), void 0 === this.sourceCaches[e]) throw new Error("There is no source with this ID"); for (const i in this._layers) if (this._layers[i].source === e) return this.fire(new t.j(new Error(`Source "${e}" cannot be removed while layer "${i}" is using it.`))); const i = this.sourceCaches[e]; delete this.sourceCaches[e], delete this._updatedSources[e], i.fire(new t.k("data", { sourceDataType: "metadata", dataType: "source", sourceId: e })), i.setEventedParent(null), i.onRemove(this.map), this._changed = !0; } setGeoJSONSourceData(e, t) { if (this._checkLoaded(), void 0 === this.sourceCaches[e]) throw new Error(`There is no source with this ID=${e}`); const i = this.sourceCaches[e].getSource(); if ("geojson" !== i.type) throw new Error(`geojsonSource.type is ${i.type}, which is !== 'geojson`); i.setData(t), this._changed = !0; } getSource(e) { return this.sourceCaches[e] && this.sourceCaches[e].getSource() } addLayer(e, i, r = {}) { this._checkLoaded(); const o = e.id; if (this.getLayer(o)) return void this.fire(new t.j(new Error(`Layer "${o}" already exists on this map.`))); let s; if ("custom" === e.type) { if (mi(this, t.by(e))) return; s = t.bv(e); } else { if ("source" in e && "object" == typeof e.source && (this.addSource(o, e.source), e = t.bw(e), e = t.e(e, { source: o })), this._validate(t.u.layer, `layers.${o}`, e, { arrayIndex: -1 }, r)) return; s = t.bv(e), this._validateLayer(s), s.setEventedParent(this, { layer: { id: o } }); } const a = i ? this._order.indexOf(i) : this._order.length; if (i && -1 === a) this.fire(new t.j(new Error(`Cannot add layer "${o}" before non-existing layer "${i}".`))); else { if (this._order.splice(a, 0, o), this._layerOrderChanged = !0, this._layers[o] = s, this._removedLayers[o] && s.source && "custom" !== s.type) { const e = this._removedLayers[o]; delete this._removedLayers[o], e.type !== s.type ? this._updatedSources[s.source] = "clear" : (this._updatedSources[s.source] = "reload", this.sourceCaches[s.source].pause()); } this._updateLayer(s), s.onAdd && s.onAdd(this.map); } } moveLayer(e, i) { if (this._checkLoaded(), this._changed = !0, !this._layers[e]) return void this.fire(new t.j(new Error(`The layer '${e}' does not exist in the map's style and cannot be moved.`))); if (e === i) return; const r = this._order.indexOf(e); this._order.splice(r, 1); const o = i ? this._order.indexOf(i) : this._order.length; i && -1 === o ? this.fire(new t.j(new Error(`Cannot move layer "${e}" before non-existing layer "${i}".`))) : (this._order.splice(o, 0, e), this._layerOrderChanged = !0); } removeLayer(e) { this._checkLoaded(); const i = this._layers[e]; if (!i) return void this.fire(new t.j(new Error(`Cannot remove non-existing layer "${e}".`))); i.setEventedParent(null); const r = this._order.indexOf(e); this._order.splice(r, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[e] = i, delete this._layers[e], this._serializedLayers && delete this._serializedLayers[e], delete this._updatedLayers[e], delete this._updatedPaintProps[e], i.onRemove && i.onRemove(this.map); } getLayer(e) { return this._layers[e] } getLayersOrder() { return [...this._order] } hasLayer(e) { return e in this._layers } setLayerZoomRange(e, i, r) { this._checkLoaded(); const o = this.getLayer(e); o ? o.minzoom === i && o.maxzoom === r || (null != i && (o.minzoom = i), null != r && (o.maxzoom = r), this._updateLayer(o)) : this.fire(new t.j(new Error(`Cannot set the zoom range of non-existing layer "${e}".`))); } setFilter(e, i, r = {}) { this._checkLoaded(); const o = this.getLayer(e); if (o) { if (!t.bz(o.filter, i)) return null == i ? (o.filter = void 0, void this._updateLayer(o)) : void (this._validate(t.u.filter, `layers.${o.id}.filter`, i, null, r) || (o.filter = t.bw(i), this._updateLayer(o))) } else this.fire(new t.j(new Error(`Cannot filter non-existing layer "${e}".`))); } getFilter(e) { return t.bw(this.getLayer(e).filter) } setLayoutProperty(e, i, r, o = {}) { this._checkLoaded(); const s = this.getLayer(e); s ? t.bz(s.getLayoutProperty(i), r) || (s.setLayoutProperty(i, r, o), this._updateLayer(s)) : this.fire(new t.j(new Error(`Cannot style non-existing layer "${e}".`))); } getLayoutProperty(e, i) { const r = this.getLayer(e); if (r) return r.getLayoutProperty(i); this.fire(new t.j(new Error(`Cannot get style of non-existing layer "${e}".`))); } setPaintProperty(e, i, r, o = {}) { this._checkLoaded(); const s = this.getLayer(e); s ? t.bz(s.getPaintProperty(i), r) || (s.setPaintProperty(i, r, o) && this._updateLayer(s), this._changed = !0, this._updatedPaintProps[e] = !0, this._serializedLayers = null) : this.fire(new t.j(new Error(`Cannot style non-existing layer "${e}".`))); } getPaintProperty(e, t) { return this.getLayer(e).getPaintProperty(t) } setFeatureState(e, i) { this._checkLoaded(); const r = e.source, o = e.sourceLayer, s = this.sourceCaches[r]; if (void 0 === s) return void this.fire(new t.j(new Error(`The source '${r}' does not exist in the map's style.`))); const a = s.getSource().type; "geojson" === a && o ? this.fire(new t.j(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : "vector" !== a || o ? (void 0 === e.id && this.fire(new t.j(new Error("The feature id parameter must be provided."))), s.setFeatureState(o, e.id, i)) : this.fire(new t.j(new Error("The sourceLayer parameter must be provided for vector source types."))); } removeFeatureState(e, i) { this._checkLoaded(); const r = e.source, o = this.sourceCaches[r]; if (void 0 === o) return void this.fire(new t.j(new Error(`The source '${r}' does not exist in the map's style.`))); const s = o.getSource().type, a = "vector" === s ? e.sourceLayer : void 0; "vector" !== s || a ? i && "string" != typeof e.id && "number" != typeof e.id ? this.fire(new t.j(new Error("A feature id is required to remove its specific state property."))) : o.removeFeatureState(a, e.id, i) : this.fire(new t.j(new Error("The sourceLayer parameter must be provided for vector source types."))); } getFeatureState(e) { this._checkLoaded(); const i = e.source, r = e.sourceLayer, o = this.sourceCaches[i]; if (void 0 !== o) return "vector" !== o.getSource().type || r ? (void 0 === e.id && this.fire(new t.j(new Error("The feature id parameter must be provided."))), o.getFeatureState(r, e.id)) : void this.fire(new t.j(new Error("The sourceLayer parameter must be provided for vector source types."))); this.fire(new t.j(new Error(`The source '${i}' does not exist in the map's style.`))); } getTransition() { return t.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition) } serialize() { if (!this._loaded) return; const e = t.bA(this.sourceCaches, (e => e.serialize())), i = this._serializeByIds(this._order, !0), r = this.map.getTerrain() || void 0, o = this.stylesheet; return t.bB({ version: o.version, name: o.name, metadata: o.metadata, light: o.light, sky: o.sky, center: o.center, zoom: o.zoom, bearing: o.bearing, pitch: o.pitch, sprite: o.sprite, glyphs: o.glyphs, transition: o.transition, projection: o.projection, sources: e, layers: i, terrain: r }, (e => void 0 !== e)) } _updateLayer(e) { this._updatedLayers[e.id] = !0, e.source && !this._updatedSources[e.source] && "raster" !== this.sourceCaches[e.source].getSource().type && (this._updatedSources[e.source] = "reload", this.sourceCaches[e.source].pause()), this._serializedLayers = null, this._changed = !0; } _flattenAndSortRenderedFeatures(e) { const t = e => "fill-extrusion" === this._layers[e].type, i = {}, r = []; for (let o = this._order.length - 1; o >= 0; o--) { const s = this._order[o]; if (t(s)) { i[s] = o; for (const t of e) { const e = t[s]; if (e) for (const t of e) r.push(t); } } } r.sort(((e, t) => t.intersectionZ - e.intersectionZ)); const o = []; for (let s = this._order.length - 1; s >= 0; s--) { const a = this._order[s]; if (t(a)) for (let e = r.length - 1; e >= 0; e--) { const t = r[e].feature; if (i[t.layer.id] < s) break; o.push(t), r.pop(); } else for (const t of e) { const e = t[a]; if (e) for (const t of e) o.push(t.feature); } } return o } queryRenderedFeatures(e, i, r) { i && i.filter && this._validate(t.u.filter, "queryRenderedFeatures.filter", i.filter, null, i); const o = {}; if (i && i.layers) { if (!(Array.isArray(i.layers) || i.layers instanceof Set)) return this.fire(new t.j(new Error("parameters.layers must be an Array or a Set of strings"))), []; for (const e of i.layers) { const i = this._layers[e]; if (!i) return this.fire(new t.j(new Error(`The layer '${e}' does not exist in the map's style and cannot be queried for features.`))), []; o[i.source] = !0; } } const s = []; i.availableImages = this._availableImages; const a = this._serializedAllLayers(), n = i.layers instanceof Set ? i.layers : Array.isArray(i.layers) ? new Set(i.layers) : null, l = Object.assign(Object.assign({}, i), { layers: n }); for (const t in this.sourceCaches) i.layers && !o[t] || s.push(N(this.sourceCaches[t], this._layers, a, e, l, r)); return this.placement && s.push(function (e, t, i, r, o, s, a) { const n = {}, l = s.queryRenderedSymbols(r), c = []; for (const e of Object.keys(l).map(Number)) c.push(a[e]); c.sort(Z); for (const i of c) { const r = i.featureIndex.lookupSymbolFeatures(l[i.bucketInstanceId], t, i.bucketIndex, i.sourceLayerIndex, o.filter, o.layers, o.availableImages, e); for (const e in r) { const t = n[e] = n[e] || [], o = r[e]; o.sort(((e, t) => { const r = i.featureSortOrder; if (r) { const i = r.indexOf(e.featureIndex); return r.indexOf(t.featureIndex) - i } return t.featureIndex - e.featureIndex })); for (const e of o) t.push(e); } } return function (e, t, i) { for (const r in e) for (const o of e[r]) G(o, i[t[r].source]); return e }(n, e, i) }(this._layers, a, this.sourceCaches, e, l, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(s) } querySourceFeatures(e, i) { i && i.filter && this._validate(t.u.filter, "querySourceFeatures.filter", i.filter, null, i); const r = this.sourceCaches[e]; return r ? function (e, t) { const i = e.getRenderableIds().map((t => e.getTileByID(t))), r = [], o = {}; for (let e = 0; e < i.length; e++) { const s = i[e], a = s.tileID.canonical.key; o[a] || (o[a] = !0, s.querySourceFeatures(r, t)); } return r }(r, i) : [] } getLight() { return this.light.getLight() } setLight(e, i = {}) { this._checkLoaded(); const r = this.light.getLight(); let o = !1; for (const i in e) if (!t.bz(e[i], r[i])) { o = !0; break } if (!o) return; const s = { now: a.now(), transition: t.e({ duration: 300, delay: 0 }, this.stylesheet.transition) }; this.light.setLight(e, i), this.light.updateTransitions(s); } getProjection() { var e; return null === (e = this.stylesheet) || void 0 === e ? void 0 : e.projection } setProjection(e) { if (this._checkLoaded(), this.projection) { if (this.projection.name === e.type) return; this.projection.destroy(), delete this.projection; } this.stylesheet.projection = e, this._setProjectionInternal(e.type); } getSky() { var e; return null === (e = this.stylesheet) || void 0 === e ? void 0 : e.sky } setSky(e, i = {}) { this._checkLoaded(); const r = this.getSky(); let o = !1; if (!e && !r) return; if (e && !r) o = !0; else if (!e && r) o = !0; else for (const i in e) if (!t.bz(e[i], r[i])) { o = !0; break } if (!o) return; const s = { now: a.now(), transition: t.e({ duration: 300, delay: 0 }, this.stylesheet.transition) }; this.stylesheet.sky = e, this.sky.setSky(e, i), this.sky.updateTransitions(s); } _setProjectionInternal(e) { const i = function (e) { if (Array.isArray(e)) { const t = new Kt({ type: e }); return { projection: t, transform: new di, cameraHelper: new pi(t) } } switch (e) { case "mercator": return { projection: new vt, transform: new Dt, cameraHelper: new kt }; case "globe": { const e = new Kt({ type: ["interpolate", ["linear"], ["zoom"], 11, "vertical-perspective", 12, "mercator"] }); return { projection: e, transform: new di, cameraHelper: new pi(e) } } case "vertical-perspective": return { projection: new Xt, transform: new ui, cameraHelper: new _i }; default: return t.w(`Unknown projection name: ${e}. Falling back to mercator projection.`), { projection: new vt, transform: new Dt, cameraHelper: new kt } } }(e); this.projection = i.projection, this.map.migrateProjection(i.transform, i.cameraHelper); for (const e in this.sourceCaches) this.sourceCaches[e].reload(); } _validate(e, i, r, o, s = {}) { return (!s || !1 !== s.validate) && mi(this, e.call(t.u, t.e({ key: i, style: this.serialize(), value: r, styleSpec: t.v }, o))) } _remove(e = !0) { this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), oe().off(te, this._rtlPluginLoaded); for (const e in this._layers) this._layers[e].setEventedParent(null); for (const e in this.sourceCaches) { const t = this.sourceCaches[e]; t.setEventedParent(null), t.onRemove(this.map); } this.imageManager.setEventedParent(null), this.setEventedParent(null), e && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(e); } _clearSource(e) { this.sourceCaches[e].clearTiles(); } _reloadSource(e) { this.sourceCaches[e].resume(), this.sourceCaches[e].reload(); } _updateSources(e) { for (const t in this.sourceCaches) this.sourceCaches[t].update(e, this.map.terrain); } _generateCollisionBoxes() { for (const e in this.sourceCaches) this._reloadSource(e); } _updatePlacement(e, t, i, r, o = !1) { let s = !1, n = !1; const l = {}; for (const t of this._order) { const i = this._layers[t]; if ("symbol" !== i.type) continue; if (!l[i.source]) { const e = this.sourceCaches[i.source]; l[i.source] = e.getRenderableIds(!0).map((t => e.getTileByID(t))).sort(((e, t) => t.tileID.overscaledZ - e.tileID.overscaledZ || (e.tileID.isLessThan(t.tileID) ? -1 : 1))); } const r = this.crossTileSymbolIndex.addLayer(i, l[i.source], e.center.lng); s = s || r; } if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((o = o || this._layerOrderChanged || 0 === i) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(a.now(), e.zoom)) && (this.pauseablePlacement = new st(e, this.map.terrain, this._order, o, t, i, r, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(a.now()), n = !0), s && this.pauseablePlacement.placement.setStale()), n || s) for (const e of this._order) { const t = this._layers[e]; "symbol" === t.type && this.placement.updateLayerOpacities(t, l[t.source]); } return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(a.now()) } _releaseSymbolFadeTiles() { for (const e in this.sourceCaches) this.sourceCaches[e].releaseSymbolFadeTiles(); } getImages(e, i) { return t._(this, void 0, void 0, (function* () { const e = yield this.imageManager.getImages(i.icons); this._updateTilesForChangedImages(); const t = this.sourceCaches[i.source]; return t && t.setDependencies(i.tileID.key, i.type, i.icons), e })) } getGlyphs(e, i) { return t._(this, void 0, void 0, (function* () { const e = yield this.glyphManager.getGlyphs(i.stacks), t = this.sourceCaches[i.source]; return t && t.setDependencies(i.tileID.key, i.type, [""]), e })) } getGlyphsUrl() { return this.stylesheet.glyphs || null } setGlyphs(e, i = {}) { this._checkLoaded(), e && this._validate(t.u.glyphs, "glyphs", e, null, i) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = e, this.glyphManager.entries = {}, this.glyphManager.setURL(e)); } addSprite(e, i, r = {}, o) { this._checkLoaded(); const s = [{ id: e, url: i }], a = [...f(this.stylesheet.sprite), ...s]; this._validate(t.u.sprite, "sprite", a, null, r) || (this.stylesheet.sprite = a, this._loadSprite(s, !0, o)); } removeSprite(e) { this._checkLoaded(); const i = f(this.stylesheet.sprite); if (i.find((t => t.id === e))) { if (this._spritesImagesIds[e]) for (const t of this._spritesImagesIds[e]) this.imageManager.removeImage(t), this._changedImages[t] = !0; i.splice(i.findIndex((t => t.id === e)), 1), this.stylesheet.sprite = i.length > 0 ? i : void 0, delete this._spritesImagesIds[e], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t.k("data", { dataType: "style" })); } else this.fire(new t.j(new Error(`Sprite "${e}" doesn't exists on this map.`))); } getSprite() { return f(this.stylesheet.sprite) } setSprite(e, i = {}, r) { this._checkLoaded(), e && this._validate(t.u.sprite, "sprite", e, null, i) || (this.stylesheet.sprite = e, e ? this._loadSprite(e, !0, r) : (this._unloadSprite(), r && r(null))); } } var vi = t.aA([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]); class xi { constructor() { this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null; } bind(e, t, i, r, o, s, a, n, l) { this.context = e; let c = this.boundPaintVertexBuffers.length !== r.length; for (let e = 0; !c && e < r.length; e++)this.boundPaintVertexBuffers[e] !== r[e] && (c = !0); !this.vao || this.boundProgram !== t || this.boundLayoutVertexBuffer !== i || c || this.boundIndexBuffer !== o || this.boundVertexOffset !== s || this.boundDynamicVertexBuffer !== a || this.boundDynamicVertexBuffer2 !== n || this.boundDynamicVertexBuffer3 !== l ? this.freshBind(t, i, r, o, s, a, n, l) : (e.bindVertexArray.set(this.vao), a && a.bind(), o && o.dynamicDraw && o.bind(), n && n.bind(), l && l.bind()); } freshBind(e, t, i, r, o, s, a, n) { const l = e.numAttributes, c = this.context, h = c.gl; this.vao && this.destroy(), this.vao = c.createVertexArray(), c.bindVertexArray.set(this.vao), this.boundProgram = e, this.boundLayoutVertexBuffer = t, this.boundPaintVertexBuffers = i, this.boundIndexBuffer = r, this.boundVertexOffset = o, this.boundDynamicVertexBuffer = s, this.boundDynamicVertexBuffer2 = a, this.boundDynamicVertexBuffer3 = n, t.enableAttributes(h, e); for (const t of i) t.enableAttributes(h, e); s && s.enableAttributes(h, e), a && a.enableAttributes(h, e), n && n.enableAttributes(h, e), t.bind(), t.setVertexAttribPointers(h, e, o); for (const t of i) t.bind(), t.setVertexAttribPointers(h, e, o); s && (s.bind(), s.setVertexAttribPointers(h, e, o)), r && r.bind(), a && (a.bind(), a.setVertexAttribPointers(h, e, o)), n && (n.bind(), n.setVertexAttribPointers(h, e, o)), c.currentNumAttributes = l; } destroy() { this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null); } } const bi = (e, i, r, o, s) => ({ u_texture: 0, u_ele_delta: e, u_fog_matrix: i, u_fog_color: r ? r.properties.get("fog-color") : t.b4.white, u_fog_ground_blend: r ? r.properties.get("fog-ground-blend") : 1, u_fog_ground_blend_opacity: s ? 0 : r ? r.calculateFogBlendOpacity(o) : 0, u_horizon_color: r ? r.properties.get("horizon-color") : t.b4.white, u_horizon_fog_blend: r ? r.properties.get("horizon-fog-blend") : 1, u_is_globe_mode: s ? 1 : 0 }), yi = { mainMatrix: "u_projection_matrix", tileMercatorCoords: "u_projection_tile_mercator_coords", clippingPlane: "u_projection_clipping_plane", projectionTransition: "u_projection_transition", fallbackMatrix: "u_projection_fallback_matrix" }; function wi(e) { const t = []; for (let i = 0; i < e.length; i++) { if (null === e[i]) continue; const r = e[i].split(" "); t.push(r.pop()); } return t } class Ti { constructor(e, i, r, o, s, a, n, l) { const c = e.gl; this.program = c.createProgram(); const h = wi(i.staticAttributes), u = r ? r.getBinderAttributes() : [], d = h.concat(u), _ = dt.prelude.staticUniforms ? wi(dt.prelude.staticUniforms) : [], p = n.staticUniforms ? wi(n.staticUniforms) : [], m = i.staticUniforms ? wi(i.staticUniforms) : [], f = r ? r.getBinderUniforms() : [], g = _.concat(p).concat(m).concat(f), v = []; for (const e of g) v.indexOf(e) < 0 && v.push(e); const x = r ? r.defines() : []; Ut(c) && x.unshift("#version 300 es"), s && x.push("#define OVERDRAW_INSPECTOR;"), a && x.push("#define TERRAIN3D;"), l && x.push(l); let b = x.concat(dt.prelude.fragmentSource, n.fragmentSource, i.fragmentSource).join("\n"), y = x.concat(dt.prelude.vertexSource, n.vertexSource, i.vertexSource).join("\n"); Ut(c) || (b = function (e) { return e.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(") }(b), y = function (e) { return e.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(") }(y)); const w = c.createShader(c.FRAGMENT_SHADER); if (c.isContextLost()) return void (this.failedToCreate = !0); if (c.shaderSource(w, b), c.compileShader(w), !c.getShaderParameter(w, c.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${c.getShaderInfoLog(w)}`); c.attachShader(this.program, w); const T = c.createShader(c.VERTEX_SHADER); if (c.isContextLost()) return void (this.failedToCreate = !0); if (c.shaderSource(T, y), c.compileShader(T), !c.getShaderParameter(T, c.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${c.getShaderInfoLog(T)}`); c.attachShader(this.program, T), this.attributes = {}; const P = {}; this.numAttributes = d.length; for (let e = 0; e < this.numAttributes; e++)d[e] && (c.bindAttribLocation(this.program, e, d[e]), this.attributes[d[e]] = e); if (c.linkProgram(this.program), !c.getProgramParameter(this.program, c.LINK_STATUS)) throw new Error(`Program failed to link: ${c.getProgramInfoLog(this.program)}`); c.deleteShader(T), c.deleteShader(w); for (let e = 0; e < v.length; e++) { const t = v[e]; if (t && !P[t]) { const e = c.getUniformLocation(this.program, t); e && (P[t] = e); } } this.fixedUniforms = o(e, P), this.terrainUniforms = ((e, i) => ({ u_depth: new t.bC(e, i.u_depth), u_terrain: new t.bC(e, i.u_terrain), u_terrain_dim: new t.b5(e, i.u_terrain_dim), u_terrain_matrix: new t.bD(e, i.u_terrain_matrix), u_terrain_unpack: new t.bE(e, i.u_terrain_unpack), u_terrain_exaggeration: new t.b5(e, i.u_terrain_exaggeration) }))(e, P), this.projectionUniforms = ((e, i) => ({ u_projection_matrix: new t.bD(e, i.u_projection_matrix), u_projection_tile_mercator_coords: new t.bE(e, i.u_projection_tile_mercator_coords), u_projection_clipping_plane: new t.bE(e, i.u_projection_clipping_plane), u_projection_transition: new t.b5(e, i.u_projection_transition), u_projection_fallback_matrix: new t.bD(e, i.u_projection_fallback_matrix) }))(e, P), this.binderUniforms = r ? r.getUniforms(e, P) : []; } draw(e, t, i, r, o, s, a, n, l, c, h, u, d, _, p, m, f, g, v) { const x = e.gl; if (this.failedToCreate) return; if (e.program.set(this.program), e.setDepthMode(i), e.setStencilMode(r), e.setColorMode(o), e.setCullFace(s), n) { e.activeTexture.set(x.TEXTURE2), x.bindTexture(x.TEXTURE_2D, n.depthTexture), e.activeTexture.set(x.TEXTURE3), x.bindTexture(x.TEXTURE_2D, n.texture); for (const e in this.terrainUniforms) this.terrainUniforms[e].set(n[e]); } if (l) for (const e in l) this.projectionUniforms[yi[e]].set(l[e]); if (a) for (const e in this.fixedUniforms) this.fixedUniforms[e].set(a[e]); m && m.setUniforms(e, this.binderUniforms, _, { zoom: p }); let b = 0; switch (t) { case x.LINES: b = 2; break; case x.TRIANGLES: b = 3; break; case x.LINE_STRIP: b = 1; }for (const i of d.get()) { const r = i.vaos || (i.vaos = {}); (r[c] || (r[c] = new xi)).bind(e, this, h, m ? m.getPaintVertexBuffers() : [], u, i.vertexOffset, f, g, v), x.drawElements(t, i.primitiveLength * b, x.UNSIGNED_SHORT, i.primitiveOffset * b * 2); } } } function Pi(e, i, r) { const o = 1 / t.at(r, 1, i.transform.tileZoom), s = Math.pow(2, r.tileID.overscaledZ), a = r.tileSize * Math.pow(2, i.transform.tileZoom) / s, n = a * (r.tileID.canonical.x + r.tileID.wrap * s), l = a * r.tileID.canonical.y; return { u_image: 0, u_texsize: r.imageAtlasTexture.size, u_scale: [o, e.fromScale, e.toScale], u_fade: e.t, u_pixel_coord_upper: [n >> 16, l >> 16], u_pixel_coord_lower: [65535 & n, 65535 & l] } } const Ci = (e, i, r, o) => { const s = e.style.light, a = s.properties.get("position"), n = [a.x, a.y, a.z], l = t.bI(); "viewport" === s.properties.get("anchor") && t.bJ(l, e.transform.bearingInRadians), t.bK(n, n, l); const c = e.transform.transformLightDirection(n), h = s.properties.get("color"); return { u_lightpos: n, u_lightpos_globe: c, u_lightintensity: s.properties.get("intensity"), u_lightcolor: [h.r, h.g, h.b], u_vertical_gradient: +i, u_opacity: r, u_fill_translate: o } }, Ii = (e, i, r, o, s, a, n) => t.e(Ci(e, i, r, o), Pi(a, e, n), { u_height_factor: -Math.pow(2, s.overscaledZ) / n.tileSize / 8 }), Ei = (e, i, r, o) => t.e(Pi(i, e, r), { u_fill_translate: o }), Mi = (e, t) => ({ u_world: e, u_fill_translate: t }), Si = (e, i, r, o, s) => t.e(Ei(e, i, r, s), { u_world: o }), Ri = (e, i, r, o, s) => { const a = e.transform; let n, l, c = 0; if ("map" === r.paint.get("circle-pitch-alignment")) { const e = t.at(i, 1, a.zoom); n = !0, l = [e, e], c = e / (t.X * Math.pow(2, i.tileID.overscaledZ)) * 2 * Math.PI * s; } else n = !1, l = a.pixelsToGLUnits; return { u_camera_to_center_distance: a.cameraToCenterDistance, u_scale_with_map: +("map" === r.paint.get("circle-pitch-scale")), u_pitch_with_map: +n, u_device_pixel_ratio: e.pixelRatio, u_extrude_scale: l, u_globe_extrude_scale: c, u_translate: o } }, Di = e => ({ u_pixel_extrude_scale: [1 / e.width, 1 / e.height] }), zi = e => ({ u_viewport_size: [e.width, e.height] }), Ai = (e, t = 1) => ({ u_color: e, u_overlay: 0, u_overlay_scale: t }), Li = (e, i, r, o) => { const s = t.at(e, 1, i) / (t.X * Math.pow(2, e.tileID.overscaledZ)) * 2 * Math.PI * o; return { u_extrude_scale: t.at(e, 1, i), u_intensity: r, u_globe_extrude_scale: s } }, ki = (e, i, r, o) => { const s = t.H(); t.bL(s, 0, e.width, e.height, 0, 0, 1); const a = e.context.gl; return { u_matrix: s, u_world: [a.drawingBufferWidth, a.drawingBufferHeight], u_image: r, u_color_ramp: o, u_opacity: i.paint.get("heatmap-opacity") } }, Fi = (e, t, i) => { const r = i.paint.get("hillshade-shadow-color"), o = i.paint.get("hillshade-highlight-color"), s = i.paint.get("hillshade-accent-color"); let a = i.paint.get("hillshade-illumination-direction") * (Math.PI / 180); return "viewport" === i.paint.get("hillshade-illumination-anchor") && (a += e.transform.bearingInRadians), { u_image: 0, u_latrange: ji(0, t.tileID), u_light: [i.paint.get("hillshade-exaggeration"), a], u_shadow: r, u_highlight: o, u_accent: s } }, Bi = (e, i) => { const r = i.stride, o = t.H(); return t.bL(o, 0, t.X, -8192, 0, 0, 1), t.J(o, o, [0, -8192, 0]), { u_matrix: o, u_image: 1, u_dimension: [r, r], u_zoom: e.overscaledZ, u_unpack: i.getUnpackVector() } }; function ji(e, i) { const r = Math.pow(2, i.canonical.z), o = i.canonical.y; return [new t.Y(0, o / r).toLngLat().lat, new t.Y(0, (o + 1) / r).toLngLat().lat] } const Oi = (e, i, r, o) => { const s = e.transform; return { u_translation: Vi(e, i, r), u_ratio: o / t.at(i, 1, s.zoom), u_device_pixel_ratio: e.pixelRatio, u_units_to_pixels: [1 / s.pixelsToGLUnits[0], 1 / s.pixelsToGLUnits[1]] } }, Ni = (e, i, r, o, s) => t.e(Oi(e, i, r, o), { u_image: 0, u_image_height: s }), Zi = (e, i, r, o, s) => { const a = e.transform, n = Ui(i, a); return { u_translation: Vi(e, i, r), u_texsize: i.imageAtlasTexture.size, u_ratio: o / t.at(i, 1, a.zoom), u_device_pixel_ratio: e.pixelRatio, u_image: 0, u_scale: [n, s.fromScale, s.toScale], u_fade: s.t, u_units_to_pixels: [1 / a.pixelsToGLUnits[0], 1 / a.pixelsToGLUnits[1]] } }, Gi = (e, i, r, o, s, a) => { const n = e.lineAtlas, l = Ui(i, e.transform), c = "round" === r.layout.get("line-cap"), h = n.getDash(s.from, c), u = n.getDash(s.to, c), d = h.width * a.fromScale, _ = u.width * a.toScale; return t.e(Oi(e, i, r, o), { u_patternscale_a: [l / d, -h.height / 2], u_patternscale_b: [l / _, -u.height / 2], u_sdfgamma: n.width / (256 * Math.min(d, _) * e.pixelRatio) / 2, u_image: 0, u_tex_y_a: h.y, u_tex_y_b: u.y, u_mix: a.t }) }; function Ui(e, i) { return 1 / t.at(e, 1, i.tileZoom) } function Vi(e, i, r) { return t.au(e.transform, i, r.paint.get("line-translate"), r.paint.get("line-translate-anchor")) } const qi = (e, t, i, r, o) => { return { u_tl_parent: e, u_scale_parent: t, u_buffer_scale: 1, u_fade_t: i.mix, u_opacity: i.opacity * r.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: r.paint.get("raster-brightness-min"), u_brightness_high: r.paint.get("raster-brightness-max"), u_saturation_factor: (a = r.paint.get("raster-saturation"), a > 0 ? 1 - 1 / (1.001 - a) : -a), u_contrast_factor: (s = r.paint.get("raster-contrast"), s > 0 ? 1 / (1 - s) : 1 + s), u_spin_weights: Hi(r.paint.get("raster-hue-rotate")), u_coords_top: [o[0].x, o[0].y, o[1].x, o[1].y], u_coords_bottom: [o[3].x, o[3].y, o[2].x, o[2].y] }; var s, a; }; function Hi(e) { e *= Math.PI / 180; const t = Math.sin(e), i = Math.cos(e); return [(2 * i + 1) / 3, (-Math.sqrt(3) * t - i + 1) / 3, (Math.sqrt(3) * t - i + 1) / 3] } const Wi = (e, t, i, r, o, s, a, n, l, c, h, u, d) => { const _ = a.transform; return { u_is_size_zoom_constant: +("constant" === e || "source" === e), u_is_size_feature_constant: +("constant" === e || "camera" === e), u_size_t: t ? t.uSizeT : 0, u_size: t ? t.uSize : 0, u_camera_to_center_distance: _.cameraToCenterDistance, u_pitch: _.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +i, u_aspect_ratio: _.width / _.height, u_fade_change: a.options.fadeDuration ? a.symbolFadeChange : 1, u_label_plane_matrix: n, u_coord_matrix: l, u_is_text: +h, u_pitch_with_map: +r, u_is_along_line: o, u_is_variable_anchor: s, u_texsize: u, u_texture: 0, u_translation: c, u_pitched_scale: d } }, Xi = (e, i, r, o, s, a, n, l, c, h, u, d, _, p) => { const m = n.transform; return t.e(Wi(e, i, r, o, s, a, n, l, c, h, u, d, p), { u_gamma_scale: o ? Math.cos(m.pitch * Math.PI / 180) * m.cameraToCenterDistance : 1, u_device_pixel_ratio: n.pixelRatio, u_is_halo: 1 }) }, $i = (e, i, r, o, s, a, n, l, c, h, u, d, _) => t.e(Xi(e, i, r, o, s, a, n, l, c, h, !0, u, 0, _), { u_texsize_icon: d, u_texture_icon: 1 }), Ki = (e, t) => ({ u_opacity: e, u_color: t }), Yi = (e, i, r, o, s) => t.e(function (e, i, r, o) { const s = r.imageManager.getPattern(e.from.toString()), a = r.imageManager.getPattern(e.to.toString()), { width: n, height: l } = r.imageManager.getPixelSize(), c = Math.pow(2, o.tileID.overscaledZ), h = o.tileSize * Math.pow(2, r.transform.tileZoom) / c, u = h * (o.tileID.canonical.x + o.tileID.wrap * c), d = h * o.tileID.canonical.y; return { u_image: 0, u_pattern_tl_a: s.tl, u_pattern_br_a: s.br, u_pattern_tl_b: a.tl, u_pattern_br_b: a.br, u_texsize: [n, l], u_mix: i.t, u_pattern_size_a: s.displaySize, u_pattern_size_b: a.displaySize, u_scale_a: i.fromScale, u_scale_b: i.toScale, u_tile_units_to_pixels: 1 / t.at(o, 1, r.transform.tileZoom), u_pixel_coord_upper: [u >> 16, d >> 16], u_pixel_coord_lower: [65535 & u, 65535 & d] } }(r, s, i, o), { u_opacity: e }), Ji = (e, t) => { }, Qi = { fillExtrusion: (e, i) => ({ u_lightpos: new t.bG(e, i.u_lightpos), u_lightpos_globe: new t.bG(e, i.u_lightpos_globe), u_lightintensity: new t.b5(e, i.u_lightintensity), u_lightcolor: new t.bG(e, i.u_lightcolor), u_vertical_gradient: new t.b5(e, i.u_vertical_gradient), u_opacity: new t.b5(e, i.u_opacity), u_fill_translate: new t.bH(e, i.u_fill_translate) }), fillExtrusionPattern: (e, i) => ({ u_lightpos: new t.bG(e, i.u_lightpos), u_lightpos_globe: new t.bG(e, i.u_lightpos_globe), u_lightintensity: new t.b5(e, i.u_lightintensity), u_lightcolor: new t.bG(e, i.u_lightcolor), u_vertical_gradient: new t.b5(e, i.u_vertical_gradient), u_height_factor: new t.b5(e, i.u_height_factor), u_opacity: new t.b5(e, i.u_opacity), u_fill_translate: new t.bH(e, i.u_fill_translate), u_image: new t.bC(e, i.u_image), u_texsize: new t.bH(e, i.u_texsize), u_pixel_coord_upper: new t.bH(e, i.u_pixel_coord_upper), u_pixel_coord_lower: new t.bH(e, i.u_pixel_coord_lower), u_scale: new t.bG(e, i.u_scale), u_fade: new t.b5(e, i.u_fade) }), fill: (e, i) => ({ u_fill_translate: new t.bH(e, i.u_fill_translate) }), fillPattern: (e, i) => ({ u_image: new t.bC(e, i.u_image), u_texsize: new t.bH(e, i.u_texsize), u_pixel_coord_upper: new t.bH(e, i.u_pixel_coord_upper), u_pixel_coord_lower: new t.bH(e, i.u_pixel_coord_lower), u_scale: new t.bG(e, i.u_scale), u_fade: new t.b5(e, i.u_fade), u_fill_translate: new t.bH(e, i.u_fill_translate) }), fillOutline: (e, i) => ({ u_world: new t.bH(e, i.u_world), u_fill_translate: new t.bH(e, i.u_fill_translate) }), fillOutlinePattern: (e, i) => ({ u_world: new t.bH(e, i.u_world), u_image: new t.bC(e, i.u_image), u_texsize: new t.bH(e, i.u_texsize), u_pixel_coord_upper: new t.bH(e, i.u_pixel_coord_upper), u_pixel_coord_lower: new t.bH(e, i.u_pixel_coord_lower), u_scale: new t.bG(e, i.u_scale), u_fade: new t.b5(e, i.u_fade), u_fill_translate: new t.bH(e, i.u_fill_translate) }), circle: (e, i) => ({ u_camera_to_center_distance: new t.b5(e, i.u_camera_to_center_distance), u_scale_with_map: new t.bC(e, i.u_scale_with_map), u_pitch_with_map: new t.bC(e, i.u_pitch_with_map), u_extrude_scale: new t.bH(e, i.u_extrude_scale), u_device_pixel_ratio: new t.b5(e, i.u_device_pixel_ratio), u_globe_extrude_scale: new t.b5(e, i.u_globe_extrude_scale), u_translate: new t.bH(e, i.u_translate) }), collisionBox: (e, i) => ({ u_pixel_extrude_scale: new t.bH(e, i.u_pixel_extrude_scale) }), collisionCircle: (e, i) => ({ u_viewport_size: new t.bH(e, i.u_viewport_size) }), debug: (e, i) => ({ u_color: new t.bF(e, i.u_color), u_overlay: new t.bC(e, i.u_overlay), u_overlay_scale: new t.b5(e, i.u_overlay_scale) }), depth: Ji, clippingMask: Ji, heatmap: (e, i) => ({ u_extrude_scale: new t.b5(e, i.u_extrude_scale), u_intensity: new t.b5(e, i.u_intensity), u_globe_extrude_scale: new t.b5(e, i.u_globe_extrude_scale) }), heatmapTexture: (e, i) => ({ u_matrix: new t.bD(e, i.u_matrix), u_world: new t.bH(e, i.u_world), u_image: new t.bC(e, i.u_image), u_color_ramp: new t.bC(e, i.u_color_ramp), u_opacity: new t.b5(e, i.u_opacity) }), hillshade: (e, i) => ({ u_image: new t.bC(e, i.u_image), u_latrange: new t.bH(e, i.u_latrange), u_light: new t.bH(e, i.u_light), u_shadow: new t.bF(e, i.u_shadow), u_highlight: new t.bF(e, i.u_highlight), u_accent: new t.bF(e, i.u_accent) }), hillshadePrepare: (e, i) => ({ u_matrix: new t.bD(e, i.u_matrix), u_image: new t.bC(e, i.u_image), u_dimension: new t.bH(e, i.u_dimension), u_zoom: new t.b5(e, i.u_zoom), u_unpack: new t.bE(e, i.u_unpack) }), line: (e, i) => ({ u_translation: new t.bH(e, i.u_translation), u_ratio: new t.b5(e, i.u_ratio), u_device_pixel_ratio: new t.b5(e, i.u_device_pixel_ratio), u_units_to_pixels: new t.bH(e, i.u_units_to_pixels) }), lineGradient: (e, i) => ({ u_translation: new t.bH(e, i.u_translation), u_ratio: new t.b5(e, i.u_ratio), u_device_pixel_ratio: new t.b5(e, i.u_device_pixel_ratio), u_units_to_pixels: new t.bH(e, i.u_units_to_pixels), u_image: new t.bC(e, i.u_image), u_image_height: new t.b5(e, i.u_image_height) }), linePattern: (e, i) => ({ u_translation: new t.bH(e, i.u_translation), u_texsize: new t.bH(e, i.u_texsize), u_ratio: new t.b5(e, i.u_ratio), u_device_pixel_ratio: new t.b5(e, i.u_device_pixel_ratio), u_image: new t.bC(e, i.u_image), u_units_to_pixels: new t.bH(e, i.u_units_to_pixels), u_scale: new t.bG(e, i.u_scale), u_fade: new t.b5(e, i.u_fade) }), lineSDF: (e, i) => ({ u_translation: new t.bH(e, i.u_translation), u_ratio: new t.b5(e, i.u_ratio), u_device_pixel_ratio: new t.b5(e, i.u_device_pixel_ratio), u_units_to_pixels: new t.bH(e, i.u_units_to_pixels), u_patternscale_a: new t.bH(e, i.u_patternscale_a), u_patternscale_b: new t.bH(e, i.u_patternscale_b), u_sdfgamma: new t.b5(e, i.u_sdfgamma), u_image: new t.bC(e, i.u_image), u_tex_y_a: new t.b5(e, i.u_tex_y_a), u_tex_y_b: new t.b5(e, i.u_tex_y_b), u_mix: new t.b5(e, i.u_mix) }), raster: (e, i) => ({ u_tl_parent: new t.bH(e, i.u_tl_parent), u_scale_parent: new t.b5(e, i.u_scale_parent), u_buffer_scale: new t.b5(e, i.u_buffer_scale), u_fade_t: new t.b5(e, i.u_fade_t), u_opacity: new t.b5(e, i.u_opacity), u_image0: new t.bC(e, i.u_image0), u_image1: new t.bC(e, i.u_image1), u_brightness_low: new t.b5(e, i.u_brightness_low), u_brightness_high: new t.b5(e, i.u_brightness_high), u_saturation_factor: new t.b5(e, i.u_saturation_factor), u_contrast_factor: new t.b5(e, i.u_contrast_factor), u_spin_weights: new t.bG(e, i.u_spin_weights), u_coords_top: new t.bE(e, i.u_coords_top), u_coords_bottom: new t.bE(e, i.u_coords_bottom) }), symbolIcon: (e, i) => ({ u_is_size_zoom_constant: new t.bC(e, i.u_is_size_zoom_constant), u_is_size_feature_constant: new t.bC(e, i.u_is_size_feature_constant), u_size_t: new t.b5(e, i.u_size_t), u_size: new t.b5(e, i.u_size), u_camera_to_center_distance: new t.b5(e, i.u_camera_to_center_distance), u_pitch: new t.b5(e, i.u_pitch), u_rotate_symbol: new t.bC(e, i.u_rotate_symbol), u_aspect_ratio: new t.b5(e, i.u_aspect_ratio), u_fade_change: new t.b5(e, i.u_fade_change), u_label_plane_matrix: new t.bD(e, i.u_label_plane_matrix), u_coord_matrix: new t.bD(e, i.u_coord_matrix), u_is_text: new t.bC(e, i.u_is_text), u_pitch_with_map: new t.bC(e, i.u_pitch_with_map), u_is_along_line: new t.bC(e, i.u_is_along_line), u_is_variable_anchor: new t.bC(e, i.u_is_variable_anchor), u_texsize: new t.bH(e, i.u_texsize), u_texture: new t.bC(e, i.u_texture), u_translation: new t.bH(e, i.u_translation), u_pitched_scale: new t.b5(e, i.u_pitched_scale) }), symbolSDF: (e, i) => ({ u_is_size_zoom_constant: new t.bC(e, i.u_is_size_zoom_constant), u_is_size_feature_constant: new t.bC(e, i.u_is_size_feature_constant), u_size_t: new t.b5(e, i.u_size_t), u_size: new t.b5(e, i.u_size), u_camera_to_center_distance: new t.b5(e, i.u_camera_to_center_distance), u_pitch: new t.b5(e, i.u_pitch), u_rotate_symbol: new t.bC(e, i.u_rotate_symbol), u_aspect_ratio: new t.b5(e, i.u_aspect_ratio), u_fade_change: new t.b5(e, i.u_fade_change), u_label_plane_matrix: new t.bD(e, i.u_label_plane_matrix), u_coord_matrix: new t.bD(e, i.u_coord_matrix), u_is_text: new t.bC(e, i.u_is_text), u_pitch_with_map: new t.bC(e, i.u_pitch_with_map), u_is_along_line: new t.bC(e, i.u_is_along_line), u_is_variable_anchor: new t.bC(e, i.u_is_variable_anchor), u_texsize: new t.bH(e, i.u_texsize), u_texture: new t.bC(e, i.u_texture), u_gamma_scale: new t.b5(e, i.u_gamma_scale), u_device_pixel_ratio: new t.b5(e, i.u_device_pixel_ratio), u_is_halo: new t.bC(e, i.u_is_halo), u_translation: new t.bH(e, i.u_translation), u_pitched_scale: new t.b5(e, i.u_pitched_scale) }), symbolTextAndIcon: (e, i) => ({ u_is_size_zoom_constant: new t.bC(e, i.u_is_size_zoom_constant), u_is_size_feature_constant: new t.bC(e, i.u_is_size_feature_constant), u_size_t: new t.b5(e, i.u_size_t), u_size: new t.b5(e, i.u_size), u_camera_to_center_distance: new t.b5(e, i.u_camera_to_center_distance), u_pitch: new t.b5(e, i.u_pitch), u_rotate_symbol: new t.bC(e, i.u_rotate_symbol), u_aspect_ratio: new t.b5(e, i.u_aspect_ratio), u_fade_change: new t.b5(e, i.u_fade_change), u_label_plane_matrix: new t.bD(e, i.u_label_plane_matrix), u_coord_matrix: new t.bD(e, i.u_coord_matrix), u_is_text: new t.bC(e, i.u_is_text), u_pitch_with_map: new t.bC(e, i.u_pitch_with_map), u_is_along_line: new t.bC(e, i.u_is_along_line), u_is_variable_anchor: new t.bC(e, i.u_is_variable_anchor), u_texsize: new t.bH(e, i.u_texsize), u_texsize_icon: new t.bH(e, i.u_texsize_icon), u_texture: new t.bC(e, i.u_texture), u_texture_icon: new t.bC(e, i.u_texture_icon), u_gamma_scale: new t.b5(e, i.u_gamma_scale), u_device_pixel_ratio: new t.b5(e, i.u_device_pixel_ratio), u_is_halo: new t.bC(e, i.u_is_halo), u_translation: new t.bH(e, i.u_translation), u_pitched_scale: new t.b5(e, i.u_pitched_scale) }), background: (e, i) => ({ u_opacity: new t.b5(e, i.u_opacity), u_color: new t.bF(e, i.u_color) }), backgroundPattern: (e, i) => ({ u_opacity: new t.b5(e, i.u_opacity), u_image: new t.bC(e, i.u_image), u_pattern_tl_a: new t.bH(e, i.u_pattern_tl_a), u_pattern_br_a: new t.bH(e, i.u_pattern_br_a), u_pattern_tl_b: new t.bH(e, i.u_pattern_tl_b), u_pattern_br_b: new t.bH(e, i.u_pattern_br_b), u_texsize: new t.bH(e, i.u_texsize), u_mix: new t.b5(e, i.u_mix), u_pattern_size_a: new t.bH(e, i.u_pattern_size_a), u_pattern_size_b: new t.bH(e, i.u_pattern_size_b), u_scale_a: new t.b5(e, i.u_scale_a), u_scale_b: new t.b5(e, i.u_scale_b), u_pixel_coord_upper: new t.bH(e, i.u_pixel_coord_upper), u_pixel_coord_lower: new t.bH(e, i.u_pixel_coord_lower), u_tile_units_to_pixels: new t.b5(e, i.u_tile_units_to_pixels) }), terrain: (e, i) => ({ u_texture: new t.bC(e, i.u_texture), u_ele_delta: new t.b5(e, i.u_ele_delta), u_fog_matrix: new t.bD(e, i.u_fog_matrix), u_fog_color: new t.bF(e, i.u_fog_color), u_fog_ground_blend: new t.b5(e, i.u_fog_ground_blend), u_fog_ground_blend_opacity: new t.b5(e, i.u_fog_ground_blend_opacity), u_horizon_color: new t.bF(e, i.u_horizon_color), u_horizon_fog_blend: new t.b5(e, i.u_horizon_fog_blend), u_is_globe_mode: new t.b5(e, i.u_is_globe_mode) }), terrainDepth: (e, i) => ({ u_ele_delta: new t.b5(e, i.u_ele_delta) }), terrainCoords: (e, i) => ({ u_texture: new t.bC(e, i.u_texture), u_terrain_coords_id: new t.b5(e, i.u_terrain_coords_id), u_ele_delta: new t.b5(e, i.u_ele_delta) }), projectionErrorMeasurement: (e, i) => ({ u_input: new t.b5(e, i.u_input), u_output_expected: new t.b5(e, i.u_output_expected) }), atmosphere: (e, i) => ({ u_sun_pos: new t.bG(e, i.u_sun_pos), u_atmosphere_blend: new t.b5(e, i.u_atmosphere_blend), u_globe_position: new t.bG(e, i.u_globe_position), u_globe_radius: new t.b5(e, i.u_globe_radius), u_inv_proj_matrix: new t.bD(e, i.u_inv_proj_matrix) }), sky: (e, i) => ({ u_sky_color: new t.bF(e, i.u_sky_color), u_horizon_color: new t.bF(e, i.u_horizon_color), u_horizon: new t.bH(e, i.u_horizon), u_horizon_normal: new t.bH(e, i.u_horizon_normal), u_sky_horizon_blend: new t.b5(e, i.u_sky_horizon_blend), u_sky_blend: new t.b5(e, i.u_sky_blend) }) }; class er { constructor(e, t, i) { this.context = e; const r = e.gl; this.buffer = r.createBuffer(), this.dynamicDraw = Boolean(i), this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), r.bufferData(r.ELEMENT_ARRAY_BUFFER, t.arrayBuffer, this.dynamicDraw ? r.DYNAMIC_DRAW : r.STATIC_DRAW), this.dynamicDraw || delete t.arrayBuffer; } bind() { this.context.bindElementBuffer.set(this.buffer); } updateData(e) { const t = this.context.gl; if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode."); this.context.unbindVAO(), this.bind(), t.bufferSubData(t.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer); } destroy() { this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer); } } const tr = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" }; class ir { constructor(e, t, i, r) { this.length = t.length, this.attributes = i, this.itemSize = t.bytesPerElement, this.dynamicDraw = r, this.context = e; const o = e.gl; this.buffer = o.createBuffer(), e.bindVertexBuffer.set(this.buffer), o.bufferData(o.ARRAY_BUFFER, t.arrayBuffer, this.dynamicDraw ? o.DYNAMIC_DRAW : o.STATIC_DRAW), this.dynamicDraw || delete t.arrayBuffer; } bind() { this.context.bindVertexBuffer.set(this.buffer); } updateData(e) { if (e.length !== this.length) throw new Error(`Length of new data is ${e.length}, which doesn't match current length of ${this.length}`); const t = this.context.gl; this.bind(), t.bufferSubData(t.ARRAY_BUFFER, 0, e.arrayBuffer); } enableAttributes(e, t) { for (let i = 0; i < this.attributes.length; i++) { const r = t.attributes[this.attributes[i].name]; void 0 !== r && e.enableVertexAttribArray(r); } } setVertexAttribPointers(e, t, i) { for (let r = 0; r < this.attributes.length; r++) { const o = this.attributes[r], s = t.attributes[o.name]; void 0 !== s && e.vertexAttribPointer(s, o.components, e[tr[o.type]], !1, this.itemSize, o.offset + this.itemSize * (i || 0)); } } destroy() { this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer); } } class rr { constructor(e) { this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1; } get() { return this.current } set(e) { } getDefault() { return this.default } setDefault() { this.set(this.default); } } class or extends rr { getDefault() { return t.b4.transparent } set(e) { const t = this.current; (e.r !== t.r || e.g !== t.g || e.b !== t.b || e.a !== t.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1); } } class sr extends rr { getDefault() { return 1 } set(e) { (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = !1); } } class ar extends rr { getDefault() { return 0 } set(e) { (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = !1); } } class nr extends rr { getDefault() { return [!0, !0, !0, !0] } set(e) { const t = this.current; (e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || e[3] !== t[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1); } } class lr extends rr { getDefault() { return !0 } set(e) { (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = !1); } } class cr extends rr { getDefault() { return 255 } set(e) { (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = !1); } } class hr extends rr { getDefault() { return { func: this.gl.ALWAYS, ref: 0, mask: 255 } } set(e) { const t = this.current; (e.func !== t.func || e.ref !== t.ref || e.mask !== t.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = !1); } } class ur extends rr { getDefault() { const e = this.gl; return [e.KEEP, e.KEEP, e.KEEP] } set(e) { const t = this.current; (e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = !1); } } class dr extends rr { getDefault() { return !1 } set(e) { if (e === this.current && !this.dirty) return; const t = this.gl; e ? t.enable(t.STENCIL_TEST) : t.disable(t.STENCIL_TEST), this.current = e, this.dirty = !1; } } class _r extends rr { getDefault() { return [0, 1] } set(e) { const t = this.current; (e[0] !== t[0] || e[1] !== t[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = !1); } } class pr extends rr { getDefault() { return !1 } set(e) { if (e === this.current && !this.dirty) return; const t = this.gl; e ? t.enable(t.DEPTH_TEST) : t.disable(t.DEPTH_TEST), this.current = e, this.dirty = !1; } } class mr extends rr { getDefault() { return this.gl.LESS } set(e) { (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = !1); } } class fr extends rr { getDefault() { return !1 } set(e) { if (e === this.current && !this.dirty) return; const t = this.gl; e ? t.enable(t.BLEND) : t.disable(t.BLEND), this.current = e, this.dirty = !1; } } class gr extends rr { getDefault() { const e = this.gl; return [e.ONE, e.ZERO] } set(e) { const t = this.current; (e[0] !== t[0] || e[1] !== t[1] || this.dirty) && (this.gl.blendFunc(e[0], e[1]), this.current = e, this.dirty = !1); } } class vr extends rr { getDefault() { return t.b4.transparent } set(e) { const t = this.current; (e.r !== t.r || e.g !== t.g || e.b !== t.b || e.a !== t.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1); } } class xr extends rr { getDefault() { return this.gl.FUNC_ADD } set(e) { (e !== this.current || this.dirty) && (this.gl.blendEquation(e), this.current = e, this.dirty = !1); } } class br extends rr { getDefault() { return !1 } set(e) { if (e === this.current && !this.dirty) return; const t = this.gl; e ? t.enable(t.CULL_FACE) : t.disable(t.CULL_FACE), this.current = e, this.dirty = !1; } } class yr extends rr { getDefault() { return this.gl.BACK } set(e) { (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = !1); } } class wr extends rr { getDefault() { return this.gl.CCW } set(e) { (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = !1); } } class Tr extends rr { getDefault() { return null } set(e) { (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = !1); } } class Pr extends rr { getDefault() { return this.gl.TEXTURE0 } set(e) { (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = !1); } } class Cr extends rr { getDefault() { const e = this.gl; return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight] } set(e) { const t = this.current; (e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || e[3] !== t[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1); } } class Ir extends rr { getDefault() { return null } set(e) { if (e === this.current && !this.dirty) return; const t = this.gl; t.bindFramebuffer(t.FRAMEBUFFER, e), this.current = e, this.dirty = !1; } } class Er extends rr { getDefault() { return null } set(e) { if (e === this.current && !this.dirty) return; const t = this.gl; t.bindRenderbuffer(t.RENDERBUFFER, e), this.current = e, this.dirty = !1; } } class Mr extends rr { getDefault() { return null } set(e) { if (e === this.current && !this.dirty) return; const t = this.gl; t.bindTexture(t.TEXTURE_2D, e), this.current = e, this.dirty = !1; } } class Sr extends rr { getDefault() { return null } set(e) { if (e === this.current && !this.dirty) return; const t = this.gl; t.bindBuffer(t.ARRAY_BUFFER, e), this.current = e, this.dirty = !1; } } class Rr extends rr { getDefault() { return null } set(e) { const t = this.gl; t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = !1; } } class Dr extends rr { getDefault() { return null } set(e) { var t; if (e === this.current && !this.dirty) return; const i = this.gl; Ut(i) ? i.bindVertexArray(e) : null === (t = i.getExtension("OES_vertex_array_object")) || void 0 === t || t.bindVertexArrayOES(e), this.current = e, this.dirty = !1; } } class zr extends rr { getDefault() { return 4 } set(e) { if (e === this.current && !this.dirty) return; const t = this.gl; t.pixelStorei(t.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = !1; } } class Ar extends rr { getDefault() { return !1 } set(e) { if (e === this.current && !this.dirty) return; const t = this.gl; t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = !1; } } class Lr extends rr { getDefault() { return !1 } set(e) { if (e === this.current && !this.dirty) return; const t = this.gl; t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = !1; } } class kr extends rr { constructor(e, t) { super(e), this.context = e, this.parent = t; } getDefault() { return null } } class Fr extends kr { setDirty() { this.dirty = !0; } set(e) { if (e === this.current && !this.dirty) return; this.context.bindFramebuffer.set(this.parent); const t = this.gl; t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1; } } class Br extends kr { set(e) { if (e === this.current && !this.dirty) return; this.context.bindFramebuffer.set(this.parent); const t = this.gl; t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, e), this.current = e, this.dirty = !1; } } class jr extends kr { set(e) { if (e === this.current && !this.dirty) return; this.context.bindFramebuffer.set(this.parent); const t = this.gl; t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, e), this.current = e, this.dirty = !1; } } const Or = "Framebuffer is not complete"; class Nr { constructor(e, t, i, r, o) { this.context = e, this.width = t, this.height = i; const s = e.gl, a = this.framebuffer = s.createFramebuffer(); if (this.colorAttachment = new Fr(e, a), r) this.depthAttachment = o ? new jr(e, a) : new Br(e, a); else if (o) throw new Error("Stencil cannot be set without depth"); if (s.checkFramebufferStatus(s.FRAMEBUFFER) !== s.FRAMEBUFFER_COMPLETE) throw new Error(Or) } destroy() { const e = this.context.gl, t = this.colorAttachment.get(); if (t && e.deleteTexture(t), this.depthAttachment) { const t = this.depthAttachment.get(); t && e.deleteRenderbuffer(t); } e.deleteFramebuffer(this.framebuffer); } } class Zr { constructor(e) { var t, i; if (this.gl = e, this.clearColor = new or(this), this.clearDepth = new sr(this), this.clearStencil = new ar(this), this.colorMask = new nr(this), this.depthMask = new lr(this), this.stencilMask = new cr(this), this.stencilFunc = new hr(this), this.stencilOp = new ur(this), this.stencilTest = new dr(this), this.depthRange = new _r(this), this.depthTest = new pr(this), this.depthFunc = new mr(this), this.blend = new fr(this), this.blendFunc = new gr(this), this.blendColor = new vr(this), this.blendEquation = new xr(this), this.cullFace = new br(this), this.cullFaceSide = new yr(this), this.frontFace = new wr(this), this.program = new Tr(this), this.activeTexture = new Pr(this), this.viewport = new Cr(this), this.bindFramebuffer = new Ir(this), this.bindRenderbuffer = new Er(this), this.bindTexture = new Mr(this), this.bindVertexBuffer = new Sr(this), this.bindElementBuffer = new Rr(this), this.bindVertexArray = new Dr(this), this.pixelStoreUnpack = new zr(this), this.pixelStoreUnpackPremultiplyAlpha = new Ar(this), this.pixelStoreUnpackFlipY = new Lr(this), this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), Ut(e)) { this.HALF_FLOAT = e.HALF_FLOAT; const r = e.getExtension("EXT_color_buffer_half_float"); this.RGBA16F = null !== (t = e.RGBA16F) && void 0 !== t ? t : null == r ? void 0 : r.RGBA16F_EXT, this.RGB16F = null !== (i = e.RGB16F) && void 0 !== i ? i : null == r ? void 0 : r.RGB16F_EXT, e.getExtension("EXT_color_buffer_float"); } else { e.getExtension("EXT_color_buffer_half_float"), e.getExtension("OES_texture_half_float_linear"); const t = e.getExtension("OES_texture_half_float"); this.HALF_FLOAT = null == t ? void 0 : t.HALF_FLOAT_OES; } } setDefault() { this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault(); } setDirty() { this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0; } createIndexBuffer(e, t) { return new er(this, e, t) } createVertexBuffer(e, t, i) { return new ir(this, e, t, i) } createRenderbuffer(e, t, i) { const r = this.gl, o = r.createRenderbuffer(); return this.bindRenderbuffer.set(o), r.renderbufferStorage(r.RENDERBUFFER, e, t, i), this.bindRenderbuffer.set(null), o } createFramebuffer(e, t, i, r) { return new Nr(this, e, t, i, r) } clear({ color: e, depth: t, stencil: i }) { const r = this.gl; let o = 0; e && (o |= r.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set([!0, !0, !0, !0])), void 0 !== t && (o |= r.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t), this.depthMask.set(!0)), void 0 !== i && (o |= r.STENCIL_BUFFER_BIT, this.clearStencil.set(i), this.stencilMask.set(255)), r.clear(o); } setCullFace(e) { !1 === e.enable ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace)); } setDepthMode(e) { e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(!1); } setStencilMode(e) { e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({ func: e.test.func, ref: e.ref, mask: e.test.mask })) : this.stencilTest.set(!1); } setColorMode(e) { t.bz(e.blendFunction, Ft.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(e.blendFunction), this.blendColor.set(e.blendColor)), this.colorMask.set(e.mask); } createVertexArray() { var e; return Ut(this.gl) ? this.gl.createVertexArray() : null === (e = this.gl.getExtension("OES_vertex_array_object")) || void 0 === e ? void 0 : e.createVertexArrayOES() } deleteVertexArray(e) { var t; return Ut(this.gl) ? this.gl.deleteVertexArray(e) : null === (t = this.gl.getExtension("OES_vertex_array_object")) || void 0 === t ? void 0 : t.deleteVertexArrayOES(e) } unbindVAO() { this.bindVertexArray.set(null); } } let Gr; function Ur(e, i, r, o, s) { const a = e.context, n = e.transform, l = a.gl, c = e.useProgram("collisionBox"), h = []; let u = 0, d = 0; for (let t = 0; t < o.length; t++) { const _ = o[t], p = i.getTile(_).getBucket(r); if (!p) continue; const m = s ? p.textCollisionBox : p.iconCollisionBox, f = p.collisionCircleArray; f.length > 0 && (h.push({ circleArray: f, circleOffset: d, coord: _ }), u += f.length / 4, d = u), m && c.draw(a, l.LINES, Ot.disabled, Zt.disabled, e.colorModeForRenderPass(), jt.disabled, Di(e.transform), e.style.map.terrain && e.style.map.terrain.getTerrainData(_), n.getProjectionData({ overscaledTileID: _, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), r.id, m.layoutVertexBuffer, m.indexBuffer, m.segments, null, e.transform.zoom, null, null, m.collisionVertexBuffer); } if (!s || !h.length) return; const _ = e.useProgram("collisionCircle"), p = new t.bM; p.resize(4 * u), p._trim(); let m = 0; for (const e of h) for (let t = 0; t < e.circleArray.length / 4; t++) { const i = 4 * t, r = e.circleArray[i + 0], o = e.circleArray[i + 1], s = e.circleArray[i + 2], a = e.circleArray[i + 3]; p.emplace(m++, r, o, s, a, 0), p.emplace(m++, r, o, s, a, 1), p.emplace(m++, r, o, s, a, 2), p.emplace(m++, r, o, s, a, 3); } (!Gr || Gr.length < 2 * u) && (Gr = function (e) { const i = 2 * e, r = new t.bO; r.resize(i), r._trim(); for (let e = 0; e < i; e++) { const t = 6 * e; r.uint16[t + 0] = 4 * e + 0, r.uint16[t + 1] = 4 * e + 1, r.uint16[t + 2] = 4 * e + 2, r.uint16[t + 3] = 4 * e + 2, r.uint16[t + 4] = 4 * e + 3, r.uint16[t + 5] = 4 * e + 0; } return r }(u)); const f = a.createIndexBuffer(Gr, !0), g = a.createVertexBuffer(p, t.bN.members, !0); for (const i of h) { const o = zi(e.transform); _.draw(a, l.TRIANGLES, Ot.disabled, Zt.disabled, e.colorModeForRenderPass(), jt.disabled, o, e.style.map.terrain && e.style.map.terrain.getTerrainData(i.coord), null, r.id, g, f, t.aD.simpleSegment(0, 2 * i.circleOffset, i.circleArray.length, i.circleArray.length / 2), null, e.transform.zoom, null, null, null); } g.destroy(), f.destroy(); } const Vr = t.aq(new Float32Array(16)); function qr(e, i, r, o, s, a) { const { horizontalAlign: n, verticalAlign: l } = t.ay(e); return new t.P((-(n - .5) * i / s + o[0]) * a, (-(l - .5) * r / s + o[1]) * a) } function Hr(e, i, r, o, s, a) { const n = i.tileAnchorPoint.add(new t.P(i.translation[0], i.translation[1])); if (i.pitchWithMap) { let e = o.mult(a); r || (e = e.rotate(-s)); const t = n.add(e); return ye(t.x, t.y, i.pitchedLabelPlaneMatrix, i.getElevation).point } if (r) { const t = Re(i.tileAnchorPoint.x + 1, i.tileAnchorPoint.y, i).point.sub(e), r = Math.atan(t.y / t.x) + (t.x < 0 ? Math.PI : 0); return e.add(o.rotate(r)) } return e.add(o) } function Wr(e, i, r, o, s, a, n, l, c, h, u, d) { const _ = e.text.placedSymbolArray, p = e.text.dynamicLayoutVertexArray, m = e.icon.dynamicLayoutVertexArray, f = {}; p.clear(); for (let m = 0; m < _.length; m++) { const g = _.get(m), v = g.hidden || !g.crossTileID || e.allowVerticalPlacement && !g.placedOrientation ? null : o[g.crossTileID]; if (v) { const o = new t.P(g.anchorX, g.anchorY), _ = { getElevation: d, width: s.width, height: s.height, pitchedLabelPlaneMatrix: a, lineVertexArray: null, pitchWithMap: r, transform: s, projectionCache: null, tileAnchorPoint: o, translation: h, unwrappedTileID: u }, m = r ? ze(o.x, o.y, _) : Re(o.x, o.y, _), x = we(s.cameraToCenterDistance, m.signedDistanceFromCamera); let b = t.aj(e.textSizeData, l, g) * x / t.as; r && (b *= e.tilePixelRatio / n); const { width: y, height: w, anchor: T, textOffset: P, textBoxScale: C } = v, I = qr(T, y, w, P, C, b), E = s.getPitchedTextCorrection(o.x + h[0], o.y + h[1], u), M = Hr(m.point, _, i, I, -s.bearingInRadians, E), S = e.allowVerticalPlacement && g.placedOrientation === t.ai.vertical ? Math.PI / 2 : 0; for (let e = 0; e < g.numGlyphs; e++)t.ak(p, M, S); c && g.associatedIconIndex >= 0 && (f[g.associatedIconIndex] = { shiftedAnchor: M, angle: S }); } else Be(g.numGlyphs, p); } if (c) { m.clear(); const i = e.icon.placedSymbolArray; for (let e = 0; e < i.length; e++) { const r = i.get(e); if (r.hidden) Be(r.numGlyphs, m); else { const i = f[e]; if (i) for (let e = 0; e < r.numGlyphs; e++)t.ak(m, i.shiftedAnchor, i.angle); else Be(r.numGlyphs, m); } } e.icon.dynamicLayoutVertexBuffer.updateData(m); } e.text.dynamicLayoutVertexBuffer.updateData(p); } function Xr(e, t, i) { return i.iconsInText && t ? "symbolTextAndIcon" : e ? "symbolSDF" : "symbolIcon" } function $r(e, i, r, o, s, a, n, l, c, h, u, d, _) { const p = e.context, m = p.gl, f = e.transform, g = "map" === l, v = "map" === c, x = "viewport" !== l && "point" !== r.layout.get("symbol-placement"), b = g && !v && !x, y = !r.layout.get("symbol-sort-key").isConstant(); let w = !1; const T = e.getDepthModeForSublayer(0, Ot.ReadOnly), P = r._unevaluatedLayout.hasValue("text-variable-anchor") || r._unevaluatedLayout.hasValue("text-variable-anchor-offset"), C = [], I = f.getCircleRadiusCorrection(); for (const l of o) { const o = i.getTile(l), c = o.getBucket(r); if (!c) continue; const u = s ? c.text : c.icon; if (!u || !u.segments.get().length || !u.hasVisibleVertices) continue; const d = u.programConfigurations.get(r.id), p = s || c.sdfIcons, T = s ? c.textSizeData : c.iconSizeData, E = v || 0 !== f.pitch, M = e.useProgram(Xr(p, s, c), d), S = t.ah(T, f.zoom), R = e.style.map.terrain && e.style.map.terrain.getTerrainData(l); let D, z, A, L, k = [0, 0], F = null; if (s) z = o.glyphAtlasTexture, A = m.LINEAR, D = o.glyphAtlasTexture.size, c.iconsInText && (k = o.imageAtlasTexture.size, F = o.imageAtlasTexture, L = E || e.options.rotating || e.options.zooming || "composite" === T.kind || "camera" === T.kind ? m.LINEAR : m.NEAREST); else { const t = 1 !== r.layout.get("icon-size").constantOr(0) || c.iconsNeedLinear; z = o.imageAtlasTexture, A = p || e.options.rotating || e.options.zooming || t || E ? m.LINEAR : m.NEAREST, D = o.imageAtlasTexture.size; } const B = t.at(o, 1, e.transform.zoom), j = ve(g, e.transform, B), O = t.H(); t.an(O, j); const N = xe(v, g, e.transform, B), Z = t.au(f, o, a, n), G = f.getProjectionData({ overscaledTileID: l, applyGlobeMatrix: !_, applyTerrainMatrix: !0 }), U = P && c.hasTextData(), V = "none" !== r.layout.get("icon-text-fit") && U && c.hasIconData(); if (x) { const t = e.style.map.terrain ? (t, i) => e.style.map.terrain.getElevation(l, t, i) : null, i = "map" === r.layout.get("text-rotation-alignment"); Pe(c, e, s, j, O, v, h, i, l.toUnwrapped(), f.width, f.height, Z, t); } const q = s && P || V, H = x || q ? Vr : v ? j : e.transform.clipSpaceToPixelsMatrix, W = p && 0 !== r.paint.get(s ? "text-halo-width" : "icon-halo-width").constantOr(1); let X; X = p ? c.iconsInText ? $i(T.kind, S, b, v, x, q, e, H, N, Z, D, k, I) : Xi(T.kind, S, b, v, x, q, e, H, N, Z, s, D, 0, I) : Wi(T.kind, S, b, v, x, q, e, H, N, Z, s, D, I); const $ = { program: M, buffers: u, uniformValues: X, projectionData: G, atlasTexture: z, atlasTextureIcon: F, atlasInterpolation: A, atlasInterpolationIcon: L, isSDF: p, hasHalo: W }; if (y && c.canOverlap) { w = !0; const e = u.segments.get(); for (const i of e) C.push({ segments: new t.aD([i]), sortKey: i.sortKey, state: $, terrainData: R }); } else C.push({ segments: u.segments, sortKey: 0, state: $, terrainData: R }); } w && C.sort(((e, t) => e.sortKey - t.sortKey)); for (const t of C) { const i = t.state; if (p.activeTexture.set(m.TEXTURE0), i.atlasTexture.bind(i.atlasInterpolation, m.CLAMP_TO_EDGE), i.atlasTextureIcon && (p.activeTexture.set(m.TEXTURE1), i.atlasTextureIcon && i.atlasTextureIcon.bind(i.atlasInterpolationIcon, m.CLAMP_TO_EDGE)), i.isSDF) { const o = i.uniformValues; i.hasHalo && (o.u_is_halo = 1, Kr(i.buffers, t.segments, r, e, i.program, T, u, d, o, i.projectionData, t.terrainData)), o.u_is_halo = 0; } Kr(i.buffers, t.segments, r, e, i.program, T, u, d, i.uniformValues, i.projectionData, t.terrainData); } } function Kr(e, t, i, r, o, s, a, n, l, c, h) { const u = r.context; o.draw(u, u.gl.TRIANGLES, s, a, n, jt.backCCW, l, h, c, i.id, e.layoutVertexBuffer, e.indexBuffer, t, i.paint, r.transform.zoom, e.programConfigurations.get(i.id), e.dynamicLayoutVertexBuffer, e.opacityVertexBuffer); } function Yr(e, i, r, o, s) { const a = e.context, n = a.gl, l = Zt.disabled, c = new Ft([n.ONE, n.ONE], t.b4.transparent, [!0, !0, !0, !0]), h = i.getBucket(r); if (!h) return; const u = o.key; let d = r.heatmapFbos.get(u); d || (d = Qr(a, i.tileSize, i.tileSize), r.heatmapFbos.set(u, d)), a.bindFramebuffer.set(d.framebuffer), a.viewport.set([0, 0, i.tileSize, i.tileSize]), a.clear({ color: t.b4.transparent }); const _ = h.programConfigurations.get(r.id), p = e.useProgram("heatmap", _, !s), m = e.transform.getProjectionData({ overscaledTileID: i.tileID, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), f = e.style.map.terrain.getTerrainData(o); p.draw(a, n.TRIANGLES, Ot.disabled, l, c, jt.disabled, Li(i, e.transform.zoom, r.paint.get("heatmap-intensity"), 1), f, m, r.id, h.layoutVertexBuffer, h.indexBuffer, h.segments, r.paint, e.transform.zoom, _); } function Jr(e, t, i, r, o) { const s = e.context, a = s.gl, n = e.transform; s.setColorMode(e.colorModeForRenderPass()); const l = eo(s, t), c = i.key, h = t.heatmapFbos.get(c); if (!h) return; s.activeTexture.set(a.TEXTURE0), a.bindTexture(a.TEXTURE_2D, h.colorAttachment.get()), s.activeTexture.set(a.TEXTURE1), l.bind(a.LINEAR, a.CLAMP_TO_EDGE); const u = n.getProjectionData({ overscaledTileID: i, applyTerrainMatrix: o, applyGlobeMatrix: !r }); e.useProgram("heatmapTexture").draw(s, a.TRIANGLES, Ot.disabled, Zt.disabled, e.colorModeForRenderPass(), jt.disabled, ki(e, t, 0, 1), null, u, t.id, e.rasterBoundsBuffer, e.quadTriangleIndexBuffer, e.rasterBoundsSegments, t.paint, n.zoom), h.destroy(), t.heatmapFbos.delete(c); } function Qr(e, t, i) { var r, o; const s = e.gl, a = s.createTexture(); s.bindTexture(s.TEXTURE_2D, a), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, s.LINEAR), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MAG_FILTER, s.LINEAR); const n = null !== (r = e.HALF_FLOAT) && void 0 !== r ? r : s.UNSIGNED_BYTE, l = null !== (o = e.RGBA16F) && void 0 !== o ? o : s.RGBA; s.texImage2D(s.TEXTURE_2D, 0, l, t, i, 0, s.RGBA, n, null); const c = e.createFramebuffer(t, i, !1, !1); return c.colorAttachment.set(a), c } function eo(e, t) { return t.colorRampTexture || (t.colorRampTexture = new v(e, t.colorRamp, e.gl.RGBA)), t.colorRampTexture } function to(e, t, i, r, o) { if (!i || !r || !r.imageAtlas) return; const s = r.imageAtlas.patternPositions; let a = s[i.to.toString()], n = s[i.from.toString()]; if (!a && n && (a = n), !n && a && (n = a), !a || !n) { const e = o.getPaintProperty(t); a = s[e], n = s[e]; } a && n && e.setConstantPatternPositions(a, n); } function io(e, i, r, o, s, a, n, l) { const c = e.context.gl, h = "fill-pattern", u = r.paint.get(h), d = u && u.constantOr(1), _ = r.getCrossfadeParameters(); let p, m, f, g, v; const x = e.transform, b = r.paint.get("fill-translate"), y = r.paint.get("fill-translate-anchor"); n ? (m = d && !r.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", p = c.LINES) : (m = d ? "fillPattern" : "fill", p = c.TRIANGLES); const w = u.constantOr(null); for (const u of o) { const T = i.getTile(u); if (d && !T.patternsLoaded()) continue; const P = T.getBucket(r); if (!P) continue; const C = P.programConfigurations.get(r.id), I = e.useProgram(m, C), E = e.style.map.terrain && e.style.map.terrain.getTerrainData(u); d && (e.context.activeTexture.set(c.TEXTURE0), T.imageAtlasTexture.bind(c.LINEAR, c.CLAMP_TO_EDGE), C.updatePaintBuffers(_)), to(C, h, w, T, r); const M = x.getProjectionData({ overscaledTileID: u, applyGlobeMatrix: !l, applyTerrainMatrix: !0 }), S = t.au(x, T, b, y); if (n) { g = P.indexBuffer2, v = P.segments2; const t = [c.drawingBufferWidth, c.drawingBufferHeight]; f = "fillOutlinePattern" === m && d ? Si(e, _, T, t, S) : Mi(t, S); } else g = P.indexBuffer, v = P.segments, f = d ? Ei(e, _, T, S) : { u_fill_translate: S }; let R; if ("translucent" === e.renderPass && l) { const [t] = e.getStencilConfigForOverlapAndUpdateStencilID(o); R = t[u.overscaledZ]; } else R = e.stencilModeForClipping(u); I.draw(e.context, p, s, R, a, jt.backCCW, f, E, M, r.id, P.layoutVertexBuffer, g, v, r.paint, e.transform.zoom, C); } } function ro(e, i, r, o, s, a, n, l) { const c = e.context, h = c.gl, u = "fill-extrusion-pattern", d = r.paint.get(u), _ = d.constantOr(1), p = r.getCrossfadeParameters(), m = r.paint.get("fill-extrusion-opacity"), f = d.constantOr(null), g = e.transform; for (const d of o) { const o = i.getTile(d), v = o.getBucket(r); if (!v) continue; const x = e.style.map.terrain && e.style.map.terrain.getTerrainData(d), b = v.programConfigurations.get(r.id), y = e.useProgram(_ ? "fillExtrusionPattern" : "fillExtrusion", b); _ && (e.context.activeTexture.set(h.TEXTURE0), o.imageAtlasTexture.bind(h.LINEAR, h.CLAMP_TO_EDGE), b.updatePaintBuffers(p)); const w = g.getProjectionData({ overscaledTileID: d, applyGlobeMatrix: !l, applyTerrainMatrix: !0 }); to(b, u, f, o, r); const T = t.au(g, o, r.paint.get("fill-extrusion-translate"), r.paint.get("fill-extrusion-translate-anchor")), P = r.paint.get("fill-extrusion-vertical-gradient"), C = _ ? Ii(e, P, m, T, d, p, o) : Ci(e, P, m, T); y.draw(c, c.gl.TRIANGLES, s, a, n, jt.backCCW, C, x, w, r.id, v.layoutVertexBuffer, v.indexBuffer, v.segments, r.paint, e.transform.zoom, b, e.style.map.terrain && v.centroidVertexBuffer); } } function oo(e, t, i, r, o, s, a, n, l) { var c; const h = e.style.projection, u = e.context, d = e.transform, _ = u.gl, p = e.useProgram("hillshade"), m = !e.options.moving; for (const f of r) { const r = t.getTile(f), g = r.fbo; if (!g) continue; const v = h.getMeshFromTileID(u, f.canonical, n, !0, "raster"), x = null === (c = e.style.map.terrain) || void 0 === c ? void 0 : c.getTerrainData(f); u.activeTexture.set(_.TEXTURE0), _.bindTexture(_.TEXTURE_2D, g.colorAttachment.get()); const b = d.getProjectionData({ overscaledTileID: f, aligned: m, applyGlobeMatrix: !l, applyTerrainMatrix: !0 }); p.draw(u, _.TRIANGLES, s, o[f.overscaledZ], a, jt.backCCW, Fi(e, r, i), x, b, i.id, v.vertexBuffer, v.indexBuffer, v.segments); } } const so = [new t.P(0, 0), new t.P(t.X, 0), new t.P(t.X, t.X), new t.P(0, t.X)]; function ao(e, t, i, r, o, s, a, n, l = !1, c = !1) { const h = r[r.length - 1].overscaledZ, u = e.context, d = u.gl, _ = e.useProgram("raster"), p = e.transform, m = e.style.projection, f = e.colorModeForRenderPass(), g = !e.options.moving; for (const v of r) { const r = e.getDepthModeForSublayer(v.overscaledZ - h, 1 === i.paint.get("raster-opacity") ? Ot.ReadWrite : Ot.ReadOnly, d.LESS), x = t.getTile(v); x.registerFadeDuration(i.paint.get("raster-fade-duration")); const b = t.findLoadedParent(v, 0), y = t.findLoadedSibling(v), w = no(x, b || y || null, t, i, e.transform, e.style.map.terrain); let T, P; const C = "nearest" === i.paint.get("raster-resampling") ? d.NEAREST : d.LINEAR; u.activeTexture.set(d.TEXTURE0), x.texture.bind(C, d.CLAMP_TO_EDGE, d.LINEAR_MIPMAP_NEAREST), u.activeTexture.set(d.TEXTURE1), b ? (b.texture.bind(C, d.CLAMP_TO_EDGE, d.LINEAR_MIPMAP_NEAREST), T = Math.pow(2, b.tileID.overscaledZ - x.tileID.overscaledZ), P = [x.tileID.canonical.x * T % 1, x.tileID.canonical.y * T % 1]) : x.texture.bind(C, d.CLAMP_TO_EDGE, d.LINEAR_MIPMAP_NEAREST), x.texture.useMipmap && u.extTextureFilterAnisotropic && e.transform.pitch > 20 && d.texParameterf(d.TEXTURE_2D, u.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, u.extTextureFilterAnisotropicMax); const I = e.style.map.terrain && e.style.map.terrain.getTerrainData(v), E = p.getProjectionData({ overscaledTileID: v, aligned: g, applyGlobeMatrix: !c, applyTerrainMatrix: !0 }), M = qi(P || [0, 0], T || 1, w, i, n), S = m.getMeshFromTileID(u, v.canonical, s, a, "raster"); _.draw(u, d.TRIANGLES, r, o ? o[v.overscaledZ] : Zt.disabled, f, l ? jt.frontCCW : jt.backCCW, M, I, E, i.id, S.vertexBuffer, S.indexBuffer, S.segments); } } function no(e, i, r, o, s, n) { const l = o.paint.get("raster-fade-duration"); if (!n && l > 0) { const o = a.now(), n = (o - e.timeAdded) / l, c = i ? (o - i.timeAdded) / l : -1, h = r.getSource(), u = he(s, { tileSize: h.tileSize, roundZoom: h.roundZoom }), d = !i || Math.abs(i.tileID.overscaledZ - u) > Math.abs(e.tileID.overscaledZ - u), _ = d && e.refreshedUponExpiration ? 1 : t.ab(d ? n : 1 - c, 0, 1); return e.refreshedUponExpiration && n >= 1 && (e.refreshedUponExpiration = !1), i ? { opacity: 1, mix: 1 - _ } : { opacity: _, mix: 0 } } return { opacity: 1, mix: 0 } } const lo = new t.b4(1, 0, 0, 1), co = new t.b4(0, 1, 0, 1), ho = new t.b4(0, 0, 1, 1), uo = new t.b4(1, 0, 1, 1), _o = new t.b4(0, 1, 1, 1); function po(e, t, i, r) { fo(e, 0, t + i / 2, e.transform.width, i, r); } function mo(e, t, i, r) { fo(e, t - i / 2, 0, i, e.transform.height, r); } function fo(e, t, i, r, o, s) { const a = e.context, n = a.gl; n.enable(n.SCISSOR_TEST), n.scissor(t * e.pixelRatio, i * e.pixelRatio, r * e.pixelRatio, o * e.pixelRatio), a.clear({ color: s }), n.disable(n.SCISSOR_TEST); } function go(e, i, r) { const o = e.context, s = o.gl, a = e.useProgram("debug"), n = Ot.disabled, l = Zt.disabled, c = e.colorModeForRenderPass(), h = "$debug", u = e.style.map.terrain && e.style.map.terrain.getTerrainData(r); o.activeTexture.set(s.TEXTURE0); const d = i.getTileByID(r.key).latestRawTileData, _ = Math.floor((d && d.byteLength || 0) / 1024), p = i.getTile(r).tileSize, m = 512 / Math.min(p, 512) * (r.overscaledZ / e.transform.zoom) * .5; let f = r.canonical.toString(); r.overscaledZ !== r.canonical.z && (f += ` => ${r.overscaledZ}`), function (e, t) { e.initDebugOverlayCanvas(); const i = e.debugOverlayCanvas, r = e.context.gl, o = e.debugOverlayCanvas.getContext("2d"); o.clearRect(0, 0, i.width, i.height), o.shadowColor = "white", o.shadowBlur = 2, o.lineWidth = 1.5, o.strokeStyle = "white", o.textBaseline = "top", o.font = "bold 36px Open Sans, sans-serif", o.fillText(t, 5, 5), o.strokeText(t, 5, 5), e.debugOverlayTexture.update(i), e.debugOverlayTexture.bind(r.LINEAR, r.CLAMP_TO_EDGE); }(e, `${f} ${_}kB`); const g = e.transform.getProjectionData({ overscaledTileID: r, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }); a.draw(o, s.TRIANGLES, n, l, Ft.alphaBlended, jt.disabled, Ai(t.b4.transparent, m), null, g, h, e.debugBuffer, e.quadTriangleIndexBuffer, e.debugSegments), a.draw(o, s.LINE_STRIP, n, l, c, jt.disabled, Ai(t.b4.red), u, g, h, e.debugBuffer, e.tileBorderIndexBuffer, e.debugSegments); } function vo(e, t, i, r) { const { isRenderingGlobe: o } = r, s = e.context, a = s.gl, n = e.transform, l = e.colorModeForRenderPass(), c = e.getDepthModeFor3D(), h = e.useProgram("terrain"); s.bindFramebuffer.set(null), s.viewport.set([0, 0, e.width, e.height]); for (const r of i) { const i = t.getTerrainMesh(r.tileID), u = e.renderToTexture.getTexture(r), d = t.getTerrainData(r.tileID); s.activeTexture.set(a.TEXTURE0), a.bindTexture(a.TEXTURE_2D, u.texture); const _ = t.getMeshFrameDelta(n.zoom), p = n.calculateFogMatrix(r.tileID.toUnwrapped()), m = bi(_, p, e.style.sky, n.pitch, o), f = n.getProjectionData({ overscaledTileID: r.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 }); h.draw(s, a.TRIANGLES, c, Zt.disabled, l, jt.backCCW, m, d, f, "terrain", i.vertexBuffer, i.indexBuffer, i.segments); } } function xo(e, i) { if (!i.mesh) { const r = new t.aC; r.emplaceBack(-1, -1), r.emplaceBack(1, -1), r.emplaceBack(1, 1), r.emplaceBack(-1, 1); const o = new t.aE; o.emplaceBack(0, 1, 2), o.emplaceBack(0, 2, 3), i.mesh = new pt(e.createVertexBuffer(r, mt.members), e.createIndexBuffer(o), t.aD.simpleSegment(0, 0, r.length, o.length)); } return i.mesh } class bo { constructor(e, i) { this.context = new Zr(e), this.transform = i, this._tileTextures = {}, this.terrainFacilitator = { dirty: !0, matrix: t.aq(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = de.maxUnderzooming + de.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new ht; } resize(e, t, i) { if (this.width = Math.floor(e * i), this.height = Math.floor(t * i), this.pixelRatio = i, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const e of this.style._order) this.style._layers[e].resize(); } setup() { const e = this.context, i = new t.aC; i.emplaceBack(0, 0), i.emplaceBack(t.X, 0), i.emplaceBack(0, t.X), i.emplaceBack(t.X, t.X), this.tileExtentBuffer = e.createVertexBuffer(i, mt.members), this.tileExtentSegments = t.aD.simpleSegment(0, 0, 4, 2); const r = new t.aC; r.emplaceBack(0, 0), r.emplaceBack(t.X, 0), r.emplaceBack(0, t.X), r.emplaceBack(t.X, t.X), this.debugBuffer = e.createVertexBuffer(r, mt.members), this.debugSegments = t.aD.simpleSegment(0, 0, 4, 5); const o = new t.bT; o.emplaceBack(0, 0, 0, 0), o.emplaceBack(t.X, 0, t.X, 0), o.emplaceBack(0, t.X, 0, t.X), o.emplaceBack(t.X, t.X, t.X, t.X), this.rasterBoundsBuffer = e.createVertexBuffer(o, vi.members), this.rasterBoundsSegments = t.aD.simpleSegment(0, 0, 4, 2); const s = new t.aC; s.emplaceBack(0, 0), s.emplaceBack(t.X, 0), s.emplaceBack(0, t.X), s.emplaceBack(t.X, t.X), this.rasterBoundsBufferPosOnly = e.createVertexBuffer(s, mt.members), this.rasterBoundsSegmentsPosOnly = t.aD.simpleSegment(0, 0, 4, 5); const a = new t.aC; a.emplaceBack(0, 0), a.emplaceBack(1, 0), a.emplaceBack(0, 1), a.emplaceBack(1, 1), this.viewportBuffer = e.createVertexBuffer(a, mt.members), this.viewportSegments = t.aD.simpleSegment(0, 0, 4, 2); const n = new t.bU; n.emplaceBack(0), n.emplaceBack(1), n.emplaceBack(3), n.emplaceBack(2), n.emplaceBack(0), this.tileBorderIndexBuffer = e.createIndexBuffer(n); const l = new t.aE; l.emplaceBack(1, 0, 2), l.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = e.createIndexBuffer(l); const c = this.context.gl; this.stencilClearMode = new Zt({ func: c.ALWAYS, mask: 0 }, 0, 255, c.ZERO, c.ZERO, c.ZERO), this.tileExtentMesh = new pt(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments); } clearStencil() { const e = this.context, i = e.gl; this.nextStencilID = 1, this.currentStencilSource = void 0; const r = t.H(); t.bL(r, 0, this.width, this.height, 0, 0, 1), t.K(r, r, [i.drawingBufferWidth, i.drawingBufferHeight, 0]); const o = { mainMatrix: r, tileMercatorCoords: [0, 0, 1, 1], clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: r }; this.useProgram("clippingMask", null, !0).draw(e, i.TRIANGLES, Ot.disabled, this.stencilClearMode, Ft.disabled, jt.disabled, null, null, o, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments); } _renderTileClippingMasks(e, t, i) { if (this.currentStencilSource === e.source || !e.isTileClipped() || !t || !t.length) return; this.currentStencilSource = e.source, this.nextStencilID + t.length > 256 && this.clearStencil(); const r = this.context; r.setColorMode(Ft.disabled), r.setDepthMode(Ot.disabled); const o = {}; for (const e of t) o[e.key] = this.nextStencilID++; this._renderTileMasks(o, t, i, !0), this._renderTileMasks(o, t, i, !1), this._tileClippingMaskIDs = o; } _renderTileMasks(e, t, i, r) { const o = this.context, s = o.gl, a = this.style.projection, n = this.transform, l = this.useProgram("clippingMask"); for (const c of t) { const t = e[c.key], h = this.style.map.terrain && this.style.map.terrain.getTerrainData(c), u = a.getMeshFromTileID(this.context, c.canonical, r, !0, "stencil"), d = n.getProjectionData({ overscaledTileID: c, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }); l.draw(o, s.TRIANGLES, Ot.disabled, new Zt({ func: s.ALWAYS, mask: 0 }, t, 255, s.KEEP, s.KEEP, s.REPLACE), Ft.disabled, i ? jt.disabled : jt.backCCW, null, h, d, "$clipping", u.vertexBuffer, u.indexBuffer, u.segments); } } _renderTilesDepthBuffer() { const e = this.context, t = e.gl, i = this.style.projection, r = this.transform, o = this.useProgram("depth"), s = this.getDepthModeFor3D(), a = ue(r, { tileSize: r.tileSize }); for (const n of a) { const a = this.style.map.terrain && this.style.map.terrain.getTerrainData(n), l = i.getMeshFromTileID(this.context, n.canonical, !0, !0, "raster"), c = r.getProjectionData({ overscaledTileID: n, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }); o.draw(e, t.TRIANGLES, s, Zt.disabled, Ft.disabled, jt.backCCW, null, a, c, "$clipping", l.vertexBuffer, l.indexBuffer, l.segments); } } stencilModeFor3D() { this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil(); const e = this.nextStencilID++, t = this.context.gl; return new Zt({ func: t.NOTEQUAL, mask: 255 }, e, 255, t.KEEP, t.KEEP, t.REPLACE) } stencilModeForClipping(e) { const t = this.context.gl; return new Zt({ func: t.EQUAL, mask: 255 }, this._tileClippingMaskIDs[e.key], 0, t.KEEP, t.KEEP, t.REPLACE) } getStencilConfigForOverlapAndUpdateStencilID(e) { const t = this.context.gl, i = e.sort(((e, t) => t.overscaledZ - e.overscaledZ)), r = i[i.length - 1].overscaledZ, o = i[0].overscaledZ - r + 1; if (o > 1) { this.currentStencilSource = void 0, this.nextStencilID + o > 256 && this.clearStencil(); const e = {}; for (let i = 0; i < o; i++)e[i + r] = new Zt({ func: t.GEQUAL, mask: 255 }, i + this.nextStencilID, 255, t.KEEP, t.KEEP, t.REPLACE); return this.nextStencilID += o, [e, i] } return [{ [r]: Zt.disabled }, i] } stencilConfigForOverlapTwoPass(e) { const t = this.context.gl, i = e.sort(((e, t) => t.overscaledZ - e.overscaledZ)), r = i[i.length - 1].overscaledZ, o = i[0].overscaledZ - r + 1; if (this.clearStencil(), o > 1) { const e = {}, s = {}; for (let i = 0; i < o; i++)e[i + r] = new Zt({ func: t.GREATER, mask: 255 }, o + 1 + i, 255, t.KEEP, t.KEEP, t.REPLACE), s[i + r] = new Zt({ func: t.GREATER, mask: 255 }, 1 + i, 255, t.KEEP, t.KEEP, t.REPLACE); return this.nextStencilID = 2 * o + 1, [e, s, i] } return this.nextStencilID = 3, [{ [r]: new Zt({ func: t.GREATER, mask: 255 }, 2, 255, t.KEEP, t.KEEP, t.REPLACE) }, { [r]: new Zt({ func: t.GREATER, mask: 255 }, 1, 255, t.KEEP, t.KEEP, t.REPLACE) }, i] } colorModeForRenderPass() { const e = this.context.gl; if (this._showOverdrawInspector) { const i = 1 / 8; return new Ft([e.CONSTANT_COLOR, e.ONE], new t.b4(i, i, i, 0), [!0, !0, !0, !0]) } return "opaque" === this.renderPass ? Ft.unblended : Ft.alphaBlended } getDepthModeForSublayer(e, t, i) { if (!this.opaquePassEnabledForLayer()) return Ot.disabled; const r = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon; return new Ot(i || this.context.gl.LEQUAL, t, [r, r]) } getDepthModeFor3D() { return new Ot(this.context.gl.LEQUAL, Ot.ReadWrite, this.depthRangeFor3D) } opaquePassEnabledForLayer() { return this.currentLayer < this.opaquePassCutoff } render(e, i) { var r, o; this.style = e, this.options = i, this.lineAtlas = e.lineAtlas, this.imageManager = e.imageManager, this.glyphManager = e.glyphManager, this.symbolFadeChange = e.placement.symbolFadeChange(a.now()), this.imageManager.beginFrame(); const s = this.style._order, n = this.style.sourceCaches, l = {}, c = {}, h = {}, u = { isRenderingToTexture: !1, isRenderingGlobe: (null === (r = e.projection) || void 0 === r ? void 0 : r.transitionState) > 0 }; for (const e in n) { const t = n[e]; t.used && t.prepare(this.context), l[e] = t.getVisibleCoordinates(!1), c[e] = l[e].slice().reverse(), h[e] = t.getVisibleCoordinates(!0).reverse(); } this.opaquePassCutoff = 1 / 0; for (let e = 0; e < s.length; e++)if (this.style._layers[s[e]].is3D()) { this.opaquePassCutoff = e; break } this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen"; for (const e of s) { const t = this.style._layers[e]; if (!t.hasOffscreenPass() || t.isHidden(this.transform.zoom)) continue; const i = c[t.source]; ("custom" === t.type || i.length) && this.renderLayer(this, n[t.source], t, i, u); } if (null === (o = this.style.projection) || void 0 === o || o.updateGPUdependent({ context: this.context, useProgram: e => this.useProgram(e) }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({ color: i.showOverdrawInspector ? t.b4.black : t.b4.transparent, depth: 1 }), this.clearStencil(), this.style.sky && function (e, t) { const i = e.context, r = i.gl, o = ((e, t, i) => { const r = Math.cos(t.rollInRadians), o = Math.sin(t.rollInRadians), s = yt(t), a = t.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }).projectionTransition; return { u_sky_color: e.properties.get("sky-color"), u_horizon_color: e.properties.get("horizon-color"), u_horizon: [(t.width / 2 - s * o) * i, (t.height / 2 + s * r) * i], u_horizon_normal: [-o, r], u_sky_horizon_blend: e.properties.get("sky-horizon-blend") * t.height / 2 * i, u_sky_blend: a } })(t, e.style.map.transform, e.pixelRatio), s = new Ot(r.LEQUAL, Ot.ReadWrite, [0, 1]), a = Zt.disabled, n = e.colorModeForRenderPass(), l = e.useProgram("sky"), c = xo(i, t); l.draw(i, r.TRIANGLES, s, a, n, jt.disabled, o, null, void 0, "sky", c.vertexBuffer, c.indexBuffer, c.segments); }(this, this.style.sky), this._showOverdrawInspector = i.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = s.length - 1; this.currentLayer >= 0; this.currentLayer--) { const e = this.style._layers[s[this.currentLayer]], t = n[e.source], i = l[e.source]; this._renderTileClippingMasks(e, i, !1), this.renderLayer(this, t, e, i, u); } this.renderPass = "translucent"; let d = !1; for (this.currentLayer = 0; this.currentLayer < s.length; this.currentLayer++) { const e = this.style._layers[s[this.currentLayer]], t = n[e.source]; if (this.renderToTexture && this.renderToTexture.renderLayer(e, u)) continue; this.opaquePassEnabledForLayer() || d || (d = !0, u.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer()); const i = ("symbol" === e.type ? h : c)[e.source]; this._renderTileClippingMasks(e, l[e.source], !1), this.renderLayer(this, t, e, i, u); } if (u.isRenderingGlobe && function (e, i, r) { const o = e.context, s = o.gl, a = e.useProgram("atmosphere"), n = new Ot(s.LEQUAL, Ot.ReadOnly, [0, 1]), l = e.transform, c = function (e, i) { const r = e.properties.get("position"), o = [-r.x, -r.y, -r.z], s = t.aq(new Float64Array(16)); return "map" === e.properties.get("anchor") && (t.aX(s, s, i.rollInRadians), t.aY(s, s, -i.pitchInRadians), t.aX(s, s, i.bearingInRadians), t.aY(s, s, i.center.lat * Math.PI / 180), t.bj(s, s, -i.center.lng * Math.PI / 180)), t.bS(o, o, s), o }(r, e.transform), h = l.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), u = i.properties.get("atmosphere-blend") * h.projectionTransition; if (0 === u) return; const d = ei(l.worldSize, l.center.lat), _ = l.inverseProjectionMatrix, p = new Float64Array(4); p[3] = 1, t.al(p, p, l.modelViewProjectionMatrix), p[0] /= p[3], p[1] /= p[3], p[2] /= p[3], p[3] = 1, t.al(p, p, _), p[0] /= p[3], p[1] /= p[3], p[2] /= p[3], p[3] = 1; const m = ((e, t, i, r, o) => ({ u_sun_pos: e, u_atmosphere_blend: t, u_globe_position: i, u_globe_radius: r, u_inv_proj_matrix: o }))(c, u, [p[0], p[1], p[2]], d, _), f = xo(o, i); a.draw(o, s.TRIANGLES, n, Zt.disabled, Ft.alphaBlended, jt.disabled, m, null, null, "atmosphere", f.vertexBuffer, f.indexBuffer, f.segments); }(this, this.style.sky, this.style.light), this.options.showTileBoundaries) { const e = function (e, t) { let i = null; const r = Object.values(e._layers).flatMap((i => i.source && !i.isHidden(t) ? [e.sourceCaches[i.source]] : [])), o = r.filter((e => "vector" === e.getSource().type)), s = r.filter((e => "vector" !== e.getSource().type)), a = e => { (!i || i.getSource().maxzoom < e.getSource().maxzoom) && (i = e); }; return o.forEach((e => a(e))), i || s.forEach((e => a(e))), i }(this.style, this.transform.zoom); e && function (e, t, i) { for (let r = 0; r < i.length; r++)go(e, t, i[r]); }(this, e, e.getVisibleCoordinates()); } this.options.showPadding && function (e) { const t = e.transform.padding; po(e, e.transform.height - (t.top || 0), 3, lo), po(e, t.bottom || 0, 3, co), mo(e, t.left || 0, 3, ho), mo(e, e.transform.width - (t.right || 0), 3, uo); const i = e.transform.centerPoint; !function (e, t, i, r) { fo(e, t - 1, i - 10, 2, 20, r), fo(e, t - 10, i - 1, 20, 2, r); }(e, i.x, e.transform.height - i.y, _o); }(this), this.context.setDefault(); } maybeDrawDepthAndCoords(e) { if (!this.style || !this.style.map || !this.style.map.terrain) return; const i = this.terrainFacilitator.matrix, r = this.transform.modelViewProjectionMatrix; let o = this.terrainFacilitator.dirty; o || (o = e ? !t.bV(i, r) : !t.bW(i, r)), o || (o = this.style.map.terrain.sourceCache.anyTilesAfterTime(this.terrainFacilitator.renderTime)), o && (t.bX(i, r), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, function (e, i) { const r = e.context, o = r.gl, s = e.transform, a = Ft.unblended, n = new Ot(o.LEQUAL, Ot.ReadWrite, [0, 1]), l = i.sourceCache.getRenderableTiles(), c = e.useProgram("terrainDepth"); r.bindFramebuffer.set(i.getFramebuffer("depth").framebuffer), r.viewport.set([0, 0, e.width / devicePixelRatio, e.height / devicePixelRatio]), r.clear({ color: t.b4.transparent, depth: 1 }); for (const e of l) { const t = i.getTerrainMesh(e.tileID), l = i.getTerrainData(e.tileID), h = s.getProjectionData({ overscaledTileID: e.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 }), u = { u_ele_delta: i.getMeshFrameDelta(s.zoom) }; c.draw(r, o.TRIANGLES, n, Zt.disabled, a, jt.backCCW, u, l, h, "terrain", t.vertexBuffer, t.indexBuffer, t.segments); } r.bindFramebuffer.set(null), r.viewport.set([0, 0, e.width, e.height]); }(this, this.style.map.terrain), function (e, i) { const r = e.context, o = r.gl, s = e.transform, a = Ft.unblended, n = new Ot(o.LEQUAL, Ot.ReadWrite, [0, 1]), l = i.getCoordsTexture(), c = i.sourceCache.getRenderableTiles(), h = e.useProgram("terrainCoords"); r.bindFramebuffer.set(i.getFramebuffer("coords").framebuffer), r.viewport.set([0, 0, e.width / devicePixelRatio, e.height / devicePixelRatio]), r.clear({ color: t.b4.transparent, depth: 1 }), i.coordsIndex = []; for (const e of c) { const t = i.getTerrainMesh(e.tileID), c = i.getTerrainData(e.tileID); r.activeTexture.set(o.TEXTURE0), o.bindTexture(o.TEXTURE_2D, l.texture); const u = { u_terrain_coords_id: (255 - i.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: i.getMeshFrameDelta(s.zoom) }, d = s.getProjectionData({ overscaledTileID: e.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 }); h.draw(r, o.TRIANGLES, n, Zt.disabled, a, jt.backCCW, u, c, d, "terrain", t.vertexBuffer, t.indexBuffer, t.segments), i.coordsIndex.push(e.tileID.key); } r.bindFramebuffer.set(null), r.viewport.set([0, 0, e.width, e.height]); }(this, this.style.map.terrain)); } renderLayer(e, i, r, o, s) { r.isHidden(this.transform.zoom) || ("background" === r.type || "custom" === r.type || (o || []).length) && (this.id = r.id, t.bY(r) ? function (e, i, r, o, s, a) { if ("translucent" !== e.renderPass) return; const { isRenderingToTexture: n } = a, l = Zt.disabled, c = e.colorModeForRenderPass(); (r._unevaluatedLayout.hasValue("text-variable-anchor") || r._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function (e, i, r, o, s, a, n, l, c) { const h = i.transform, u = i.style.map.terrain, d = "map" === s, _ = "map" === a; for (const s of e) { const e = o.getTile(s), a = e.getBucket(r); if (!a || !a.text || !a.text.segments.get().length) continue; const p = t.ah(a.textSizeData, h.zoom), m = t.at(e, 1, i.transform.zoom), f = ve(d, i.transform, m), g = "none" !== r.layout.get("icon-text-fit") && a.hasIconData(); { const i = Math.pow(2, h.zoom - e.tileID.overscaledZ), r = u ? (e, t) => u.getElevation(s, e, t) : null; Wr(a, d, _, c, h, f, i, p, g, t.au(h, e, n, l), s.toUnwrapped(), r); } } }(o, e, r, i, r.layout.get("text-rotation-alignment"), r.layout.get("text-pitch-alignment"), r.paint.get("text-translate"), r.paint.get("text-translate-anchor"), s), 0 !== r.paint.get("icon-opacity").constantOr(1) && $r(e, i, r, o, !1, r.paint.get("icon-translate"), r.paint.get("icon-translate-anchor"), r.layout.get("icon-rotation-alignment"), r.layout.get("icon-pitch-alignment"), r.layout.get("icon-keep-upright"), l, c, n), 0 !== r.paint.get("text-opacity").constantOr(1) && $r(e, i, r, o, !0, r.paint.get("text-translate"), r.paint.get("text-translate-anchor"), r.layout.get("text-rotation-alignment"), r.layout.get("text-pitch-alignment"), r.layout.get("text-keep-upright"), l, c, n), i.map.showCollisionBoxes && (Ur(e, i, r, o, !0), Ur(e, i, r, o, !1)); }(e, i, r, o, this.style.placement.variableOffsets, s) : t.bZ(r) ? function (e, i, r, o, s) { if ("translucent" !== e.renderPass) return; const { isRenderingToTexture: a } = s, n = r.paint.get("circle-opacity"), l = r.paint.get("circle-stroke-width"), c = r.paint.get("circle-stroke-opacity"), h = !r.layout.get("circle-sort-key").isConstant(); if (0 === n.constantOr(1) && (0 === l.constantOr(1) || 0 === c.constantOr(1))) return; const u = e.context, d = u.gl, _ = e.transform, p = e.getDepthModeForSublayer(0, Ot.ReadOnly), m = Zt.disabled, f = e.colorModeForRenderPass(), g = [], v = _.getCircleRadiusCorrection(); for (let s = 0; s < o.length; s++) { const n = o[s], l = i.getTile(n), c = l.getBucket(r); if (!c) continue; const u = r.paint.get("circle-translate"), d = r.paint.get("circle-translate-anchor"), p = t.au(_, l, u, d), m = c.programConfigurations.get(r.id), f = e.useProgram("circle", m), x = c.layoutVertexBuffer, b = c.indexBuffer, y = e.style.map.terrain && e.style.map.terrain.getTerrainData(n), w = { programConfiguration: m, program: f, layoutVertexBuffer: x, indexBuffer: b, uniformValues: Ri(e, l, r, p, v), terrainData: y, projectionData: _.getProjectionData({ overscaledTileID: n, applyGlobeMatrix: !a, applyTerrainMatrix: !0 }) }; if (h) { const e = c.segments.get(); for (const i of e) g.push({ segments: new t.aD([i]), sortKey: i.sortKey, state: w }); } else g.push({ segments: c.segments, sortKey: 0, state: w }); } h && g.sort(((e, t) => e.sortKey - t.sortKey)); for (const t of g) { const { programConfiguration: i, program: o, layoutVertexBuffer: s, indexBuffer: a, uniformValues: n, terrainData: l, projectionData: c } = t.state; o.draw(u, d.TRIANGLES, p, m, f, jt.backCCW, n, l, c, r.id, s, a, t.segments, r.paint, e.transform.zoom, i); } }(e, i, r, o, s) : t.b_(r) ? function (e, i, r, o, s) { if (0 === r.paint.get("heatmap-opacity")) return; const a = e.context, { isRenderingToTexture: n, isRenderingGlobe: l } = s; if (e.style.map.terrain) { for (const t of o) { const o = i.getTile(t); i.hasRenderableParent(t) || ("offscreen" === e.renderPass ? Yr(e, o, r, t, l) : "translucent" === e.renderPass && Jr(e, r, t, n, l)); } a.viewport.set([0, 0, e.width, e.height]); } else "offscreen" === e.renderPass ? function (e, i, r, o) { const s = e.context, a = s.gl, n = e.transform, l = Zt.disabled, c = new Ft([a.ONE, a.ONE], t.b4.transparent, [!0, !0, !0, !0]); ((function (e, i, r) { const o = e.gl; e.activeTexture.set(o.TEXTURE1), e.viewport.set([0, 0, i.width / 4, i.height / 4]); let s = r.heatmapFbos.get(t.bP); s ? (o.bindTexture(o.TEXTURE_2D, s.colorAttachment.get()), e.bindFramebuffer.set(s.framebuffer)) : (s = Qr(e, i.width / 4, i.height / 4), r.heatmapFbos.set(t.bP, s)); }))(s, e, r), s.clear({ color: t.b4.transparent }); for (let t = 0; t < o.length; t++) { const h = o[t]; if (i.hasRenderableParent(h)) continue; const u = i.getTile(h), d = u.getBucket(r); if (!d) continue; const _ = d.programConfigurations.get(r.id), p = e.useProgram("heatmap", _), m = n.getProjectionData({ overscaledTileID: h, applyGlobeMatrix: !0, applyTerrainMatrix: !1 }), f = n.getCircleRadiusCorrection(); p.draw(s, a.TRIANGLES, Ot.disabled, l, c, jt.backCCW, Li(u, n.zoom, r.paint.get("heatmap-intensity"), f), null, m, r.id, d.layoutVertexBuffer, d.indexBuffer, d.segments, r.paint, n.zoom, _); } s.viewport.set([0, 0, e.width, e.height]); }(e, i, r, o) : "translucent" === e.renderPass && function (e, i) { const r = e.context, o = r.gl; r.setColorMode(e.colorModeForRenderPass()); const s = i.heatmapFbos.get(t.bP); s && (r.activeTexture.set(o.TEXTURE0), o.bindTexture(o.TEXTURE_2D, s.colorAttachment.get()), r.activeTexture.set(o.TEXTURE1), eo(r, i).bind(o.LINEAR, o.CLAMP_TO_EDGE), e.useProgram("heatmapTexture").draw(r, o.TRIANGLES, Ot.disabled, Zt.disabled, e.colorModeForRenderPass(), jt.disabled, ki(e, i, 0, 1), null, null, i.id, e.viewportBuffer, e.quadTriangleIndexBuffer, e.viewportSegments, i.paint, e.transform.zoom)); }(e, r); }(e, i, r, o, s) : t.b$(r) ? function (e, i, r, o, s) { if ("translucent" !== e.renderPass) return; const { isRenderingToTexture: a } = s, n = r.paint.get("line-opacity"), l = r.paint.get("line-width"); if (0 === n.constantOr(1) || 0 === l.constantOr(1)) return; const c = e.getDepthModeForSublayer(0, Ot.ReadOnly), h = e.colorModeForRenderPass(), u = r.paint.get("line-dasharray"), d = r.paint.get("line-pattern"), _ = d.constantOr(1), p = r.paint.get("line-gradient"), m = r.getCrossfadeParameters(), f = _ ? "linePattern" : u ? "lineSDF" : p ? "lineGradient" : "line", g = e.context, x = g.gl, b = e.transform; let y = !0; for (const s of o) { const n = i.getTile(s); if (_ && !n.patternsLoaded()) continue; const l = n.getBucket(r); if (!l) continue; const w = l.programConfigurations.get(r.id), T = e.context.program.get(), P = e.useProgram(f, w), C = y || P.program !== T, I = e.style.map.terrain && e.style.map.terrain.getTerrainData(s), E = d.constantOr(null); if (E && n.imageAtlas) { const e = n.imageAtlas, t = e.patternPositions[E.to.toString()], i = e.patternPositions[E.from.toString()]; t && i && w.setConstantPatternPositions(t, i); } const M = b.getProjectionData({ overscaledTileID: s, applyGlobeMatrix: !a, applyTerrainMatrix: !0 }), S = b.getPixelScale(), R = _ ? Zi(e, n, r, S, m) : u ? Gi(e, n, r, S, u, m) : p ? Ni(e, n, r, S, l.lineClipsArray.length) : Oi(e, n, r, S); if (_) g.activeTexture.set(x.TEXTURE0), n.imageAtlasTexture.bind(x.LINEAR, x.CLAMP_TO_EDGE), w.updatePaintBuffers(m); else if (u && (C || e.lineAtlas.dirty)) g.activeTexture.set(x.TEXTURE0), e.lineAtlas.bind(g); else if (p) { const o = l.gradients[r.id]; let a = o.texture; if (r.gradientVersion !== o.version) { let n = 256; if (r.stepInterpolant) { const r = i.getSource().maxzoom, o = s.canonical.z === r ? Math.ceil(1 << e.transform.maxZoom - s.canonical.z) : 1; n = t.ab(t.bQ(l.maxLineLength / t.X * 1024 * o), 256, g.maxTextureSize); } o.gradient = t.bR({ expression: r.gradientExpression(), evaluationKey: "lineProgress", resolution: n, image: o.gradient || void 0, clips: l.lineClipsArray }), o.texture ? o.texture.update(o.gradient) : o.texture = new v(g, o.gradient, x.RGBA), o.version = r.gradientVersion, a = o.texture; } g.activeTexture.set(x.TEXTURE0), a.bind(r.stepInterpolant ? x.NEAREST : x.LINEAR, x.CLAMP_TO_EDGE); } let D; if (a) { const [t] = e.getStencilConfigForOverlapAndUpdateStencilID(o); D = t[s.overscaledZ]; } else D = e.stencilModeForClipping(s); P.draw(g, x.TRIANGLES, c, D, h, jt.disabled, R, I, M, r.id, l.layoutVertexBuffer, l.indexBuffer, l.segments, r.paint, e.transform.zoom, w, l.layoutVertexBuffer2), y = !1; } }(e, i, r, o, s) : t.c0(r) ? function (e, i, r, o, s) { const a = r.paint.get("fill-color"), n = r.paint.get("fill-opacity"); if (0 === n.constantOr(1)) return; const { isRenderingToTexture: l } = s, c = e.colorModeForRenderPass(), h = r.paint.get("fill-pattern"), u = e.opaquePassEnabledForLayer() && !h.constantOr(1) && 1 === a.constantOr(t.b4.transparent).a && 1 === n.constantOr(0) ? "opaque" : "translucent"; if (e.renderPass === u) { const t = e.getDepthModeForSublayer(1, "opaque" === e.renderPass ? Ot.ReadWrite : Ot.ReadOnly); io(e, i, r, o, t, c, !1, l); } if ("translucent" === e.renderPass && r.paint.get("fill-antialias")) { const t = e.getDepthModeForSublayer(r.getPaintProperty("fill-outline-color") ? 2 : 0, Ot.ReadOnly); io(e, i, r, o, t, c, !0, l); } }(e, i, r, o, s) : t.c1(r) ? function (e, t, i, r, o) { const s = i.paint.get("fill-extrusion-opacity"); if (0 === s) return; const { isRenderingToTexture: a } = o; if ("translucent" === e.renderPass) { const o = new Ot(e.context.gl.LEQUAL, Ot.ReadWrite, e.depthRangeFor3D); if (1 !== s || i.paint.get("fill-extrusion-pattern").constantOr(1)) ro(e, t, i, r, o, Zt.disabled, Ft.disabled, a), ro(e, t, i, r, o, e.stencilModeFor3D(), e.colorModeForRenderPass(), a); else { const s = e.colorModeForRenderPass(); ro(e, t, i, r, o, Zt.disabled, s, a); } } }(e, i, r, o, s) : t.c2(r) ? function (e, t, i, r, o) { if ("offscreen" !== e.renderPass && "translucent" !== e.renderPass) return; const { isRenderingToTexture: s } = o, a = e.context, n = e.style.projection.useSubdivision, l = e.getDepthModeForSublayer(0, Ot.ReadOnly), c = e.colorModeForRenderPass(); if ("offscreen" === e.renderPass) !function (e, t, i, r, o, s, a) { const n = e.context, l = n.gl; for (const c of i) { const i = t.getTile(c), h = i.dem; if (!h || !h.data) continue; if (!i.needsHillshadePrepare) continue; const u = h.dim, d = h.stride, _ = h.getPixels(); if (n.activeTexture.set(l.TEXTURE1), n.pixelStoreUnpackPremultiplyAlpha.set(!1), i.demTexture = i.demTexture || e.getTileTexture(d), i.demTexture) { const e = i.demTexture; e.update(_, { premultiply: !1 }), e.bind(l.NEAREST, l.CLAMP_TO_EDGE); } else i.demTexture = new v(n, _, l.RGBA, { premultiply: !1 }), i.demTexture.bind(l.NEAREST, l.CLAMP_TO_EDGE); n.activeTexture.set(l.TEXTURE0); let p = i.fbo; if (!p) { const e = new v(n, { width: u, height: u, data: null }, l.RGBA); e.bind(l.LINEAR, l.CLAMP_TO_EDGE), p = i.fbo = n.createFramebuffer(u, u, !0, !1), p.colorAttachment.set(e.texture); } n.bindFramebuffer.set(p.framebuffer), n.viewport.set([0, 0, u, u]), e.useProgram("hillshadePrepare").draw(n, l.TRIANGLES, o, s, a, jt.disabled, Bi(i.tileID, h), null, null, r.id, e.rasterBoundsBuffer, e.quadTriangleIndexBuffer, e.rasterBoundsSegments), i.needsHillshadePrepare = !1; } }(e, t, r, i, l, Zt.disabled, c), a.viewport.set([0, 0, e.width, e.height]); else if ("translucent" === e.renderPass) if (n) { const [o, a, n] = e.stencilConfigForOverlapTwoPass(r); oo(e, t, i, n, o, l, c, !1, s), oo(e, t, i, n, a, l, c, !0, s); } else { const [o, a] = e.getStencilConfigForOverlapAndUpdateStencilID(r); oo(e, t, i, a, o, l, c, !1, s); } }(e, i, r, o, s) : t.c3(r) ? function (e, t, i, r, o) { if ("translucent" !== e.renderPass) return; if (0 === i.paint.get("raster-opacity")) return; if (!r.length) return; const { isRenderingToTexture: s } = o, a = t.getSource(), n = e.style.projection.useSubdivision; if (a instanceof K) ao(e, t, i, r, null, !1, !1, a.tileCoords, a.flippedWindingOrder, s); else if (n) { const [o, a, n] = e.stencilConfigForOverlapTwoPass(r); ao(e, t, i, n, o, !1, !0, so, !1, s), ao(e, t, i, n, a, !0, !0, so, !1, s); } else { const [o, a] = e.getStencilConfigForOverlapAndUpdateStencilID(r); ao(e, t, i, a, o, !1, !0, so, !1, s); } }(e, i, r, o, s) : t.c4(r) ? function (e, t, i, r, o) { const s = i.paint.get("background-color"), a = i.paint.get("background-opacity"); if (0 === a) return; const { isRenderingToTexture: n } = o, l = e.context, c = l.gl, h = e.style.projection, u = e.transform, d = u.tileSize, _ = i.paint.get("background-pattern"); if (e.isPatternMissing(_)) return; const p = !_ && 1 === s.a && 1 === a && e.opaquePassEnabledForLayer() ? "opaque" : "translucent"; if (e.renderPass !== p) return; const m = Zt.disabled, f = e.getDepthModeForSublayer(0, "opaque" === p ? Ot.ReadWrite : Ot.ReadOnly), g = e.colorModeForRenderPass(), v = e.useProgram(_ ? "backgroundPattern" : "background"), x = r || ue(u, { tileSize: d, terrain: e.style.map.terrain }); _ && (l.activeTexture.set(c.TEXTURE0), e.imageManager.bind(e.context)); const b = i.getCrossfadeParameters(); for (const t of x) { const r = u.getProjectionData({ overscaledTileID: t, applyGlobeMatrix: !n, applyTerrainMatrix: !0 }), o = _ ? Yi(a, e, _, { tileID: t, tileSize: d }, b) : Ki(a, s), p = e.style.map.terrain && e.style.map.terrain.getTerrainData(t), x = h.getMeshFromTileID(l, t.canonical, !1, !0, "raster"); v.draw(l, c.TRIANGLES, f, m, g, jt.backCCW, o, p, r, i.id, x.vertexBuffer, x.indexBuffer, x.segments); } }(e, 0, r, o, s) : t.c5(r) && function (e, t, i, r) { const { isRenderingGlobe: o } = r, s = e.context, a = i.implementation, n = e.style.projection, l = e.transform, c = l.getProjectionDataForCustomLayer(o), h = { farZ: l.farZ, nearZ: l.nearZ, fov: l.fov * Math.PI / 180, modelViewProjectionMatrix: l.modelViewProjectionMatrix, projectionMatrix: l.projectionMatrix, shaderData: { variantName: n.shaderVariantName, vertexShaderPrelude: `const float PI = 3.141592653589793;\nuniform mat4 u_projection_matrix;\n${n.shaderPreludeCode.vertexSource}`, define: n.shaderDefine }, defaultProjectionData: c }, u = a.renderingMode ? a.renderingMode : "2d"; if ("offscreen" === e.renderPass) { const t = a.prerender; t && (e.setCustomLayerDefaults(), s.setColorMode(e.colorModeForRenderPass()), t.call(a, s.gl, h), s.setDirty(), e.setBaseState()); } else if ("translucent" === e.renderPass) { e.setCustomLayerDefaults(), s.setColorMode(e.colorModeForRenderPass()), s.setStencilMode(Zt.disabled); const t = "3d" === u ? e.getDepthModeFor3D() : e.getDepthModeForSublayer(0, Ot.ReadOnly); s.setDepthMode(t), a.render(s.gl, h), s.setDirty(), e.setBaseState(), s.bindFramebuffer.set(null); } }(e, 0, r, s)); } saveTileTexture(e) { const t = this._tileTextures[e.size[0]]; t ? t.push(e) : this._tileTextures[e.size[0]] = [e]; } getTileTexture(e) { const t = this._tileTextures[e]; return t && t.length > 0 ? t.pop() : null } isPatternMissing(e) { if (!e) return !1; if (!e.from || !e.to) return !0; const t = this.imageManager.getPattern(e.from.toString()), i = this.imageManager.getPattern(e.to.toString()); return !t || !i } useProgram(e, t, i = !1) { this.cache = this.cache || {}; const r = !!this.style.map.terrain, o = this.style.projection, s = e + (t ? t.cacheKey : "") + `/${i ? gt : o.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (r ? "/terrain" : ""); return this.cache[s] || (this.cache[s] = new Ti(this.context, dt[e], t, Qi[e], this._showOverdrawInspector, r, i ? dt.projectionMercator : o.shaderPreludeCode, i ? ft : o.shaderDefine)), this.cache[s] } setCustomLayerDefaults() { this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault(); } setBaseState() { const e = this.context.gl; this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD); } initDebugOverlayCanvas() { null == this.debugOverlayCanvas && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new v(this.context, this.debugOverlayCanvas, this.context.gl.RGBA)); } destroy() { this.debugOverlayTexture && this.debugOverlayTexture.destroy(); } overLimit() { const { drawingBufferWidth: e, drawingBufferHeight: t } = this.context.gl; return this.width !== e || this.height !== t } } function yo(e, t) { let i, r = !1, o = null, s = null; const a = () => { o = null, r && (e.apply(s, i), o = setTimeout(a, t), r = !1); }; return (...e) => (r = !0, s = this, i = e, o || a(), o) } class wo { constructor(e) { this._getCurrentHash = () => { const e = window.location.hash.replace("#", ""); if (this._hashName) { let t; return e.split("&").map((e => e.split("="))).forEach((e => { e[0] === this._hashName && (t = e); })), (t && t[1] || "").split("/") } return e.split("/") }, this._onHashChange = () => { const e = this._getCurrentHash(); if (!this._isValidHash(e)) return !1; const t = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(e[3] || 0) : this._map.getBearing(); return this._map.jumpTo({ center: [+e[2], +e[1]], zoom: +e[0], bearing: t, pitch: +(e[4] || 0) }), !0 }, this._updateHashUnthrottled = () => { const e = window.location.href.replace(/(#.*)?$/, this.getHashString()); window.history.replaceState(window.history.state, null, e); }, this._removeHash = () => { const e = this._getCurrentHash(); if (0 === e.length) return; const t = e.join("/"); let i = t; i.split("&").length > 0 && (i = i.split("&")[0]), this._hashName && (i = `${this._hashName}=${t}`); let r = window.location.hash.replace(i, ""); r.startsWith("#&") ? r = r.slice(0, 1) + r.slice(2) : "#" === r && (r = ""); let o = window.location.href.replace(/(#.+)?$/, r); o = o.replace("&&", "&"), window.history.replaceState(window.history.state, null, o); }, this._updateHash = yo(this._updateHashUnthrottled, 300), this._hashName = e && encodeURIComponent(e); } addTo(e) { return this._map = e, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this } remove() { return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this } getHashString(e) { const t = this._map.getCenter(), i = Math.round(100 * this._map.getZoom()) / 100, r = Math.ceil((i * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10), o = Math.pow(10, r), s = Math.round(t.lng * o) / o, a = Math.round(t.lat * o) / o, n = this._map.getBearing(), l = this._map.getPitch(); let c = ""; if (c += e ? `/${s}/${a}/${i}` : `${i}/${a}/${s}`, (n || l) && (c += "/" + Math.round(10 * n) / 10), l && (c += `/${Math.round(l)}`), this._hashName) { const e = this._hashName; let t = !1; const i = window.location.hash.slice(1).split("&").map((i => { const r = i.split("=")[0]; return r === e ? (t = !0, `${r}=${c}`) : i })).filter((e => e)); return t || i.push(`${e}=${c}`), `#${i.join("&")}` } return `#${c}` } _isValidHash(e) { if (e.length < 3 || e.some(isNaN)) return !1; try { new t.N(+e[2], +e[1]); } catch (e) { return !1 } const i = +e[0], r = +(e[3] || 0), o = +(e[4] || 0); return i >= this._map.getMinZoom() && i <= this._map.getMaxZoom() && r >= 0 && r <= 180 && o >= this._map.getMinPitch() && o <= this._map.getMaxPitch() } } const To = { linearity: .3, easing: t.c6(0, 0, .3, 1) }, Po = t.e({ deceleration: 2500, maxSpeed: 1400 }, To), Co = t.e({ deceleration: 20, maxSpeed: 1400 }, To), Io = t.e({ deceleration: 1e3, maxSpeed: 360 }, To), Eo = t.e({ deceleration: 1e3, maxSpeed: 90 }, To), Mo = t.e({ deceleration: 1e3, maxSpeed: 360 }, To); class So { constructor(e) { this._map = e, this.clear(); } clear() { this._inertiaBuffer = []; } record(e) { this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: a.now(), settings: e }); } _drainInertiaBuffer() { const e = this._inertiaBuffer, t = a.now(); for (; e.length > 0 && t - e[0].time > 160;)e.shift(); } _onMoveEnd(e) { if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return; const i = { zoom: 0, bearing: 0, pitch: 0, roll: 0, pan: new t.P(0, 0), pinchAround: void 0, around: void 0 }; for (const { settings: e } of this._inertiaBuffer) i.zoom += e.zoomDelta || 0, i.bearing += e.bearingDelta || 0, i.pitch += e.pitchDelta || 0, i.roll += e.rollDelta || 0, e.panDelta && i.pan._add(e.panDelta), e.around && (i.around = e.around), e.pinchAround && (i.pinchAround = e.pinchAround); const r = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, o = {}; if (i.pan.mag()) { const s = Do(i.pan.mag(), r, t.e({}, Po, e || {})), a = i.pan.mult(s.amount / i.pan.mag()), n = this._map.cameraHelper.handlePanInertia(a, this._map.transform); o.center = n.easingCenter, o.offset = n.easingOffset, Ro(o, s); } if (i.zoom) { const e = Do(i.zoom, r, Co); o.zoom = this._map.transform.zoom + e.amount, Ro(o, e); } if (i.bearing) { const e = Do(i.bearing, r, Io); o.bearing = this._map.transform.bearing + t.ab(e.amount, -179, 179), Ro(o, e); } if (i.pitch) { const e = Do(i.pitch, r, Eo); o.pitch = this._map.transform.pitch + e.amount, Ro(o, e); } if (i.roll) { const e = Do(i.roll, r, Mo); o.roll = this._map.transform.roll + t.ab(e.amount, -179, 179), Ro(o, e); } if (o.zoom || o.bearing) { const e = void 0 === i.pinchAround ? i.around : i.pinchAround; o.around = e ? this._map.unproject(e) : this._map.getCenter(); } return this.clear(), t.e(o, { noMoveStart: !0 }) } } function Ro(e, t) { (!e.duration || e.duration < t.duration) && (e.duration = t.duration, e.easing = t.easing); } function Do(e, i, r) { const { maxSpeed: o, linearity: s, deceleration: a } = r, n = t.ab(e * s / (i / 1e3), -o, o), l = Math.abs(n) / (a * s); return { easing: r.easing, duration: 1e3 * l, amount: n * (l / 2) } } class zo extends t.k { preventDefault() { this._defaultPrevented = !0; } get defaultPrevented() { return this._defaultPrevented } constructor(e, i, r, o = {}) { const s = n.mousePos(i.getCanvas(), r), a = i.unproject(s); super(e, t.e({ point: s, lngLat: a, originalEvent: r }, o)), this._defaultPrevented = !1, this.target = i; } } class Ao extends t.k { preventDefault() { this._defaultPrevented = !0; } get defaultPrevented() { return this._defaultPrevented } constructor(e, i, r) { const o = "touchend" === e ? r.changedTouches : r.touches, s = n.touchPos(i.getCanvasContainer(), o), a = s.map((e => i.unproject(e))), l = s.reduce(((e, t, i, r) => e.add(t.div(r.length))), new t.P(0, 0)); super(e, { points: s, point: l, lngLats: a, lngLat: i.unproject(l), originalEvent: r }), this._defaultPrevented = !1; } } class Lo extends t.k { preventDefault() { this._defaultPrevented = !0; } get defaultPrevented() { return this._defaultPrevented } constructor(e, t, i) { super(e, { originalEvent: i }), this._defaultPrevented = !1; } } class ko { constructor(e, t) { this._map = e, this._clickTolerance = t.clickTolerance; } reset() { delete this._mousedownPos; } wheel(e) { return this._firePreventable(new Lo(e.type, this._map, e)) } mousedown(e, t) { return this._mousedownPos = t, this._firePreventable(new zo(e.type, this._map, e)) } mouseup(e) { this._map.fire(new zo(e.type, this._map, e)); } click(e, t) { this._mousedownPos && this._mousedownPos.dist(t) >= this._clickTolerance || this._map.fire(new zo(e.type, this._map, e)); } dblclick(e) { return this._firePreventable(new zo(e.type, this._map, e)) } mouseover(e) { this._map.fire(new zo(e.type, this._map, e)); } mouseout(e) { this._map.fire(new zo(e.type, this._map, e)); } touchstart(e) { return this._firePreventable(new Ao(e.type, this._map, e)) } touchmove(e) { this._map.fire(new Ao(e.type, this._map, e)); } touchend(e) { this._map.fire(new Ao(e.type, this._map, e)); } touchcancel(e) { this._map.fire(new Ao(e.type, this._map, e)); } _firePreventable(e) { if (this._map.fire(e), e.defaultPrevented) return {} } isEnabled() { return !0 } isActive() { return !1 } enable() { } disable() { } } class Fo { constructor(e) { this._map = e; } reset() { this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent; } mousemove(e) { this._map.fire(new zo(e.type, this._map, e)); } mousedown() { this._delayContextMenu = !0, this._ignoreContextMenu = !1; } mouseup() { this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new zo("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent); } contextmenu(e) { this._delayContextMenu ? this._contextMenuEvent = e : this._ignoreContextMenu || this._map.fire(new zo(e.type, this._map, e)), this._map.listens("contextmenu") && e.preventDefault(); } isEnabled() { return !0 } isActive() { return !1 } enable() { } disable() { } } class Bo { constructor(e) { this._map = e; } get transform() { return this._map._requestedCameraState || this._map.transform } get center() { return { lng: this.transform.center.lng, lat: this.transform.center.lat } } get zoom() { return this.transform.zoom } get pitch() { return this.transform.pitch } get bearing() { return this.transform.bearing } unproject(e) { return this.transform.screenPointToLocation(t.P.convert(e), this._map.terrain) } } class jo { constructor(e, t) { this._map = e, this._tr = new Bo(e), this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = t.clickTolerance || 1; } isEnabled() { return !!this._enabled } isActive() { return !!this._active } enable() { this.isEnabled() || (this._enabled = !0); } disable() { this.isEnabled() && (this._enabled = !1); } mousedown(e, t) { this.isEnabled() && e.shiftKey && 0 === e.button && (n.disableDrag(), this._startPos = this._lastPos = t, this._active = !0); } mousemoveWindow(e, t) { if (!this._active) return; const i = t; if (this._lastPos.equals(i) || !this._box && i.dist(this._startPos) < this._clickTolerance) return; const r = this._startPos; this._lastPos = i, this._box || (this._box = n.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e)); const o = Math.min(r.x, i.x), s = Math.max(r.x, i.x), a = Math.min(r.y, i.y), l = Math.max(r.y, i.y); n.setTransform(this._box, `translate(${o}px,${a}px)`), this._box.style.width = s - o + "px", this._box.style.height = l - a + "px"; } mouseupWindow(e, i) { if (!this._active) return; if (0 !== e.button) return; const r = this._startPos, o = i; if (this.reset(), n.suppressClick(), r.x !== o.x || r.y !== o.y) return this._map.fire(new t.k("boxzoomend", { originalEvent: e })), { cameraAnimation: e => e.fitScreenCoordinates(r, o, this._tr.bearing, { linear: !0 }) }; this._fireEvent("boxzoomcancel", e); } keydown(e) { this._active && 27 === e.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", e)); } reset() { this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (n.remove(this._box), this._box = null), n.enableDrag(), delete this._startPos, delete this._lastPos; } _fireEvent(e, i) { return this._map.fire(new t.k(e, { originalEvent: i })) } } function Oo(e, t) { if (e.length !== t.length) throw new Error(`The number of touches and points are not equal - touches ${e.length}, points ${t.length}`); const i = {}; for (let r = 0; r < e.length; r++)i[e[r].identifier] = t[r]; return i } class No { constructor(e) { this.reset(), this.numTouches = e.numTouches; } reset() { delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1; } touchstart(e, i, r) { (this.centroid || r.length > this.numTouches) && (this.aborted = !0), this.aborted || (void 0 === this.startTime && (this.startTime = e.timeStamp), r.length === this.numTouches && (this.centroid = function (e) { const i = new t.P(0, 0); for (const t of e) i._add(t); return i.div(e.length) }(i), this.touches = Oo(r, i))); } touchmove(e, t, i) { if (this.aborted || !this.centroid) return; const r = Oo(i, t); for (const e in this.touches) { const t = r[e]; (!t || t.dist(this.touches[e]) > 30) && (this.aborted = !0); } } touchend(e, t, i) { if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0), 0 === i.length) { const e = !this.aborted && this.centroid; if (this.reset(), e) return e } } } class Zo { constructor(e) { this.singleTap = new No(e), this.numTaps = e.numTaps, this.reset(); } reset() { this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset(); } touchstart(e, t, i) { this.singleTap.touchstart(e, t, i); } touchmove(e, t, i) { this.singleTap.touchmove(e, t, i); } touchend(e, t, i) { const r = this.singleTap.touchend(e, t, i); if (r) { const t = e.timeStamp - this.lastTime < 500, i = !this.lastTap || this.lastTap.dist(r) < 30; if (t && i || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = r, this.count === this.numTaps) return this.reset(), r } } } class Go { constructor(e) { this._tr = new Bo(e), this._zoomIn = new Zo({ numTouches: 1, numTaps: 2 }), this._zoomOut = new Zo({ numTouches: 2, numTaps: 1 }), this.reset(); } reset() { this._active = !1, this._zoomIn.reset(), this._zoomOut.reset(); } touchstart(e, t, i) { this._zoomIn.touchstart(e, t, i), this._zoomOut.touchstart(e, t, i); } touchmove(e, t, i) { this._zoomIn.touchmove(e, t, i), this._zoomOut.touchmove(e, t, i); } touchend(e, t, i) { const r = this._zoomIn.touchend(e, t, i), o = this._zoomOut.touchend(e, t, i), s = this._tr; return r ? (this._active = !0, e.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: t => t.easeTo({ duration: 300, zoom: s.zoom + 1, around: s.unproject(r) }, { originalEvent: e }) }) : o ? (this._active = !0, e.preventDefault(), setTimeout((() => this.reset()), 0), { cameraAnimation: t => t.easeTo({ duration: 300, zoom: s.zoom - 1, around: s.unproject(o) }, { originalEvent: e }) }) : void 0 } touchcancel() { this.reset(); } enable() { this._enabled = !0; } disable() { this._enabled = !1, this.reset(); } isEnabled() { return this._enabled } isActive() { return this._active } } class Uo { constructor(e) { this._enabled = !!e.enable, this._moveStateManager = e.moveStateManager, this._clickTolerance = e.clickTolerance || 1, this._moveFunction = e.move, this._activateOnStart = !!e.activateOnStart, e.assignEvents(this), this.reset(); } reset(e) { this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(e); } _move(...e) { const t = this._moveFunction(...e); if (t.bearingDelta || t.pitchDelta || t.rollDelta || t.around || t.panDelta) return this._active = !0, t } dragStart(e, t) { this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e) && (this._moveStateManager.startMove(e), this._lastPoint = Array.isArray(t) ? t[0] : t, this._activateOnStart && this._lastPoint && (this._active = !0)); } dragMove(e, t) { if (!this.isEnabled()) return; const i = this._lastPoint; if (!i) return; if (e.preventDefault(), !this._moveStateManager.isValidMoveEvent(e)) return void this.reset(e); const r = Array.isArray(t) ? t[0] : t; return !this._moved && r.dist(i) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = r, this._move(i, r)) } dragEnd(e) { this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e) && (this._moved && n.suppressClick(), this.reset(e)); } enable() { this._enabled = !0; } disable() { this._enabled = !1, this.reset(); } isEnabled() { return this._enabled } isActive() { return this._active } getClickTolerance() { return this._clickTolerance } } const Vo = { 0: 1, 2: 2 }; class qo { constructor(e) { this._correctEvent = e.checkCorrectEvent; } startMove(e) { const t = n.mouseButton(e); this._eventButton = t; } endMove(e) { delete this._eventButton; } isValidStartEvent(e) { return this._correctEvent(e) } isValidMoveEvent(e) { return !function (e, t) { const i = Vo[t]; return void 0 === e.buttons || (e.buttons & i) !== i }(e, this._eventButton) } isValidEndEvent(e) { return n.mouseButton(e) === this._eventButton } } class Ho { constructor() { this._firstTouch = void 0; } _isOneFingerTouch(e) { return 1 === e.targetTouches.length } _isSameTouchEvent(e) { return e.targetTouches[0].identifier === this._firstTouch } startMove(e) { this._firstTouch = e.targetTouches[0].identifier; } endMove(e) { delete this._firstTouch; } isValidStartEvent(e) { return this._isOneFingerTouch(e) } isValidMoveEvent(e) { return this._isOneFingerTouch(e) && this._isSameTouchEvent(e) } isValidEndEvent(e) { return this._isOneFingerTouch(e) && this._isSameTouchEvent(e) } } class Wo { constructor(e = new qo({ checkCorrectEvent: () => !0 }), t = new Ho) { this.mouseMoveStateManager = e, this.oneFingerTouchMoveStateManager = t; } _executeRelevantHandler(e, t, i) { return e instanceof MouseEvent ? t(e) : "undefined" != typeof TouchEvent && e instanceof TouchEvent ? i(e) : void 0 } startMove(e) { this._executeRelevantHandler(e, (e => this.mouseMoveStateManager.startMove(e)), (e => this.oneFingerTouchMoveStateManager.startMove(e))); } endMove(e) { this._executeRelevantHandler(e, (e => this.mouseMoveStateManager.endMove(e)), (e => this.oneFingerTouchMoveStateManager.endMove(e))); } isValidStartEvent(e) { return this._executeRelevantHandler(e, (e => this.mouseMoveStateManager.isValidStartEvent(e)), (e => this.oneFingerTouchMoveStateManager.isValidStartEvent(e))) } isValidMoveEvent(e) { return this._executeRelevantHandler(e, (e => this.mouseMoveStateManager.isValidMoveEvent(e)), (e => this.oneFingerTouchMoveStateManager.isValidMoveEvent(e))) } isValidEndEvent(e) { return this._executeRelevantHandler(e, (e => this.mouseMoveStateManager.isValidEndEvent(e)), (e => this.oneFingerTouchMoveStateManager.isValidEndEvent(e))) } } const Xo = e => { e.mousedown = e.dragStart, e.mousemoveWindow = e.dragMove, e.mouseup = e.dragEnd, e.contextmenu = e => { e.preventDefault(); }; }; class $o { constructor(e, t) { this._clickTolerance = e.clickTolerance || 1, this._map = t, this.reset(); } reset() { this._active = !1, this._touches = {}, this._sum = new t.P(0, 0); } _shouldBePrevented(e) { return e < (this._map.cooperativeGestures.isEnabled() ? 2 : 1) } touchstart(e, t, i) { return this._calculateTransform(e, t, i) } touchmove(e, t, i) { if (this._active) { if (!this._shouldBePrevented(i.length)) return e.preventDefault(), this._calculateTransform(e, t, i); this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e); } } touchend(e, t, i) { this._calculateTransform(e, t, i), this._active && this._shouldBePrevented(i.length) && this.reset(); } touchcancel() { this.reset(); } _calculateTransform(e, i, r) { r.length > 0 && (this._active = !0); const o = Oo(r, i), s = new t.P(0, 0), a = new t.P(0, 0); let n = 0; for (const e in o) { const t = o[e], i = this._touches[e]; i && (s._add(t), a._add(t.sub(i)), n++, o[e] = t); } if (this._touches = o, this._shouldBePrevented(n) || !a.mag()) return; const l = a.div(n); return this._sum._add(l), this._sum.mag() < this._clickTolerance ? void 0 : { around: s.div(n), panDelta: l } } enable() { this._enabled = !0; } disable() { this._enabled = !1, this.reset(); } isEnabled() { return this._enabled } isActive() { return this._active } } class Ko { constructor() { this.reset(); } reset() { this._active = !1, delete this._firstTwoTouches; } touchstart(e, t, i) { this._firstTwoTouches || i.length < 2 || (this._firstTwoTouches = [i[0].identifier, i[1].identifier], this._start([t[0], t[1]])); } touchmove(e, t, i) { if (!this._firstTwoTouches) return; e.preventDefault(); const [r, o] = this._firstTwoTouches, s = Yo(i, t, r), a = Yo(i, t, o); if (!s || !a) return; const n = this._aroundCenter ? null : s.add(a).div(2); return this._move([s, a], n, e) } touchend(e, t, i) { if (!this._firstTwoTouches) return; const [r, o] = this._firstTwoTouches, s = Yo(i, t, r), a = Yo(i, t, o); s && a || (this._active && n.suppressClick(), this.reset()); } touchcancel() { this.reset(); } enable(e) { this._enabled = !0, this._aroundCenter = !!e && "center" === e.around; } disable() { this._enabled = !1, this.reset(); } isEnabled() { return !!this._enabled } isActive() { return !!this._active } } function Yo(e, t, i) { for (let r = 0; r < e.length; r++)if (e[r].identifier === i) return t[r] } function Jo(e, t) { return Math.log(e / t) / Math.LN2 } class Qo extends Ko { reset() { super.reset(), delete this._distance, delete this._startDistance; } _start(e) { this._startDistance = this._distance = e[0].dist(e[1]); } _move(e, t) { const i = this._distance; if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(Jo(this._distance, this._startDistance)) < .1)) return this._active = !0, { zoomDelta: Jo(this._distance, i), pinchAround: t } } } function es(e, t) { return 180 * e.angleWith(t) / Math.PI } class ts extends Ko { reset() { super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector; } _start(e) { this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1]); } _move(e, t, i) { const r = this._vector; if (this._vector = e[0].sub(e[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, { bearingDelta: es(this._vector, r), pinchAround: t } } _isBelowThreshold(e) { this._minDiameter = Math.min(this._minDiameter, e.mag()); const t = 25 / (Math.PI * this._minDiameter) * 360, i = es(e, this._startVector); return Math.abs(i) < t } } function is(e) { return Math.abs(e.y) > Math.abs(e.x) } class rs extends Ko { constructor(e) { super(), this._currentTouchCount = 0, this._map = e; } reset() { super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints; } touchstart(e, t, i) { super.touchstart(e, t, i), this._currentTouchCount = i.length; } _start(e) { this._lastPoints = e, is(e[0].sub(e[1])) && (this._valid = !1); } _move(e, t, i) { if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return; const r = e[0].sub(this._lastPoints[0]), o = e[1].sub(this._lastPoints[1]); return this._valid = this.gestureBeginsVertically(r, o, i.timeStamp), this._valid ? (this._lastPoints = e, this._active = !0, { pitchDelta: (r.y + o.y) / 2 * -.5 }) : void 0 } gestureBeginsVertically(e, t, i) { if (void 0 !== this._valid) return this._valid; const r = e.mag() >= 2, o = t.mag() >= 2; if (!r && !o) return; if (!r || !o) return void 0 === this._firstMove && (this._firstMove = i), i - this._firstMove < 100 && void 0; const s = e.y > 0 == t.y > 0; return is(e) && is(t) && s } } const os = { panStep: 100, bearingStep: 15, pitchStep: 10 }; class ss { constructor(e) { this._tr = new Bo(e); const t = os; this._panStep = t.panStep, this._bearingStep = t.bearingStep, this._pitchStep = t.pitchStep, this._rotationDisabled = !1; } reset() { this._active = !1; } keydown(e) { if (e.altKey || e.ctrlKey || e.metaKey) return; let t = 0, i = 0, r = 0, o = 0, s = 0; switch (e.keyCode) { case 61: case 107: case 171: case 187: t = 1; break; case 189: case 109: case 173: t = -1; break; case 37: e.shiftKey ? i = -1 : (e.preventDefault(), o = -1); break; case 39: e.shiftKey ? i = 1 : (e.preventDefault(), o = 1); break; case 38: e.shiftKey ? r = 1 : (e.preventDefault(), s = -1); break; case 40: e.shiftKey ? r = -1 : (e.preventDefault(), s = 1); break; default: return }return this._rotationDisabled && (i = 0, r = 0), { cameraAnimation: a => { const n = this._tr; a.easeTo({ duration: 300, easeId: "keyboardHandler", easing: as, zoom: t ? Math.round(n.zoom) + t * (e.shiftKey ? 2 : 1) : n.zoom, bearing: n.bearing + i * this._bearingStep, pitch: n.pitch + r * this._pitchStep, offset: [-o * this._panStep, -s * this._panStep], center: n.center }, { originalEvent: e }); } } } enable() { this._enabled = !0; } disable() { this._enabled = !1, this.reset(); } isEnabled() { return this._enabled } isActive() { return this._active } disableRotation() { this._rotationDisabled = !0; } enableRotation() { this._rotationDisabled = !1; } } function as(e) { return e * (2 - e) } const ns = 4.000244140625; class ls { constructor(e, t) { this._onTimeout = e => { this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e); }, this._map = e, this._tr = new Bo(e), this._triggerRenderFrame = t, this._delta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = .0022222222222222222; } setZoomRate(e) { this._defaultZoomRate = e; } setWheelZoomRate(e) { this._wheelZoomRate = e; } isEnabled() { return !!this._enabled } isActive() { return !!this._active || void 0 !== this._finishTimeout } isZooming() { return !!this._zooming } enable(e) { this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e && "center" === e.around); } disable() { this.isEnabled() && (this._enabled = !1); } _shouldBePrevented(e) { return !!this._map.cooperativeGestures.isEnabled() && !(e.ctrlKey || this._map.cooperativeGestures.isBypassed(e)) } wheel(e) { if (!this.isEnabled()) return; if (this._shouldBePrevented(e)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e); let t = e.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e.deltaY : e.deltaY; const i = a.now(), r = i - (this._lastWheelEventTime || 0); this._lastWheelEventTime = i, 0 !== t && t % ns == 0 ? this._type = "wheel" : 0 !== t && Math.abs(t) < 4 ? this._type = "trackpad" : r > 400 ? (this._type = null, this._lastValue = t, this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(r * t) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, t += this._lastValue)), e.shiftKey && t && (t /= 4), this._type && (this._lastWheelEvent = e, this._delta -= t, this._active || this._start(e)), e.preventDefault(); } _start(e) { if (!this._delta) return; this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout); const i = n.mousePos(this._map.getCanvas(), e), r = this._tr; this._aroundPoint = this._aroundCenter ? r.transform.locationToScreenPoint(t.N.convert(r.center)) : i, this._frameId || (this._frameId = !0, this._triggerRenderFrame()); } renderFrame() { if (!this._frameId) return; if (this._frameId = null, !this.isActive()) return; const e = this._tr.transform; if ("number" == typeof this._lastExpectedZoom) { const t = e.zoom - this._lastExpectedZoom; "number" == typeof this._startZoom && (this._startZoom += t), "number" == typeof this._targetZoom && (this._targetZoom += t); } if (0 !== this._delta) { const i = "wheel" === this._type && Math.abs(this._delta) > ns ? this._wheelZoomRate : this._defaultZoomRate; let r = 2 / (1 + Math.exp(-Math.abs(this._delta * i))); this._delta < 0 && 0 !== r && (r = 1 / r); const o = "number" != typeof this._targetZoom ? e.scale : t.aG(this._targetZoom); this._targetZoom = Math.min(e.maxZoom, Math.max(e.minZoom, t.a8(o * r))), "wheel" === this._type && (this._startZoom = e.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0; } const i = "number" != typeof this._targetZoom ? e.zoom : this._targetZoom, r = this._startZoom, o = this._easing; let s, n = !1; if ("wheel" === this._type && r && o) { const e = a.now() - this._lastWheelEventTime, l = Math.min((e + 5) / 200, 1), c = o(l); s = t.y.number(r, i, c), l < 1 ? this._frameId || (this._frameId = !0) : n = !0; } else s = i, n = !0; return this._active = !0, n && (this._active = !1, this._finishTimeout = setTimeout((() => { this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout; }), 200)), this._lastExpectedZoom = s, { noInertia: !0, needsRenderFrame: !n, zoomDelta: s - e.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent } } _smoothOutEasing(e) { let i = t.c8; if (this._prevEase) { const e = this._prevEase, r = (a.now() - e.start) / e.duration, o = e.easing(r + .01) - e.easing(r), s = .27 / Math.sqrt(o * o + 1e-4) * .01, n = Math.sqrt(.0729 - s * s); i = t.c6(s, n, .25, 1); } return this._prevEase = { start: a.now(), duration: e, easing: i }, i } reset() { this._active = !1, this._zooming = !1, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout); } } class cs { constructor(e, t) { this._clickZoom = e, this._tapZoom = t; } enable() { this._clickZoom.enable(), this._tapZoom.enable(); } disable() { this._clickZoom.disable(), this._tapZoom.disable(); } isEnabled() { return this._clickZoom.isEnabled() && this._tapZoom.isEnabled() } isActive() { return this._clickZoom.isActive() || this._tapZoom.isActive() } } class hs { constructor(e) { this._tr = new Bo(e), this.reset(); } reset() { this._active = !1; } dblclick(e, t) { return e.preventDefault(), { cameraAnimation: i => { i.easeTo({ duration: 300, zoom: this._tr.zoom + (e.shiftKey ? -1 : 1), around: this._tr.unproject(t) }, { originalEvent: e }); } } } enable() { this._enabled = !0; } disable() { this._enabled = !1, this.reset(); } isEnabled() { return this._enabled } isActive() { return this._active } } class us { constructor() { this._tap = new Zo({ numTouches: 1, numTaps: 1 }), this.reset(); } reset() { this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset(); } touchstart(e, t, i) { if (!this._swipePoint) if (this._tapTime) { const r = t[0], o = e.timeStamp - this._tapTime < 500, s = this._tapPoint.dist(r) < 30; o && s ? i.length > 0 && (this._swipePoint = r, this._swipeTouch = i[0].identifier) : this.reset(); } else this._tap.touchstart(e, t, i); } touchmove(e, t, i) { if (this._tapTime) { if (this._swipePoint) { if (i[0].identifier !== this._swipeTouch) return; const r = t[0], o = r.y - this._swipePoint.y; return this._swipePoint = r, e.preventDefault(), this._active = !0, { zoomDelta: o / 128 } } } else this._tap.touchmove(e, t, i); } touchend(e, t, i) { if (this._tapTime) this._swipePoint && 0 === i.length && this.reset(); else { const r = this._tap.touchend(e, t, i); r && (this._tapTime = e.timeStamp, this._tapPoint = r); } } touchcancel() { this.reset(); } enable() { this._enabled = !0; } disable() { this._enabled = !1, this.reset(); } isEnabled() { return this._enabled } isActive() { return this._active } } class ds { constructor(e, t, i) { this._el = e, this._mousePan = t, this._touchPan = i; } enable(e) { this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan"); } disable() { this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan"); } isEnabled() { return this._mousePan.isEnabled() && this._touchPan.isEnabled() } isActive() { return this._mousePan.isActive() || this._touchPan.isActive() } } class _s { constructor(e, t, i, r) { this._pitchWithRotate = e.pitchWithRotate, this._rollEnabled = e.rollEnabled, this._mouseRotate = t, this._mousePitch = i, this._mouseRoll = r; } enable() { this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable(); } disable() { this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable(); } isEnabled() { return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled()) } isActive() { return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive() } } class ps { constructor(e, t, i, r) { this._el = e, this._touchZoom = t, this._touchRotate = i, this._tapDragZoom = r, this._rotationDisabled = !1, this._enabled = !0; } enable(e) { this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate"); } disable() { this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate"); } isEnabled() { return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled() } isActive() { return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive() } disableRotation() { this._rotationDisabled = !0, this._touchRotate.disable(); } enableRotation() { this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable(); } } class ms { constructor(e, t) { this._bypassKey = -1 !== navigator.userAgent.indexOf("Mac") ? "metaKey" : "ctrlKey", this._map = e, this._options = t, this._enabled = !1; } isActive() { return !1 } reset() { } _setupUI() { if (this._container) return; const e = this._map.getCanvasContainer(); e.classList.add("maplibregl-cooperative-gestures"), this._container = n.create("div", "maplibregl-cooperative-gesture-screen", e); let t = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText"); "metaKey" === this._bypassKey && (t = this._map._getUIString("CooperativeGesturesHandler.MacHelpText")); const i = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), r = document.createElement("div"); r.className = "maplibregl-desktop-message", r.textContent = t, this._container.appendChild(r); const o = document.createElement("div"); o.className = "maplibregl-mobile-message", o.textContent = i, this._container.appendChild(o), this._container.setAttribute("aria-hidden", "true"); } _destroyUI() { this._container && (n.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container; } enable() { this._setupUI(), this._enabled = !0; } disable() { this._enabled = !1, this._destroyUI(); } isEnabled() { return this._enabled } isBypassed(e) { return e[this._bypassKey] } notifyGestureBlocked(e, i) { this._enabled && (this._map.fire(new t.k("cooperativegestureprevented", { gestureType: e, originalEvent: i })), this._container.classList.add("maplibregl-show"), setTimeout((() => { this._container.classList.remove("maplibregl-show"); }), 100)); } } const fs = e => e.zoom || e.drag || e.roll || e.pitch || e.rotate; class gs extends t.k { } function vs(e) { return e.panDelta && e.panDelta.mag() || e.zoomDelta || e.bearingDelta || e.pitchDelta || e.rollDelta } class xs { constructor(e, t) { this.handleWindowEvent = e => { this.handleEvent(e, `${e.type}Window`); }, this.handleEvent = (e, t) => { if ("blur" === e.type) return void this.stop(!0); this._updatingCamera = !0; const i = "renderFrame" === e.type ? void 0 : e, r = { needsRenderFrame: !1 }, o = {}, s = {}, a = e.touches, l = a ? this._getMapTouches(a) : void 0, c = l ? n.touchPos(this._map.getCanvas(), l) : n.mousePos(this._map.getCanvas(), e); for (const { handlerName: a, handler: n, allowed: h } of this._handlers) { if (!n.isEnabled()) continue; let u; this._blockedByActive(s, h, a) ? n.reset() : n[t || e.type] && (u = n[t || e.type](e, c, l), this.mergeHandlerResult(r, o, u, a, i), u && u.needsRenderFrame && this._triggerRenderFrame()), (u || n.isActive()) && (s[a] = n); } const h = {}; for (const e in this._previousActiveHandlers) s[e] || (h[e] = i); this._previousActiveHandlers = s, (Object.keys(h).length || vs(r)) && (this._changes.push([r, o, h]), this._triggerRenderFrame()), (Object.keys(s).length || vs(r)) && this._map._stop(!0), this._updatingCamera = !1; const { cameraAnimation: u } = r; u && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], u(this._map)); }, this._map = e, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new So(e), this._bearingSnap = t.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(t); const i = this._el; this._listeners = [[i, "touchstart", { passive: !0 }], [i, "touchmove", { passive: !1 }], [i, "touchend", void 0], [i, "touchcancel", void 0], [i, "mousedown", void 0], [i, "mousemove", void 0], [i, "mouseup", void 0], [document, "mousemove", { capture: !0 }], [document, "mouseup", void 0], [i, "mouseover", void 0], [i, "mouseout", void 0], [i, "dblclick", void 0], [i, "click", void 0], [i, "keydown", { capture: !1 }], [i, "keyup", void 0], [i, "wheel", { passive: !1 }], [i, "contextmenu", void 0], [window, "blur", void 0]]; for (const [e, t, i] of this._listeners) n.addEventListener(e, t, e === document ? this.handleWindowEvent : this.handleEvent, i); } destroy() { for (const [e, t, i] of this._listeners) n.removeEventListener(e, t, e === document ? this.handleWindowEvent : this.handleEvent, i); } _addDefaultHandlers(e) { const i = this._map, r = i.getCanvasContainer(); this._add("mapEvent", new ko(i, e)); const o = i.boxZoom = new jo(i, e); this._add("boxZoom", o), e.interactive && e.boxZoom && o.enable(); const s = i.cooperativeGestures = new ms(i, e.cooperativeGestures); this._add("cooperativeGestures", s), e.cooperativeGestures && s.enable(); const a = new Go(i), l = new hs(i); i.doubleClickZoom = new cs(l, a), this._add("tapZoom", a), this._add("clickZoom", l), e.interactive && e.doubleClickZoom && i.doubleClickZoom.enable(); const c = new us; this._add("tapDragZoom", c); const h = i.touchPitch = new rs(i); this._add("touchPitch", h), e.interactive && e.touchPitch && i.touchPitch.enable(e.touchPitch); const u = () => i.project(i.getCenter()), d = function ({ enable: e, clickTolerance: i, aroundCenter: r = !0, minPixelCenterThreshold: o = 100, rotateDegreesPerPixelMoved: s = .8 }, a) { const l = new qo({ checkCorrectEvent: e => 0 === n.mouseButton(e) && e.ctrlKey || 2 === n.mouseButton(e) && !e.ctrlKey }); return new Uo({ clickTolerance: i, move: (e, i) => { const n = a(); if (r && Math.abs(n.y - e.y) > o) return { bearingDelta: t.c7(new t.P(e.x, i.y), i, n) }; let l = (i.x - e.x) * s; return r && i.y < n.y && (l = -l), { bearingDelta: l } }, moveStateManager: l, enable: e, assignEvents: Xo }) }(e, u), _ = function ({ enable: e, clickTolerance: t, pitchDegreesPerPixelMoved: i = -.5 }) { const r = new qo({ checkCorrectEvent: e => 0 === n.mouseButton(e) && e.ctrlKey || 2 === n.mouseButton(e) }); return new Uo({ clickTolerance: t, move: (e, t) => ({ pitchDelta: (t.y - e.y) * i }), moveStateManager: r, enable: e, assignEvents: Xo }) }(e), p = function ({ enable: e, clickTolerance: t, rollDegreesPerPixelMoved: i = .3 }, r) { const o = new qo({ checkCorrectEvent: e => 2 === n.mouseButton(e) && e.ctrlKey }); return new Uo({ clickTolerance: t, move: (e, t) => { const o = r(); let s = (t.x - e.x) * i; return t.y < o.y && (s = -s), { rollDelta: s } }, moveStateManager: o, enable: e, assignEvents: Xo }) }(e, u); i.dragRotate = new _s(e, d, _, p), this._add("mouseRotate", d, ["mousePitch"]), this._add("mousePitch", _, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", p, ["mousePitch"]), e.interactive && e.dragRotate && i.dragRotate.enable(); const m = function ({ enable: e, clickTolerance: t }) { const i = new qo({ checkCorrectEvent: e => 0 === n.mouseButton(e) && !e.ctrlKey }); return new Uo({ clickTolerance: t, move: (e, t) => ({ around: t, panDelta: t.sub(e) }), activateOnStart: !0, moveStateManager: i, enable: e, assignEvents: Xo }) }(e), f = new $o(e, i); i.dragPan = new ds(r, m, f), this._add("mousePan", m), this._add("touchPan", f, ["touchZoom", "touchRotate"]), e.interactive && e.dragPan && i.dragPan.enable(e.dragPan); const g = new ts, v = new Qo; i.touchZoomRotate = new ps(r, v, g, c), this._add("touchRotate", g, ["touchPan", "touchZoom"]), this._add("touchZoom", v, ["touchPan", "touchRotate"]), e.interactive && e.touchZoomRotate && i.touchZoomRotate.enable(e.touchZoomRotate); const x = i.scrollZoom = new ls(i, (() => this._triggerRenderFrame())); this._add("scrollZoom", x, ["mousePan"]), e.interactive && e.scrollZoom && i.scrollZoom.enable(e.scrollZoom); const b = i.keyboard = new ss(i); this._add("keyboard", b), e.interactive && e.keyboard && i.keyboard.enable(), this._add("blockableMapEvent", new Fo(i)); } _add(e, t, i) { this._handlers.push({ handlerName: e, handler: t, allowed: i }), this._handlersById[e] = t; } stop(e) { if (!this._updatingCamera) { for (const { handler: e } of this._handlers) e.reset(); this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = []; } } isActive() { for (const { handler: e } of this._handlers) if (e.isActive()) return !0; return !1 } isZooming() { return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming() } isRotating() { return !!this._eventsInProgress.rotate } isMoving() { return Boolean(fs(this._eventsInProgress)) || this.isZooming() } _blockedByActive(e, t, i) { for (const r in e) if (r !== i && (!t || t.indexOf(r) < 0)) return !0; return !1 } _getMapTouches(e) { const t = []; for (const i of e) this._el.contains(i.target) && t.push(i); return t } mergeHandlerResult(e, i, r, o, s) { if (!r) return; t.e(e, r); const a = { handlerName: o, originalEvent: r.originalEvent || s }; void 0 !== r.zoomDelta && (i.zoom = a), void 0 !== r.panDelta && (i.drag = a), void 0 !== r.rollDelta && (i.roll = a), void 0 !== r.pitchDelta && (i.pitch = a), void 0 !== r.bearingDelta && (i.rotate = a); } _applyChanges() { const e = {}, i = {}, r = {}; for (const [o, s, a] of this._changes) o.panDelta && (e.panDelta = (e.panDelta || new t.P(0, 0))._add(o.panDelta)), o.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + o.zoomDelta), o.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + o.bearingDelta), o.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + o.pitchDelta), o.rollDelta && (e.rollDelta = (e.rollDelta || 0) + o.rollDelta), void 0 !== o.around && (e.around = o.around), void 0 !== o.pinchAround && (e.pinchAround = o.pinchAround), o.noInertia && (e.noInertia = o.noInertia), t.e(i, s), t.e(r, a); this._updateMapTransform(e, i, r), this._changes = []; } _updateMapTransform(e, t, i) { const r = this._map, o = r._getTransformForUpdate(), s = r.terrain; if (!(vs(e) || s && this._terrainMovement)) return this._fireEvents(t, i, !0); r._stop(!0); let { panDelta: a, zoomDelta: n, bearingDelta: l, pitchDelta: c, rollDelta: h, around: u, pinchAround: d } = e; void 0 !== d && (u = d), u = u || r.transform.centerPoint, s && !o.isPointOnMapSurface(u) && (u = o.centerPoint); const _ = { panDelta: a, zoomDelta: n, rollDelta: h, pitchDelta: c, bearingDelta: l, around: u }; this._map.cameraHelper.useGlobeControls && !o.isPointOnMapSurface(u) && (u = o.centerPoint); const p = u.distSqr(o.centerPoint) < .01 ? o.center : o.screenPointToLocation(a ? u.sub(a) : u); s ? (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(_, o), this._terrainMovement || !t.drag && !t.zoom ? t.drag && this._terrainMovement ? o.setCenter(o.screenPointToLocation(o.centerPoint.sub(a))) : this._map.cameraHelper.handleMapControlsPan(_, o, p) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, this._map.cameraHelper.handleMapControlsPan(_, o, p))) : (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(_, o), this._map.cameraHelper.handleMapControlsPan(_, o, p)), r._applyUpdatedTransform(o), this._map._update(), e.noInertia || this._inertia.record(e), this._fireEvents(t, i, !0); } _fireEvents(e, i, r) { const o = fs(this._eventsInProgress), s = fs(e), n = {}; for (const t in e) { const { originalEvent: i } = e[t]; this._eventsInProgress[t] || (n[`${t}start`] = i), this._eventsInProgress[t] = e[t]; } !o && s && this._fireEvent("movestart", s.originalEvent); for (const e in n) this._fireEvent(e, n[e]); s && this._fireEvent("move", s.originalEvent); for (const t in e) { const { originalEvent: i } = e[t]; this._fireEvent(t, i); } const l = {}; let c; for (const e in this._eventsInProgress) { const { handlerName: t, originalEvent: r } = this._eventsInProgress[e]; this._handlersById[t].isActive() || (delete this._eventsInProgress[e], c = i[t] || r, l[`${e}end`] = c); } for (const e in l) this._fireEvent(e, l[e]); const h = fs(this._eventsInProgress), u = (o || s) && !h; if (u && this._terrainMovement) { this._map._elevationFreeze = !1, this._terrainMovement = !1; const e = this._map._getTransformForUpdate(); this._map.getCenterClampedToGround() && e.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(e); } if (r && u) { this._updatingCamera = !0; const e = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i = e => 0 !== e && -this._bearingSnap < e && e < this._bearingSnap; !e || !e.essential && a.prefersReducedMotion ? (this._map.fire(new t.k("moveend", { originalEvent: c })), i(this._map.getBearing()) && this._map.resetNorth()) : (i(e.bearing || this._map.getBearing()) && (e.bearing = 0), e.freezeElevation = !0, this._map.easeTo(e, { originalEvent: c })), this._updatingCamera = !1; } } _fireEvent(e, i) { this._map.fire(new t.k(e, i ? { originalEvent: i } : {})); } _requestFrame() { return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e => { delete this._frameId, this.handleEvent(new gs("renderFrame", { timeStamp: e })), this._applyChanges(); })) } _triggerRenderFrame() { void 0 === this._frameId && (this._frameId = this._requestFrame()); } } class bs extends t.E { constructor(e, t, i) { super(), this._renderFrameCallback = () => { const e = Math.min((a.now() - this._easeStart) / this._easeOptions.duration, 1); this._onEaseFrame(this._easeOptions.easing(e)), e < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop(); }, this._moving = !1, this._zooming = !1, this.transform = e, this._bearingSnap = i.bearingSnap, this.cameraHelper = t, this.on("moveend", (() => { delete this._requestedCameraState; })); } migrateProjection(e, t) { e.apply(this.transform), this.transform = e, this.cameraHelper = t; } getCenter() { return new t.N(this.transform.center.lng, this.transform.center.lat) } setCenter(e, t) { return this.jumpTo({ center: e }, t) } getCenterElevation() { return this.transform.elevation } setCenterElevation(e, t) { return this.jumpTo({ elevation: e }, t), this } getCenterClampedToGround() { return this._centerClampedToGround } setCenterClampedToGround(e) { this._centerClampedToGround = e; } panBy(e, i, r) { return e = t.P.convert(e).mult(-1), this.panTo(this.transform.center, t.e({ offset: e }, i), r) } panTo(e, i, r) { return this.easeTo(t.e({ center: e }, i), r) } getZoom() { return this.transform.zoom } setZoom(e, t) { return this.jumpTo({ zoom: e }, t), this } zoomTo(e, i, r) { return this.easeTo(t.e({ zoom: e }, i), r) } zoomIn(e, t) { return this.zoomTo(this.getZoom() + 1, e, t), this } zoomOut(e, t) { return this.zoomTo(this.getZoom() - 1, e, t), this } getVerticalFieldOfView() { return this.transform.fov } setVerticalFieldOfView(e, i) { return e != this.transform.fov && (this.transform.setFov(e), this.fire(new t.k("movestart", i)).fire(new t.k("move", i)).fire(new t.k("moveend", i))), this } getBearing() { return this.transform.bearing } setBearing(e, t) { return this.jumpTo({ bearing: e }, t), this } getPadding() { return this.transform.padding } setPadding(e, t) { return this.jumpTo({ padding: e }, t), this } rotateTo(e, i, r) { return this.easeTo(t.e({ bearing: e }, i), r) } resetNorth(e, i) { return this.rotateTo(0, t.e({ duration: 1e3 }, e), i), this } resetNorthPitch(e, i) { return this.easeTo(t.e({ bearing: 0, pitch: 0, roll: 0, duration: 1e3 }, e), i), this } snapToNorth(e, t) { return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, t) : this } getPitch() { return this.transform.pitch } setPitch(e, t) { return this.jumpTo({ pitch: e }, t), this } getRoll() { return this.transform.roll } setRoll(e, t) { return this.jumpTo({ roll: e }, t), this } cameraForBounds(e, t) { e = V.convert(e).adjustAntiMeridian(); const i = t && t.bearing || 0; return this._cameraForBoxAndBearing(e.getNorthWest(), e.getSouthEast(), i, t) } _cameraForBoxAndBearing(e, i, r, o) { const s = { top: 0, bottom: 0, right: 0, left: 0 }; if ("number" == typeof (o = t.e({ padding: s, offset: [0, 0], maxZoom: this.transform.maxZoom }, o)).padding) { const e = o.padding; o.padding = { top: e, bottom: e, right: e, left: e }; } const a = t.e(s, o.padding); o.padding = a; const n = this.transform, l = new V(e, i); return this.cameraHelper.cameraForBoxAndBearing(o, a, l, r, n) } fitBounds(e, t, i) { return this._fitInternal(this.cameraForBounds(e, t), t, i) } fitScreenCoordinates(e, i, r, o, s) { return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(t.P.convert(e)), this.transform.screenPointToLocation(t.P.convert(i)), r, o), o, s) } _fitInternal(e, i, r) { return e ? (delete (i = t.e(e, i)).padding, i.linear ? this.easeTo(i, r) : this.flyTo(i, r)) : this } jumpTo(e, i) { this.stop(); const r = this._getTransformForUpdate(); let o = !1, s = !1, a = !1; const n = r.zoom; this.cameraHelper.handleJumpToCenterZoom(r, e); const l = r.zoom !== n; return "elevation" in e && r.elevation !== +e.elevation && r.setElevation(+e.elevation), "bearing" in e && r.bearing !== +e.bearing && (o = !0, r.setBearing(+e.bearing)), "pitch" in e && r.pitch !== +e.pitch && (s = !0, r.setPitch(+e.pitch)), "roll" in e && r.roll !== +e.roll && (a = !0, r.setRoll(+e.roll)), null == e.padding || r.isPaddingEqual(e.padding) || r.setPadding(e.padding), this._applyUpdatedTransform(r), this.fire(new t.k("movestart", i)).fire(new t.k("move", i)), l && this.fire(new t.k("zoomstart", i)).fire(new t.k("zoom", i)).fire(new t.k("zoomend", i)), o && this.fire(new t.k("rotatestart", i)).fire(new t.k("rotate", i)).fire(new t.k("rotateend", i)), s && this.fire(new t.k("pitchstart", i)).fire(new t.k("pitch", i)).fire(new t.k("pitchend", i)), a && this.fire(new t.k("rollstart", i)).fire(new t.k("roll", i)).fire(new t.k("rollend", i)), this.fire(new t.k("moveend", i)) } calculateCameraOptionsFromTo(e, i, r, o = 0) { const s = t.Y.fromLngLat(e, i), a = t.Y.fromLngLat(r, o), n = a.x - s.x, l = a.y - s.y, c = a.z - s.z, h = Math.hypot(n, l, c); if (0 === h) throw new Error("Can't calculate camera options with same From and To"); const u = Math.hypot(n, l), d = t.a8(this.transform.cameraToCenterDistance / h / this.transform.tileSize), _ = 180 * Math.atan2(n, -l) / Math.PI; let p = 180 * Math.acos(u / h) / Math.PI; return p = c < 0 ? 90 - p : 90 + p, { center: a.toLngLat(), elevation: o, zoom: d, pitch: p, bearing: _ } } calculateCameraOptionsFromCameraLngLatAltRotation(e, t, i, r, o) { const s = this.transform.calculateCenterFromCameraLngLatAlt(e, t, i, r); return { center: s.center, elevation: s.elevation, zoom: s.zoom, bearing: i, pitch: r, roll: o } } easeTo(e, i) { this._stop(!1, e.easeId), (!1 === (e = t.e({ offset: [0, 0], duration: 500, easing: t.c8 }, e)).animate || !e.essential && a.prefersReducedMotion) && (e.duration = 0); const r = this._getTransformForUpdate(), o = this.getBearing(), s = r.pitch, n = r.roll, l = "bearing" in e ? this._normalizeBearing(e.bearing, o) : o, c = "pitch" in e ? +e.pitch : s, h = "roll" in e ? this._normalizeBearing(e.roll, n) : n, u = "padding" in e ? e.padding : r.padding, d = t.P.convert(e.offset); let _, p; e.around && (_ = t.N.convert(e.around), p = r.locationToScreenPoint(_)); const m = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching, rolling: this._rolling }, f = this.cameraHelper.handleEaseTo(r, { bearing: l, pitch: c, roll: h, padding: u, around: _, aroundPoint: p, offsetAsPoint: d, offset: e.offset, zoom: e.zoom, center: e.center }); return this._rotating = this._rotating || o !== l, this._pitching = this._pitching || c !== s, this._rolling = this._rolling || h !== n, this._padding = !r.isPaddingEqual(u), this._zooming = this._zooming || f.isZooming, this._easeId = e.easeId, this._prepareEase(i, e.noMoveStart, m), this.terrain && this._prepareElevation(f.elevationCenter), this._ease((t => { f.easeFunc(t), this.terrain && !e.freezeElevation && this._updateElevation(t), this._applyUpdatedTransform(r), this._fireMoveEvents(i); }), (t => { this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(i, t); }), e), this } _prepareEase(e, i, r = {}) { this._moving = !0, i || r.moving || this.fire(new t.k("movestart", e)), this._zooming && !r.zooming && this.fire(new t.k("zoomstart", e)), this._rotating && !r.rotating && this.fire(new t.k("rotatestart", e)), this._pitching && !r.pitching && this.fire(new t.k("pitchstart", e)), this._rolling && !r.rolling && this.fire(new t.k("rollstart", e)); } _prepareElevation(e) { this._elevationCenter = e, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(e, this.transform.tileZoom), this._elevationFreeze = !0; } _updateElevation(e) { this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom)); const i = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom); if (e < 1 && i !== this._elevationTarget) { const t = this._elevationTarget - this._elevationStart; this._elevationStart += e * (t - (i - (t * e + this._elevationStart)) / (1 - e)), this._elevationTarget = i; } this.transform.setElevation(t.y.number(this._elevationStart, this._elevationTarget, e)); } _finalizeElevation() { this._elevationFreeze = !1, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain); } _getTransformForUpdate() { return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform } _elevateCameraIfInsideTerrain(e) { if (!this.terrain && e.elevation >= 0 && e.pitch <= 90) return {}; const t = e.getCameraLngLat(), i = e.getCameraAltitude(), r = this.terrain ? this.terrain.getElevationForLngLatZoom(t, e.zoom) : 0; if (i < r) { const i = this.calculateCameraOptionsFromTo(t, r, e.center, e.elevation); return { pitch: i.pitch, zoom: i.zoom } } return {} } _applyUpdatedTransform(e) { const t = []; if (t.push((e => this._elevateCameraIfInsideTerrain(e))), this.transformCameraUpdate && t.push((e => this.transformCameraUpdate(e))), !t.length) return; const i = e.clone(); for (const e of t) { const t = i.clone(), { center: r, zoom: o, roll: s, pitch: a, bearing: n, elevation: l } = e(t); r && t.setCenter(r), void 0 !== l && t.setElevation(l), void 0 !== o && t.setZoom(o), void 0 !== s && t.setRoll(s), void 0 !== a && t.setPitch(a), void 0 !== n && t.setBearing(n), i.apply(t); } this.transform.apply(i); } _fireMoveEvents(e) { this.fire(new t.k("move", e)), this._zooming && this.fire(new t.k("zoom", e)), this._rotating && this.fire(new t.k("rotate", e)), this._pitching && this.fire(new t.k("pitch", e)), this._rolling && this.fire(new t.k("roll", e)); } _afterEase(e, i) { if (this._easeId && i && this._easeId === i) return; delete this._easeId; const r = this._zooming, o = this._rotating, s = this._pitching, a = this._rolling; this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._rolling = !1, this._padding = !1, r && this.fire(new t.k("zoomend", e)), o && this.fire(new t.k("rotateend", e)), s && this.fire(new t.k("pitchend", e)), a && this.fire(new t.k("rollend", e)), this.fire(new t.k("moveend", e)); } flyTo(e, i) { if (!e.essential && a.prefersReducedMotion) { const r = t.M(e, ["center", "zoom", "bearing", "pitch", "roll", "elevation"]); return this.jumpTo(r, i) } this.stop(), e = t.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: t.c8 }, e); const r = this._getTransformForUpdate(), o = r.bearing, s = r.pitch, n = r.roll, l = r.padding, c = "bearing" in e ? this._normalizeBearing(e.bearing, o) : o, h = "pitch" in e ? +e.pitch : s, u = "roll" in e ? this._normalizeBearing(e.roll, n) : n, d = "padding" in e ? e.padding : r.padding, _ = t.P.convert(e.offset); let p = r.centerPoint.add(_); const m = r.screenPointToLocation(p), f = this.cameraHelper.handleFlyTo(r, { bearing: c, pitch: h, roll: u, padding: d, locationAtOffset: m, offsetAsPoint: _, center: e.center, minZoom: e.minZoom, zoom: e.zoom }); let g = e.curve; const v = Math.max(r.width, r.height), x = v / f.scaleOfZoom, b = f.pixelPathLength; "number" == typeof f.scaleOfMinZoom && (g = Math.sqrt(v / f.scaleOfMinZoom / b * 2)); const y = g * g; function w(e) { const t = (x * x - v * v + (e ? -1 : 1) * y * y * b * b) / (2 * (e ? x : v) * y * b); return Math.log(Math.sqrt(t * t + 1) - t) } function T(e) { return (Math.exp(e) - Math.exp(-e)) / 2 } function P(e) { return (Math.exp(e) + Math.exp(-e)) / 2 } const C = w(!1); let I = function (e) { return P(C) / P(C + g * e) }, E = function (e) { return v * ((P(C) * (T(t = C + g * e) / P(t)) - T(C)) / y) / b; var t; }, M = (w(!0) - C) / g; if (Math.abs(b) < 2e-6 || !isFinite(M)) { if (Math.abs(v - x) < 1e-6) return this.easeTo(e, i); const t = x < v ? -1 : 1; M = Math.abs(Math.log(x / v)) / g, E = () => 0, I = e => Math.exp(t * g * e); } return e.duration = "duration" in e ? +e.duration : 1e3 * M / ("screenSpeed" in e ? +e.screenSpeed / g : +e.speed), e.maxDuration && e.duration > e.maxDuration && (e.duration = 0), this._zooming = !0, this._rotating = o !== c, this._pitching = h !== s, this._rolling = u !== n, this._padding = !r.isPaddingEqual(d), this._prepareEase(i, !1), this.terrain && this._prepareElevation(f.targetCenter), this._ease((a => { const m = a * M, g = 1 / I(m), v = E(m); this._rotating && r.setBearing(t.y.number(o, c, a)), this._pitching && r.setPitch(t.y.number(s, h, a)), this._rolling && r.setRoll(t.y.number(n, u, a)), this._padding && (r.interpolatePadding(l, d, a), p = r.centerPoint.add(_)), f.easeFunc(a, g, v, p), this.terrain && !e.freezeElevation && this._updateElevation(a), this._applyUpdatedTransform(r), this._fireMoveEvents(i); }), (() => { this.terrain && e.freezeElevation && this._finalizeElevation(), this._afterEase(i); }), e), this } isEasing() { return !!this._easeFrameId } stop() { return this._stop() } _stop(e, t) { var i; if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) { const e = this._onEaseEnd; delete this._onEaseEnd, e.call(this, t); } return e || null === (i = this.handlers) || void 0 === i || i.stop(!1), this } _ease(e, t, i) { !1 === i.animate || 0 === i.duration ? (e(1), t()) : (this._easeStart = a.now(), this._easeOptions = i, this._onEaseFrame = e, this._onEaseEnd = t, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback)); } _normalizeBearing(e, i) { e = t.aI(e, -180, 180); const r = Math.abs(e - i); return Math.abs(e - 360 - i) < r && (e -= 360), Math.abs(e + 360 - i) < r && (e += 360), e } queryTerrainElevation(e) { return this.terrain ? this.terrain.getElevationForLngLatZoom(t.N.convert(e), this.transform.tileZoom) : null } } const ys = { compact: !0, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' }; class ws { constructor(e = ys) { this._toggleAttribution = () => { this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open"))); }, this._updateData = e => { !e || "metadata" !== e.sourceDataType && "visibility" !== e.sourceDataType && "style" !== e.dataType && "terrain" !== e.type || this._updateAttributions(); }, this._updateCompact = () => { this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? !1 === this._compact ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show")); }, this._updateCompactMinimize = () => { this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show"); }, this.options = e; } getDefaultPosition() { return "bottom-right" } onAdd(e) { return this._map = e, this._compact = this.options.compact, this._container = n.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = n.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = n.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container } onRemove() { n.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._sanitizedAttributionHTML = void 0; } _setElementTitle(e, t) { const i = this._map._getUIString(`AttributionControl.${t}`); e.title = i, e.setAttribute("aria-label", i); } _updateAttributions() { if (!this._map.style) return; let e = []; if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = e.concat(this.options.customAttribution.map((e => "string" != typeof e ? "" : e))) : "string" == typeof this.options.customAttribution && e.push(this.options.customAttribution)), this._map.style.stylesheet) { const e = this._map.style.stylesheet; this.styleOwner = e.owner, this.styleId = e.id; } const t = this._map.style.sourceCaches; for (const i in t) { const r = t[i]; if (r.used || r.usedForTerrain) { const t = r.getSource(); t.attribution && e.indexOf(t.attribution) < 0 && e.push(t.attribution); } } e = e.filter((e => String(e).trim())), e.sort(((e, t) => e.length - t.length)), e = e.filter(((t, i) => { for (let r = i + 1; r < e.length; r++)if (e[r].indexOf(t) >= 0) return !1; return !0 })); const i = e.join(" | "); i !== this._sanitizedAttributionHTML && (this._sanitizedAttributionHTML = n.sanitize(i), e.length ? (this._innerContainer.innerHTML = this._sanitizedAttributionHTML, this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null); } } class Ts { constructor(e = {}) { this._updateCompact = () => { const e = this._container.children; if (e.length) { const t = e[0]; this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? !1 !== this._compact && t.classList.add("maplibregl-compact") : t.classList.remove("maplibregl-compact"); } }, this.options = e; } getDefaultPosition() { return "bottom-left" } onAdd(e) { this._map = e, this._compact = this.options && this.options.compact, this._container = n.create("div", "maplibregl-ctrl"); const t = n.create("a", "maplibregl-ctrl-logo"); return t.target = "_blank", t.rel = "noopener nofollow", t.href = "https://maplibre.org/", t.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container } onRemove() { n.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0; } } class Ps { constructor() { this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1; } add(e) { const t = ++this._id; return this._queue.push({ callback: e, id: t, cancelled: !1 }), t } remove(e) { const t = this._currentlyRunning, i = t ? this._queue.concat(t) : this._queue; for (const t of i) if (t.id === e) return void (t.cancelled = !0) } run(e = 0) { if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running."); const t = this._currentlyRunning = this._queue; this._queue = []; for (const i of t) if (!i.cancelled && (i.callback(e), this._cleared)) break; this._cleared = !1, this._currentlyRunning = !1; } clear() { this._currentlyRunning && (this._cleared = !0), this._queue = []; } } var Cs = t.aA([{ name: "a_pos3d", type: "Int16", components: 3 }]); class Is extends t.E { constructor(e) { super(), this._lastTilesetChange = a.now(), this.sourceCache = e, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = e._source.tileSize * 2 ** this.deltaZoom, e.usedForTerrain = !0, e.tileSize = this.tileSize; } destruct() { this.sourceCache.usedForTerrain = !1, this.sourceCache.tileSize = null; } update(e, i) { this.sourceCache.update(e, i), this._renderableTilesKeys = []; const r = {}; for (const o of ue(e, { tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: !1, terrain: i, calculateTileZoom: this.sourceCache._source.calculateTileZoom })) r[o.key] = !0, this._renderableTilesKeys.push(o.key), this._tiles[o.key] || (o.terrainRttPosMatrix32f = new Float64Array(16), t.bL(o.terrainRttPosMatrix32f, 0, t.X, t.X, 0, 0, 1), this._tiles[o.key] = new se(o, this.tileSize), this._lastTilesetChange = a.now()); for (const e in this._tiles) r[e] || delete this._tiles[e]; } freeRtt(e) { for (const t in this._tiles) { const i = this._tiles[t]; (!e || i.tileID.equals(e) || i.tileID.isChildOf(e) || e.isChildOf(i.tileID)) && (i.rtt = []); } } getRenderableTiles() { return this._renderableTilesKeys.map((e => this.getTileByID(e))) } getTileByID(e) { return this._tiles[e] } getTerrainCoords(e) { const i = {}; for (const r of this._renderableTilesKeys) { const o = this._tiles[r].tileID, s = e.clone(), a = t.a$(); if (o.canonical.equals(e.canonical)) t.bL(a, 0, t.X, t.X, 0, 0, 1); else if (o.canonical.isChildOf(e.canonical)) { const i = o.canonical.z - e.canonical.z, r = o.canonical.x - (o.canonical.x >> i << i), s = o.canonical.y - (o.canonical.y >> i << i), n = t.X >> i; t.bL(a, 0, n, n, 0, 0, 1), t.J(a, a, [-r * n, -s * n, 0]); } else { if (!e.canonical.isChildOf(o.canonical)) continue; { const i = e.canonical.z - o.canonical.z, r = e.canonical.x - (e.canonical.x >> i << i), s = e.canonical.y - (e.canonical.y >> i << i), n = t.X >> i; t.bL(a, 0, t.X, t.X, 0, 0, 1), t.J(a, a, [r * n, s * n, 0]), t.K(a, a, [1 / 2 ** i, 1 / 2 ** i, 0]); } } s.terrainRttPosMatrix32f = new Float32Array(a), i[r] = s; } return i } getSourceTile(e, t) { const i = this.sourceCache._source; let r = e.overscaledZ - this.deltaZoom; if (r > i.maxzoom && (r = i.maxzoom), r < i.minzoom) return null; this._sourceTileCache[e.key] || (this._sourceTileCache[e.key] = e.scaledTo(r).key); let o = this.sourceCache.getTileByID(this._sourceTileCache[e.key]); if ((!o || !o.dem) && t) for (; r >= i.minzoom && (!o || !o.dem);)o = this.sourceCache.getTileByID(e.scaledTo(r--).key); return o } anyTilesAfterTime(e = Date.now()) { return this._lastTilesetChange >= e } } class Es { constructor(e, t, i) { this._meshCache = {}, this.painter = e, this.sourceCache = new Is(t), this.options = i, this.exaggeration = "number" == typeof i.exaggeration ? i.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024; } getDEMElevation(e, i, r, o = t.X) { var s; if (!(i >= 0 && i < o && r >= 0 && r < o)) return 0; const a = this.getTerrainData(e), n = null === (s = a.tile) || void 0 === s ? void 0 : s.dem; if (!n) return 0; const l = t.c9([], [i / o * t.X, r / o * t.X], a.u_terrain_matrix), c = [l[0] * n.dim, l[1] * n.dim], h = Math.floor(c[0]), u = Math.floor(c[1]), d = c[0] - h, _ = c[1] - u; return n.get(h, u) * (1 - d) * (1 - _) + n.get(h + 1, u) * d * (1 - _) + n.get(h, u + 1) * (1 - d) * _ + n.get(h + 1, u + 1) * d * _ } getElevationForLngLatZoom(e, i) { if (!t.ca(i, e.wrap())) return 0; const { tileID: r, mercatorX: o, mercatorY: s } = this._getOverscaledTileIDFromLngLatZoom(e, i); return this.getElevation(r, o % t.X, s % t.X, t.X) } getElevation(e, i, r, o = t.X) { return this.getDEMElevation(e, i, r, o) * this.exaggeration } getTerrainData(e) { if (!this._emptyDemTexture) { const e = this.painter.context, i = new t.R({ width: 1, height: 1 }, new Uint8Array(4)); this._emptyDepthTexture = new v(e, i, e.gl.RGBA, { premultiply: !1 }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new v(e, new t.R({ width: 1, height: 1 }), e.gl.RGBA, { premultiply: !1 }), this._emptyDemTexture.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = t.aq([]); } const i = this.sourceCache.getSourceTile(e, !0); if (i && i.dem && (!i.demTexture || i.needsTerrainPrepare)) { const e = this.painter.context; i.demTexture = this.painter.getTileTexture(i.dem.stride), i.demTexture ? i.demTexture.update(i.dem.getPixels(), { premultiply: !1 }) : i.demTexture = new v(e, i.dem.getPixels(), e.gl.RGBA, { premultiply: !1 }), i.demTexture.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE), i.needsTerrainPrepare = !1; } const r = i && i + i.tileID.key + e.key; if (r && !this._demMatrixCache[r]) { const r = this.sourceCache.sourceCache._source.maxzoom; let o = e.canonical.z - i.tileID.canonical.z; e.overscaledZ > e.canonical.z && (e.canonical.z >= r ? o = e.canonical.z - r : t.w("cannot calculate elevation if elevation maxzoom > source.maxzoom")); const s = e.canonical.x - (e.canonical.x >> o << o), a = e.canonical.y - (e.canonical.y >> o << o), n = t.cb(new Float64Array(16), [1 / (t.X << o), 1 / (t.X << o), 0]); t.J(n, n, [s * t.X, a * t.X, 0]), this._demMatrixCache[e.key] = { matrix: n, coord: e }; } return { u_depth: 2, u_terrain: 3, u_terrain_dim: i && i.dem && i.dem.dim || 1, u_terrain_matrix: r ? this._demMatrixCache[e.key].matrix : this._emptyDemMatrix, u_terrain_unpack: i && i.dem && i.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (i && i.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: i } } getFramebuffer(e) { const t = this.painter, i = t.width / devicePixelRatio, r = t.height / devicePixelRatio; return !this._fbo || this._fbo.width === i && this._fbo.height === r || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new v(t.context, { width: i, height: r, data: null }, t.context.gl.RGBA, { premultiply: !1 }), this._fboCoordsTexture.bind(t.context.gl.NEAREST, t.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new v(t.context, { width: i, height: r, data: null }, t.context.gl.RGBA, { premultiply: !1 }), this._fboDepthTexture.bind(t.context.gl.NEAREST, t.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = t.context.createFramebuffer(i, r, !0, !1), this._fbo.depthAttachment.set(t.context.createRenderbuffer(t.context.gl.DEPTH_COMPONENT16, i, r))), this._fbo.colorAttachment.set("coords" === e ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo } getCoordsTexture() { const e = this.painter.context; if (this._coordsTexture) return this._coordsTexture; const i = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4); for (let e = 0, t = 0; e < this._coordsTextureSize; e++)for (let r = 0; r < this._coordsTextureSize; r++, t += 4)i[t + 0] = 255 & r, i[t + 1] = 255 & e, i[t + 2] = r >> 8 << 4 | e >> 8, i[t + 3] = 0; const r = new t.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(i.buffer)), o = new v(e, r, e.gl.RGBA, { premultiply: !1 }); return o.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE), this._coordsTexture = o, o } pointCoordinate(e) { this.painter.maybeDrawDepthAndCoords(!0); const i = new Uint8Array(4), r = this.painter.context, o = r.gl, s = Math.round(e.x * this.painter.pixelRatio / devicePixelRatio), a = Math.round(e.y * this.painter.pixelRatio / devicePixelRatio), n = Math.round(this.painter.height / devicePixelRatio); r.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), o.readPixels(s, n - a - 1, 1, 1, o.RGBA, o.UNSIGNED_BYTE, i), r.bindFramebuffer.set(null); const l = i[0] + (i[2] >> 4 << 8), c = i[1] + ((15 & i[2]) << 8), h = this.coordsIndex[255 - i[3]], u = h && this.sourceCache.getTileByID(h); if (!u) return null; const d = this._coordsTextureSize, _ = (1 << u.tileID.canonical.z) * d; return new t.Y((u.tileID.canonical.x * d + l) / _ + u.tileID.wrap, (u.tileID.canonical.y * d + c) / _, this.getElevation(u.tileID, l, c, d)) } depthAtPoint(e) { const t = new Uint8Array(4), i = this.painter.context, r = i.gl; return i.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), r.readPixels(e.x, this.painter.height / devicePixelRatio - e.y - 1, 1, 1, r.RGBA, r.UNSIGNED_BYTE, t), i.bindFramebuffer.set(null), (t[0] / 16777216 + t[1] / 65536 + t[2] / 256 + t[3]) / 256 } getTerrainMesh(e) { var i; const r = (null === (i = this.painter.style.projection) || void 0 === i ? void 0 : i.transitionState) > 0, o = r && 0 === e.canonical.y, s = r && e.canonical.y === (1 << e.canonical.z) - 1, a = `m_${o ? "n" : ""}_${s ? "s" : ""}`; if (this._meshCache[a]) return this._meshCache[a]; const n = this.painter.context, l = new t.cc, c = new t.aE, h = this.meshSize, u = t.X / h, d = h * h; for (let e = 0; e <= h; e++)for (let t = 0; t <= h; t++)l.emplaceBack(t * u, e * u, 0); for (let e = 0; e < d; e += h + 1)for (let t = 0; t < h; t++)c.emplaceBack(t + e, h + t + e + 1, h + t + e + 2), c.emplaceBack(t + e, h + t + e + 2, t + e + 1); const _ = l.length, p = _ + (h + 1), m = (h + 1) * h, f = o ? t.b6 : 0, g = o ? 0 : 1, v = s ? t.b7 : t.X, x = s ? 0 : 1; for (let e = 0; e <= h; e++)l.emplaceBack(e * u, f, g); for (let e = 0; e <= h; e++)l.emplaceBack(e * u, v, x); for (let e = 0; e < h; e++)c.emplaceBack(m + e, p + e, p + e + 1), c.emplaceBack(m + e, p + e + 1, m + e + 1), c.emplaceBack(0 + e, _ + e + 1, _ + e), c.emplaceBack(0 + e, 0 + e + 1, _ + e + 1); const b = l.length, y = b + 2 * (h + 1); for (const e of [0, 1]) for (let i = 0; i <= h; i++)for (const r of [0, 1]) l.emplaceBack(e * t.X, i * u, r); for (let e = 0; e < 2 * h; e += 2)c.emplaceBack(b + e, b + e + 1, b + e + 3), c.emplaceBack(b + e, b + e + 3, b + e + 2), c.emplaceBack(y + e, y + e + 3, y + e + 1), c.emplaceBack(y + e, y + e + 2, y + e + 3); const w = new pt(n.createVertexBuffer(l, Cs.members), n.createIndexBuffer(c), t.aD.simpleSegment(0, 0, l.length, c.length)); return this._meshCache[a] = w, w } getMeshFrameDelta(e) { return 2 * Math.PI * t.bo / Math.pow(2, Math.max(e, 0)) / 5 } getMinTileElevationForLngLatZoom(e, t) { var i; const { tileID: r } = this._getOverscaledTileIDFromLngLatZoom(e, t); return null !== (i = this.getMinMaxElevation(r).minElevation) && void 0 !== i ? i : 0 } getMinMaxElevation(e) { const t = this.getTerrainData(e).tile, i = { minElevation: null, maxElevation: null }; return t && t.dem && (i.minElevation = t.dem.min * this.exaggeration, i.maxElevation = t.dem.max * this.exaggeration), i } _getOverscaledTileIDFromLngLatZoom(e, i) { const r = t.Y.fromLngLat(e.wrap()), o = (1 << i) * t.X, s = r.x * o, a = r.y * o, n = Math.floor(s / t.X), l = Math.floor(a / t.X); return { tileID: new t.S(i, 0, i, n, l), mercatorX: s, mercatorY: a } } } class Ms { constructor(e, t, i) { this._context = e, this._size = t, this._tileSize = i, this._objects = [], this._recentlyUsed = [], this._stamp = 0; } destruct() { for (const e of this._objects) e.texture.destroy(), e.fbo.destroy(); } _createObject(e) { const t = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0), i = new v(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA); return i.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), t.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), t.colorAttachment.set(i.texture), { id: e, fbo: t, texture: i, stamp: -1, inUse: !1 } } getObjectForId(e) { return this._objects[e] } useObject(e) { e.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter((t => e.id !== t)), this._recentlyUsed.push(e.id); } stampObject(e) { e.stamp = ++this._stamp; } getOrCreateFreeObject() { for (const e of this._recentlyUsed) if (!this._objects[e].inUse) return this._objects[e]; if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!"); const e = this._createObject(this._objects.length); return this._objects.push(e), e } freeObject(e) { e.inUse = !1; } freeAllObjects() { for (const e of this._objects) this.freeObject(e); } isFull() { return !(this._objects.length < this._size) && !1 === this._objects.some((e => !e.inUse)) } } const Ss = { background: !0, fill: !0, line: !0, raster: !0, hillshade: !0 }; class Rs { constructor(e, t) { this.painter = e, this.terrain = t, this.pool = new Ms(e.context, 30, t.sourceCache.tileSize * t.qualityFactor); } destruct() { this.pool.destruct(); } getTexture(e) { return this.pool.getObjectForId(e.rtt[this._stacks.length - 1].id).texture } prepareForRender(e, t) { this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = e._order.filter((i => !e._layers[i].isHidden(t))), this._coordsAscending = {}; for (const t in e.sourceCaches) { this._coordsAscending[t] = {}; const i = e.sourceCaches[t].getVisibleCoordinates(); for (const e of i) { const i = this.terrain.sourceCache.getTerrainCoords(e); for (const e in i) this._coordsAscending[t][e] || (this._coordsAscending[t][e] = []), this._coordsAscending[t][e].push(i[e]); } } this._coordsAscendingStr = {}; for (const t of e._order) { const i = e._layers[t], r = i.source; if (Ss[i.type] && !this._coordsAscendingStr[r]) { this._coordsAscendingStr[r] = {}; for (const e in this._coordsAscending[r]) this._coordsAscendingStr[r][e] = this._coordsAscending[r][e].map((e => e.key)).sort().join(); } } for (const e of this._renderableTiles) for (const t in this._coordsAscendingStr) { const i = this._coordsAscendingStr[t][e.tileID.key]; i && i !== e.rttCoords[t] && (e.rtt = []); } } renderLayer(e, i) { if (e.isHidden(this.painter.transform.zoom)) return !1; const r = Object.assign(Object.assign({}, i), { isRenderingToTexture: !0 }), o = e.type, s = this.painter, a = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e.id; if (Ss[o] && (this._prevType && Ss[this._prevType] || this._stacks.push([]), this._prevType = o, this._stacks[this._stacks.length - 1].push(e.id), !a)) return !0; if (Ss[this._prevType] || Ss[o] && a) { this._prevType = o; const e = this._stacks.length - 1, i = this._stacks[e] || []; for (const o of this._renderableTiles) { if (this.pool.isFull() && (vo(this.painter, this.terrain, this._rttTiles, r), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(o), o.rtt[e]) { const t = this.pool.getObjectForId(o.rtt[e].id); if (t.stamp === o.rtt[e].stamp) { this.pool.useObject(t); continue } } const a = this.pool.getOrCreateFreeObject(); this.pool.useObject(a), this.pool.stampObject(a), o.rtt[e] = { id: a.id, stamp: a.stamp }, s.context.bindFramebuffer.set(a.fbo.framebuffer), s.context.clear({ color: t.b4.transparent, stencil: 0 }), s.currentStencilSource = void 0; for (let e = 0; e < i.length; e++) { const t = s.style._layers[i[e]], n = t.source ? this._coordsAscending[t.source][o.tileID.key] : [o.tileID]; s.context.viewport.set([0, 0, a.fbo.width, a.fbo.height]), s._renderTileClippingMasks(t, n, !0), s.renderLayer(s, s.style.sourceCaches[t.source], t, n, r), t.source && (o.rttCoords[t.source] = this._coordsAscendingStr[t.source][o.tileID.key]); } } return vo(this.painter, this.terrain, this._rttTiles, r), this._rttTiles = [], this.pool.freeAllObjects(), Ss[o] } return !1 } } const Ds = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "Map.Title": "Map", "Marker.Title": "Map marker", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "Popup.Close": "Close popup", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "GlobeControl.Enable": "Enable globe", "GlobeControl.Disable": "Disable globe", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use ⌘ + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, zs = i, As = { hash: !1, interactive: !0, bearingSnap: 7, attributionControl: ys, maplibreLogo: !1, refreshExpiredTiles: !0, canvasContextAttributes: { antialias: !1, preserveDrawingBuffer: !1, powerPreference: "high-performance", failIfMajorPerformanceCaveat: !1, desynchronized: !1, contextType: void 0 }, scrollZoom: !0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, cooperativeGestures: !1, trackResize: !0, center: [0, 0], elevation: 0, zoom: 0, bearing: 0, pitch: 0, roll: 0, renderWorldCopies: !0, maxTileCacheSize: null, maxTileCacheZoomLevels: t.a.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: !0, clickTolerance: 3, localIdeographFontFamily: "sans-serif", pitchWithRotate: !0, rollEnabled: !1, validateStyle: !0, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: !0, centerClampedToGround: !0 }, Ls = { showCompass: !0, showZoom: !0, visualizePitch: !1, visualizeRoll: !0 }; class ks { constructor(e, i, r = !1) { this.mousedown = e => { this.startMove(e, n.mousePos(this.element, e)), n.addEventListener(window, "mousemove", this.mousemove), n.addEventListener(window, "mouseup", this.mouseup); }, this.mousemove = e => { this.move(e, n.mousePos(this.element, e)); }, this.mouseup = e => { this._rotatePitchHanlder.dragEnd(e), this.offTemp(); }, this.touchstart = e => { 1 !== e.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = n.touchPos(this.element, e.targetTouches)[0], this.startMove(e, this._startPos), n.addEventListener(window, "touchmove", this.touchmove, { passive: !1 }), n.addEventListener(window, "touchend", this.touchend)); }, this.touchmove = e => { 1 !== e.targetTouches.length ? this.reset() : (this._lastPos = n.touchPos(this.element, e.targetTouches)[0], this.move(e, this._lastPos)); }, this.touchend = e => { 0 === e.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp(); }, this.reset = () => { this._rotatePitchHanlder.reset(), delete this._startPos, delete this._lastPos, this.offTemp(); }, this._clickTolerance = 10, this.element = i; const o = new Wo; this._rotatePitchHanlder = new Uo({ clickTolerance: 3, move: (e, o) => { const s = i.getBoundingClientRect(), a = new t.P((s.bottom - s.top) / 2, (s.right - s.left) / 2); return { bearingDelta: t.c7(new t.P(e.x, o.y), o, a), pitchDelta: r ? -.5 * (o.y - e.y) : void 0 } }, moveStateManager: o, enable: !0, assignEvents: () => { } }), this.map = e, n.addEventListener(i, "mousedown", this.mousedown), n.addEventListener(i, "touchstart", this.touchstart, { passive: !1 }), n.addEventListener(i, "touchcancel", this.reset); } startMove(e, t) { this._rotatePitchHanlder.dragStart(e, t), n.disableDrag(); } move(e, t) { const i = this.map, { bearingDelta: r, pitchDelta: o } = this._rotatePitchHanlder.dragMove(e, t) || {}; r && i.setBearing(i.getBearing() + r), o && i.setPitch(i.getPitch() + o); } off() { const e = this.element; n.removeEventListener(e, "mousedown", this.mousedown), n.removeEventListener(e, "touchstart", this.touchstart, { passive: !1 }), n.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), n.removeEventListener(window, "touchend", this.touchend), n.removeEventListener(e, "touchcancel", this.reset), this.offTemp(); } offTemp() { n.enableDrag(), n.removeEventListener(window, "mousemove", this.mousemove), n.removeEventListener(window, "mouseup", this.mouseup), n.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), n.removeEventListener(window, "touchend", this.touchend); } } let Fs; function Bs(e, i, r) { const o = new t.N(e.lng, e.lat); if (e = new t.N(e.lng, e.lat), i) { const o = new t.N(e.lng - 360, e.lat), s = new t.N(e.lng + 360, e.lat), a = r.locationToScreenPoint(e).distSqr(i); r.locationToScreenPoint(o).distSqr(i) < a ? e = o : r.locationToScreenPoint(s).distSqr(i) < a && (e = s); } for (; Math.abs(e.lng - r.center.lng) > 180;) { const t = r.locationToScreenPoint(e); if (t.x >= 0 && t.y >= 0 && t.x <= r.width && t.y <= r.height) break; e.lng > r.center.lng ? e.lng -= 360 : e.lng += 360; } return e.lng !== o.lng && r.isPointOnMapSurface(r.locationToScreenPoint(e)) ? e : o } const js = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" }; function Os(e, t, i) { const r = e.classList; for (const e in js) r.remove(`maplibregl-${i}-anchor-${e}`); r.add(`maplibregl-${i}-anchor-${t}`); } class Ns extends t.E { constructor(e) { if (super(), this._onKeyPress = e => { const t = e.code, i = e.charCode || e.keyCode; "Space" !== t && "Enter" !== t && 32 !== i && 13 !== i || this.togglePopup(); }, this._onMapClick = e => { const t = e.originalEvent.target, i = this._element; this._popup && (t === i || i.contains(t)) && this.togglePopup(); }, this._update = e => { var t; if (!this._map) return; const i = this._map.loaded() && !this._map.isMoving(); ("terrain" === (null == e ? void 0 : e.type) || "render" === (null == e ? void 0 : e.type) && !i) && this._map.once("render", this._update), this._lngLat = this._map.transform.renderWorldCopies ? Bs(this._lngLat, this._flatPos, this._map.transform) : null === (t = this._lngLat) || void 0 === t ? void 0 : t.wrap(), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset)); let r = ""; "viewport" === this._rotationAlignment || "auto" === this._rotationAlignment ? r = `rotateZ(${this._rotation}deg)` : "map" === this._rotationAlignment && (r = `rotateZ(${this._rotation - this._map.getBearing()}deg)`); let o = ""; "viewport" === this._pitchAlignment || "auto" === this._pitchAlignment ? o = "rotateX(0deg)" : "map" === this._pitchAlignment && (o = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || e && "moveend" !== e.type || (this._pos = this._pos.round()), n.setTransform(this._element, `${js[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${o} ${r}`), a.frameAsync(new AbortController).then((() => { this._updateOpacity(e && "moveend" === e.type); })).catch((() => { })); }, this._onMove = e => { if (!this._isDragging) { const t = this._clickTolerance || this._map._clickTolerance; this._isDragging = e.point.dist(this._pointerdownPos) >= t; } this._isDragging && (this._pos = e.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new t.k("dragstart"))), this.fire(new t.k("drag"))); }, this._onUp = () => { this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), "active" === this._state && this.fire(new t.k("dragend")), this._state = "inactive"; }, this._addDragHandler = e => { this._element.contains(e.originalEvent.target) && (e.preventDefault(), this._positionDelta = e.point.sub(this._pos).add(this._offset), this._pointerdownPos = e.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp)); }, this._anchor = e && e.anchor || "center", this._color = e && e.color || "#3FB1CE", this._scale = e && e.scale || 1, this._draggable = e && e.draggable || !1, this._clickTolerance = e && e.clickTolerance || 0, this._subpixelPositioning = e && e.subpixelPositioning || !1, this._isDragging = !1, this._state = "inactive", this._rotation = e && e.rotation || 0, this._rotationAlignment = e && e.rotationAlignment || "auto", this._pitchAlignment = e && e.pitchAlignment && "auto" !== e.pitchAlignment ? e.pitchAlignment : this._rotationAlignment, this.setOpacity(), this.setOpacity(null == e ? void 0 : e.opacity, null == e ? void 0 : e.opacityWhenCovered), e && e.element) this._element = e.element, this._offset = t.P.convert(e && e.offset || [0, 0]); else { this._defaultMarker = !0, this._element = n.create("div"); const i = n.createNS("http://www.w3.org/2000/svg", "svg"), r = 41, o = 27; i.setAttributeNS(null, "display", "block"), i.setAttributeNS(null, "height", `${r}px`), i.setAttributeNS(null, "width", `${o}px`), i.setAttributeNS(null, "viewBox", `0 0 ${o} ${r}`); const s = n.createNS("http://www.w3.org/2000/svg", "g"); s.setAttributeNS(null, "stroke", "none"), s.setAttributeNS(null, "stroke-width", "1"), s.setAttributeNS(null, "fill", "none"), s.setAttributeNS(null, "fill-rule", "evenodd"); const a = n.createNS("http://www.w3.org/2000/svg", "g"); a.setAttributeNS(null, "fill-rule", "nonzero"); const l = n.createNS("http://www.w3.org/2000/svg", "g"); l.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), l.setAttributeNS(null, "fill", "#000000"); const c = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }]; for (const e of c) { const t = n.createNS("http://www.w3.org/2000/svg", "ellipse"); t.setAttributeNS(null, "opacity", "0.04"), t.setAttributeNS(null, "cx", "10.5"), t.setAttributeNS(null, "cy", "5.80029008"), t.setAttributeNS(null, "rx", e.rx), t.setAttributeNS(null, "ry", e.ry), l.appendChild(t); } const h = n.createNS("http://www.w3.org/2000/svg", "g"); h.setAttributeNS(null, "fill", this._color); const u = n.createNS("http://www.w3.org/2000/svg", "path"); u.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), h.appendChild(u); const d = n.createNS("http://www.w3.org/2000/svg", "g"); d.setAttributeNS(null, "opacity", "0.25"), d.setAttributeNS(null, "fill", "#000000"); const _ = n.createNS("http://www.w3.org/2000/svg", "path"); _.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), d.appendChild(_); const p = n.createNS("http://www.w3.org/2000/svg", "g"); p.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), p.setAttributeNS(null, "fill", "#FFFFFF"); const m = n.createNS("http://www.w3.org/2000/svg", "g"); m.setAttributeNS(null, "transform", "translate(8.0, 8.0)"); const f = n.createNS("http://www.w3.org/2000/svg", "circle"); f.setAttributeNS(null, "fill", "#000000"), f.setAttributeNS(null, "opacity", "0.25"), f.setAttributeNS(null, "cx", "5.5"), f.setAttributeNS(null, "cy", "5.5"), f.setAttributeNS(null, "r", "5.4999962"); const g = n.createNS("http://www.w3.org/2000/svg", "circle"); g.setAttributeNS(null, "fill", "#FFFFFF"), g.setAttributeNS(null, "cx", "5.5"), g.setAttributeNS(null, "cy", "5.5"), g.setAttributeNS(null, "r", "5.4999962"), m.appendChild(f), m.appendChild(g), a.appendChild(l), a.appendChild(h), a.appendChild(d), a.appendChild(p), a.appendChild(m), i.appendChild(a), i.setAttributeNS(null, "height", r * this._scale + "px"), i.setAttributeNS(null, "width", o * this._scale + "px"), this._element.appendChild(i), this._offset = t.P.convert(e && e.offset || [0, -14]); } if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (e => { e.preventDefault(); })), this._element.addEventListener("mousedown", (e => { e.preventDefault(); })), Os(this._element, this._anchor, "marker"), e && e.className) for (const t of e.className.split(" ")) this._element.classList.add(t); this._popup = null; } addTo(e) { return this.remove(), this._map = e, this._element.setAttribute("aria-label", e._getUIString("Marker.Title")), e.getCanvasContainer().appendChild(this._element), e.on("move", this._update), e.on("moveend", this._update), e.on("terrain", this._update), e.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this } remove() { return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), n.remove(this._element), this._popup && this._popup.remove(), this } getLngLat() { return this._lngLat } setLngLat(e) { return this._lngLat = t.N.convert(e), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this } getElement() { return this._element } setPopup(e) { if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e) { if (!("offset" in e.options)) { const t = 38.1, i = 13.5, r = Math.abs(i) / Math.SQRT2; e.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [r, -1 * (t - i + r)], "bottom-right": [-r, -1 * (t - i + r)], left: [i, -1 * (t - i)], right: [-13.5, -1 * (t - i)] } : this._offset; } this._popup = e, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress); } return this } setSubpixelPositioning(e) { return this._subpixelPositioning = e, this } getPopup() { return this._popup } togglePopup() { const e = this._popup; return this._element.style.opacity === this._opacityWhenCovered ? this : e ? (e.isOpen() ? e.remove() : (e.setLngLat(this._lngLat), e.addTo(this._map)), this) : this } _updateOpacity(e = !1) { var i, r; if (!(null === (i = this._map) || void 0 === i ? void 0 : i.terrain)) { const e = this._map.transform.isLocationOccluded(this._lngLat) ? this._opacityWhenCovered : this._opacity; return void (this._element.style.opacity !== e && (this._element.style.opacity = e)) } if (e) this._opacityTimeout = null; else { if (this._opacityTimeout) return; this._opacityTimeout = setTimeout((() => { this._opacityTimeout = null; }), 100); } const o = this._map, s = o.terrain.depthAtPoint(this._pos), a = o.terrain.getElevationForLngLatZoom(this._lngLat, o.transform.tileZoom); if (o.transform.lngLatToCameraDepth(this._lngLat, a) - s < .006) return void (this._element.style.opacity = this._opacity); const n = -this._offset.y / o.transform.pixelsPerMeter, l = Math.sin(o.getPitch() * Math.PI / 180) * n, c = o.terrain.depthAtPoint(new t.P(this._pos.x, this._pos.y - this._offset.y)), h = o.transform.lngLatToCameraDepth(this._lngLat, a + l) - c > .006; (null === (r = this._popup) || void 0 === r ? void 0 : r.isOpen()) && h && this._popup.remove(), this._element.style.opacity = h ? this._opacityWhenCovered : this._opacity; } getOffset() { return this._offset } setOffset(e) { return this._offset = t.P.convert(e), this._update(), this } addClassName(e) { this._element.classList.add(e); } removeClassName(e) { this._element.classList.remove(e); } toggleClassName(e) { return this._element.classList.toggle(e) } setDraggable(e) { return this._draggable = !!e, this._map && (e ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this } isDraggable() { return this._draggable } setRotation(e) { return this._rotation = e || 0, this._update(), this } getRotation() { return this._rotation } setRotationAlignment(e) { return this._rotationAlignment = e || "auto", this._update(), this } getRotationAlignment() { return this._rotationAlignment } setPitchAlignment(e) { return this._pitchAlignment = e && "auto" !== e ? e : this._rotationAlignment, this._update(), this } getPitchAlignment() { return this._pitchAlignment } setOpacity(e, t) { return void 0 === e && void 0 === t && (this._opacity = "1", this._opacityWhenCovered = "0.2"), void 0 !== e && (this._opacity = e), void 0 !== t && (this._opacityWhenCovered = t), this._map && this._updateOpacity(!0), this } } const Zs = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0 }; let Gs = 0, Us = !1; const Vs = { maxWidth: 100, unit: "metric" }; function qs(e, t, i) { const r = i && i.maxWidth || 100, o = e._container.clientHeight / 2, s = e._container.clientWidth / 2, a = e.unproject([s - r / 2, o]), n = e.unproject([s + r / 2, o]), l = Math.round(e.project(n).x - e.project(a).x), c = Math.min(r, l, e._container.clientWidth), h = a.distanceTo(n); if (i && "imperial" === i.unit) { const i = 3.2808 * h; i > 5280 ? Hs(t, c, i / 5280, e._getUIString("ScaleControl.Miles")) : Hs(t, c, i, e._getUIString("ScaleControl.Feet")); } else i && "nautical" === i.unit ? Hs(t, c, h / 1852, e._getUIString("ScaleControl.NauticalMiles")) : h >= 1e3 ? Hs(t, c, h / 1e3, e._getUIString("ScaleControl.Kilometers")) : Hs(t, c, h, e._getUIString("ScaleControl.Meters")); } function Hs(e, t, i, r) { const o = function (e) { const t = Math.pow(10, `${Math.floor(e)}`.length - 1); let i = e / t; return i = i >= 10 ? 10 : i >= 5 ? 5 : i >= 3 ? 3 : i >= 2 ? 2 : i >= 1 ? 1 : function (e) { const t = Math.pow(10, Math.ceil(-Math.log(e) / Math.LN10)); return Math.round(e * t) / t }(i), t * i }(i); e.style.width = t * (o / i) + "px", e.innerHTML = `${o}&nbsp;${r}`; } const Ws = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px", subpixelPositioning: !1 }, Xs = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", "); function $s(e) { if (e) { if ("number" == typeof e) { const i = Math.round(Math.abs(e) / Math.SQRT2); return { center: new t.P(0, 0), top: new t.P(0, e), "top-left": new t.P(i, i), "top-right": new t.P(-i, i), bottom: new t.P(0, -e), "bottom-left": new t.P(i, -i), "bottom-right": new t.P(-i, -i), left: new t.P(e, 0), right: new t.P(-e, 0) } } if (e instanceof t.P || Array.isArray(e)) { const i = t.P.convert(e); return { center: i, top: i, "top-left": i, "top-right": i, bottom: i, "bottom-left": i, "bottom-right": i, left: i, right: i } } return { center: t.P.convert(e.center || [0, 0]), top: t.P.convert(e.top || [0, 0]), "top-left": t.P.convert(e["top-left"] || [0, 0]), "top-right": t.P.convert(e["top-right"] || [0, 0]), bottom: t.P.convert(e.bottom || [0, 0]), "bottom-left": t.P.convert(e["bottom-left"] || [0, 0]), "bottom-right": t.P.convert(e["bottom-right"] || [0, 0]), left: t.P.convert(e.left || [0, 0]), right: t.P.convert(e.right || [0, 0]) } } return $s(new t.P(0, 0)) } const Ks = i; e.AJAXError = t.cg, e.Event = t.k, e.Evented = t.E, e.LngLat = t.N, e.MercatorCoordinate = t.Y, e.Point = t.P, e.addProtocol = t.ch, e.config = t.a, e.removeProtocol = t.ci, e.AttributionControl = ws, e.BoxZoomHandler = jo, e.CanvasSource = J, e.CooperativeGesturesHandler = ms, e.DoubleClickZoomHandler = cs, e.DragPanHandler = ds, e.DragRotateHandler = _s, e.EdgeInsets = Pt, e.FullscreenControl = class extends t.E { constructor(e = {}) { super(), this._onFullscreenChange = () => { var e; let t = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement; for (; null === (e = null == t ? void 0 : t.shadowRoot) || void 0 === e ? void 0 : e.fullscreenElement;)t = t.shadowRoot.fullscreenElement; t === this._container !== this._fullscreen && this._handleFullscreenChange(); }, this._onClickFullscreen = () => { this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen(); }, this._fullscreen = !1, e && e.container && (e.container instanceof HTMLElement ? this._container = e.container : t.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange"); } onAdd(e) { return this._map = e, this._container || (this._container = this._map.getContainer()), this._controlContainer = n.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer } onRemove() { n.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange); } _setupUI() { const e = this._fullscreenButton = n.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer); n.create("span", "maplibregl-ctrl-icon", e).setAttribute("aria-hidden", "true"), e.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange); } _updateTitle() { const e = this._getTitle(); this._fullscreenButton.setAttribute("aria-label", e), this._fullscreenButton.title = e; } _getTitle() { return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter") } _isFullscreen() { return this._fullscreen } _handleFullscreenChange() { this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new t.k("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new t.k("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable()); } _exitFullscreen() { window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen(); } _requestFullscreen() { this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen(); } _togglePseudoFullScreen() { this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize(); } }, e.GeoJSONSource = $, e.GeolocateControl = class extends t.E { constructor(e) { super(), this._onSuccess = e => { if (this._map) { if (this._isOutOfMapMaxBounds(e)) return this._setErrorState(), this.fire(new t.k("outofmaxbounds", e)), this._updateMarker(), void this._finish(); if (this.options.trackUserLocation) switch (this._lastKnownPosition = e, this._watchState) { case "WAITING_ACTIVE": case "ACTIVE_LOCK": case "ACTIVE_ERROR": this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active"); break; case "BACKGROUND": case "BACKGROUND_ERROR": this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"); break; default: throw new Error(`Unexpected watchState ${this._watchState}`) }this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(e), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(e), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new t.k("geolocate", e)), this._finish(); } }, this._updateCamera = e => { const i = new t.N(e.coords.longitude, e.coords.latitude), r = e.coords.accuracy, o = this._map.getBearing(), s = t.e({ bearing: o }, this.options.fitBoundsOptions), a = V.fromLngLat(i, r); this._map.fitBounds(a, s, { geolocateSource: !0 }); }, this._updateMarker = e => { if (e) { const i = new t.N(e.coords.longitude, e.coords.latitude); this._accuracyCircleMarker.setLngLat(i).addTo(this._map), this._userLocationDotMarker.setLngLat(i).addTo(this._map), this._accuracy = e.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius(); } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove(); }, this._onZoom = () => { this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius(); }, this._onError = e => { if (this._map) { if (this.options.trackUserLocation) if (1 === e.code) { this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0; const e = this._map._getUIString("GeolocateControl.LocationNotAvailable"); this._geolocateButton.title = e, this._geolocateButton.setAttribute("aria-label", e), void 0 !== this._geolocationWatchID && this._clearWatch(); } else { if (3 === e.code && Us) return; this._setErrorState(); } "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new t.k("error", e)), this._finish(); } }, this._finish = () => { this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0; }, this._setupUI = () => { this._map && (this._container.addEventListener("contextmenu", (e => e.preventDefault())), this._geolocateButton = n.create("button", "maplibregl-ctrl-geolocate", this._container), n.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = !0); }, this._finishSetupUI = e => { if (this._map) { if (!1 === e) { t.w("Geolocation support is not available so the GeolocateControl will be disabled."); const e = this._map._getUIString("GeolocateControl.LocationNotAvailable"); this._geolocateButton.disabled = !0, this._geolocateButton.title = e, this._geolocateButton.setAttribute("aria-label", e); } else { const e = this._map._getUIString("GeolocateControl.FindMyLocation"); this._geolocateButton.disabled = !1, this._geolocateButton.title = e, this._geolocateButton.setAttribute("aria-label", e); } this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = n.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new Ns({ element: this._dotElement }), this._circleElement = n.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Ns({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", (() => this.trigger())), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (e => { e.geolocateSource || "ACTIVE_LOCK" !== this._watchState || e.originalEvent && "resize" === e.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new t.k("trackuserlocationend")), this.fire(new t.k("userlocationlostfocus"))); })); } }, this.options = t.e({}, Zs, e); } onAdd(e) { return this._map = e, this._container = n.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), function () { return t._(this, arguments, void 0, (function* (e = !1) { if (void 0 !== Fs && !e) return Fs; if (void 0 === window.navigator.permissions) return Fs = !!window.navigator.geolocation, Fs; try { const e = yield window.navigator.permissions.query({ name: "geolocation" }); Fs = "denied" !== e.state; } catch (e) { Fs = !!window.navigator.geolocation; } return Fs })) }().then((e => this._finishSetupUI(e))), this._container } onRemove() { void 0 !== this._geolocationWatchID && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), n.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, Gs = 0, Us = !1; } _isOutOfMapMaxBounds(e) { const t = this._map.getMaxBounds(), i = e.coords; return t && (i.longitude < t.getWest() || i.longitude > t.getEast() || i.latitude < t.getSouth() || i.latitude > t.getNorth()) } _setErrorState() { switch (this._watchState) { case "WAITING_ACTIVE": this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"); break; case "ACTIVE_LOCK": this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"); break; case "BACKGROUND": this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"); break; case "ACTIVE_ERROR": break; default: throw new Error(`Unexpected watchState ${this._watchState}`) } } _updateCircleRadius() { const e = this._map.getBounds(), t = e.getSouthEast(), i = e.getNorthEast(), r = t.distanceTo(i), o = Math.ceil(this._accuracy / (r / this._map._container.clientHeight) * 2); this._circleElement.style.width = `${o}px`, this._circleElement.style.height = `${o}px`; } trigger() { if (!this._setup) return t.w("Geolocate control triggered before added to a map"), !1; if (this.options.trackUserLocation) { switch (this._watchState) { case "OFF": this._watchState = "WAITING_ACTIVE", this.fire(new t.k("trackuserlocationstart")); break; case "WAITING_ACTIVE": case "ACTIVE_LOCK": case "ACTIVE_ERROR": case "BACKGROUND_ERROR": Gs--, Us = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new t.k("trackuserlocationend")); break; case "BACKGROUND": this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new t.k("trackuserlocationstart")), this.fire(new t.k("userlocationfocus")); break; default: throw new Error(`Unexpected watchState ${this._watchState}`) }switch (this._watchState) { case "WAITING_ACTIVE": this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active"); break; case "ACTIVE_LOCK": this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active"); break; case "OFF": break; default: throw new Error(`Unexpected watchState ${this._watchState}`) }if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch(); else if (void 0 === this._geolocationWatchID) { let e; this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Gs++, Gs > 1 ? (e = { maximumAge: 6e5, timeout: 0 }, Us = !0) : (e = this.options.positionOptions, Us = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, e); } } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4); return !0 } _clearWatch() { window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null); } }, e.GlobeControl = class { constructor() { this._toggleProjection = () => { var e; const t = null === (e = this._map.getProjection()) || void 0 === e ? void 0 : e.type; this._map.setProjection("mercator" !== t && t ? { type: "mercator" } : { type: "globe" }), this._updateGlobeIcon(); }, this._updateGlobeIcon = () => { var e; this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), "globe" === (null === (e = this._map.getProjection()) || void 0 === e ? void 0 : e.type) ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable")); }; } onAdd(e) { return this._map = e, this._container = n.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = n.create("button", "maplibregl-ctrl-globe", this._container), n.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container } onRemove() { n.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0; } }, e.Hash = wo, e.ImageSource = K, e.KeyboardHandler = ss, e.LngLatBounds = V, e.LogoControl = Ts, e.Map = class extends bs { constructor(e) { var i, r; t.cd.mark(t.ce.create); const o = Object.assign(Object.assign(Object.assign({}, As), e), { canvasContextAttributes: Object.assign(Object.assign({}, As.canvasContextAttributes), e.canvasContextAttributes) }); if (null != o.minZoom && null != o.maxZoom && o.minZoom > o.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom"); if (null != o.minPitch && null != o.maxPitch && o.minPitch > o.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch"); if (null != o.minPitch && o.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0"); if (null != o.maxPitch && o.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180"); const s = new Dt, a = new kt; if (void 0 !== o.minZoom && s.setMinZoom(o.minZoom), void 0 !== o.maxZoom && s.setMaxZoom(o.maxZoom), void 0 !== o.minPitch && s.setMinPitch(o.minPitch), void 0 !== o.maxPitch && s.setMaxPitch(o.maxPitch), void 0 !== o.renderWorldCopies && s.setRenderWorldCopies(o.renderWorldCopies), super(s, a, { bearingSnap: o.bearingSnap }), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new Ps, this._controls = [], this._mapId = t.a1(), this._contextLost = e => { e.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new t.k("webglcontextlost", { originalEvent: e })); }, this._contextRestored = e => { this._setupPainter(), this.resize(), this._update(), this.fire(new t.k("webglcontextrestored", { originalEvent: e })); }, this._onMapScroll = e => { if (e.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1 }, this._onWindowOnline = () => { this._update(); }, this._interactive = o.interactive, this._maxTileCacheSize = o.maxTileCacheSize, this._maxTileCacheZoomLevels = o.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, o.canvasContextAttributes), this._trackResize = !0 === o.trackResize, this._bearingSnap = o.bearingSnap, this._centerClampedToGround = o.centerClampedToGround, this._refreshExpiredTiles = !0 === o.refreshExpiredTiles, this._fadeDuration = o.fadeDuration, this._crossSourceCollisions = !0 === o.crossSourceCollisions, this._collectResourceTiming = !0 === o.collectResourceTiming, this._locale = Object.assign(Object.assign({}, Ds), o.locale), this._clickTolerance = o.clickTolerance, this._overridePixelRatio = o.pixelRatio, this._maxCanvasSize = o.maxCanvasSize, this.transformCameraUpdate = o.transformCameraUpdate, this.cancelPendingTileRequestsWhileZooming = !0 === o.cancelPendingTileRequestsWhileZooming, this._imageQueueHandle = p.addThrottleControl((() => this.isMoving())), this._requestManager = new m(o.transformRequest), "string" == typeof o.container) { if (this._container = document.getElementById(o.container), !this._container) throw new Error(`Container '${o.container}' not found.`) } else { if (!(o.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement."); this._container = o.container; } if (o.maxBounds && this.setMaxBounds(o.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", (() => this._update(!1))), this.on("moveend", (() => this._update(!1))), this.on("zoom", (() => this._update(!0))), this.on("terrain", (() => { this.painter.terrainFacilitator.dirty = !0, this._update(!0); })), this.once("idle", (() => { this._idleTriggered = !0; })), "undefined" != typeof window) { addEventListener("online", this._onWindowOnline, !1); let e = !1; const t = yo((e => { this._trackResize && !this._removed && (this.resize(e), this.redraw()); }), 50); this._resizeObserver = new ResizeObserver((i => { e ? t(i) : e = !0; })), this._resizeObserver.observe(this._container); } this.handlers = new xs(this, o), this._hash = o.hash && new wo("string" == typeof o.hash && o.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: o.center, elevation: o.elevation, zoom: o.zoom, bearing: o.bearing, pitch: o.pitch, roll: o.roll }), o.bounds && (this.resize(), this.fitBounds(o.bounds, t.e({}, o.fitBoundsOptions, { duration: 0 })))); const n = "string" == typeof o.style || !("globe" === (null === (r = null === (i = o.style) || void 0 === i ? void 0 : i.projection) || void 0 === r ? void 0 : r.type)); this.resize(null, n), this._localIdeographFontFamily = o.localIdeographFontFamily, this._validateStyle = o.validateStyle, o.style && this.setStyle(o.style, { localIdeographFontFamily: o.localIdeographFontFamily }), o.attributionControl && this.addControl(new ws("boolean" == typeof o.attributionControl ? void 0 : o.attributionControl)), o.maplibreLogo && this.addControl(new Ts, o.logoPosition), this.on("style.load", (() => { if (n || this._resizeTransform(), this.transform.unmodified) { const e = t.M(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]); this.jumpTo(e); } })), this.on("data", (e => { this._update("style" === e.dataType), this.fire(new t.k(`${e.dataType}data`, e)); })), this.on("dataloading", (e => { this.fire(new t.k(`${e.dataType}dataloading`, e)); })), this.on("dataabort", (e => { this.fire(new t.k("sourcedataabort", e)); })); } _getMapId() { return this._mapId } addControl(e, i) { if (void 0 === i && (i = e.getDefaultPosition ? e.getDefaultPosition() : "top-right"), !e || !e.onAdd) return this.fire(new t.j(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods."))); const r = e.onAdd(this); this._controls.push(e); const o = this._controlPositions[i]; return -1 !== i.indexOf("bottom") ? o.insertBefore(r, o.firstChild) : o.appendChild(r), this } removeControl(e) { if (!e || !e.onRemove) return this.fire(new t.j(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods."))); const i = this._controls.indexOf(e); return i > -1 && this._controls.splice(i, 1), e.onRemove(this), this } hasControl(e) { return this._controls.indexOf(e) > -1 } calculateCameraOptionsFromTo(e, t, i, r) { return null == r && this.terrain && (r = this.terrain.getElevationForLngLatZoom(i, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(e, t, i, r) } resize(e, i = !0) { const [r, o] = this._containerDimensions(), s = this._getClampedPixelRatio(r, o); if (this._resizeCanvas(r, o, s), this.painter.resize(r, o, s), this.painter.overLimit()) { const e = this.painter.context.gl; this._maxCanvasSize = [e.drawingBufferWidth, e.drawingBufferHeight]; const t = this._getClampedPixelRatio(r, o); this._resizeCanvas(r, o, t), this.painter.resize(r, o, t); } this._resizeTransform(i); const a = !this._moving; return a && (this.stop(), this.fire(new t.k("movestart", e)).fire(new t.k("move", e))), this.fire(new t.k("resize", e)), a && this.fire(new t.k("moveend", e)), this } _resizeTransform(e = !0) { var t; const [i, r] = this._containerDimensions(); this.transform.resize(i, r, e), null === (t = this._requestedCameraState) || void 0 === t || t.resize(i, r, e); } _getClampedPixelRatio(e, t) { const { 0: i, 1: r } = this._maxCanvasSize, o = this.getPixelRatio(), s = e * o, a = t * o; return Math.min(s > i ? i / s : 1, a > r ? r / a : 1) * o } getPixelRatio() { var e; return null !== (e = this._overridePixelRatio) && void 0 !== e ? e : devicePixelRatio } setPixelRatio(e) { this._overridePixelRatio = e, this.resize(); } getBounds() { return this.transform.getBounds() } getMaxBounds() { return this.transform.getMaxBounds() } setMaxBounds(e) { return this.transform.setMaxBounds(V.convert(e)), this._update() } setMinZoom(e) { if ((e = null == e ? -2 : e) >= -2 && e <= this.transform.maxZoom) return this.transform.setMinZoom(e), this._update(), this.getZoom() < e && this.setZoom(e), this; throw new Error("minZoom must be between -2 and the current maxZoom, inclusive") } getMinZoom() { return this.transform.minZoom } setMaxZoom(e) { if ((e = null == e ? 22 : e) >= this.transform.minZoom) return this.transform.setMaxZoom(e), this._update(), this.getZoom() > e && this.setZoom(e), this; throw new Error("maxZoom must be greater than the current minZoom") } getMaxZoom() { return this.transform.maxZoom } setMinPitch(e) { if ((e = null == e ? 0 : e) < 0) throw new Error("minPitch must be greater than or equal to 0"); if (e >= 0 && e <= this.transform.maxPitch) return this.transform.setMinPitch(e), this._update(), this.getPitch() < e && this.setPitch(e), this; throw new Error("minPitch must be between 0 and the current maxPitch, inclusive") } getMinPitch() { return this.transform.minPitch } setMaxPitch(e) { if ((e = null == e ? 60 : e) > 180) throw new Error("maxPitch must be less than or equal to 180"); if (e >= this.transform.minPitch) return this.transform.setMaxPitch(e), this._update(), this.getPitch() > e && this.setPitch(e), this; throw new Error("maxPitch must be greater than the current minPitch") } getMaxPitch() { return this.transform.maxPitch } getRenderWorldCopies() { return this.transform.renderWorldCopies } setRenderWorldCopies(e) { return this.transform.setRenderWorldCopies(e), this._update() } project(e) { return this.transform.locationToScreenPoint(t.N.convert(e), this.style && this.terrain) } unproject(e) { return this.transform.screenPointToLocation(t.P.convert(e), this.terrain) } isMoving() { var e; return this._moving || (null === (e = this.handlers) || void 0 === e ? void 0 : e.isMoving()) } isZooming() { var e; return this._zooming || (null === (e = this.handlers) || void 0 === e ? void 0 : e.isZooming()) } isRotating() { var e; return this._rotating || (null === (e = this.handlers) || void 0 === e ? void 0 : e.isRotating()) } _createDelegatedListener(e, t, i) { if ("mouseenter" === e || "mouseover" === e) { let r = !1; const o = o => { const s = t.filter((e => this.getLayer(e))), a = 0 !== s.length ? this.queryRenderedFeatures(o.point, { layers: s }) : []; a.length ? r || (r = !0, i.call(this, new zo(e, this, o.originalEvent, { features: a }))) : r = !1; }; return { layers: t, listener: i, delegates: { mousemove: o, mouseout: () => { r = !1; } } } } if ("mouseleave" === e || "mouseout" === e) { let r = !1; const o = o => { const s = t.filter((e => this.getLayer(e))); (0 !== s.length ? this.queryRenderedFeatures(o.point, { layers: s }) : []).length ? r = !0 : r && (r = !1, i.call(this, new zo(e, this, o.originalEvent))); }, s = t => { r && (r = !1, i.call(this, new zo(e, this, t.originalEvent))); }; return { layers: t, listener: i, delegates: { mousemove: o, mouseout: s } } } { const r = e => { const r = t.filter((e => this.getLayer(e))), o = 0 !== r.length ? this.queryRenderedFeatures(e.point, { layers: r }) : []; o.length && (e.features = o, i.call(this, e), delete e.features); }; return { layers: t, listener: i, delegates: { [e]: r } } } } _saveDelegatedListener(e, t) { this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e] = this._delegatedListeners[e] || [], this._delegatedListeners[e].push(t); } _removeDelegatedListener(e, t, i) { if (!this._delegatedListeners || !this._delegatedListeners[e]) return; const r = this._delegatedListeners[e]; for (let e = 0; e < r.length; e++) { const o = r[e]; if (o.listener === i && o.layers.length === t.length && o.layers.every((e => t.includes(e)))) { for (const e in o.delegates) this.off(e, o.delegates[e]); return void r.splice(e, 1) } } } on(e, t, i) { if (void 0 === i) return super.on(e, t); const r = "string" == typeof t ? [t] : t, o = this._createDelegatedListener(e, r, i); this._saveDelegatedListener(e, o); for (const e in o.delegates) this.on(e, o.delegates[e]); return { unsubscribe: () => { this._removeDelegatedListener(e, r, i); } } } once(e, t, i) { if (void 0 === i) return super.once(e, t); const r = "string" == typeof t ? [t] : t, o = this._createDelegatedListener(e, r, i); for (const t in o.delegates) { const s = o.delegates[t]; o.delegates[t] = (...t) => { this._removeDelegatedListener(e, r, i), s(...t); }; } this._saveDelegatedListener(e, o); for (const e in o.delegates) this.once(e, o.delegates[e]); return this } off(e, t, i) { return void 0 === i ? super.off(e, t) : (this._removeDelegatedListener(e, "string" == typeof t ? [t] : t, i), this) } queryRenderedFeatures(e, i) { if (!this.style) return []; let r; const o = e instanceof t.P || Array.isArray(e), s = o ? e : [[0, 0], [this.transform.width, this.transform.height]]; if (i = i || (o ? {} : e) || {}, s instanceof t.P || "number" == typeof s[0]) r = [t.P.convert(s)]; else { const e = t.P.convert(s[0]), i = t.P.convert(s[1]); r = [e, new t.P(i.x, e.y), i, new t.P(e.x, i.y), e]; } return this.style.queryRenderedFeatures(r, i, this.transform) } querySourceFeatures(e, t) { return this.style.querySourceFeatures(e, t) } setStyle(e, i) { return !1 !== (i = t.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, i)).diff && i.localIdeographFontFamily === this._localIdeographFontFamily && this.style && e ? (this._diffStyle(e, i), this) : (this._localIdeographFontFamily = i.localIdeographFontFamily, this._updateStyle(e, i)) } setTransformRequest(e) { return this._requestManager.setTransformRequest(e), this } _getUIString(e) { const t = this._locale[e]; if (null == t) throw new Error(`Missing UI string '${e}'`); return t } _updateStyle(e, t) { var i, r; if (t.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", (() => this._updateStyle(e, t))); const o = this.style && t.transformStyle ? this.style.serialize() : void 0; return this.style && (this.style.setEventedParent(null), this.style._remove(!e)), e ? (this.style = new gi(this, t || {}), this.style.setEventedParent(this, { style: this.style }), "string" == typeof e ? this.style.loadURL(e, t, o) : this.style.loadJSON(e, t, o), this) : (null === (r = null === (i = this.style) || void 0 === i ? void 0 : i.projection) || void 0 === r || r.destroy(), delete this.style, this) } _lazyInitEmptyStyle() { this.style || (this.style = new gi(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty()); } _diffStyle(e, i) { if ("string" == typeof e) { const r = this._requestManager.transformRequest(e, "Style"); t.h(r, new AbortController).then((e => { this._updateDiff(e.data, i); })).catch((e => { e && this.fire(new t.j(e)); })); } else "object" == typeof e && this._updateDiff(e, i); } _updateDiff(e, i) { try { this.style.setState(e, i) && this._update(!0); } catch (r) { t.w(`Unable to perform style diff: ${r.message || r.error || r}.  Rebuilding the style from scratch.`), this._updateStyle(e, i); } } getStyle() { if (this.style) return this.style.serialize() } isStyleLoaded() { return this.style ? this.style.loaded() : t.w("There is no style added to the map.") } addSource(e, t) { return this._lazyInitEmptyStyle(), this.style.addSource(e, t), this._update(!0) } isSourceLoaded(e) { const i = this.style && this.style.sourceCaches[e]; if (void 0 !== i) return i.loaded(); this.fire(new t.j(new Error(`There is no source with ID '${e}'`))); } setTerrain(e) { if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), e) { const i = this.style.sourceCaches[e.source]; if (!i) throw new Error(`cannot load terrain, because there exists no source with ID: ${e.source}`); null === this.terrain && i.reload(); for (const i in this.style._layers) { const r = this.style._layers[i]; "hillshade" === r.type && r.source === e.source && t.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality."); } this.terrain = new Es(this.painter, i, e), this.painter.renderToTexture = new Rs(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = t => { "style" === t.dataType ? this.terrain.sourceCache.freeRtt() : "source" === t.dataType && t.tile && (t.sourceId !== e.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), this.terrain.sourceCache.freeRtt(t.tile.tileID)); }, this.style.on("data", this._terrainDataCallback); } else this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0); return this.fire(new t.k("terrain", { terrain: e })), this } getTerrain() { var e, t; return null !== (t = null === (e = this.terrain) || void 0 === e ? void 0 : e.options) && void 0 !== t ? t : null } areTilesLoaded() { const e = this.style && this.style.sourceCaches; for (const t in e) { const i = e[t]._tiles; for (const e in i) { const t = i[e]; if ("loaded" !== t.state && "errored" !== t.state) return !1 } } return !0 } removeSource(e) { return this.style.removeSource(e), this._update(!0) } getSource(e) { return this.style.getSource(e) } addImage(e, i, r = {}) { const { pixelRatio: o = 1, sdf: s = !1, stretchX: n, stretchY: l, content: c, textFitWidth: h, textFitHeight: u } = r; if (this._lazyInitEmptyStyle(), !(i instanceof HTMLImageElement || t.b(i))) { if (void 0 === i.width || void 0 === i.height) return this.fire(new t.j(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"))); { const { width: r, height: a, data: d } = i, _ = i; return this.style.addImage(e, { data: new t.R({ width: r, height: a }, new Uint8Array(d)), pixelRatio: o, stretchX: n, stretchY: l, content: c, textFitWidth: h, textFitHeight: u, sdf: s, version: 0, userImage: _ }), _.onAdd && _.onAdd(this, e), this } } { const { width: r, height: d, data: _ } = a.getImageData(i); this.style.addImage(e, { data: new t.R({ width: r, height: d }, _), pixelRatio: o, stretchX: n, stretchY: l, content: c, textFitWidth: h, textFitHeight: u, sdf: s, version: 0 }); } } updateImage(e, i) { const r = this.style.getImage(e); if (!r) return this.fire(new t.j(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead."))); const o = i instanceof HTMLImageElement || t.b(i) ? a.getImageData(i) : i, { width: s, height: n, data: l } = o; if (void 0 === s || void 0 === n) return this.fire(new t.j(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"))); if (s !== r.data.width || n !== r.data.height) return this.fire(new t.j(new Error("The width and height of the updated image must be that same as the previous version of the image"))); const c = !(i instanceof HTMLImageElement || t.b(i)); return r.data.replace(l, c), this.style.updateImage(e, r), this } getImage(e) { return this.style.getImage(e) } hasImage(e) { return e ? !!this.style.getImage(e) : (this.fire(new t.j(new Error("Missing required image id"))), !1) } removeImage(e) { this.style.removeImage(e); } loadImage(e) { return p.getImage(this._requestManager.transformRequest(e, "Image"), new AbortController) } listImages() { return this.style.listImages() } addLayer(e, t) { return this._lazyInitEmptyStyle(), this.style.addLayer(e, t), this._update(!0) } moveLayer(e, t) { return this.style.moveLayer(e, t), this._update(!0) } removeLayer(e) { return this.style.removeLayer(e), this._update(!0) } getLayer(e) { return this.style.getLayer(e) } getLayersOrder() { return this.style.getLayersOrder() } setLayerZoomRange(e, t, i) { return this.style.setLayerZoomRange(e, t, i), this._update(!0) } setFilter(e, t, i = {}) { return this.style.setFilter(e, t, i), this._update(!0) } getFilter(e) { return this.style.getFilter(e) } setPaintProperty(e, t, i, r = {}) { return this.style.setPaintProperty(e, t, i, r), this._update(!0) } getPaintProperty(e, t) { return this.style.getPaintProperty(e, t) } setLayoutProperty(e, t, i, r = {}) { return this.style.setLayoutProperty(e, t, i, r), this._update(!0) } getLayoutProperty(e, t) { return this.style.getLayoutProperty(e, t) } setGlyphs(e, t = {}) { return this._lazyInitEmptyStyle(), this.style.setGlyphs(e, t), this._update(!0) } getGlyphs() { return this.style.getGlyphsUrl() } addSprite(e, t, i = {}) { return this._lazyInitEmptyStyle(), this.style.addSprite(e, t, i, (e => { e || this._update(!0); })), this } removeSprite(e) { return this._lazyInitEmptyStyle(), this.style.removeSprite(e), this._update(!0) } getSprite() { return this.style.getSprite() } setSprite(e, t = {}) { return this._lazyInitEmptyStyle(), this.style.setSprite(e, t, (e => { e || this._update(!0); })), this } setLight(e, t = {}) { return this._lazyInitEmptyStyle(), this.style.setLight(e, t), this._update(!0) } getLight() { return this.style.getLight() } setSky(e, t = {}) { return this._lazyInitEmptyStyle(), this.style.setSky(e, t), this._update(!0) } getSky() { return this.style.getSky() } setFeatureState(e, t) { return this.style.setFeatureState(e, t), this._update() } removeFeatureState(e, t) { return this.style.removeFeatureState(e, t), this._update() } getFeatureState(e) { return this.style.getFeatureState(e) } getContainer() { return this._container } getCanvasContainer() { return this._canvasContainer } getCanvas() { return this._canvas } _containerDimensions() { let e = 0, t = 0; return this._container && (e = this._container.clientWidth || 400, t = this._container.clientHeight || 300), [e, t] } _setupContainer() { const e = this._container; e.classList.add("maplibregl-map"); const t = this._canvasContainer = n.create("div", "maplibregl-canvas-container", e); this._interactive && t.classList.add("maplibregl-interactive"), this._canvas = n.create("canvas", "maplibregl-canvas", t), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region"); const i = this._containerDimensions(), r = this._getClampedPixelRatio(i[0], i[1]); this._resizeCanvas(i[0], i[1], r); const o = this._controlContainer = n.create("div", "maplibregl-control-container", e), s = this._controlPositions = {};["top-left", "top-right", "bottom-left", "bottom-right"].forEach((e => { s[e] = n.create("div", `maplibregl-ctrl-${e} `, o); })), this._container.addEventListener("scroll", this._onMapScroll, !1); } _resizeCanvas(e, t, i) { this._canvas.width = Math.floor(i * e), this._canvas.height = Math.floor(i * t), this._canvas.style.width = `${e}px`, this._canvas.style.height = `${t}px`; } _setupPainter() { const e = Object.assign(Object.assign({}, this._canvasContextAttributes), { alpha: !0, depth: !0, stencil: !0, premultipliedAlpha: !0 }); let t = null; this._canvas.addEventListener("webglcontextcreationerror", (i => { t = { requestedAttributes: e }, i && (t.statusMessage = i.statusMessage, t.type = i.type); }), { once: !0 }); let i = null; if (i = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, e) : this._canvas.getContext("webgl2", e) || this._canvas.getContext("webgl", e), !i) { const e = "Failed to initialize WebGL"; throw t ? (t.message = e, new Error(JSON.stringify(t))) : new Error(e) } this.painter = new bo(i, this.transform), l.testSupport(i); } migrateProjection(e, i) { super.migrateProjection(e, i), this.painter.transform = e, this.fire(new t.k("projectiontransition", { newProjection: this.style.projection.name })); } loaded() { return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded() } _update(e) { return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || e, this._sourcesDirty = !0, this.triggerRepaint(), this) : this } _requestRenderFrame(e) { return this._update(), this._renderTaskQueue.add(e) } _cancelRenderFrame(e) { this._renderTaskQueue.remove(e); } _render(e) { var i, r, o, s, n; const l = this._idleTriggered ? this._fadeDuration : 0, c = (null === (i = this.style.projection) || void 0 === i ? void 0 : i.transitionState) > 0; if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(e), this._removed) return; let h = !1; if (this.style && this._styleDirty) { this._styleDirty = !1; const e = this.transform.zoom, i = a.now(); this.style.zoomHistory.update(e, i); const r = new t.z(e, { now: i, fadeDuration: l, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), o = r.crossFadingFactor(); 1 === o && o === this._crossFadingFactor || (h = !0, this._crossFadingFactor = o), this.style.update(r); } const u = (null === (r = this.style.projection) || void 0 === r ? void 0 : r.transitionState) > 0 !== c; null === (o = this.style.projection) || void 0 === o || o.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState(null === (s = this.style.projection) || void 0 === s ? void 0 : s.transitionState, null === (n = this.style.projection) || void 0 === n ? void 0 : n.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || u) && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, l, this._crossSourceCollisions, u), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: l, showPadding: this.showPadding }), this.fire(new t.k("render")), this.loaded() && !this._loaded && (this._loaded = !0, t.cd.mark(t.ce.load), this.fire(new t.k("load"))), this.style && (this.style.hasTransitions() || h) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(); const d = this._sourcesDirty || this._styleDirty || this._placementDirty; return d || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new t.k("idle")), !this._loaded || this._fullyLoaded || d || (this._fullyLoaded = !0, t.cd.mark(t.ce.fullLoad)), this } redraw() { return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this } remove() { var e; this._hash && this._hash.remove(); for (const e of this._controls) e.onRemove(this); this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), "undefined" != typeof window && removeEventListener("online", this._onWindowOnline, !1), p.removeThrottleControl(this._imageQueueHandle), null === (e = this._resizeObserver) || void 0 === e || e.disconnect(); const i = this.painter.context.gl.getExtension("WEBGL_lose_context"); (null == i ? void 0 : i.loseContext) && i.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), n.remove(this._canvasContainer), n.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, !1), this._container.classList.remove("maplibregl-map"), t.cd.clearMetrics(), this._removed = !0, this.fire(new t.k("remove")); } triggerRepaint() { this.style && !this._frameRequest && (this._frameRequest = new AbortController, a.frame(this._frameRequest, (e => { t.cd.frame(e), this._frameRequest = null; try { this._render(e); } catch (e) { if (!t.cf(e) && !function (e) { return e.message === Or }(e)) throw e } }), (() => { }))); } get showTileBoundaries() { return !!this._showTileBoundaries } set showTileBoundaries(e) { this._showTileBoundaries !== e && (this._showTileBoundaries = e, this._update()); } get showPadding() { return !!this._showPadding } set showPadding(e) { this._showPadding !== e && (this._showPadding = e, this._update()); } get showCollisionBoxes() { return !!this._showCollisionBoxes } set showCollisionBoxes(e) { this._showCollisionBoxes !== e && (this._showCollisionBoxes = e, e ? this.style._generateCollisionBoxes() : this._update()); } get showOverdrawInspector() { return !!this._showOverdrawInspector } set showOverdrawInspector(e) { this._showOverdrawInspector !== e && (this._showOverdrawInspector = e, this._update()); } get repaint() { return !!this._repaint } set repaint(e) { this._repaint !== e && (this._repaint = e, this.triggerRepaint()); } get vertices() { return !!this._vertices } set vertices(e) { this._vertices = e, this._update(); } get version() { return zs } getCameraTargetElevation() { return this.transform.elevation } getProjection() { return this.style.getProjection() } setProjection(e) { return this._lazyInitEmptyStyle(), this.style.setProjection(e), this._update(!0) } }, e.MapMouseEvent = zo, e.MapTouchEvent = Ao, e.MapWheelEvent = Lo, e.Marker = Ns, e.NavigationControl = class { constructor(e) { this._updateZoomButtons = () => { const e = this._map.getZoom(), t = e === this._map.getMaxZoom(), i = e === this._map.getMinZoom(); this._zoomInButton.disabled = t, this._zoomOutButton.disabled = i, this._zoomInButton.setAttribute("aria-disabled", t.toString()), this._zoomOutButton.setAttribute("aria-disabled", i.toString()); }, this._rotateCompassArrow = () => { this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), .5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), .5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing - this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`; }, this._setButtonTitle = (e, t) => { const i = this._map._getUIString(`NavigationControl.${t}`); e.title = i, e.setAttribute("aria-label", i); }, this.options = t.e({}, Ls, e), this._container = n.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (e => e.preventDefault())), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (e => this._map.zoomIn({}, { originalEvent: e }))), n.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (e => this._map.zoomOut({}, { originalEvent: e }))), n.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (e => { this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: e }) : this._map.resetNorth({}, { originalEvent: e }); })), this._compassIcon = n.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true")); } onAdd(e) { return this._map = e, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new ks(this._map, this._compass, this.options.visualizePitch)), this._container } onRemove() { n.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map; } _createButton(e, t) { const i = n.create("button", e, this._container); return i.type = "button", i.addEventListener("click", t), i } }, e.Popup = class extends t.E { constructor(e) { super(), this.remove = () => (this._content && n.remove(this._content), this._container && (n.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new t.k("close"))), this), this._onMouseUp = e => { this._update(e.point); }, this._onMouseMove = e => { this._update(e.point); }, this._onDrag = e => { this._update(e.point); }, this._update = e => { var t; if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return; if (!this._container) { if (this._container = n.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = n.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const e of this.options.className.split(" ")) this._container.classList.add(e); this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer"); } if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = this._map.transform.renderWorldCopies && !this._trackPointer ? Bs(this._lngLat, this._flatPos, this._map.transform) : null === (t = this._lngLat) || void 0 === t ? void 0 : t.wrap(), this._trackPointer && !e) return; const i = this._flatPos = this._pos = this._trackPointer && e ? e : this._map.project(this._lngLat); this._map.terrain && (this._flatPos = this._trackPointer && e ? e : this._map.transform.locationToScreenPoint(this._lngLat)); let r = this.options.anchor; const o = $s(this.options.offset); if (!r) { const e = this._container.offsetWidth, t = this._container.offsetHeight; let s; s = i.y + o.bottom.y < t ? ["top"] : i.y > this._map.transform.height - t ? ["bottom"] : [], i.x < e / 2 ? s.push("left") : i.x > this._map.transform.width - e / 2 && s.push("right"), r = 0 === s.length ? "bottom" : s.join("-"); } let s = i.add(o[r]); this.options.subpixelPositioning || (s = s.round()), n.setTransform(this._container, `${js[r]} translate(${s.x}px,${s.y}px)`), Os(this._container, r, "popup"); }, this._onClose = () => { this.remove(); }, this.options = t.e(Object.create(Ws), e); } addTo(e) { return this._map && this.remove(), this._map = e, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new t.k("open")), this } isOpen() { return !!this._map } getLngLat() { return this._lngLat } setLngLat(e) { return this._lngLat = t.N.convert(e), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this } trackPointer() { return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this } getElement() { return this._container } setText(e) { return this.setDOMContent(document.createTextNode(e)) } setHTML(e) { const t = document.createDocumentFragment(), i = document.createElement("body"); let r; for (i.innerHTML = e; r = i.firstChild, r;)t.appendChild(r); return this.setDOMContent(t) } getMaxWidth() { var e; return null === (e = this._container) || void 0 === e ? void 0 : e.style.maxWidth } setMaxWidth(e) { return this.options.maxWidth = e, this._update(), this } setDOMContent(e) { if (this._content) for (; this._content.hasChildNodes();)this._content.firstChild && this._content.removeChild(this._content.firstChild); else this._content = n.create("div", "maplibregl-popup-content", this._container); return this._content.appendChild(e), this._createCloseButton(), this._update(), this._focusFirstElement(), this } addClassName(e) { return this._container && this._container.classList.add(e), this } removeClassName(e) { return this._container && this._container.classList.remove(e), this } setOffset(e) { return this.options.offset = e, this._update(), this } toggleClassName(e) { if (this._container) return this._container.classList.toggle(e) } setSubpixelPositioning(e) { this.options.subpixelPositioning = e; } _createCloseButton() { this.options.closeButton && (this._closeButton = n.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose)); } _focusFirstElement() { if (!this.options.focusAfterOpen || !this._container) return; const e = this._container.querySelector(Xs); e && e.focus(); } }, e.RasterDEMTileSource = X, e.RasterTileSource = W, e.ScaleControl = class { constructor(e) { this._onMove = () => { qs(this._map, this._container, this.options); }, this.setUnit = e => { this.options.unit = e, qs(this._map, this._container, this.options); }, this.options = Object.assign(Object.assign({}, Vs), e); } getDefaultPosition() { return "bottom-left" } onAdd(e) { return this._map = e, this._container = n.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", e.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container } onRemove() { n.remove(this._container), this._map.off("move", this._onMove), this._map = void 0; } }, e.ScrollZoomHandler = ls, e.Style = gi, e.TerrainControl = class { constructor(e) { this._toggleTerrain = () => { this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon(); }, this._updateTerrainIcon = () => { this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable")); }, this.options = e; } onAdd(e) { return this._map = e, this._container = n.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = n.create("button", "maplibregl-ctrl-terrain", this._container), n.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container } onRemove() { n.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0; } }, e.TwoFingersTouchPitchHandler = rs, e.TwoFingersTouchRotateHandler = ts, e.TwoFingersTouchZoomHandler = Qo, e.TwoFingersTouchZoomRotateHandler = ps, e.VectorTileSource = H, e.VideoSource = Y, e.addSourceType = (e, i) => t._(void 0, void 0, void 0, (function* () { if (ee(e)) throw new Error(`A source type called "${e}" already exists.`); ((e, t) => { Q[e] = t; })(e, i); })), e.clearPrewarmedResources = function () { const e = L; e && (e.isPreloaded() && 1 === e.numActive() ? (e.release(D), L = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()")); }, e.createTileMesh = Ht, e.getMaxParallelImageRequests = function () { return t.a.MAX_PARALLEL_IMAGE_REQUESTS }, e.getRTLTextPluginStatus = function () { return oe().getRTLTextPluginStatus() }, e.getVersion = function () { return Ks }, e.getWorkerCount = function () { return z.workerCount }, e.getWorkerUrl = function () { return t.a.WORKER_URL }, e.importScriptInWorkers = function (e) { return j().broadcast("IS", e) }, e.prewarm = function () { F().acquire(D); }, e.setMaxParallelImageRequests = function (e) { t.a.MAX_PARALLEL_IMAGE_REQUESTS = e; }, e.setRTLTextPlugin = function (e, t) { return oe().setRTLTextPlugin(e, t) }, e.setWorkerCount = function (e) { z.workerCount = e; }, e.setWorkerUrl = function (e) { t.a.WORKER_URL = e; }; }));

            //
            // Our custom intro provides a specialized "define()" function, called by the
            // AMD modules below, that sets up the worker blob URL and then executes the
            // main module, storing its exported value as 'maplibregl'


            var maplibregl$1 = maplibregl;

            return maplibregl$1;

        }));
        //# sourceMappingURL=maplibre-gl.js.map
    </script>
    <style>
        .maplibregl-map {
            font: 12px/20px Helvetica Neue, Arial, Helvetica, sans-serif;
            overflow: hidden;
            position: relative;
            -webkit-tap-highlight-color: rgb(0 0 0/0)
        }

        .maplibregl-canvas {
            left: 0;
            position: absolute;
            top: 0
        }

        .maplibregl-map:fullscreen {
            height: 100%;
            width: 100%
        }

        .maplibregl-ctrl-group button.maplibregl-ctrl-compass {
            touch-action: none
        }

        .maplibregl-canvas-container.maplibregl-interactive,
        .maplibregl-ctrl-group button.maplibregl-ctrl-compass {
            cursor: grab;
            -webkit-user-select: none;
            -moz-user-select: none;
            user-select: none
        }

        .maplibregl-canvas-container.maplibregl-interactive.maplibregl-track-pointer {
            cursor: pointer
        }

        .maplibregl-canvas-container.maplibregl-interactive:active,
        .maplibregl-ctrl-group button.maplibregl-ctrl-compass:active {
            cursor: grabbing
        }

        .maplibregl-canvas-container.maplibregl-touch-zoom-rotate,
        .maplibregl-canvas-container.maplibregl-touch-zoom-rotate .maplibregl-canvas {
            touch-action: pan-x pan-y
        }

        .maplibregl-canvas-container.maplibregl-touch-drag-pan,
        .maplibregl-canvas-container.maplibregl-touch-drag-pan .maplibregl-canvas {
            touch-action: pinch-zoom
        }

        .maplibregl-canvas-container.maplibregl-touch-zoom-rotate.maplibregl-touch-drag-pan,
        .maplibregl-canvas-container.maplibregl-touch-zoom-rotate.maplibregl-touch-drag-pan .maplibregl-canvas {
            touch-action: none
        }

        .maplibregl-canvas-container.maplibregl-touch-drag-pan.maplibregl-cooperative-gestures,
        .maplibregl-canvas-container.maplibregl-touch-drag-pan.maplibregl-cooperative-gestures .maplibregl-canvas {
            touch-action: pan-x pan-y
        }

        .maplibregl-ctrl-bottom-left,
        .maplibregl-ctrl-bottom-right,
        .maplibregl-ctrl-top-left,
        .maplibregl-ctrl-top-right {
            pointer-events: none;
            position: absolute;
            z-index: 2
        }

        .maplibregl-ctrl-top-left {
            left: 0;
            top: 0
        }

        .maplibregl-ctrl-top-right {
            right: 0;
            top: 0
        }

        .maplibregl-ctrl-bottom-left {
            bottom: 0;
            left: 0
        }

        .maplibregl-ctrl-bottom-right {
            bottom: 0;
            right: 0
        }

        .maplibregl-ctrl {
            clear: both;
            pointer-events: auto;
            transform: translate(0)
        }

        .maplibregl-ctrl-top-left .maplibregl-ctrl {
            float: left;
            margin: 10px 0 0 10px
        }

        .maplibregl-ctrl-top-right .maplibregl-ctrl {
            float: right;
            margin: 10px 10px 0 0
        }

        .maplibregl-ctrl-bottom-left .maplibregl-ctrl {
            float: left;
            margin: 0 0 10px 10px
        }

        .maplibregl-ctrl-bottom-right .maplibregl-ctrl {
            float: right;
            margin: 0 10px 10px 0
        }

        .maplibregl-ctrl-group {
            background: #fff;
            border-radius: 4px
        }

        .maplibregl-ctrl-group:not(:empty) {
            box-shadow: 0 0 0 2px rgba(0, 0, 0, .1)
        }

        @media (forced-colors:active) {
            .maplibregl-ctrl-group:not(:empty) {
                box-shadow: 0 0 0 2px ButtonText
            }
        }

        .maplibregl-ctrl-group button {
            background-color: transparent;
            border: 0;
            box-sizing: border-box;
            cursor: pointer;
            display: block;
            height: 29px;
            outline: none;
            padding: 0;
            width: 29px
        }

        .maplibregl-ctrl-group button+button {
            border-top: 1px solid #ddd
        }

        .maplibregl-ctrl button .maplibregl-ctrl-icon {
            background-position: 50%;
            background-repeat: no-repeat;
            display: block;
            height: 100%;
            width: 100%
        }

        @media (forced-colors:active) {
            .maplibregl-ctrl-icon {
                background-color: transparent
            }

            .maplibregl-ctrl-group button+button {
                border-top: 1px solid ButtonText
            }
        }

        .maplibregl-ctrl button::-moz-focus-inner {
            border: 0;
            padding: 0
        }

        .maplibregl-ctrl-attrib-button:focus,
        .maplibregl-ctrl-group button:focus {
            box-shadow: 0 0 2px 2px #0096ff
        }

        .maplibregl-ctrl button:disabled {
            cursor: not-allowed
        }

        .maplibregl-ctrl button:disabled .maplibregl-ctrl-icon {
            opacity: .25
        }

        @media (hover:hover) {
            .maplibregl-ctrl button:not(:disabled):hover {
                background-color: rgb(0 0 0/5%)
            }
        }

        .maplibregl-ctrl button:not(:disabled):active {
            background-color: rgb(0 0 0/5%)
        }

        .maplibregl-ctrl-group button:focus:focus-visible {
            box-shadow: 0 0 2px 2px #0096ff
        }

        .maplibregl-ctrl-group button:focus:not(:focus-visible) {
            box-shadow: none
        }

        .maplibregl-ctrl-group button:focus:first-child {
            border-radius: 4px 4px 0 0
        }

        .maplibregl-ctrl-group button:focus:last-child {
            border-radius: 0 0 4px 4px
        }

        .maplibregl-ctrl-group button:focus:only-child {
            border-radius: inherit
        }

        .maplibregl-ctrl button.maplibregl-ctrl-zoom-out .maplibregl-ctrl-icon {
            background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23333' viewBox='0 0 29 29'%3E%3Cpath d='M10 13c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h9c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13z'/%3E%3C/svg%3E")
        }

        .maplibregl-ctrl button.maplibregl-ctrl-zoom-in .maplibregl-ctrl-icon {
            background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23333' viewBox='0 0 29 29'%3E%3Cpath d='M14.5 8.5c-.75 0-1.5.75-1.5 1.5v3h-3c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h3v3c0 .75.75 1.5 1.5 1.5S16 19.75 16 19v-3h3c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-3v-3c0-.75-.75-1.5-1.5-1.5'/%3E%3C/svg%3E")
        }

        @media (forced-colors:active) {
            .maplibregl-ctrl button.maplibregl-ctrl-zoom-out .maplibregl-ctrl-icon {
                background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23fff' viewBox='0 0 29 29'%3E%3Cpath d='M10 13c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h9c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13z'/%3E%3C/svg%3E")
            }

            .maplibregl-ctrl button.maplibregl-ctrl-zoom-in .maplibregl-ctrl-icon {
                background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23fff' viewBox='0 0 29 29'%3E%3Cpath d='M14.5 8.5c-.75 0-1.5.75-1.5 1.5v3h-3c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h3v3c0 .75.75 1.5 1.5 1.5S16 19.75 16 19v-3h3c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-3v-3c0-.75-.75-1.5-1.5-1.5'/%3E%3C/svg%3E")
            }
        }

        @media (forced-colors:active) and (prefers-color-scheme:light) {
            .maplibregl-ctrl button.maplibregl-ctrl-zoom-out .maplibregl-ctrl-icon {
                background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' viewBox='0 0 29 29'%3E%3Cpath d='M10 13c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h9c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13z'/%3E%3C/svg%3E")
            }

            .maplibregl-ctrl button.maplibregl-ctrl-zoom-in .maplibregl-ctrl-icon {
                background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' viewBox='0 0 29 29'%3E%3Cpath d='M14.5 8.5c-.75 0-1.5.75-1.5 1.5v3h-3c-.75 0-1.5.75-1.5 1.5S9.25 16 10 16h3v3c0 .75.75 1.5 1.5 1.5S16 19.75 16 19v-3h3c.75 0 1.5-.75 1.5-1.5S19.75 13 19 13h-3v-3c0-.75-.75-1.5-1.5-1.5'/%3E%3C/svg%3E")
            }
        }

        .maplibregl-ctrl button.maplibregl-ctrl-fullscreen .maplibregl-ctrl-icon {
            background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23333' viewBox='0 0 29 29'%3E%3Cpath d='M24 16v5.5c0 1.75-.75 2.5-2.5 2.5H16v-1l3-1.5-4-5.5 1-1 5.5 4 1.5-3zM6 16l1.5 3 5.5-4 1 1-4 5.5 3 1.5v1H7.5C5.75 24 5 23.25 5 21.5V16zm7-11v1l-3 1.5 4 5.5-1 1-5.5-4L6 13H5V7.5C5 5.75 5.75 5 7.5 5zm11 2.5c0-1.75-.75-2.5-2.5-2.5H16v1l3 1.5-4 5.5 1 1 5.5-4 1.5 3h1z'/%3E%3C/svg%3E")
        }

        .maplibregl-ctrl button.maplibregl-ctrl-shrink .maplibregl-ctrl-icon {
            background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' viewBox='0 0 29 29'%3E%3Cpath d='M18.5 16c-1.75 0-2.5.75-2.5 2.5V24h1l1.5-3 5.5 4 1-1-4-5.5 3-1.5v-1zM13 18.5c0-1.75-.75-2.5-2.5-2.5H5v1l3 1.5L4 24l1 1 5.5-4 1.5 3h1zm3-8c0 1.75.75 2.5 2.5 2.5H24v-1l-3-1.5L25 5l-1-1-5.5 4L17 5h-1zM10.5 13c1.75 0 2.5-.75 2.5-2.5V5h-1l-1.5 3L5 4 4 5l4 5.5L5 12v1z'/%3E%3C/svg%3E")
        }

        @media (forced-colors:active) {
            .maplibregl-ctrl button.maplibregl-ctrl-fullscreen .maplibregl-ctrl-icon {
                background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23fff' viewBox='0 0 29 29'%3E%3Cpath d='M24 16v5.5c0 1.75-.75 2.5-2.5 2.5H16v-1l3-1.5-4-5.5 1-1 5.5 4 1.5-3zM6 16l1.5 3 5.5-4 1 1-4 5.5 3 1.5v1H7.5C5.75 24 5 23.25 5 21.5V16zm7-11v1l-3 1.5 4 5.5-1 1-5.5-4L6 13H5V7.5C5 5.75 5.75 5 7.5 5zm11 2.5c0-1.75-.75-2.5-2.5-2.5H16v1l3 1.5-4 5.5 1 1 5.5-4 1.5 3h1z'/%3E%3C/svg%3E")
            }

            .maplibregl-ctrl button.maplibregl-ctrl-shrink .maplibregl-ctrl-icon {
                background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23fff' viewBox='0 0 29 29'%3E%3Cpath d='M18.5 16c-1.75 0-2.5.75-2.5 2.5V24h1l1.5-3 5.5 4 1-1-4-5.5 3-1.5v-1zM13 18.5c0-1.75-.75-2.5-2.5-2.5H5v1l3 1.5L4 24l1 1 5.5-4 1.5 3h1zm3-8c0 1.75.75 2.5 2.5 2.5H24v-1l-3-1.5L25 5l-1-1-5.5 4L17 5h-1zM10.5 13c1.75 0 2.5-.75 2.5-2.5V5h-1l-1.5 3L5 4 4 5l4 5.5L5 12v1z'/%3E%3C/svg%3E")
            }
        }

        @media (forced-colors:active) and (prefers-color-scheme:light) {
            .maplibregl-ctrl button.maplibregl-ctrl-fullscreen .maplibregl-ctrl-icon {
                background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' viewBox='0 0 29 29'%3E%3Cpath d='M24 16v5.5c0 1.75-.75 2.5-2.5 2.5H16v-1l3-1.5-4-5.5 1-1 5.5 4 1.5-3zM6 16l1.5 3 5.5-4 1 1-4 5.5 3 1.5v1H7.5C5.75 24 5 23.25 5 21.5V16zm7-11v1l-3 1.5 4 5.5-1 1-5.5-4L6 13H5V7.5C5 5.75 5.75 5 7.5 5zm11 2.5c0-1.75-.75-2.5-2.5-2.5H16v1l3 1.5-4 5.5 1 1 5.5-4 1.5 3h1z'/%3E%3C/svg%3E")
            }

            .maplibregl-ctrl button.maplibregl-ctrl-shrink .maplibregl-ctrl-icon {
                background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' viewBox='0 0 29 29'%3E%3Cpath d='M18.5 16c-1.75 0-2.5.75-2.5 2.5V24h1l1.5-3 5.5 4 1-1-4-5.5 3-1.5v-1zM13 18.5c0-1.75-.75-2.5-2.5-2.5H5v1l3 1.5L4 24l1 1 5.5-4 1.5 3h1zm3-8c0 1.75.75 2.5 2.5 2.5H24v-1l-3-1.5L25 5l-1-1-5.5 4L17 5h-1zM10.5 13c1.75 0 2.5-.75 2.5-2.5V5h-1l-1.5 3L5 4 4 5l4 5.5L5 12v1z'/%3E%3C/svg%3E")
            }
        }

        .maplibregl-ctrl button.maplibregl-ctrl-compass .maplibregl-ctrl-icon {
            background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23333' viewBox='0 0 29 29'%3E%3Cpath d='m10.5 14 4-8 4 8z'/%3E%3Cpath fill='%23ccc' d='m10.5 16 4 8 4-8z'/%3E%3C/svg%3E")
        }

        @media (forced-colors:active) {
            .maplibregl-ctrl button.maplibregl-ctrl-compass .maplibregl-ctrl-icon {
                background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23fff' viewBox='0 0 29 29'%3E%3Cpath d='m10.5 14 4-8 4 8z'/%3E%3Cpath fill='%23ccc' d='m10.5 16 4 8 4-8z'/%3E%3C/svg%3E")
            }
        }

        @media (forced-colors:active) and (prefers-color-scheme:light) {
            .maplibregl-ctrl button.maplibregl-ctrl-compass .maplibregl-ctrl-icon {
                background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' viewBox='0 0 29 29'%3E%3Cpath d='m10.5 14 4-8 4 8z'/%3E%3Cpath fill='%23ccc' d='m10.5 16 4 8 4-8z'/%3E%3C/svg%3E")
            }
        }

        .maplibregl-ctrl button.maplibregl-ctrl-globe .maplibregl-ctrl-icon {
            background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='22' height='22' fill='none' stroke='%23333' viewBox='0 0 22 22'%3E%3Ccircle cx='11' cy='11' r='8.5'/%3E%3Cpath d='M17.5 11c0 4.819-3.02 8.5-6.5 8.5S4.5 15.819 4.5 11 7.52 2.5 11 2.5s6.5 3.681 6.5 8.5Z'/%3E%3Cpath d='M13.5 11c0 2.447-.331 4.64-.853 6.206-.262.785-.562 1.384-.872 1.777-.314.399-.58.517-.775.517s-.461-.118-.775-.517c-.31-.393-.61-.992-.872-1.777C8.831 15.64 8.5 13.446 8.5 11s.331-4.64.853-6.206c.262-.785.562-1.384.872-1.777.314-.399.58-.517.775-.517s.461.118.775.517c.31.393.61.992.872 1.777.522 1.565.853 3.76.853 6.206Z'/%3E%3Cpath d='M11 7.5c-1.909 0-3.622-.166-4.845-.428-.616-.132-1.08-.283-1.379-.434a1.3 1.3 0 0 1-.224-.138q.07-.058.224-.138c.299-.151.763-.302 1.379-.434C7.378 5.666 9.091 5.5 11 5.5s3.622.166 4.845.428c.616.132 1.08.283 1.379.434.105.053.177.1.224.138q-.07.058-.224.138c-.299.151-.763.302-1.379.434-1.223.262-2.936.428-4.845.428ZM4.486 6.436ZM11 16.5c-1.909 0-3.622-.166-4.845-.428-.616-.132-1.08-.283-1.379-.434a1.3 1.3 0 0 1-.224-.138 1.3 1.3 0 0 1 .224-.138c.299-.151.763-.302 1.379-.434C7.378 14.666 9.091 14.5 11 14.5s3.622.166 4.845.428c.616.132 1.08.283 1.379.434.105.053.177.1.224.138a1.3 1.3 0 0 1-.224.138c-.299.151-.763.302-1.379.434-1.223.262-2.936.428-4.845.428Zm-6.514-1.064ZM11 12.5c-2.46 0-4.672-.222-6.255-.574-.796-.177-1.406-.38-1.805-.59a1.5 1.5 0 0 1-.39-.272.3.3 0 0 1-.047-.064.3.3 0 0 1 .048-.064c.066-.073.189-.167.389-.272.399-.21 1.009-.413 1.805-.59C6.328 9.722 8.54 9.5 11 9.5s4.672.222 6.256.574c.795.177 1.405.38 1.804.59.2.105.323.2.39.272a.3.3 0 0 1 .047.064.3.3 0 0 1-.048.064 1.4 1.4 0 0 1-.389.272c-.399.21-1.009.413-1.804.59-1.584.352-3.796.574-6.256.574Zm-8.501-1.51v.002zm0 .018v.002zm17.002.002v-.002zm0-.018v-.002z'/%3E%3C/svg%3E")
        }

        .maplibregl-ctrl button.maplibregl-ctrl-globe-enabled .maplibregl-ctrl-icon {
            background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='22' height='22' fill='none' stroke='%2333b5e5' viewBox='0 0 22 22'%3E%3Ccircle cx='11' cy='11' r='8.5'/%3E%3Cpath d='M17.5 11c0 4.819-3.02 8.5-6.5 8.5S4.5 15.819 4.5 11 7.52 2.5 11 2.5s6.5 3.681 6.5 8.5Z'/%3E%3Cpath d='M13.5 11c0 2.447-.331 4.64-.853 6.206-.262.785-.562 1.384-.872 1.777-.314.399-.58.517-.775.517s-.461-.118-.775-.517c-.31-.393-.61-.992-.872-1.777C8.831 15.64 8.5 13.446 8.5 11s.331-4.64.853-6.206c.262-.785.562-1.384.872-1.777.314-.399.58-.517.775-.517s.461.118.775.517c.31.393.61.992.872 1.777.522 1.565.853 3.76.853 6.206Z'/%3E%3Cpath d='M11 7.5c-1.909 0-3.622-.166-4.845-.428-.616-.132-1.08-.283-1.379-.434a1.3 1.3 0 0 1-.224-.138q.07-.058.224-.138c.299-.151.763-.302 1.379-.434C7.378 5.666 9.091 5.5 11 5.5s3.622.166 4.845.428c.616.132 1.08.283 1.379.434.105.053.177.1.224.138q-.07.058-.224.138c-.299.151-.763.302-1.379.434-1.223.262-2.936.428-4.845.428ZM4.486 6.436ZM11 16.5c-1.909 0-3.622-.166-4.845-.428-.616-.132-1.08-.283-1.379-.434a1.3 1.3 0 0 1-.224-.138 1.3 1.3 0 0 1 .224-.138c.299-.151.763-.302 1.379-.434C7.378 14.666 9.091 14.5 11 14.5s3.622.166 4.845.428c.616.132 1.08.283 1.379.434.105.053.177.1.224.138a1.3 1.3 0 0 1-.224.138c-.299.151-.763.302-1.379.434-1.223.262-2.936.428-4.845.428Zm-6.514-1.064ZM11 12.5c-2.46 0-4.672-.222-6.255-.574-.796-.177-1.406-.38-1.805-.59a1.5 1.5 0 0 1-.39-.272.3.3 0 0 1-.047-.064.3.3 0 0 1 .048-.064c.066-.073.189-.167.389-.272.399-.21 1.009-.413 1.805-.59C6.328 9.722 8.54 9.5 11 9.5s4.672.222 6.256.574c.795.177 1.405.38 1.804.59.2.105.323.2.39.272a.3.3 0 0 1 .047.064.3.3 0 0 1-.048.064 1.4 1.4 0 0 1-.389.272c-.399.21-1.009.413-1.804.59-1.584.352-3.796.574-6.256.574Zm-8.501-1.51v.002zm0 .018v.002zm17.002.002v-.002zm0-.018v-.002z'/%3E%3C/svg%3E")
        }

        .maplibregl-ctrl button.maplibregl-ctrl-terrain .maplibregl-ctrl-icon {
            background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='22' height='22' fill='%23333' viewBox='0 0 22 22'%3E%3Cpath d='m1.754 13.406 4.453-4.851 3.09 3.09 3.281 3.277.969-.969-3.309-3.312 3.844-4.121 6.148 6.886h1.082v-.855l-7.207-8.07-4.84 5.187L6.169 6.57l-5.48 5.965v.871ZM.688 16.844h20.625v1.375H.688Zm0 0'/%3E%3C/svg%3E")
        }

        .maplibregl-ctrl button.maplibregl-ctrl-terrain-enabled .maplibregl-ctrl-icon {
            background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='22' height='22' fill='%2333b5e5' viewBox='0 0 22 22'%3E%3Cpath d='m1.754 13.406 4.453-4.851 3.09 3.09 3.281 3.277.969-.969-3.309-3.312 3.844-4.121 6.148 6.886h1.082v-.855l-7.207-8.07-4.84 5.187L6.169 6.57l-5.48 5.965v.871ZM.688 16.844h20.625v1.375H.688Zm0 0'/%3E%3C/svg%3E")
        }

        .maplibregl-ctrl button.maplibregl-ctrl-geolocate .maplibregl-ctrl-icon {
            background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23333' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E")
        }

        .maplibregl-ctrl button.maplibregl-ctrl-geolocate:disabled .maplibregl-ctrl-icon {
            background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23aaa' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3Cpath fill='red' d='m14 5 1 1-9 9-1-1z'/%3E%3C/svg%3E")
        }

        .maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-active .maplibregl-ctrl-icon {
            background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%2333b5e5' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E")
        }

        .maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-active-error .maplibregl-ctrl-icon {
            background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23e58978' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E")
        }

        .maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-background .maplibregl-ctrl-icon {
            background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%2333b5e5' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3C/svg%3E")
        }

        .maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-background-error .maplibregl-ctrl-icon {
            background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23e54e33' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3C/svg%3E")
        }

        .maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-waiting .maplibregl-ctrl-icon {
            animation: maplibregl-spin 2s linear infinite
        }

        @media (forced-colors:active) {
            .maplibregl-ctrl button.maplibregl-ctrl-geolocate .maplibregl-ctrl-icon {
                background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23fff' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E")
            }

            .maplibregl-ctrl button.maplibregl-ctrl-geolocate:disabled .maplibregl-ctrl-icon {
                background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23999' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3Cpath fill='red' d='m14 5 1 1-9 9-1-1z'/%3E%3C/svg%3E")
            }

            .maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-active .maplibregl-ctrl-icon {
                background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%2333b5e5' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E")
            }

            .maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-active-error .maplibregl-ctrl-icon {
                background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23e58978' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E")
            }

            .maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-background .maplibregl-ctrl-icon {
                background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%2333b5e5' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3C/svg%3E")
            }

            .maplibregl-ctrl button.maplibregl-ctrl-geolocate.maplibregl-ctrl-geolocate-background-error .maplibregl-ctrl-icon {
                background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23e54e33' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3C/svg%3E")
            }
        }

        @media (forced-colors:active) and (prefers-color-scheme:light) {
            .maplibregl-ctrl button.maplibregl-ctrl-geolocate .maplibregl-ctrl-icon {
                background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3C/svg%3E")
            }

            .maplibregl-ctrl button.maplibregl-ctrl-geolocate:disabled .maplibregl-ctrl-icon {
                background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='29' height='29' fill='%23666' viewBox='0 0 20 20'%3E%3Cpath d='M10 4C9 4 9 5 9 5v.1A5 5 0 0 0 5.1 9H5s-1 0-1 1 1 1 1 1h.1A5 5 0 0 0 9 14.9v.1s0 1 1 1 1-1 1-1v-.1a5 5 0 0 0 3.9-3.9h.1s1 0 1-1-1-1-1-1h-.1A5 5 0 0 0 11 5.1V5s0-1-1-1m0 2.5a3.5 3.5 0 1 1 0 7 3.5 3.5 0 1 1 0-7'/%3E%3Ccircle cx='10' cy='10' r='2'/%3E%3Cpath fill='red' d='m14 5 1 1-9 9-1-1z'/%3E%3C/svg%3E")
            }
        }

        @keyframes maplibregl-spin {
            0% {
                transform: rotate(0deg)
            }

            to {
                transform: rotate(1turn)
            }
        }

        a.maplibregl-ctrl-logo {
            background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='88' height='23' fill='none'%3E%3Cpath fill='%23000' fill-opacity='.4' fill-rule='evenodd' d='M17.408 16.796h-1.827l2.501-12.095h.198l3.324 6.533.988 2.19.988-2.19 3.258-6.533h.181l2.6 12.095h-1.81l-1.218-5.644-.362-1.71-.658 1.71-2.929 5.644h-.098l-2.914-5.644-.757-1.71-.345 1.71zm1.958-3.42-.726 3.663a1.255 1.255 0 0 1-1.232 1.011h-1.827a1.255 1.255 0 0 1-1.229-1.509l2.501-12.095a1.255 1.255 0 0 1 1.23-1.001h.197a1.25 1.25 0 0 1 1.12.685l3.19 6.273 3.125-6.263a1.25 1.25 0 0 1 1.123-.695h.181a1.255 1.255 0 0 1 1.227.991l1.443 6.71a5 5 0 0 1 .314-.787l.009-.016a4.6 4.6 0 0 1 1.777-1.887c.782-.46 1.668-.667 2.611-.667a4.6 4.6 0 0 1 1.7.32l.306.134c.21-.16.474-.256.759-.256h1.694a1.255 1.255 0 0 1 1.212.925 1.255 1.255 0 0 1 1.212-.925h1.711c.284 0 .545.094.755.252.613-.3 1.312-.45 2.075-.45 1.356 0 2.557.445 3.482 1.4q.47.48.763 1.064V4.701a1.255 1.255 0 0 1 1.255-1.255h1.86A1.255 1.255 0 0 1 54.44 4.7v9.194h2.217c.19 0 .37.043.532.118v-4.77c0-.356.147-.678.385-.906a2.42 2.42 0 0 1-.682-1.71c0-.665.267-1.253.735-1.7a2.45 2.45 0 0 1 1.722-.674 2.43 2.43 0 0 1 1.705.675q.318.302.504.683V4.7a1.255 1.255 0 0 1 1.255-1.255h1.744A1.255 1.255 0 0 1 65.812 4.7v3.335a4.8 4.8 0 0 1 1.526-.246c.938 0 1.817.214 2.59.69a4.47 4.47 0 0 1 1.67 1.743v-.98a1.255 1.255 0 0 1 1.256-1.256h1.777c.233 0 .451.064.639.174a3.4 3.4 0 0 1 1.567-.372c.346 0 .861.02 1.285.232a1.25 1.25 0 0 1 .689 1.004 4.7 4.7 0 0 1 .853-.588c.795-.44 1.675-.647 2.61-.647 1.385 0 2.65.39 3.525 1.396.836.938 1.168 2.173 1.168 3.528q-.001.515-.056 1.051a1.255 1.255 0 0 1-.947 1.09l.408.952a1.255 1.255 0 0 1-.477 1.552c-.418.268-.92.463-1.458.612-.613.171-1.304.244-2.049.244-1.06 0-2.043-.207-2.886-.698l-.015-.008c-.798-.48-1.419-1.135-1.818-1.963l-.004-.008a5.8 5.8 0 0 1-.548-2.512q0-.429.053-.843a1.3 1.3 0 0 1-.333-.086l-.166-.004c-.223 0-.426.062-.643.228-.03.024-.142.139-.142.59v3.883a1.255 1.255 0 0 1-1.256 1.256h-1.777a1.255 1.255 0 0 1-1.256-1.256V15.69l-.032.057a4.8 4.8 0 0 1-1.86 1.833 5.04 5.04 0 0 1-2.484.634 4.5 4.5 0 0 1-1.935-.424 1.25 1.25 0 0 1-.764.258h-1.71a1.255 1.255 0 0 1-1.256-1.255V7.687a2.4 2.4 0 0 1-.428.625c.253.23.412.561.412.93v7.553a1.255 1.255 0 0 1-1.256 1.255h-1.843a1.25 1.25 0 0 1-.894-.373c-.228.23-.544.373-.894.373H51.32a1.255 1.255 0 0 1-1.256-1.255v-1.251l-.061.117a4.7 4.7 0 0 1-1.782 1.884 4.77 4.77 0 0 1-2.485.67 5.6 5.6 0 0 1-1.485-.188l.009 2.764a1.255 1.255 0 0 1-1.255 1.259h-1.729a1.255 1.255 0 0 1-1.255-1.255v-3.537a1.255 1.255 0 0 1-1.167.793h-1.679a1.25 1.25 0 0 1-.77-.263 4.5 4.5 0 0 1-1.945.429c-.885 0-1.724-.21-2.495-.632l-.017-.01a5 5 0 0 1-1.081-.836 1.255 1.255 0 0 1-1.254 1.312h-1.81a1.255 1.255 0 0 1-1.228-.99l-.782-3.625-2.044 3.939a1.25 1.25 0 0 1-1.115.676h-.098a1.25 1.25 0 0 1-1.116-.68l-2.061-3.994zM35.92 16.63l.207-.114.223-.15q.493-.356.735-.785l.061-.118.033 1.332h1.678V9.242h-1.694l-.033 1.267q-.133-.329-.526-.658l-.032-.028a3.2 3.2 0 0 0-.668-.428l-.27-.12a3.3 3.3 0 0 0-1.235-.23q-1.136-.001-1.974.493a3.36 3.36 0 0 0-1.3 1.382q-.445.89-.444 2.074 0 1.2.51 2.107a3.8 3.8 0 0 0 1.382 1.381 3.9 3.9 0 0 0 1.893.477q.795 0 1.455-.33zm-2.789-5.38q-.576.675-.575 1.762 0 1.102.559 1.794.576.675 1.645.675a2.25 2.25 0 0 0 .934-.19 2.2 2.2 0 0 0 .468-.29l.178-.161a2.2 2.2 0 0 0 .397-.561q.244-.5.244-1.15v-.115q0-.708-.296-1.267l-.043-.077a2.2 2.2 0 0 0-.633-.709l-.13-.086-.047-.028a2.1 2.1 0 0 0-1.073-.285q-1.052 0-1.629.692zm2.316 2.706c.163-.17.28-.407.28-.83v-.114c0-.292-.06-.508-.15-.68a.96.96 0 0 0-.353-.389.85.85 0 0 0-.464-.127c-.4 0-.56.114-.664.239l-.01.012c-.148.174-.275.45-.275.945 0 .506.122.801.27.99.097.11.266.224.68.224.303 0 .504-.09.687-.269zm7.545 1.705a2.6 2.6 0 0 0 .331.423q.319.33.755.548l.173.074q.65.255 1.49.255 1.02 0 1.844-.493a3.45 3.45 0 0 0 1.316-1.4q.493-.904.493-2.089 0-1.909-.988-2.913-.988-1.02-2.584-1.02-.898 0-1.575.347a3 3 0 0 0-.415.262l-.199.166a3.4 3.4 0 0 0-.64.82V9.242h-1.712v11.553h1.729l-.017-5.134zm.53-1.138q.206.29.48.5l.155.11.053.034q.51.296 1.119.297 1.07 0 1.645-.675.577-.69.576-1.762 0-1.119-.576-1.777-.558-.675-1.645-.675-.435 0-.835.16a2 2 0 0 0-.284.136 2 2 0 0 0-.363.254 2.2 2.2 0 0 0-.46.569l-.082.162a2.6 2.6 0 0 0-.213 1.072v.115q0 .707.296 1.267l.135.211zm.964-.818a1.1 1.1 0 0 0 .367.385.94.94 0 0 0 .476.118c.423 0 .59-.117.687-.23.159-.194.28-.478.28-.95 0-.53-.133-.8-.266-.952l-.021-.025c-.078-.094-.231-.221-.68-.221a1 1 0 0 0-.503.135l-.012.007a.86.86 0 0 0-.335.343c-.073.133-.132.324-.132.614v.115a1.4 1.4 0 0 0 .14.66zm15.7-6.222q.347-.346.346-.856a1.05 1.05 0 0 0-.345-.79 1.18 1.18 0 0 0-.84-.329q-.51 0-.855.33a1.05 1.05 0 0 0-.346.79q0 .51.346.855.345.346.856.346.51 0 .839-.346zm4.337 9.314.033-1.332q.191.403.59.747l.098.081a4 4 0 0 0 .316.224l.223.122a3.2 3.2 0 0 0 1.44.322 3.8 3.8 0 0 0 1.875-.477 3.5 3.5 0 0 0 1.382-1.366q.527-.89.526-2.09 0-1.184-.444-2.073a3.24 3.24 0 0 0-1.283-1.399q-.823-.51-1.942-.51a3.5 3.5 0 0 0-1.527.344l-.086.043-.165.09a3 3 0 0 0-.33.214q-.432.315-.656.707a2 2 0 0 0-.099.198l.082-1.283V4.701h-1.744v12.095zm.473-2.509a2.5 2.5 0 0 0 .566.7q.117.098.245.18l.144.08a2.1 2.1 0 0 0 .975.232q1.07 0 1.645-.675.576-.69.576-1.778 0-1.102-.576-1.777-.56-.691-1.645-.692a2.2 2.2 0 0 0-1.015.235q-.22.113-.415.282l-.15.142a2.1 2.1 0 0 0-.42.594q-.223.479-.223 1.1v.115q0 .705.293 1.26zm2.616-.293c.157-.191.28-.479.28-.967 0-.51-.13-.79-.276-.961l-.021-.026c-.082-.1-.232-.225-.67-.225a.87.87 0 0 0-.681.279l-.012.011c-.154.155-.274.38-.274.807v.115c0 .285.057.499.144.669a1.1 1.1 0 0 0 .367.405c.137.082.28.123.455.123.423 0 .59-.118.686-.23zm8.266-3.013q.345-.13.724-.14l.069-.002q.493 0 .642.099l.247-1.794q-.196-.099-.717-.099a2.3 2.3 0 0 0-.545.063 2 2 0 0 0-.411.148 2.2 2.2 0 0 0-.4.249 2.5 2.5 0 0 0-.485.499 2.7 2.7 0 0 0-.32.581l-.05.137v-1.48h-1.778v7.553h1.777v-3.884q0-.546.159-.943a1.5 1.5 0 0 1 .466-.636 2.5 2.5 0 0 1 .399-.253 2 2 0 0 1 .224-.099zm9.784 2.656.05-.922q0-1.743-.856-2.698-.838-.97-2.584-.97-1.119-.001-2.007.493a3.46 3.46 0 0 0-1.4 1.382q-.493.906-.493 2.106 0 1.07.428 1.975.428.89 1.332 1.432.906.526 2.255.526.973 0 1.668-.185l.044-.012.135-.04q.613-.184.984-.421l-.542-1.267q-.3.162-.642.274l-.297.087q-.51.131-1.3.131-.954 0-1.497-.444a1.6 1.6 0 0 1-.192-.193q-.366-.44-.512-1.234l-.004-.021zm-5.427-1.256-.003.022h3.752v-.138q-.011-.727-.288-1.118a1 1 0 0 0-.156-.176q-.46-.428-1.316-.428-.986 0-1.494.604-.379.45-.494 1.234zm-27.053 2.77V4.7h-1.86v12.095h5.333V15.15zm7.103-5.908v7.553h-1.843V9.242h1.843z'/%3E%3Cpath fill='%23fff' d='m19.63 11.151-.757-1.71-.345 1.71-1.12 5.644h-1.827L18.083 4.7h.197l3.325 6.533.988 2.19.988-2.19L26.839 4.7h.181l2.6 12.095h-1.81l-1.218-5.644-.362-1.71-.658 1.71-2.93 5.644h-.098l-2.913-5.644zm14.836 5.81q-1.02 0-1.893-.478a3.8 3.8 0 0 1-1.381-1.382q-.51-.906-.51-2.106 0-1.185.444-2.074a3.36 3.36 0 0 1 1.3-1.382q.839-.494 1.974-.494a3.3 3.3 0 0 1 1.234.231 3.3 3.3 0 0 1 .97.575q.396.33.527.659l.033-1.267h1.694v7.553H37.18l-.033-1.332q-.279.593-1.02 1.053a3.17 3.17 0 0 1-1.662.444zm.296-1.482q.938 0 1.58-.642.642-.66.642-1.711v-.115q0-.708-.296-1.267a2.2 2.2 0 0 0-.807-.872 2.1 2.1 0 0 0-1.119-.313q-1.053 0-1.629.692-.575.675-.575 1.76 0 1.103.559 1.795.577.675 1.645.675zm6.521-6.237h1.711v1.4q.906-1.597 2.83-1.597 1.596 0 2.584 1.02.988 1.005.988 2.914 0 1.185-.493 2.09a3.46 3.46 0 0 1-1.316 1.399 3.5 3.5 0 0 1-1.844.493q-.954 0-1.662-.329a2.67 2.67 0 0 1-1.086-.97l.017 5.134h-1.728zm4.048 6.22q1.07 0 1.645-.674.577-.69.576-1.762 0-1.119-.576-1.777-.558-.675-1.645-.675-.592 0-1.12.296-.51.28-.822.823-.296.527-.296 1.234v.115q0 .708.296 1.267.313.543.823.855.51.296 1.119.297z'/%3E%3Cpath fill='%23e1e3e9' d='M51.325 4.7h1.86v10.45h3.473v1.646h-5.333zm7.12 4.542h1.843v7.553h-1.843zm.905-1.415a1.16 1.16 0 0 1-.856-.346 1.17 1.17 0 0 1-.346-.856 1.05 1.05 0 0 1 .346-.79q.346-.329.856-.329.494 0 .839.33a1.05 1.05 0 0 1 .345.79 1.16 1.16 0 0 1-.345.855q-.33.346-.84.346zm7.875 9.133a3.17 3.17 0 0 1-1.662-.444q-.723-.46-1.004-1.053l-.033 1.332h-1.71V4.701h1.743v4.657l-.082 1.283q.279-.658 1.086-1.119a3.5 3.5 0 0 1 1.778-.477q1.119 0 1.942.51a3.24 3.24 0 0 1 1.283 1.4q.445.888.444 2.072 0 1.201-.526 2.09a3.5 3.5 0 0 1-1.382 1.366 3.8 3.8 0 0 1-1.876.477zm-.296-1.481q1.069 0 1.645-.675.577-.69.577-1.778 0-1.102-.577-1.776-.56-.691-1.645-.692a2.12 2.12 0 0 0-1.58.659q-.642.641-.642 1.694v.115q0 .71.296 1.267a2.4 2.4 0 0 0 .807.872 2.1 2.1 0 0 0 1.119.313zm5.927-6.237h1.777v1.481q.263-.757.856-1.217a2.14 2.14 0 0 1 1.349-.46q.527 0 .724.098l-.247 1.794q-.149-.099-.642-.099-.774 0-1.416.494-.626.493-.626 1.58v3.883h-1.777V9.242zm9.534 7.718q-1.35 0-2.255-.526-.904-.543-1.332-1.432a4.6 4.6 0 0 1-.428-1.975q0-1.2.493-2.106a3.46 3.46 0 0 1 1.4-1.382q.889-.495 2.007-.494 1.744 0 2.584.97.855.956.856 2.7 0 .444-.05.92h-5.43q.18 1.005.708 1.45.542.443 1.497.443.79 0 1.3-.131a4 4 0 0 0 .938-.362l.542 1.267q-.411.263-1.119.46-.708.198-1.711.197zm1.596-4.558q.016-1.02-.444-1.432-.46-.428-1.316-.428-1.728 0-1.991 1.86z'/%3E%3Cpath d='M5.074 15.948a.484.657 0 0 0-.486.659v1.84a.484.657 0 0 0 .486.659h4.101a.484.657 0 0 0 .486-.659v-1.84a.484.657 0 0 0-.486-.659zm3.56 1.16H5.617v.838h3.017z' style='fill:%23fff;fill-rule:evenodd;stroke-width:1.03600001'/%3E%3Cg style='stroke-width:1.12603545'%3E%3Cpath d='M-9.408-1.416c-3.833-.025-7.056 2.912-7.08 6.615-.02 3.08 1.653 4.832 3.107 6.268.903.892 1.721 1.74 2.32 2.902l-.525-.004c-.543-.003-.992.304-1.24.639a1.87 1.87 0 0 0-.362 1.121l-.011 1.877c-.003.402.104.787.347 1.125.244.338.688.653 1.23.656l4.142.028c.542.003.99-.306 1.238-.641a1.87 1.87 0 0 0 .363-1.121l.012-1.875a1.87 1.87 0 0 0-.348-1.127c-.243-.338-.688-.653-1.23-.656l-.518-.004c.597-1.145 1.425-1.983 2.348-2.87 1.473-1.414 3.18-3.149 3.2-6.226-.016-3.59-2.923-6.684-6.993-6.707m-.006 1.1v.002c3.274.02 5.92 2.532 5.9 5.6-.017 2.706-1.39 4.026-2.863 5.44-1.034.994-2.118 2.033-2.814 3.633-.018.041-.052.055-.075.065q-.013.004-.02.01a.34.34 0 0 1-.226.084.34.34 0 0 1-.224-.086l-.092-.077c-.699-1.615-1.768-2.669-2.781-3.67-1.454-1.435-2.797-2.762-2.78-5.478.02-3.067 2.7-5.545 5.975-5.523m-.02 2.826c-1.62-.01-2.944 1.315-2.955 2.96-.01 1.646 1.295 2.988 2.916 2.999h.002c1.621.01 2.943-1.316 2.953-2.961.011-1.646-1.294-2.988-2.916-2.998m-.005 1.1c1.017.006 1.829.83 1.822 1.89s-.83 1.874-1.848 1.867c-1.018-.006-1.829-.83-1.822-1.89s.83-1.874 1.848-1.868m-2.155 11.857 4.14.025c.271.002.49.305.487.676l-.013 1.875c-.003.37-.224.67-.495.668l-4.14-.025c-.27-.002-.487-.306-.485-.676l.012-1.875c.003-.37.224-.67.494-.668' style='color:%23000;font-style:normal;font-variant:normal;font-weight:400;font-stretch:normal;font-size:medium;line-height:normal;font-family:sans-serif;font-variant-ligatures:normal;font-variant-position:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-feature-settings:normal;text-indent:0;text-align:start;text-decoration:none;text-decoration-line:none;text-decoration-style:solid;text-decoration-color:%23000;letter-spacing:normal;word-spacing:normal;text-transform:none;writing-mode:lr-tb;direction:ltr;text-orientation:mixed;dominant-baseline:auto;baseline-shift:baseline;text-anchor:start;white-space:normal;shape-padding:0;clip-rule:evenodd;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:%23000;solid-opacity:1;vector-effect:none;fill:%23000;fill-opacity:.4;fill-rule:evenodd;stroke:none;stroke-width:2.47727823;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto' transform='translate(15.553 2.85)scale(.88807)'/%3E%3Cpath d='M-9.415-.316C-12.69-.338-15.37 2.14-15.39 5.207c-.017 2.716 1.326 4.041 2.78 5.477 1.013 1 2.081 2.055 2.78 3.67l.092.076a.34.34 0 0 0 .225.086.34.34 0 0 0 .227-.083l.019-.01c.022-.009.057-.024.074-.064.697-1.6 1.78-2.64 2.814-3.634 1.473-1.414 2.847-2.733 2.864-5.44.02-3.067-2.627-5.58-5.901-5.601m-.057 8.784c1.621.011 2.944-1.315 2.955-2.96.01-1.646-1.295-2.988-2.916-2.999-1.622-.01-2.945 1.315-2.955 2.96s1.295 2.989 2.916 3' style='clip-rule:evenodd;fill:%23e1e3e9;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:2.47727823;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:.4' transform='translate(15.553 2.85)scale(.88807)'/%3E%3Cpath d='M-11.594 15.465c-.27-.002-.492.297-.494.668l-.012 1.876c-.003.371.214.673.485.675l4.14.027c.271.002.492-.298.495-.668l.012-1.877c.003-.37-.215-.672-.485-.674z' style='clip-rule:evenodd;fill:%23fff;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:2.47727823;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:.4' transform='translate(15.553 2.85)scale(.88807)'/%3E%3C/g%3E%3C/svg%3E");
            background-repeat: no-repeat;
            cursor: pointer;
            display: block;
            height: 23px;
            margin: 0 0 -4px -4px;
            overflow: hidden;
            width: 88px
        }

        a.maplibregl-ctrl-logo.maplibregl-compact {
            width: 14px
        }

        @media (forced-colors:active) {
            a.maplibregl-ctrl-logo {
                background-color: transparent;
                background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='88' height='23' fill='none'%3E%3Cpath fill='%23000' fill-opacity='.4' fill-rule='evenodd' d='M17.408 16.796h-1.827l2.501-12.095h.198l3.324 6.533.988 2.19.988-2.19 3.258-6.533h.181l2.6 12.095h-1.81l-1.218-5.644-.362-1.71-.658 1.71-2.929 5.644h-.098l-2.914-5.644-.757-1.71-.345 1.71zm1.958-3.42-.726 3.663a1.255 1.255 0 0 1-1.232 1.011h-1.827a1.255 1.255 0 0 1-1.229-1.509l2.501-12.095a1.255 1.255 0 0 1 1.23-1.001h.197a1.25 1.25 0 0 1 1.12.685l3.19 6.273 3.125-6.263a1.25 1.25 0 0 1 1.123-.695h.181a1.255 1.255 0 0 1 1.227.991l1.443 6.71a5 5 0 0 1 .314-.787l.009-.016a4.6 4.6 0 0 1 1.777-1.887c.782-.46 1.668-.667 2.611-.667a4.6 4.6 0 0 1 1.7.32l.306.134c.21-.16.474-.256.759-.256h1.694a1.255 1.255 0 0 1 1.212.925 1.255 1.255 0 0 1 1.212-.925h1.711c.284 0 .545.094.755.252.613-.3 1.312-.45 2.075-.45 1.356 0 2.557.445 3.482 1.4q.47.48.763 1.064V4.701a1.255 1.255 0 0 1 1.255-1.255h1.86A1.255 1.255 0 0 1 54.44 4.7v9.194h2.217c.19 0 .37.043.532.118v-4.77c0-.356.147-.678.385-.906a2.42 2.42 0 0 1-.682-1.71c0-.665.267-1.253.735-1.7a2.45 2.45 0 0 1 1.722-.674 2.43 2.43 0 0 1 1.705.675q.318.302.504.683V4.7a1.255 1.255 0 0 1 1.255-1.255h1.744A1.255 1.255 0 0 1 65.812 4.7v3.335a4.8 4.8 0 0 1 1.526-.246c.938 0 1.817.214 2.59.69a4.47 4.47 0 0 1 1.67 1.743v-.98a1.255 1.255 0 0 1 1.256-1.256h1.777c.233 0 .451.064.639.174a3.4 3.4 0 0 1 1.567-.372c.346 0 .861.02 1.285.232a1.25 1.25 0 0 1 .689 1.004 4.7 4.7 0 0 1 .853-.588c.795-.44 1.675-.647 2.61-.647 1.385 0 2.65.39 3.525 1.396.836.938 1.168 2.173 1.168 3.528q-.001.515-.056 1.051a1.255 1.255 0 0 1-.947 1.09l.408.952a1.255 1.255 0 0 1-.477 1.552c-.418.268-.92.463-1.458.612-.613.171-1.304.244-2.049.244-1.06 0-2.043-.207-2.886-.698l-.015-.008c-.798-.48-1.419-1.135-1.818-1.963l-.004-.008a5.8 5.8 0 0 1-.548-2.512q0-.429.053-.843a1.3 1.3 0 0 1-.333-.086l-.166-.004c-.223 0-.426.062-.643.228-.03.024-.142.139-.142.59v3.883a1.255 1.255 0 0 1-1.256 1.256h-1.777a1.255 1.255 0 0 1-1.256-1.256V15.69l-.032.057a4.8 4.8 0 0 1-1.86 1.833 5.04 5.04 0 0 1-2.484.634 4.5 4.5 0 0 1-1.935-.424 1.25 1.25 0 0 1-.764.258h-1.71a1.255 1.255 0 0 1-1.256-1.255V7.687a2.4 2.4 0 0 1-.428.625c.253.23.412.561.412.93v7.553a1.255 1.255 0 0 1-1.256 1.255h-1.843a1.25 1.25 0 0 1-.894-.373c-.228.23-.544.373-.894.373H51.32a1.255 1.255 0 0 1-1.256-1.255v-1.251l-.061.117a4.7 4.7 0 0 1-1.782 1.884 4.77 4.77 0 0 1-2.485.67 5.6 5.6 0 0 1-1.485-.188l.009 2.764a1.255 1.255 0 0 1-1.255 1.259h-1.729a1.255 1.255 0 0 1-1.255-1.255v-3.537a1.255 1.255 0 0 1-1.167.793h-1.679a1.25 1.25 0 0 1-.77-.263 4.5 4.5 0 0 1-1.945.429c-.885 0-1.724-.21-2.495-.632l-.017-.01a5 5 0 0 1-1.081-.836 1.255 1.255 0 0 1-1.254 1.312h-1.81a1.255 1.255 0 0 1-1.228-.99l-.782-3.625-2.044 3.939a1.25 1.25 0 0 1-1.115.676h-.098a1.25 1.25 0 0 1-1.116-.68l-2.061-3.994zM35.92 16.63l.207-.114.223-.15q.493-.356.735-.785l.061-.118.033 1.332h1.678V9.242h-1.694l-.033 1.267q-.133-.329-.526-.658l-.032-.028a3.2 3.2 0 0 0-.668-.428l-.27-.12a3.3 3.3 0 0 0-1.235-.23q-1.136-.001-1.974.493a3.36 3.36 0 0 0-1.3 1.382q-.445.89-.444 2.074 0 1.2.51 2.107a3.8 3.8 0 0 0 1.382 1.381 3.9 3.9 0 0 0 1.893.477q.795 0 1.455-.33zm-2.789-5.38q-.576.675-.575 1.762 0 1.102.559 1.794.576.675 1.645.675a2.25 2.25 0 0 0 .934-.19 2.2 2.2 0 0 0 .468-.29l.178-.161a2.2 2.2 0 0 0 .397-.561q.244-.5.244-1.15v-.115q0-.708-.296-1.267l-.043-.077a2.2 2.2 0 0 0-.633-.709l-.13-.086-.047-.028a2.1 2.1 0 0 0-1.073-.285q-1.052 0-1.629.692zm2.316 2.706c.163-.17.28-.407.28-.83v-.114c0-.292-.06-.508-.15-.68a.96.96 0 0 0-.353-.389.85.85 0 0 0-.464-.127c-.4 0-.56.114-.664.239l-.01.012c-.148.174-.275.45-.275.945 0 .506.122.801.27.99.097.11.266.224.68.224.303 0 .504-.09.687-.269zm7.545 1.705a2.6 2.6 0 0 0 .331.423q.319.33.755.548l.173.074q.65.255 1.49.255 1.02 0 1.844-.493a3.45 3.45 0 0 0 1.316-1.4q.493-.904.493-2.089 0-1.909-.988-2.913-.988-1.02-2.584-1.02-.898 0-1.575.347a3 3 0 0 0-.415.262l-.199.166a3.4 3.4 0 0 0-.64.82V9.242h-1.712v11.553h1.729l-.017-5.134zm.53-1.138q.206.29.48.5l.155.11.053.034q.51.296 1.119.297 1.07 0 1.645-.675.577-.69.576-1.762 0-1.119-.576-1.777-.558-.675-1.645-.675-.435 0-.835.16a2 2 0 0 0-.284.136 2 2 0 0 0-.363.254 2.2 2.2 0 0 0-.46.569l-.082.162a2.6 2.6 0 0 0-.213 1.072v.115q0 .707.296 1.267l.135.211zm.964-.818a1.1 1.1 0 0 0 .367.385.94.94 0 0 0 .476.118c.423 0 .59-.117.687-.23.159-.194.28-.478.28-.95 0-.53-.133-.8-.266-.952l-.021-.025c-.078-.094-.231-.221-.68-.221a1 1 0 0 0-.503.135l-.012.007a.86.86 0 0 0-.335.343c-.073.133-.132.324-.132.614v.115a1.4 1.4 0 0 0 .14.66zm15.7-6.222q.347-.346.346-.856a1.05 1.05 0 0 0-.345-.79 1.18 1.18 0 0 0-.84-.329q-.51 0-.855.33a1.05 1.05 0 0 0-.346.79q0 .51.346.855.345.346.856.346.51 0 .839-.346zm4.337 9.314.033-1.332q.191.403.59.747l.098.081a4 4 0 0 0 .316.224l.223.122a3.2 3.2 0 0 0 1.44.322 3.8 3.8 0 0 0 1.875-.477 3.5 3.5 0 0 0 1.382-1.366q.527-.89.526-2.09 0-1.184-.444-2.073a3.24 3.24 0 0 0-1.283-1.399q-.823-.51-1.942-.51a3.5 3.5 0 0 0-1.527.344l-.086.043-.165.09a3 3 0 0 0-.33.214q-.432.315-.656.707a2 2 0 0 0-.099.198l.082-1.283V4.701h-1.744v12.095zm.473-2.509a2.5 2.5 0 0 0 .566.7q.117.098.245.18l.144.08a2.1 2.1 0 0 0 .975.232q1.07 0 1.645-.675.576-.69.576-1.778 0-1.102-.576-1.777-.56-.691-1.645-.692a2.2 2.2 0 0 0-1.015.235q-.22.113-.415.282l-.15.142a2.1 2.1 0 0 0-.42.594q-.223.479-.223 1.1v.115q0 .705.293 1.26zm2.616-.293c.157-.191.28-.479.28-.967 0-.51-.13-.79-.276-.961l-.021-.026c-.082-.1-.232-.225-.67-.225a.87.87 0 0 0-.681.279l-.012.011c-.154.155-.274.38-.274.807v.115c0 .285.057.499.144.669a1.1 1.1 0 0 0 .367.405c.137.082.28.123.455.123.423 0 .59-.118.686-.23zm8.266-3.013q.345-.13.724-.14l.069-.002q.493 0 .642.099l.247-1.794q-.196-.099-.717-.099a2.3 2.3 0 0 0-.545.063 2 2 0 0 0-.411.148 2.2 2.2 0 0 0-.4.249 2.5 2.5 0 0 0-.485.499 2.7 2.7 0 0 0-.32.581l-.05.137v-1.48h-1.778v7.553h1.777v-3.884q0-.546.159-.943a1.5 1.5 0 0 1 .466-.636 2.5 2.5 0 0 1 .399-.253 2 2 0 0 1 .224-.099zm9.784 2.656.05-.922q0-1.743-.856-2.698-.838-.97-2.584-.97-1.119-.001-2.007.493a3.46 3.46 0 0 0-1.4 1.382q-.493.906-.493 2.106 0 1.07.428 1.975.428.89 1.332 1.432.906.526 2.255.526.973 0 1.668-.185l.044-.012.135-.04q.613-.184.984-.421l-.542-1.267q-.3.162-.642.274l-.297.087q-.51.131-1.3.131-.954 0-1.497-.444a1.6 1.6 0 0 1-.192-.193q-.366-.44-.512-1.234l-.004-.021zm-5.427-1.256-.003.022h3.752v-.138q-.011-.727-.288-1.118a1 1 0 0 0-.156-.176q-.46-.428-1.316-.428-.986 0-1.494.604-.379.45-.494 1.234zm-27.053 2.77V4.7h-1.86v12.095h5.333V15.15zm7.103-5.908v7.553h-1.843V9.242h1.843z'/%3E%3Cpath fill='%23fff' d='m19.63 11.151-.757-1.71-.345 1.71-1.12 5.644h-1.827L18.083 4.7h.197l3.325 6.533.988 2.19.988-2.19L26.839 4.7h.181l2.6 12.095h-1.81l-1.218-5.644-.362-1.71-.658 1.71-2.93 5.644h-.098l-2.913-5.644zm14.836 5.81q-1.02 0-1.893-.478a3.8 3.8 0 0 1-1.381-1.382q-.51-.906-.51-2.106 0-1.185.444-2.074a3.36 3.36 0 0 1 1.3-1.382q.839-.494 1.974-.494a3.3 3.3 0 0 1 1.234.231 3.3 3.3 0 0 1 .97.575q.396.33.527.659l.033-1.267h1.694v7.553H37.18l-.033-1.332q-.279.593-1.02 1.053a3.17 3.17 0 0 1-1.662.444zm.296-1.482q.938 0 1.58-.642.642-.66.642-1.711v-.115q0-.708-.296-1.267a2.2 2.2 0 0 0-.807-.872 2.1 2.1 0 0 0-1.119-.313q-1.053 0-1.629.692-.575.675-.575 1.76 0 1.103.559 1.795.577.675 1.645.675zm6.521-6.237h1.711v1.4q.906-1.597 2.83-1.597 1.596 0 2.584 1.02.988 1.005.988 2.914 0 1.185-.493 2.09a3.46 3.46 0 0 1-1.316 1.399 3.5 3.5 0 0 1-1.844.493q-.954 0-1.662-.329a2.67 2.67 0 0 1-1.086-.97l.017 5.134h-1.728zm4.048 6.22q1.07 0 1.645-.674.577-.69.576-1.762 0-1.119-.576-1.777-.558-.675-1.645-.675-.592 0-1.12.296-.51.28-.822.823-.296.527-.296 1.234v.115q0 .708.296 1.267.313.543.823.855.51.296 1.119.297z'/%3E%3Cpath fill='%23e1e3e9' d='M51.325 4.7h1.86v10.45h3.473v1.646h-5.333zm7.12 4.542h1.843v7.553h-1.843zm.905-1.415a1.16 1.16 0 0 1-.856-.346 1.17 1.17 0 0 1-.346-.856 1.05 1.05 0 0 1 .346-.79q.346-.329.856-.329.494 0 .839.33a1.05 1.05 0 0 1 .345.79 1.16 1.16 0 0 1-.345.855q-.33.346-.84.346zm7.875 9.133a3.17 3.17 0 0 1-1.662-.444q-.723-.46-1.004-1.053l-.033 1.332h-1.71V4.701h1.743v4.657l-.082 1.283q.279-.658 1.086-1.119a3.5 3.5 0 0 1 1.778-.477q1.119 0 1.942.51a3.24 3.24 0 0 1 1.283 1.4q.445.888.444 2.072 0 1.201-.526 2.09a3.5 3.5 0 0 1-1.382 1.366 3.8 3.8 0 0 1-1.876.477zm-.296-1.481q1.069 0 1.645-.675.577-.69.577-1.778 0-1.102-.577-1.776-.56-.691-1.645-.692a2.12 2.12 0 0 0-1.58.659q-.642.641-.642 1.694v.115q0 .71.296 1.267a2.4 2.4 0 0 0 .807.872 2.1 2.1 0 0 0 1.119.313zm5.927-6.237h1.777v1.481q.263-.757.856-1.217a2.14 2.14 0 0 1 1.349-.46q.527 0 .724.098l-.247 1.794q-.149-.099-.642-.099-.774 0-1.416.494-.626.493-.626 1.58v3.883h-1.777V9.242zm9.534 7.718q-1.35 0-2.255-.526-.904-.543-1.332-1.432a4.6 4.6 0 0 1-.428-1.975q0-1.2.493-2.106a3.46 3.46 0 0 1 1.4-1.382q.889-.495 2.007-.494 1.744 0 2.584.97.855.956.856 2.7 0 .444-.05.92h-5.43q.18 1.005.708 1.45.542.443 1.497.443.79 0 1.3-.131a4 4 0 0 0 .938-.362l.542 1.267q-.411.263-1.119.46-.708.198-1.711.197zm1.596-4.558q.016-1.02-.444-1.432-.46-.428-1.316-.428-1.728 0-1.991 1.86z'/%3E%3Cpath d='M5.074 15.948a.484.657 0 0 0-.486.659v1.84a.484.657 0 0 0 .486.659h4.101a.484.657 0 0 0 .486-.659v-1.84a.484.657 0 0 0-.486-.659zm3.56 1.16H5.617v.838h3.017z' style='fill:%23fff;fill-rule:evenodd;stroke-width:1.03600001'/%3E%3Cg style='stroke-width:1.12603545'%3E%3Cpath d='M-9.408-1.416c-3.833-.025-7.056 2.912-7.08 6.615-.02 3.08 1.653 4.832 3.107 6.268.903.892 1.721 1.74 2.32 2.902l-.525-.004c-.543-.003-.992.304-1.24.639a1.87 1.87 0 0 0-.362 1.121l-.011 1.877c-.003.402.104.787.347 1.125.244.338.688.653 1.23.656l4.142.028c.542.003.99-.306 1.238-.641a1.87 1.87 0 0 0 .363-1.121l.012-1.875a1.87 1.87 0 0 0-.348-1.127c-.243-.338-.688-.653-1.23-.656l-.518-.004c.597-1.145 1.425-1.983 2.348-2.87 1.473-1.414 3.18-3.149 3.2-6.226-.016-3.59-2.923-6.684-6.993-6.707m-.006 1.1v.002c3.274.02 5.92 2.532 5.9 5.6-.017 2.706-1.39 4.026-2.863 5.44-1.034.994-2.118 2.033-2.814 3.633-.018.041-.052.055-.075.065q-.013.004-.02.01a.34.34 0 0 1-.226.084.34.34 0 0 1-.224-.086l-.092-.077c-.699-1.615-1.768-2.669-2.781-3.67-1.454-1.435-2.797-2.762-2.78-5.478.02-3.067 2.7-5.545 5.975-5.523m-.02 2.826c-1.62-.01-2.944 1.315-2.955 2.96-.01 1.646 1.295 2.988 2.916 2.999h.002c1.621.01 2.943-1.316 2.953-2.961.011-1.646-1.294-2.988-2.916-2.998m-.005 1.1c1.017.006 1.829.83 1.822 1.89s-.83 1.874-1.848 1.867c-1.018-.006-1.829-.83-1.822-1.89s.83-1.874 1.848-1.868m-2.155 11.857 4.14.025c.271.002.49.305.487.676l-.013 1.875c-.003.37-.224.67-.495.668l-4.14-.025c-.27-.002-.487-.306-.485-.676l.012-1.875c.003-.37.224-.67.494-.668' style='color:%23000;font-style:normal;font-variant:normal;font-weight:400;font-stretch:normal;font-size:medium;line-height:normal;font-family:sans-serif;font-variant-ligatures:normal;font-variant-position:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-feature-settings:normal;text-indent:0;text-align:start;text-decoration:none;text-decoration-line:none;text-decoration-style:solid;text-decoration-color:%23000;letter-spacing:normal;word-spacing:normal;text-transform:none;writing-mode:lr-tb;direction:ltr;text-orientation:mixed;dominant-baseline:auto;baseline-shift:baseline;text-anchor:start;white-space:normal;shape-padding:0;clip-rule:evenodd;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:%23000;solid-opacity:1;vector-effect:none;fill:%23000;fill-opacity:.4;fill-rule:evenodd;stroke:none;stroke-width:2.47727823;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto' transform='translate(15.553 2.85)scale(.88807)'/%3E%3Cpath d='M-9.415-.316C-12.69-.338-15.37 2.14-15.39 5.207c-.017 2.716 1.326 4.041 2.78 5.477 1.013 1 2.081 2.055 2.78 3.67l.092.076a.34.34 0 0 0 .225.086.34.34 0 0 0 .227-.083l.019-.01c.022-.009.057-.024.074-.064.697-1.6 1.78-2.64 2.814-3.634 1.473-1.414 2.847-2.733 2.864-5.44.02-3.067-2.627-5.58-5.901-5.601m-.057 8.784c1.621.011 2.944-1.315 2.955-2.96.01-1.646-1.295-2.988-2.916-2.999-1.622-.01-2.945 1.315-2.955 2.96s1.295 2.989 2.916 3' style='clip-rule:evenodd;fill:%23e1e3e9;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:2.47727823;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:.4' transform='translate(15.553 2.85)scale(.88807)'/%3E%3Cpath d='M-11.594 15.465c-.27-.002-.492.297-.494.668l-.012 1.876c-.003.371.214.673.485.675l4.14.027c.271.002.492-.298.495-.668l.012-1.877c.003-.37-.215-.672-.485-.674z' style='clip-rule:evenodd;fill:%23fff;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:2.47727823;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:.4' transform='translate(15.553 2.85)scale(.88807)'/%3E%3C/g%3E%3C/svg%3E")
            }
        }

        @media (forced-colors:active) and (prefers-color-scheme:light) {
            a.maplibregl-ctrl-logo {
                background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='88' height='23' fill='none'%3E%3Cpath fill='%23000' fill-opacity='.4' fill-rule='evenodd' d='M17.408 16.796h-1.827l2.501-12.095h.198l3.324 6.533.988 2.19.988-2.19 3.258-6.533h.181l2.6 12.095h-1.81l-1.218-5.644-.362-1.71-.658 1.71-2.929 5.644h-.098l-2.914-5.644-.757-1.71-.345 1.71zm1.958-3.42-.726 3.663a1.255 1.255 0 0 1-1.232 1.011h-1.827a1.255 1.255 0 0 1-1.229-1.509l2.501-12.095a1.255 1.255 0 0 1 1.23-1.001h.197a1.25 1.25 0 0 1 1.12.685l3.19 6.273 3.125-6.263a1.25 1.25 0 0 1 1.123-.695h.181a1.255 1.255 0 0 1 1.227.991l1.443 6.71a5 5 0 0 1 .314-.787l.009-.016a4.6 4.6 0 0 1 1.777-1.887c.782-.46 1.668-.667 2.611-.667a4.6 4.6 0 0 1 1.7.32l.306.134c.21-.16.474-.256.759-.256h1.694a1.255 1.255 0 0 1 1.212.925 1.255 1.255 0 0 1 1.212-.925h1.711c.284 0 .545.094.755.252.613-.3 1.312-.45 2.075-.45 1.356 0 2.557.445 3.482 1.4q.47.48.763 1.064V4.701a1.255 1.255 0 0 1 1.255-1.255h1.86A1.255 1.255 0 0 1 54.44 4.7v9.194h2.217c.19 0 .37.043.532.118v-4.77c0-.356.147-.678.385-.906a2.42 2.42 0 0 1-.682-1.71c0-.665.267-1.253.735-1.7a2.45 2.45 0 0 1 1.722-.674 2.43 2.43 0 0 1 1.705.675q.318.302.504.683V4.7a1.255 1.255 0 0 1 1.255-1.255h1.744A1.255 1.255 0 0 1 65.812 4.7v3.335a4.8 4.8 0 0 1 1.526-.246c.938 0 1.817.214 2.59.69a4.47 4.47 0 0 1 1.67 1.743v-.98a1.255 1.255 0 0 1 1.256-1.256h1.777c.233 0 .451.064.639.174a3.4 3.4 0 0 1 1.567-.372c.346 0 .861.02 1.285.232a1.25 1.25 0 0 1 .689 1.004 4.7 4.7 0 0 1 .853-.588c.795-.44 1.675-.647 2.61-.647 1.385 0 2.65.39 3.525 1.396.836.938 1.168 2.173 1.168 3.528q-.001.515-.056 1.051a1.255 1.255 0 0 1-.947 1.09l.408.952a1.255 1.255 0 0 1-.477 1.552c-.418.268-.92.463-1.458.612-.613.171-1.304.244-2.049.244-1.06 0-2.043-.207-2.886-.698l-.015-.008c-.798-.48-1.419-1.135-1.818-1.963l-.004-.008a5.8 5.8 0 0 1-.548-2.512q0-.429.053-.843a1.3 1.3 0 0 1-.333-.086l-.166-.004c-.223 0-.426.062-.643.228-.03.024-.142.139-.142.59v3.883a1.255 1.255 0 0 1-1.256 1.256h-1.777a1.255 1.255 0 0 1-1.256-1.256V15.69l-.032.057a4.8 4.8 0 0 1-1.86 1.833 5.04 5.04 0 0 1-2.484.634 4.5 4.5 0 0 1-1.935-.424 1.25 1.25 0 0 1-.764.258h-1.71a1.255 1.255 0 0 1-1.256-1.255V7.687a2.4 2.4 0 0 1-.428.625c.253.23.412.561.412.93v7.553a1.255 1.255 0 0 1-1.256 1.255h-1.843a1.25 1.25 0 0 1-.894-.373c-.228.23-.544.373-.894.373H51.32a1.255 1.255 0 0 1-1.256-1.255v-1.251l-.061.117a4.7 4.7 0 0 1-1.782 1.884 4.77 4.77 0 0 1-2.485.67 5.6 5.6 0 0 1-1.485-.188l.009 2.764a1.255 1.255 0 0 1-1.255 1.259h-1.729a1.255 1.255 0 0 1-1.255-1.255v-3.537a1.255 1.255 0 0 1-1.167.793h-1.679a1.25 1.25 0 0 1-.77-.263 4.5 4.5 0 0 1-1.945.429c-.885 0-1.724-.21-2.495-.632l-.017-.01a5 5 0 0 1-1.081-.836 1.255 1.255 0 0 1-1.254 1.312h-1.81a1.255 1.255 0 0 1-1.228-.99l-.782-3.625-2.044 3.939a1.25 1.25 0 0 1-1.115.676h-.098a1.25 1.25 0 0 1-1.116-.68l-2.061-3.994zM35.92 16.63l.207-.114.223-.15q.493-.356.735-.785l.061-.118.033 1.332h1.678V9.242h-1.694l-.033 1.267q-.133-.329-.526-.658l-.032-.028a3.2 3.2 0 0 0-.668-.428l-.27-.12a3.3 3.3 0 0 0-1.235-.23q-1.136-.001-1.974.493a3.36 3.36 0 0 0-1.3 1.382q-.445.89-.444 2.074 0 1.2.51 2.107a3.8 3.8 0 0 0 1.382 1.381 3.9 3.9 0 0 0 1.893.477q.795 0 1.455-.33zm-2.789-5.38q-.576.675-.575 1.762 0 1.102.559 1.794.576.675 1.645.675a2.25 2.25 0 0 0 .934-.19 2.2 2.2 0 0 0 .468-.29l.178-.161a2.2 2.2 0 0 0 .397-.561q.244-.5.244-1.15v-.115q0-.708-.296-1.267l-.043-.077a2.2 2.2 0 0 0-.633-.709l-.13-.086-.047-.028a2.1 2.1 0 0 0-1.073-.285q-1.052 0-1.629.692zm2.316 2.706c.163-.17.28-.407.28-.83v-.114c0-.292-.06-.508-.15-.68a.96.96 0 0 0-.353-.389.85.85 0 0 0-.464-.127c-.4 0-.56.114-.664.239l-.01.012c-.148.174-.275.45-.275.945 0 .506.122.801.27.99.097.11.266.224.68.224.303 0 .504-.09.687-.269zm7.545 1.705a2.6 2.6 0 0 0 .331.423q.319.33.755.548l.173.074q.65.255 1.49.255 1.02 0 1.844-.493a3.45 3.45 0 0 0 1.316-1.4q.493-.904.493-2.089 0-1.909-.988-2.913-.988-1.02-2.584-1.02-.898 0-1.575.347a3 3 0 0 0-.415.262l-.199.166a3.4 3.4 0 0 0-.64.82V9.242h-1.712v11.553h1.729l-.017-5.134zm.53-1.138q.206.29.48.5l.155.11.053.034q.51.296 1.119.297 1.07 0 1.645-.675.577-.69.576-1.762 0-1.119-.576-1.777-.558-.675-1.645-.675-.435 0-.835.16a2 2 0 0 0-.284.136 2 2 0 0 0-.363.254 2.2 2.2 0 0 0-.46.569l-.082.162a2.6 2.6 0 0 0-.213 1.072v.115q0 .707.296 1.267l.135.211zm.964-.818a1.1 1.1 0 0 0 .367.385.94.94 0 0 0 .476.118c.423 0 .59-.117.687-.23.159-.194.28-.478.28-.95 0-.53-.133-.8-.266-.952l-.021-.025c-.078-.094-.231-.221-.68-.221a1 1 0 0 0-.503.135l-.012.007a.86.86 0 0 0-.335.343c-.073.133-.132.324-.132.614v.115a1.4 1.4 0 0 0 .14.66zm15.7-6.222q.347-.346.346-.856a1.05 1.05 0 0 0-.345-.79 1.18 1.18 0 0 0-.84-.329q-.51 0-.855.33a1.05 1.05 0 0 0-.346.79q0 .51.346.855.345.346.856.346.51 0 .839-.346zm4.337 9.314.033-1.332q.191.403.59.747l.098.081a4 4 0 0 0 .316.224l.223.122a3.2 3.2 0 0 0 1.44.322 3.8 3.8 0 0 0 1.875-.477 3.5 3.5 0 0 0 1.382-1.366q.527-.89.526-2.09 0-1.184-.444-2.073a3.24 3.24 0 0 0-1.283-1.399q-.823-.51-1.942-.51a3.5 3.5 0 0 0-1.527.344l-.086.043-.165.09a3 3 0 0 0-.33.214q-.432.315-.656.707a2 2 0 0 0-.099.198l.082-1.283V4.701h-1.744v12.095zm.473-2.509a2.5 2.5 0 0 0 .566.7q.117.098.245.18l.144.08a2.1 2.1 0 0 0 .975.232q1.07 0 1.645-.675.576-.69.576-1.778 0-1.102-.576-1.777-.56-.691-1.645-.692a2.2 2.2 0 0 0-1.015.235q-.22.113-.415.282l-.15.142a2.1 2.1 0 0 0-.42.594q-.223.479-.223 1.1v.115q0 .705.293 1.26zm2.616-.293c.157-.191.28-.479.28-.967 0-.51-.13-.79-.276-.961l-.021-.026c-.082-.1-.232-.225-.67-.225a.87.87 0 0 0-.681.279l-.012.011c-.154.155-.274.38-.274.807v.115c0 .285.057.499.144.669a1.1 1.1 0 0 0 .367.405c.137.082.28.123.455.123.423 0 .59-.118.686-.23zm8.266-3.013q.345-.13.724-.14l.069-.002q.493 0 .642.099l.247-1.794q-.196-.099-.717-.099a2.3 2.3 0 0 0-.545.063 2 2 0 0 0-.411.148 2.2 2.2 0 0 0-.4.249 2.5 2.5 0 0 0-.485.499 2.7 2.7 0 0 0-.32.581l-.05.137v-1.48h-1.778v7.553h1.777v-3.884q0-.546.159-.943a1.5 1.5 0 0 1 .466-.636 2.5 2.5 0 0 1 .399-.253 2 2 0 0 1 .224-.099zm9.784 2.656.05-.922q0-1.743-.856-2.698-.838-.97-2.584-.97-1.119-.001-2.007.493a3.46 3.46 0 0 0-1.4 1.382q-.493.906-.493 2.106 0 1.07.428 1.975.428.89 1.332 1.432.906.526 2.255.526.973 0 1.668-.185l.044-.012.135-.04q.613-.184.984-.421l-.542-1.267q-.3.162-.642.274l-.297.087q-.51.131-1.3.131-.954 0-1.497-.444a1.6 1.6 0 0 1-.192-.193q-.366-.44-.512-1.234l-.004-.021zm-5.427-1.256-.003.022h3.752v-.138q-.011-.727-.288-1.118a1 1 0 0 0-.156-.176q-.46-.428-1.316-.428-.986 0-1.494.604-.379.45-.494 1.234zm-27.053 2.77V4.7h-1.86v12.095h5.333V15.15zm7.103-5.908v7.553h-1.843V9.242h1.843z'/%3E%3Cpath fill='%23fff' d='m19.63 11.151-.757-1.71-.345 1.71-1.12 5.644h-1.827L18.083 4.7h.197l3.325 6.533.988 2.19.988-2.19L26.839 4.7h.181l2.6 12.095h-1.81l-1.218-5.644-.362-1.71-.658 1.71-2.93 5.644h-.098l-2.913-5.644zm14.836 5.81q-1.02 0-1.893-.478a3.8 3.8 0 0 1-1.381-1.382q-.51-.906-.51-2.106 0-1.185.444-2.074a3.36 3.36 0 0 1 1.3-1.382q.839-.494 1.974-.494a3.3 3.3 0 0 1 1.234.231 3.3 3.3 0 0 1 .97.575q.396.33.527.659l.033-1.267h1.694v7.553H37.18l-.033-1.332q-.279.593-1.02 1.053a3.17 3.17 0 0 1-1.662.444zm.296-1.482q.938 0 1.58-.642.642-.66.642-1.711v-.115q0-.708-.296-1.267a2.2 2.2 0 0 0-.807-.872 2.1 2.1 0 0 0-1.119-.313q-1.053 0-1.629.692-.575.675-.575 1.76 0 1.103.559 1.795.577.675 1.645.675zm6.521-6.237h1.711v1.4q.906-1.597 2.83-1.597 1.596 0 2.584 1.02.988 1.005.988 2.914 0 1.185-.493 2.09a3.46 3.46 0 0 1-1.316 1.399 3.5 3.5 0 0 1-1.844.493q-.954 0-1.662-.329a2.67 2.67 0 0 1-1.086-.97l.017 5.134h-1.728zm4.048 6.22q1.07 0 1.645-.674.577-.69.576-1.762 0-1.119-.576-1.777-.558-.675-1.645-.675-.592 0-1.12.296-.51.28-.822.823-.296.527-.296 1.234v.115q0 .708.296 1.267.313.543.823.855.51.296 1.119.297z'/%3E%3Cpath fill='%23e1e3e9' d='M51.325 4.7h1.86v10.45h3.473v1.646h-5.333zm7.12 4.542h1.843v7.553h-1.843zm.905-1.415a1.16 1.16 0 0 1-.856-.346 1.17 1.17 0 0 1-.346-.856 1.05 1.05 0 0 1 .346-.79q.346-.329.856-.329.494 0 .839.33a1.05 1.05 0 0 1 .345.79 1.16 1.16 0 0 1-.345.855q-.33.346-.84.346zm7.875 9.133a3.17 3.17 0 0 1-1.662-.444q-.723-.46-1.004-1.053l-.033 1.332h-1.71V4.701h1.743v4.657l-.082 1.283q.279-.658 1.086-1.119a3.5 3.5 0 0 1 1.778-.477q1.119 0 1.942.51a3.24 3.24 0 0 1 1.283 1.4q.445.888.444 2.072 0 1.201-.526 2.09a3.5 3.5 0 0 1-1.382 1.366 3.8 3.8 0 0 1-1.876.477zm-.296-1.481q1.069 0 1.645-.675.577-.69.577-1.778 0-1.102-.577-1.776-.56-.691-1.645-.692a2.12 2.12 0 0 0-1.58.659q-.642.641-.642 1.694v.115q0 .71.296 1.267a2.4 2.4 0 0 0 .807.872 2.1 2.1 0 0 0 1.119.313zm5.927-6.237h1.777v1.481q.263-.757.856-1.217a2.14 2.14 0 0 1 1.349-.46q.527 0 .724.098l-.247 1.794q-.149-.099-.642-.099-.774 0-1.416.494-.626.493-.626 1.58v3.883h-1.777V9.242zm9.534 7.718q-1.35 0-2.255-.526-.904-.543-1.332-1.432a4.6 4.6 0 0 1-.428-1.975q0-1.2.493-2.106a3.46 3.46 0 0 1 1.4-1.382q.889-.495 2.007-.494 1.744 0 2.584.97.855.956.856 2.7 0 .444-.05.92h-5.43q.18 1.005.708 1.45.542.443 1.497.443.79 0 1.3-.131a4 4 0 0 0 .938-.362l.542 1.267q-.411.263-1.119.46-.708.198-1.711.197zm1.596-4.558q.016-1.02-.444-1.432-.46-.428-1.316-.428-1.728 0-1.991 1.86z'/%3E%3Cpath d='M5.074 15.948a.484.657 0 0 0-.486.659v1.84a.484.657 0 0 0 .486.659h4.101a.484.657 0 0 0 .486-.659v-1.84a.484.657 0 0 0-.486-.659zm3.56 1.16H5.617v.838h3.017z' style='fill:%23fff;fill-rule:evenodd;stroke-width:1.03600001'/%3E%3Cg style='stroke-width:1.12603545'%3E%3Cpath d='M-9.408-1.416c-3.833-.025-7.056 2.912-7.08 6.615-.02 3.08 1.653 4.832 3.107 6.268.903.892 1.721 1.74 2.32 2.902l-.525-.004c-.543-.003-.992.304-1.24.639a1.87 1.87 0 0 0-.362 1.121l-.011 1.877c-.003.402.104.787.347 1.125.244.338.688.653 1.23.656l4.142.028c.542.003.99-.306 1.238-.641a1.87 1.87 0 0 0 .363-1.121l.012-1.875a1.87 1.87 0 0 0-.348-1.127c-.243-.338-.688-.653-1.23-.656l-.518-.004c.597-1.145 1.425-1.983 2.348-2.87 1.473-1.414 3.18-3.149 3.2-6.226-.016-3.59-2.923-6.684-6.993-6.707m-.006 1.1v.002c3.274.02 5.92 2.532 5.9 5.6-.017 2.706-1.39 4.026-2.863 5.44-1.034.994-2.118 2.033-2.814 3.633-.018.041-.052.055-.075.065q-.013.004-.02.01a.34.34 0 0 1-.226.084.34.34 0 0 1-.224-.086l-.092-.077c-.699-1.615-1.768-2.669-2.781-3.67-1.454-1.435-2.797-2.762-2.78-5.478.02-3.067 2.7-5.545 5.975-5.523m-.02 2.826c-1.62-.01-2.944 1.315-2.955 2.96-.01 1.646 1.295 2.988 2.916 2.999h.002c1.621.01 2.943-1.316 2.953-2.961.011-1.646-1.294-2.988-2.916-2.998m-.005 1.1c1.017.006 1.829.83 1.822 1.89s-.83 1.874-1.848 1.867c-1.018-.006-1.829-.83-1.822-1.89s.83-1.874 1.848-1.868m-2.155 11.857 4.14.025c.271.002.49.305.487.676l-.013 1.875c-.003.37-.224.67-.495.668l-4.14-.025c-.27-.002-.487-.306-.485-.676l.012-1.875c.003-.37.224-.67.494-.668' style='color:%23000;font-style:normal;font-variant:normal;font-weight:400;font-stretch:normal;font-size:medium;line-height:normal;font-family:sans-serif;font-variant-ligatures:normal;font-variant-position:normal;font-variant-caps:normal;font-variant-numeric:normal;font-variant-alternates:normal;font-feature-settings:normal;text-indent:0;text-align:start;text-decoration:none;text-decoration-line:none;text-decoration-style:solid;text-decoration-color:%23000;letter-spacing:normal;word-spacing:normal;text-transform:none;writing-mode:lr-tb;direction:ltr;text-orientation:mixed;dominant-baseline:auto;baseline-shift:baseline;text-anchor:start;white-space:normal;shape-padding:0;clip-rule:evenodd;display:inline;overflow:visible;visibility:visible;opacity:1;isolation:auto;mix-blend-mode:normal;color-interpolation:sRGB;color-interpolation-filters:linearRGB;solid-color:%23000;solid-opacity:1;vector-effect:none;fill:%23000;fill-opacity:.4;fill-rule:evenodd;stroke:none;stroke-width:2.47727823;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;color-rendering:auto;image-rendering:auto;shape-rendering:auto;text-rendering:auto' transform='translate(15.553 2.85)scale(.88807)'/%3E%3Cpath d='M-9.415-.316C-12.69-.338-15.37 2.14-15.39 5.207c-.017 2.716 1.326 4.041 2.78 5.477 1.013 1 2.081 2.055 2.78 3.67l.092.076a.34.34 0 0 0 .225.086.34.34 0 0 0 .227-.083l.019-.01c.022-.009.057-.024.074-.064.697-1.6 1.78-2.64 2.814-3.634 1.473-1.414 2.847-2.733 2.864-5.44.02-3.067-2.627-5.58-5.901-5.601m-.057 8.784c1.621.011 2.944-1.315 2.955-2.96.01-1.646-1.295-2.988-2.916-2.999-1.622-.01-2.945 1.315-2.955 2.96s1.295 2.989 2.916 3' style='clip-rule:evenodd;fill:%23e1e3e9;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:2.47727823;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:.4' transform='translate(15.553 2.85)scale(.88807)'/%3E%3Cpath d='M-11.594 15.465c-.27-.002-.492.297-.494.668l-.012 1.876c-.003.371.214.673.485.675l4.14.027c.271.002.492-.298.495-.668l.012-1.877c.003-.37-.215-.672-.485-.674z' style='clip-rule:evenodd;fill:%23fff;fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:2.47727823;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:.4' transform='translate(15.553 2.85)scale(.88807)'/%3E%3C/g%3E%3C/svg%3E")
            }
        }

        .maplibregl-ctrl.maplibregl-ctrl-attrib {
            background-color: hsla(0, 0%, 100%, .5);
            margin: 0;
            padding: 0 5px
        }

        @media screen {
            .maplibregl-ctrl-attrib.maplibregl-compact {
                background-color: #fff;
                border-radius: 12px;
                box-sizing: content-box;
                color: #000;
                margin: 10px;
                min-height: 20px;
                padding: 2px 24px 2px 0;
                position: relative
            }

            .maplibregl-ctrl-attrib.maplibregl-compact-show {
                padding: 2px 28px 2px 8px;
                visibility: visible
            }

            .maplibregl-ctrl-bottom-left>.maplibregl-ctrl-attrib.maplibregl-compact-show,
            .maplibregl-ctrl-top-left>.maplibregl-ctrl-attrib.maplibregl-compact-show {
                border-radius: 12px;
                padding: 2px 8px 2px 28px
            }

            .maplibregl-ctrl-attrib.maplibregl-compact .maplibregl-ctrl-attrib-inner {
                display: none
            }

            .maplibregl-ctrl-attrib-button {
                background-color: hsla(0, 0%, 100%, .5);
                background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' fill-rule='evenodd' viewBox='0 0 20 20'%3E%3Cpath d='M4 10a6 6 0 1 0 12 0 6 6 0 1 0-12 0m5-3a1 1 0 1 0 2 0 1 1 0 1 0-2 0m0 3a1 1 0 1 1 2 0v3a1 1 0 1 1-2 0'/%3E%3C/svg%3E");
                border: 0;
                border-radius: 12px;
                box-sizing: border-box;
                cursor: pointer;
                display: none;
                height: 24px;
                outline: none;
                position: absolute;
                right: 0;
                top: 0;
                width: 24px
            }

            .maplibregl-ctrl-attrib summary.maplibregl-ctrl-attrib-button {
                -webkit-appearance: none;
                -moz-appearance: none;
                appearance: none;
                list-style: none
            }

            .maplibregl-ctrl-attrib summary.maplibregl-ctrl-attrib-button::-webkit-details-marker {
                display: none
            }

            .maplibregl-ctrl-bottom-left .maplibregl-ctrl-attrib-button,
            .maplibregl-ctrl-top-left .maplibregl-ctrl-attrib-button {
                left: 0
            }

            .maplibregl-ctrl-attrib.maplibregl-compact .maplibregl-ctrl-attrib-button,
            .maplibregl-ctrl-attrib.maplibregl-compact-show .maplibregl-ctrl-attrib-inner {
                display: block
            }

            .maplibregl-ctrl-attrib.maplibregl-compact-show .maplibregl-ctrl-attrib-button {
                background-color: rgb(0 0 0/5%)
            }

            .maplibregl-ctrl-bottom-right>.maplibregl-ctrl-attrib.maplibregl-compact:after {
                bottom: 0;
                right: 0
            }

            .maplibregl-ctrl-top-right>.maplibregl-ctrl-attrib.maplibregl-compact:after {
                right: 0;
                top: 0
            }

            .maplibregl-ctrl-top-left>.maplibregl-ctrl-attrib.maplibregl-compact:after {
                left: 0;
                top: 0
            }

            .maplibregl-ctrl-bottom-left>.maplibregl-ctrl-attrib.maplibregl-compact:after {
                bottom: 0;
                left: 0
            }
        }

        @media screen and (forced-colors:active) {
            .maplibregl-ctrl-attrib.maplibregl-compact:after {
                background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' fill='%23fff' fill-rule='evenodd' viewBox='0 0 20 20'%3E%3Cpath d='M4 10a6 6 0 1 0 12 0 6 6 0 1 0-12 0m5-3a1 1 0 1 0 2 0 1 1 0 1 0-2 0m0 3a1 1 0 1 1 2 0v3a1 1 0 1 1-2 0'/%3E%3C/svg%3E")
            }
        }

        @media screen and (forced-colors:active) and (prefers-color-scheme:light) {
            .maplibregl-ctrl-attrib.maplibregl-compact:after {
                background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' fill-rule='evenodd' viewBox='0 0 20 20'%3E%3Cpath d='M4 10a6 6 0 1 0 12 0 6 6 0 1 0-12 0m5-3a1 1 0 1 0 2 0 1 1 0 1 0-2 0m0 3a1 1 0 1 1 2 0v3a1 1 0 1 1-2 0'/%3E%3C/svg%3E")
            }
        }

        .maplibregl-ctrl-attrib a {
            color: rgba(0, 0, 0, .75);
            text-decoration: none
        }

        .maplibregl-ctrl-attrib a:hover {
            color: inherit;
            text-decoration: underline
        }

        .maplibregl-attrib-empty {
            display: none
        }

        .maplibregl-ctrl-scale {
            background-color: hsla(0, 0%, 100%, .75);
            border: 2px solid #333;
            border-top: #333;
            box-sizing: border-box;
            color: #333;
            font-size: 10px;
            padding: 0 5px
        }

        .maplibregl-popup {
            display: flex;
            left: 0;
            pointer-events: none;
            position: absolute;
            top: 0;
            will-change: transform
        }

        .maplibregl-popup-anchor-top,
        .maplibregl-popup-anchor-top-left,
        .maplibregl-popup-anchor-top-right {
            flex-direction: column
        }

        .maplibregl-popup-anchor-bottom,
        .maplibregl-popup-anchor-bottom-left,
        .maplibregl-popup-anchor-bottom-right {
            flex-direction: column-reverse
        }

        .maplibregl-popup-anchor-left {
            flex-direction: row
        }

        .maplibregl-popup-anchor-right {
            flex-direction: row-reverse
        }

        .maplibregl-popup-tip {
            border: 10px solid transparent;
            height: 0;
            width: 0;
            z-index: 1
        }

        .maplibregl-popup-anchor-top .maplibregl-popup-tip {
            align-self: center;
            border-bottom-color: #fff;
            border-top: none
        }

        .maplibregl-popup-anchor-top-left .maplibregl-popup-tip {
            align-self: flex-start;
            border-bottom-color: #fff;
            border-left: none;
            border-top: none
        }

        .maplibregl-popup-anchor-top-right .maplibregl-popup-tip {
            align-self: flex-end;
            border-bottom-color: #fff;
            border-right: none;
            border-top: none
        }

        .maplibregl-popup-anchor-bottom .maplibregl-popup-tip {
            align-self: center;
            border-bottom: none;
            border-top-color: #fff
        }

        .maplibregl-popup-anchor-bottom-left .maplibregl-popup-tip {
            align-self: flex-start;
            border-bottom: none;
            border-left: none;
            border-top-color: #fff
        }

        .maplibregl-popup-anchor-bottom-right .maplibregl-popup-tip {
            align-self: flex-end;
            border-bottom: none;
            border-right: none;
            border-top-color: #fff
        }

        .maplibregl-popup-anchor-left .maplibregl-popup-tip {
            align-self: center;
            border-left: none;
            border-right-color: #fff
        }

        .maplibregl-popup-anchor-right .maplibregl-popup-tip {
            align-self: center;
            border-left-color: #fff;
            border-right: none
        }

        .maplibregl-popup-close-button {
            background-color: transparent;
            border: 0;
            border-radius: 0 3px 0 0;
            cursor: pointer;
            position: absolute;
            right: 0;
            top: 0
        }

        .maplibregl-popup-close-button:hover {
            background-color: rgb(0 0 0/5%)
        }

        .maplibregl-popup-content {
            background: #fff;
            border-radius: 3px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, .1);
            padding: 15px 10px;
            pointer-events: auto;
            position: relative
        }

        .maplibregl-popup-anchor-top-left .maplibregl-popup-content {
            border-top-left-radius: 0
        }

        .maplibregl-popup-anchor-top-right .maplibregl-popup-content {
            border-top-right-radius: 0
        }

        .maplibregl-popup-anchor-bottom-left .maplibregl-popup-content {
            border-bottom-left-radius: 0
        }

        .maplibregl-popup-anchor-bottom-right .maplibregl-popup-content {
            border-bottom-right-radius: 0
        }

        .maplibregl-popup-track-pointer {
            display: none
        }

        .maplibregl-popup-track-pointer * {
            pointer-events: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            user-select: none
        }

        .maplibregl-map:hover .maplibregl-popup-track-pointer {
            display: flex
        }

        .maplibregl-map:active .maplibregl-popup-track-pointer {
            display: none
        }

        .maplibregl-marker {
            left: 0;
            position: absolute;
            top: 0;
            transition: opacity .2s;
            will-change: transform
        }

        .maplibregl-user-location-dot,
        .maplibregl-user-location-dot:before {
            background-color: #1da1f2;
            border-radius: 50%;
            height: 15px;
            width: 15px
        }

        .maplibregl-user-location-dot:before {
            animation: maplibregl-user-location-dot-pulse 2s infinite;
            content: "";
            position: absolute
        }

        .maplibregl-user-location-dot:after {
            border: 2px solid #fff;
            border-radius: 50%;
            box-shadow: 0 0 3px rgba(0, 0, 0, .35);
            box-sizing: border-box;
            content: "";
            height: 19px;
            left: -2px;
            position: absolute;
            top: -2px;
            width: 19px
        }

        @keyframes maplibregl-user-location-dot-pulse {
            0% {
                opacity: 1;
                transform: scale(1)
            }

            70% {
                opacity: 0;
                transform: scale(3)
            }

            to {
                opacity: 0;
                transform: scale(1)
            }
        }

        .maplibregl-user-location-dot-stale {
            background-color: #aaa
        }

        .maplibregl-user-location-dot-stale:after {
            display: none
        }

        .maplibregl-user-location-accuracy-circle {
            background-color: #1da1f233;
            border-radius: 100%;
            height: 1px;
            width: 1px
        }

        .maplibregl-crosshair,
        .maplibregl-crosshair .maplibregl-interactive,
        .maplibregl-crosshair .maplibregl-interactive:active {
            cursor: crosshair
        }

        .maplibregl-boxzoom {
            background: #fff;
            border: 2px dotted #202020;
            height: 0;
            left: 0;
            opacity: .5;
            position: absolute;
            top: 0;
            width: 0
        }

        .maplibregl-cooperative-gesture-screen {
            align-items: center;
            background: rgba(0, 0, 0, .4);
            color: #fff;
            display: flex;
            font-size: 1.4em;
            inset: 0;
            justify-content: center;
            line-height: 1.2;
            opacity: 0;
            padding: 1rem;
            pointer-events: none;
            position: absolute;
            transition: opacity 1s ease 1s;
            z-index: 99999
        }

        .maplibregl-cooperative-gesture-screen.maplibregl-show {
            opacity: 1;
            transition: opacity .05s
        }

        .maplibregl-cooperative-gesture-screen .maplibregl-mobile-message {
            display: none
        }

        @media (hover:none),
        (pointer:coarse) {
            .maplibregl-cooperative-gesture-screen .maplibregl-desktop-message {
                display: none
            }

            .maplibregl-cooperative-gesture-screen .maplibregl-mobile-message {
                display: block
            }
        }

        .maplibregl-pseudo-fullscreen {
            height: 100% !important;
            left: 0 !important;
            position: fixed !important;
            top: 0 !important;
            width: 100% !important;
            z-index: 99999
        }
    </style>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            color-scheme: light;
        }

        * {
            box-sizing: border-box;
            accent-color: #3563a7;
        }

        #map {
            width: 100%;
            height: calc(100% - 40px);
        }

        #map2 {
            width: 100%;
            height: 35vh;
            min-height: 300px;
        }

        #controls {
            position: fixed;
            right: 0;
            bottom: 30px;
            padding: 5px;
        }

        button {
            color: #FFF;
            background: #3563a7;
            border: solid 2px #ededeb;
            font-size: 18px;
            border-radius: 4px;
            padding: 0.2em 0.5em;
            transition: 0.1s;
            margin: 2px 0;
        }

        button:active {
            filter: brightness(0.8);
        }

        button.border-button {
            color: #3563a7;
            background: #FFF;
            border: solid 2px #3563a7;
        }

        #controls button {
            width: 50px;
            height: 50px;
            font-size: 22px;
            font-weight: bold;
            border-radius: 50%;
            padding: 0;
            box-shadow: 2px 1px 3px 1px rgba(0, 0, 0, 0.5);
        }

        .positionIcon {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #0094ff;
            outline: solid 3px #FFF;
        }

        dialog label {
            display: block;
        }

        dialog input[type="text"],
        dialog input[type="number"],
        dialog select,
        dialog textarea {
            width: 100%;
        }

        #kanban-type {
            display: flex;
            flex-wrap: wrap;
            margin: 8px 0;
        }

        #kanban-type div {
            width: 100%;
            display: flex;
            flex-wrap: nowrap;
        }

        #kanban-type label {
            width: 100%;
            border: solid 1px #888;
            border-radius: 3px;
            display: inline-block;
            padding: 2px 0.5em;
            line-height: 35px;
            margin: 3px;
            font-size: 18px;
            background: #FFF;
        }

        #kanban-type label:has(:checked) {
            border: solid 1px #3563a7;
            background: #cce7f7;
        }

        #kanban-type label img {
            vertical-align: middle;
            height: 35px;
            margin: 0 3px;
        }

        dialog {
            width: 100%;
            height: 100%;
            max-width: none;
            max-height: none;
            border: none;
            margin: 0;
            padding: 45px 5px 5px 5px;
        }

        dialog {
            background: #ededeb;
        }

        h3 {

            height: 40px;
            line-height: 40px;
            margin: 0;
            background: #3563a7;
            color: #FFF;
            padding: 0 0.7em;
        }

        dialog h3 {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            box-shadow: 0 0 4px rgba(0, 0, 0, 0.5);
        }

        .maplibregl-ctrl-attrib {
            padding: 2px 9px !important;
        }

        .maplibregl-ctrl-attrib a {
            pointer-events: none !important;
        }

        .maplibregl-ctrl-attrib-button {
            display: none !important;
        }

        .maplibregl-popup-content p {
            margin: 0.25em 0;
        }

        button.maplibregl-popup-close-button {
            color: #000;
        }

        h3 button {
            font-weight: bold;
            font-size: 18px;
            height: 36px;
            width: 36px;
            vertical-align: top;
            margin: 2px 8px 2px 0;
            color: #FFF;
            border-radius: 50%;
            border: solid 1px #FFF;
            background: #3563a7;
        }

        #menu {
            padding: 55px 8px 10px 8px;
        }

        #menu div button {
            height: 40px;
            width: 100%;
            text-align: left;
        }

        #photo {
            display: none;
        }

        .maplibregl-ctrl-attrib.maplibregl-compact .maplibregl-ctrl-attrib-inner {
            display: block !important;
        }

        label {
            margin: 8px 0;
        }

        label:has(input:disabled),
        label:has(input:disabled) * {
            color: #333;
            background: #CCC;
            text-decoration: line-through;
        }

        textarea {
            resize: vertical;
        }

        input[type="text"],
        input[type="number"],
        select,
        textarea {
            padding: 4px 4px;
            border-radius: 3px;
            font-size: 15px;
            border: solid 1px #666;
            margin-bottom: 6px;
        }

        input[type="text"]:focus,
        input[type="number"]:focus,
        select:focus,
        textarea:focus {
            border: solid 1px #3563a7;
            outline: solid 3px #8fb4ca;
        }

        button#append {
            width: 100%;
            height: 60px;
            border-radius: 10px;
            font-size: 20px;
        }

        hr {
            border: solid 1px #888;
            margin: 10px 0;
        }

        #map2 {
            border: solid 1px #999;
            border-radius: 4px;
        }
    </style>
</head>

<body>
    <h3><button id="menu_show">≣</button>探究ツール</h3>

    <div id="map"></div>

    <dialog id="dialog">
        <h3><button id="cancel">＜</button> 看板を追加</h3>

        <div>地図をタップして位置を調整</div>
        <div id="map2"></div>

        <div style="padding:0 4px;">
            <div id="kanban-type">
                <div>
                    <label><input type="radio" name="kanban-type" id="type-1" value="sode">
                        <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgoKPHN2ZwogICB3aWR0aD0iMzguOTAxNTczbW0iCiAgIGhlaWdodD0iMzguODAzODQxbW0iCiAgIHZpZXdCb3g9IjAgMCAzOC45MDE1NzMgMzguODAzODQxIgogICB2ZXJzaW9uPSIxLjEiCiAgIGlkPSJzdmcxIgogICB4bWxuczppbmtzY2FwZT0iaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZSIKICAgeG1sbnM6c29kaXBvZGk9Imh0dHA6Ly9zb2RpcG9kaS5zb3VyY2Vmb3JnZS5uZXQvRFREL3NvZGlwb2RpLTAuZHRkIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBpZD0ibmFtZWR2aWV3MSIKICAgICBwYWdlY29sb3I9IiM1MDUwNTAiCiAgICAgYm9yZGVyY29sb3I9IiNlZWVlZWUiCiAgICAgYm9yZGVyb3BhY2l0eT0iMSIKICAgICBpbmtzY2FwZTpzaG93cGFnZXNoYWRvdz0iMCIKICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMCIKICAgICBpbmtzY2FwZTpwYWdlY2hlY2tlcmJvYXJkPSIwIgogICAgIGlua3NjYXBlOmRlc2tjb2xvcj0iIzUwNTA1MCIKICAgICBpbmtzY2FwZTpkb2N1bWVudC11bml0cz0ibW0iIC8+CiAgPGRlZnMKICAgICBpZD0iZGVmczEiIC8+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiCiAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTY4LjQyMDg0NywtNzIuNjI1NDc5KSI+CiAgICA8ZwogICAgICAgaWQ9Imc0IgogICAgICAgaW5rc2NhcGU6ZXhwb3J0LWZpbGVuYW1lPSJzb2RlLnN2ZyIKICAgICAgIGlua3NjYXBlOmV4cG9ydC14ZHBpPSIyMC44OTM3NTciCiAgICAgICBpbmtzY2FwZTpleHBvcnQteWRwaT0iMjAuODkzNzU3Ij4KICAgICAgPGcKICAgICAgICAgaWQ9ImcxMyI+CiAgICAgICAgPHJlY3QKICAgICAgICAgICBzdHlsZT0iZmlsbDojZmZmZmZmO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojYzdjN2M3O3N0cm9rZS13aWR0aDowO3N0cm9rZS1saW5lY2FwOnJvdW5kO3BhaW50LW9yZGVyOm1hcmtlcnMgZmlsbCBzdHJva2UiCiAgICAgICAgICAgaWQ9InJlY3QxIgogICAgICAgICAgIHdpZHRoPSIzOC45MDE1NzciCiAgICAgICAgICAgaGVpZ2h0PSIzOC44MDM4MzciCiAgICAgICAgICAgeD0iNjguNDIwODQ1IgogICAgICAgICAgIHk9IjcyLjYyNTQ4MSIgLz4KICAgICAgICA8cmVjdAogICAgICAgICAgIHN0eWxlPSJmaWxsOiM2NjY2NjY7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOiNjN2M3Yzc7c3Ryb2tlLXdpZHRoOjA7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7cGFpbnQtb3JkZXI6bWFya2VycyBmaWxsIHN0cm9rZSIKICAgICAgICAgICBpZD0icmVjdDIiCiAgICAgICAgICAgd2lkdGg9IjMuNjMxMjgxOSIKICAgICAgICAgICBoZWlnaHQ9IjM4LjgwMzgzNyIKICAgICAgICAgICB4PSI2OC40MjA4NDUiCiAgICAgICAgICAgeT0iNzIuNjI1NDgxIiAvPgogICAgICAgIDxwYXRoCiAgICAgICAgICAgaWQ9InJlY3QyLTYtNCIKICAgICAgICAgICBzdHlsZT0ic3Ryb2tlLXdpZHRoOjAuMztzdHJva2UtbGluZWNhcDpyb3VuZDtwYWludC1vcmRlcjptYXJrZXJzIGZpbGwgc3Ryb2tlIgogICAgICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOm9mZnNldCIKICAgICAgICAgICBpbmtzY2FwZTpyYWRpdXM9IjEuMTUzNjIxMiIKICAgICAgICAgICBpbmtzY2FwZTpvcmlnaW5hbD0iTSA3Ny4wODIwMzEgODAuMzYxMzI4IEMgNzYuNzQ5NjMxIDgwLjM2MTMyOCA3Ni40ODI0MjIgODAuNjMwNDkxIDc2LjQ4MjQyMiA4MC45NjI4OTEgTCA3Ni40ODI0MjIgMTAzLjA5MTggQyA3Ni40ODI0MjIgMTAzLjQyNDIgNzYuNzQ5NjMxIDEwMy42OTMzNiA3Ny4wODIwMzEgMTAzLjY5MzM2IEwgMTA0LjYzNDc3IDEwMy42OTMzNiBDIDEwNC45NjcxNyAxMDMuNjkzMzYgMTA1LjIzNDM3IDEwMy40MjQyIDEwNS4yMzQzOCAxMDMuMDkxOCBMIDEwNS4yMzQzOCA4MC45NjI4OTEgQyAxMDUuMjM0MzggODAuNjMwNDkxIDEwNC45NjcxNyA4MC4zNjEzMjggMTA0LjYzNDc3IDgwLjM2MTMyOCBMIDc3LjA4MjAzMSA4MC4zNjEzMjggeiAiCiAgICAgICAgICAgZD0ibSA3Ny4wODIwMzEsNzkuMjA3MDMxIGMgLTAuOTU1MTY3LDAgLTEuNzUzOTA2LDAuODA1MjE0IC0xLjc1MzkwNiwxLjc1NTg2IFYgMTAzLjA5MTggYyAwLDAuOTUwNjQgMC43OTg3NDYsMS43NTU4NiAxLjc1MzkwNiwxLjc1NTg2IGggMjcuNTUyNzM5IGMgMC45NTUxNiwwIDEuNzUzODcsLTAuODA1MjYgMS43NTM5LC0xLjc1NTg2IFYgODAuOTYyODkxIGMgMCwtMC45NTA2NDkgLTAuNzk4NzQsLTEuNzU1ODYgLTEuNzUzOSwtMS43NTU4NiB6IiAvPgogICAgICAgIDxwYXRoCiAgICAgICAgICAgaWQ9InJlY3QyLTYiCiAgICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6I2ZmZmZmZjtzdHJva2Utd2lkdGg6MTtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjE7cGFpbnQtb3JkZXI6bm9ybWFsIgogICAgICAgICAgIHNvZGlwb2RpOnR5cGU9Imlua3NjYXBlOm9mZnNldCIKICAgICAgICAgICBpbmtzY2FwZTpyYWRpdXM9IjAiCiAgICAgICAgICAgaW5rc2NhcGU6b3JpZ2luYWw9Ik0gNzcuMDgyMDMxIDgwLjM2MTMyOCBDIDc2Ljc0OTYzMSA4MC4zNjEzMjggNzYuNDgyNDIyIDgwLjYzMDQ5MSA3Ni40ODI0MjIgODAuOTYyODkxIEwgNzYuNDgyNDIyIDEwMy4wOTE4IEMgNzYuNDgyNDIyIDEwMy40MjQyIDc2Ljc0OTYzMSAxMDMuNjkzMzYgNzcuMDgyMDMxIDEwMy42OTMzNiBMIDEwNC42MzQ3NyAxMDMuNjkzMzYgQyAxMDQuOTY3MTcgMTAzLjY5MzM2IDEwNS4yMzQzOCAxMDMuNDI0MiAxMDUuMjM0MzggMTAzLjA5MTggTCAxMDUuMjM0MzggODAuOTYyODkxIEMgMTA1LjIzNDM4IDgwLjYzMDQ5MSAxMDQuOTY3MTcgODAuMzYxMzI4IDEwNC42MzQ3NyA4MC4zNjEzMjggTCA3Ny4wODIwMzEgODAuMzYxMzI4IHogIgogICAgICAgICAgIGQ9Im0gNzcuMDgyMDMxLDgwLjM2MTMyOCBjIC0wLjMzMjQsMCAtMC41OTk2MDksMC4yNjkxNjMgLTAuNTk5NjA5LDAuNjAxNTYzIFYgMTAzLjA5MTggYyAwLDAuMzMyNCAwLjI2NzIwOSwwLjYwMTU2IDAuNTk5NjA5LDAuNjAxNTYgaCAyNy41NTI3MzkgYyAwLjMzMjQsMCAwLjU5OTYxLC0wLjI2OTE2IDAuNTk5NjEsLTAuNjAxNTYgViA4MC45NjI4OTEgYyAwLC0wLjMzMjQgLTAuMjY3MjEsLTAuNjAxNTYzIC0wLjU5OTYxLC0wLjYwMTU2MyB6IiAvPgogICAgICAgIDxyZWN0CiAgICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MC4zNzcxNzg7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjE7cGFpbnQtb3JkZXI6bWFya2VycyBmaWxsIHN0cm9rZSIKICAgICAgICAgICBpZD0icmVjdDMiCiAgICAgICAgICAgd2lkdGg9IjQuMDUyNDEzIgogICAgICAgICAgIGhlaWdodD0iMTUuMDAyODk2IgogICAgICAgICAgIHg9IjcyLjA1MjEyNCIKICAgICAgICAgICB5PSI4NC41MjU5NDgiIC8+CiAgICAgIDwvZz4KICAgIDwvZz4KICA8L2c+Cjwvc3ZnPgo=">
                        袖看板</label>
                    <label><input type="radio" name="kanban-type" id="type-2" value="hekimen">
                        <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgoKPHN2ZwogICB3aWR0aD0iMzguOTAxNjA4bW0iCiAgIGhlaWdodD0iMzguODAzODQxbW0iCiAgIHZpZXdCb3g9IjAgMCAzOC45MDE2MDggMzguODAzODQxIgogICB2ZXJzaW9uPSIxLjEiCiAgIGlkPSJzdmcxIgogICB4bWxuczppbmtzY2FwZT0iaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZSIKICAgeG1sbnM6c29kaXBvZGk9Imh0dHA6Ly9zb2RpcG9kaS5zb3VyY2Vmb3JnZS5uZXQvRFREL3NvZGlwb2RpLTAuZHRkIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBpZD0ibmFtZWR2aWV3MSIKICAgICBwYWdlY29sb3I9IiM1MDUwNTAiCiAgICAgYm9yZGVyY29sb3I9IiNlZWVlZWUiCiAgICAgYm9yZGVyb3BhY2l0eT0iMSIKICAgICBpbmtzY2FwZTpzaG93cGFnZXNoYWRvdz0iMCIKICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMCIKICAgICBpbmtzY2FwZTpwYWdlY2hlY2tlcmJvYXJkPSIwIgogICAgIGlua3NjYXBlOmRlc2tjb2xvcj0iIzUwNTA1MCIKICAgICBpbmtzY2FwZTpkb2N1bWVudC11bml0cz0ibW0iIC8+CiAgPGRlZnMKICAgICBpZD0iZGVmczEiIC8+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiCiAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTExNi4xMTMwMiwtNzIuNjI1NDc5KSI+CiAgICA8ZwogICAgICAgaWQ9Imc3IgogICAgICAgaW5rc2NhcGU6ZXhwb3J0LWZpbGVuYW1lPSJrYWdlLnN2ZyIKICAgICAgIGlua3NjYXBlOmV4cG9ydC14ZHBpPSIyMC44OTM3NTciCiAgICAgICBpbmtzY2FwZTpleHBvcnQteWRwaT0iMjAuODkzNzU3Ij4KICAgICAgPHJlY3QKICAgICAgICAgc3R5bGU9ImZpbGw6I2ZmZmZmZjtmaWxsLW9wYWNpdHk6MTtzdHJva2U6I2M3YzdjNztzdHJva2Utd2lkdGg6MDtzdHJva2UtbGluZWNhcDpyb3VuZDtwYWludC1vcmRlcjptYXJrZXJzIGZpbGwgc3Ryb2tlIgogICAgICAgICBpZD0icmVjdDEtNyIKICAgICAgICAgd2lkdGg9IjM4LjkwMTU3NyIKICAgICAgICAgaGVpZ2h0PSIzOC44MDM4MzciCiAgICAgICAgIHg9IjExNi4xMTMwMyIKICAgICAgICAgeT0iNzIuNjI1NDgxIiAvPgogICAgICA8cmVjdAogICAgICAgICBzdHlsZT0iZmlsbDojNjY2NjY2O2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojYzdjN2M3O3N0cm9rZS13aWR0aDowO3N0cm9rZS1saW5lY2FwOnJvdW5kO3BhaW50LW9yZGVyOm1hcmtlcnMgZmlsbCBzdHJva2UiCiAgICAgICAgIGlkPSJyZWN0Mi02NCIKICAgICAgICAgd2lkdGg9IjM4LjkwMTYwNCIKICAgICAgICAgaGVpZ2h0PSIzOC44MDM4MzciCiAgICAgICAgIHg9IjExNi4xMTMwMyIKICAgICAgICAgeT0iNzIuNjI1NDgxIiAvPgogICAgICA8cGF0aAogICAgICAgICBpZD0icmVjdDQtNSIKICAgICAgICAgc3R5bGU9ImZpbGw6IzAwMDAwMDtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MTtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjE7cGFpbnQtb3JkZXI6bm9ybWFsIgogICAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpvZmZzZXQiCiAgICAgICAgIGlua3NjYXBlOnJhZGl1cz0iMS4wMjkyMDk2IgogICAgICAgICBpbmtzY2FwZTpvcmlnaW5hbD0iTSAxMTkuNTIzNDQgODUuMzA0Njg4IEMgMTE5LjE2MzM0IDg1LjMwNDY4OCAxMTguODczMDUgODUuNTcyMTcxIDExOC44NzMwNSA4NS45MDYyNSBMIDExOC44NzMwNSA5OC4xNDg0MzggQyAxMTguODczMDUgOTguNDgyNTE2IDExOS4xNjMzNCA5OC43NSAxMTkuNTIzNDQgOTguNzUgTCAxNTEuNjAzNTIgOTguNzUgQyAxNTEuOTYzNjIgOTguNzUgMTUyLjI1MzkxIDk4LjQ4MjUxNiAxNTIuMjUzOTEgOTguMTQ4NDM4IEwgMTUyLjI1MzkxIDg1LjkwNjI1IEMgMTUyLjI1MzkxIDg1LjU3MjE3MSAxNTEuOTYzNjIgODUuMzA0Njg4IDE1MS42MDM1MiA4NS4zMDQ2ODggTCAxMTkuNTIzNDQgODUuMzA0Njg4IHogIgogICAgICAgICBkPSJtIDExOS41MjM0NCw4NC4yNzUzOTEgYyAtMC44Njk3NywwIC0xLjY3OTY5LDAuNzAwNTc2IC0xLjY3OTY5LDEuNjMwODU5IHYgMTIuMjQyMTg3IGMgMCwwLjkzMDI4NCAwLjgwOTkyLDEuNjMwODYgMS42Nzk2OSwxLjYzMDg2IGggMzIuMDgwMDggYyAwLjg2OTc2LDAgMS42Nzk2OCwtMC43MDA1NzYgMS42Nzk2OCwtMS42MzA4NiBWIDg1LjkwNjI1IGMgMCwtMC45MzAyODMgLTAuODA5OTIsLTEuNjMwODU5IC0xLjY3OTY4LC0xLjYzMDg1OSB6IiAvPgogICAgICA8cGF0aAogICAgICAgICBpZD0icmVjdDQiCiAgICAgICAgIHN0eWxlPSJmaWxsOiMwMDAwMDA7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOiNmZmZmZmY7c3Ryb2tlLXdpZHRoOjE7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxO3BhaW50LW9yZGVyOm5vcm1hbCIKICAgICAgICAgc29kaXBvZGk6dHlwZT0iaW5rc2NhcGU6b2Zmc2V0IgogICAgICAgICBpbmtzY2FwZTpyYWRpdXM9IjAiCiAgICAgICAgIGlua3NjYXBlOm9yaWdpbmFsPSJNIDExOS41MjM0NCA4NS4zMDQ2ODggQyAxMTkuMTYzMzQgODUuMzA0Njg4IDExOC44NzMwNSA4NS41NzIxNzEgMTE4Ljg3MzA1IDg1LjkwNjI1IEwgMTE4Ljg3MzA1IDk4LjE0ODQzOCBDIDExOC44NzMwNSA5OC40ODI1MTYgMTE5LjE2MzM0IDk4Ljc1IDExOS41MjM0NCA5OC43NSBMIDE1MS42MDM1MiA5OC43NSBDIDE1MS45NjM2MiA5OC43NSAxNTIuMjUzOTEgOTguNDgyNTE2IDE1Mi4yNTM5MSA5OC4xNDg0MzggTCAxNTIuMjUzOTEgODUuOTA2MjUgQyAxNTIuMjUzOTEgODUuNTcyMTcxIDE1MS45NjM2MiA4NS4zMDQ2ODggMTUxLjYwMzUyIDg1LjMwNDY4OCBMIDExOS41MjM0NCA4NS4zMDQ2ODggeiAiCiAgICAgICAgIGQ9Im0gMTE5LjUyMzQ0LDg1LjMwNDY4OCBjIC0wLjM2MDEsMCAtMC42NTAzOSwwLjI2NzQ4MyAtMC42NTAzOSwwLjYwMTU2MiB2IDEyLjI0MjE4OCBjIDAsMC4zMzQwNzggMC4yOTAyOSwwLjYwMTU2MiAwLjY1MDM5LDAuNjAxNTYyIGggMzIuMDgwMDggYyAwLjM2MDEsMCAwLjY1MDM5LC0wLjI2NzQ4NCAwLjY1MDM5LC0wLjYwMTU2MiBWIDg1LjkwNjI1IGMgMCwtMC4zMzQwNzkgLTAuMjkwMjksLTAuNjAxNTYyIC0wLjY1MDM5LC0wLjYwMTU2MiB6IiAvPgogICAgPC9nPgogIDwvZz4KPC9zdmc+Cg==">
                        壁面看板</label>
                </div>
                <div>
                    <!--<label><input type="radio" name="kanban-type" id="type-3" value="oki">
                <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgoKPHN2ZwogICB3aWR0aD0iMzguOTAxNTk2bW0iCiAgIGhlaWdodD0iMzguODAzODMzbW0iCiAgIHZpZXdCb3g9IjAgMCAzOC45MDE1OTYgMzguODAzODMzIgogICB2ZXJzaW9uPSIxLjEiCiAgIGlkPSJzdmcxIgogICB4bWxuczppbmtzY2FwZT0iaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZSIKICAgeG1sbnM6c29kaXBvZGk9Imh0dHA6Ly9zb2RpcG9kaS5zb3VyY2Vmb3JnZS5uZXQvRFREL3NvZGlwb2RpLTAuZHRkIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBpZD0ibmFtZWR2aWV3MSIKICAgICBwYWdlY29sb3I9IiM1MDUwNTAiCiAgICAgYm9yZGVyY29sb3I9IiNlZWVlZWUiCiAgICAgYm9yZGVyb3BhY2l0eT0iMSIKICAgICBpbmtzY2FwZTpzaG93cGFnZXNoYWRvdz0iMCIKICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMCIKICAgICBpbmtzY2FwZTpwYWdlY2hlY2tlcmJvYXJkPSIwIgogICAgIGlua3NjYXBlOmRlc2tjb2xvcj0iIzUwNTA1MCIKICAgICBpbmtzY2FwZTpkb2N1bWVudC11bml0cz0ibW0iIC8+CiAgPGRlZnMKICAgICBpZD0iZGVmczEiIC8+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiCiAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTY4LjQyMDgzMSwtMTE3LjMzMjY1KSI+CiAgICA8ZwogICAgICAgaWQ9Imc5Ij4KICAgICAgPHJlY3QKICAgICAgICAgc3R5bGU9ImZpbGw6I2ZmZmZmZjtmaWxsLW9wYWNpdHk6MTtzdHJva2U6I2M3YzdjNztzdHJva2Utd2lkdGg6MDtzdHJva2UtbGluZWNhcDpyb3VuZDtwYWludC1vcmRlcjptYXJrZXJzIGZpbGwgc3Ryb2tlIgogICAgICAgICBpZD0icmVjdDItNjQtNSIKICAgICAgICAgd2lkdGg9IjM4LjkwMTYwNCIKICAgICAgICAgaGVpZ2h0PSIzOC44MDM4MzciCiAgICAgICAgIHg9IjY4LjQyMDgzIgogICAgICAgICB5PSIxMTcuMzMyNjUiIC8+CiAgICAgIDxnCiAgICAgICAgIGlkPSJnNi02IgogICAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxLjM1OTc2LC0zLjUwMjI0MzMpIj4KICAgICAgICA8cGF0aAogICAgICAgICAgIGlkPSJyZWN0Ni04IgogICAgICAgICAgIHN0eWxlPSJmaWxsOiMyZTJlMmU7c3Ryb2tlOiMyZTJlMmU7c3Ryb2tlLXdpZHRoOjAuNzExNzMyO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZCIKICAgICAgICAgICBzb2RpcG9kaTp0eXBlPSJpbmtzY2FwZTpvZmZzZXQiCiAgICAgICAgICAgaW5rc2NhcGU6cmFkaXVzPSIwLjY2MjExMDAzIgogICAgICAgICAgIGlua3NjYXBlOm9yaWdpbmFsPSJNIC0xMjkuNDg4MjggMTI1LjE1NDMgTCAtMTQ1LjkyMzgzIDE1Ny41NTg1OSBMIC0xNDMuNTQ2ODggMTU3LjU1ODU5IEwgLTE0MS4wMTU2MiAxNTIuNTY4MzYgTCAtMTI5LjQ4ODI4IDE1Mi41NjgzNiBMIC0xMjkuNDg4MjggMTU3LjU1ODU5IEwgLTEyOC4zOTY0OCAxNTcuNTU4NTkgTCAtMTI2LjA0Njg4IDE1Ny41NTg1OSBMIC0xMDkuNjExMzMgMTU3LjU1ODU5IEwgLTEwOS42MTEzMyAxMjUuMTU0MyBMIC0xMjkuNDg4MjggMTI1LjE1NDMgeiAiCiAgICAgICAgICAgZD0ibSAtMTI5LjQ4ODI4LDEyNC40OTIxOSBhIDAuNjYyMTc2MjQsMC42NjIxNzYyNCAwIDAgMCAtMC41ODk4NCwwLjM2MzI4IGwgLTE2LjQzNTU1LDMyLjQwNDMgYSAwLjY2MjE3NjI0LDAuNjYyMTc2MjQgMCAwIDAgMC41ODk4NCwwLjk2MDkzIGggMi4zNzY5NiBhIDAuNjYyMTc2MjQsMC42NjIxNzYyNCAwIDAgMCAwLjU4OTg0LC0wLjM2MzI4IGwgMi4zNDc2NiwtNC42MjY5NSBoIDEwLjQ1ODk4IHYgNC4zMjgxMiBhIDAuNjYyMTc2MjQsMC42NjIxNzYyNCAwIDAgMCAwLjY2MjExLDAuNjYyMTEgaCAxLjA5MTggMi4zNDk2IDE2LjQzNTU1IGEgMC42NjIxNzYyNCwwLjY2MjE3NjI0IDAgMCAwIDAuNjYyMTEsLTAuNjYyMTEgViAxMjUuMTU0MyBhIDAuNjYyMTc2MjQsMC42NjIxNzYyNCAwIDAgMCAtMC42NjIxMSwtMC42NjIxMSB6IgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KC0xLDAsLTAuMjUzNjIyMjIsMC45NjczMDMzNSwtMS4zNTk5MDY2LDMuNTAyNzI5NikiIC8+CiAgICAgIDwvZz4KICAgICAgPGcKICAgICAgICAgaWQ9Imc2Ij4KICAgICAgICA8cmVjdAogICAgICAgICAgIHN0eWxlPSJmaWxsOiMyZTJlMmU7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOiMyZTJlMmU7c3Ryb2tlLXdpZHRoOjAuNzExNzMyO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MTtwYWludC1vcmRlcjpub3JtYWwiCiAgICAgICAgICAgaWQ9InJlY3Q2IgogICAgICAgICAgIHdpZHRoPSIxOS44NzY0NDgiCiAgICAgICAgICAgaGVpZ2h0PSIzMi40MDMxMDMiCiAgICAgICAgICAgeD0iLTEyOS40ODc3NSIKICAgICAgICAgICB5PSIxMjUuMTU0OCIKICAgICAgICAgICByeT0iMCIKICAgICAgICAgICB0cmFuc2Zvcm09Im1hdHJpeCgtMSwwLC0wLjI1MzYyMjIyLDAuOTY3MzAzMzUsMCwwKSIgLz4KICAgICAgICA8cGF0aAogICAgICAgICAgIGlkPSJwYXRoNiIKICAgICAgICAgICBzdHlsZT0iZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojZmZmZmZmO3N0cm9rZS13aWR0aDowLjk7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxO3BhaW50LW9yZGVyOm5vcm1hbCIKICAgICAgICAgICBkPSJtIDc3Ljg2OTI3MiwxMjEuMDYyNjYgOC4yMTgxMDIsMzEuMzQzODIgaCAyLjM0ODE3NyBsIC0xLjI2NTU1NiwtNC44MjcwOSBoIDE1LjE0OTk4NSBsIDEuMjY1NTYsNC44MjcwOSBoIDIuMzc4NjYgbCAtOC4yMTgxMDUsLTMxLjM0MzgyIHoiIC8+CiAgICAgIDwvZz4KICAgIDwvZz4KICA8L2c+Cjwvc3ZnPgo=">
                置き看板</label>-->
                    <label><input type="radio" name="kanban-type" id="type-4" value="kenshoku">
                        <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgoKPHN2ZwogICB3aWR0aD0iMzguOTAxNjE1bW0iCiAgIGhlaWdodD0iMzguODAzODMzbW0iCiAgIHZpZXdCb3g9IjAgMCAzOC45MDE2MTUgMzguODAzODMzIgogICB2ZXJzaW9uPSIxLjEiCiAgIGlkPSJzdmcxIgogICB4bWxuczppbmtzY2FwZT0iaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZSIKICAgeG1sbnM6c29kaXBvZGk9Imh0dHA6Ly9zb2RpcG9kaS5zb3VyY2Vmb3JnZS5uZXQvRFREL3NvZGlwb2RpLTAuZHRkIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBpZD0ibmFtZWR2aWV3MSIKICAgICBwYWdlY29sb3I9IiM1MDUwNTAiCiAgICAgYm9yZGVyY29sb3I9IiNlZWVlZWUiCiAgICAgYm9yZGVyb3BhY2l0eT0iMSIKICAgICBpbmtzY2FwZTpzaG93cGFnZXNoYWRvdz0iMCIKICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMCIKICAgICBpbmtzY2FwZTpwYWdlY2hlY2tlcmJvYXJkPSIwIgogICAgIGlua3NjYXBlOmRlc2tjb2xvcj0iIzUwNTA1MCIKICAgICBpbmtzY2FwZTpkb2N1bWVudC11bml0cz0ibW0iIC8+CiAgPGRlZnMKICAgICBpZD0iZGVmczEiIC8+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiCiAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTExNi4xMTMsLTExNy4zMzI2NSkiPgogICAgPHJlY3QKICAgICAgIHN0eWxlPSJmaWxsOiNmZmZmZmY7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOiNjN2M3Yzc7c3Ryb2tlLXdpZHRoOjA7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7cGFpbnQtb3JkZXI6bWFya2VycyBmaWxsIHN0cm9rZSIKICAgICAgIGlkPSJyZWN0MS03LTMiCiAgICAgICB3aWR0aD0iMzguOTAxNTc3IgogICAgICAgaGVpZ2h0PSIzOC44MDM4MzciCiAgICAgICB4PSIxMTYuMTEzMDEiCiAgICAgICB5PSIxMTcuMzMyNjUiIC8+CiAgICA8cmVjdAogICAgICAgc3R5bGU9ImZpbGw6I2ZmZmZmZjtmaWxsLW9wYWNpdHk6MTtzdHJva2U6I2ZmZmZmZjtzdHJva2Utd2lkdGg6MDtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2Utb3BhY2l0eToxO3BhaW50LW9yZGVyOm1hcmtlcnMgZmlsbCBzdHJva2UiCiAgICAgICBpZD0icmVjdDItNjQtMSIKICAgICAgIHdpZHRoPSIzOC45MDE2MDQiCiAgICAgICBoZWlnaHQ9IjM4LjgwMzgzNyIKICAgICAgIHg9IjExNi4xMTMwMSIKICAgICAgIHk9IjExNy4zMzI2NSIgLz4KICAgIDxnCiAgICAgICBpZD0iZzEwIj4KICAgICAgPHBhdGgKICAgICAgICAgaWQ9InJlY3Q5LTQiCiAgICAgICAgIHN0eWxlPSJmaWxsOiNmZmZmZmY7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBkPSJtIDExOS4yMDA1NiwxMjAuNzMwMTYgaCAwLjA3OSBjIDAuMzg3OCwwIDAuNywwLjMxMjIgMC43LDAuNyB2IDMxLjI1MzMxIGMgMCwwLjM4NzggLTAuMzEyMiwwLjcgLTAuNywwLjcgaCAtMC4wNzkgYyAtMC4zODc4LDAgLTAuNywtMC4zMTIyIC0wLjcsLTAuNyB2IC0zMS4yNTMzMSBjIDAsLTAuMzg3OCAwLjMxMjIsLTAuNyAwLjcsLTAuNyB6IiAvPgogICAgICA8cGF0aAogICAgICAgICBpZD0icmVjdDktNC01IgogICAgICAgICBzdHlsZT0iZmlsbDojZmZmZmZmO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoyO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgICAgZD0ibSAxNTEuODQ4MDQsMTIwLjczMDE2IGggMC4wNzkgYyAwLjM4NzgsMCAwLjcsMC4zMTIyIDAuNywwLjcgdiAzMS4yNTMzMSBjIDAsMC4zODc4IC0wLjMxMjIsMC43IC0wLjcsMC43IGggLTAuMDc5IGMgLTAuMzg3OCwwIC0wLjcsLTAuMzEyMiAtMC43LC0wLjcgdiAtMzEuMjUzMzEgYyAwLC0wLjM4NzggMC4zMTIyLC0wLjcgMC43LC0wLjcgeiIKICAgICAgICAgaW5rc2NhcGU6bGFiZWw9InJlY3Q5LTQtNSIgLz4KICAgIDwvZz4KICAgIDxyZWN0CiAgICAgICBzdHlsZT0iZmlsbDojMDAwMDAwO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDoyLjEwMTA3O3N0cm9rZS1saW5lY2FwOnNxdWFyZTtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjE7cGFpbnQtb3JkZXI6bm9ybWFsIgogICAgICAgaWQ9InJlY3QxMyIKICAgICAgIHdpZHRoPSIzMi42NDc0OCIKICAgICAgIGhlaWdodD0iMjQuMDQ0NjI2IgogICAgICAgeD0iMTE5LjI0MDA2IgogICAgICAgeT0iMTE5LjczMDE2IiAvPgogICAgPGcKICAgICAgIGlkPSJnMTIiCiAgICAgICBzdHlsZT0iZGlzcGxheTppbmxpbmUiPgogICAgICA8cmVjdAogICAgICAgICBzdHlsZT0iZmlsbDojZmZmZmZmO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDowLjI3NjIyNztzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjE7cGFpbnQtb3JkZXI6bm9ybWFsIgogICAgICAgICBpZD0icmVjdDExIgogICAgICAgICB3aWR0aD0iMS40NzkwMDE0IgogICAgICAgICBoZWlnaHQ9IjMyLjg2MDkwNSIKICAgICAgICAgeD0iMTE4LjUwMDU2IgogICAgICAgICB5PSIxMjAuNTIyNTciCiAgICAgICAgIHJ4PSIwLjY5OTk5OTk5IgogICAgICAgICByeT0iMC43MDQ0NTAzMSIgLz4KICAgICAgPHJlY3QKICAgICAgICAgc3R5bGU9ImZpbGw6I2ZmZmZmZjtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MC4yNzYyMjc7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxO3BhaW50LW9yZGVyOm5vcm1hbCIKICAgICAgICAgaWQ9InJlY3QxMiIKICAgICAgICAgd2lkdGg9IjEuNDc5MDAxNCIKICAgICAgICAgaGVpZ2h0PSIzMi44NjA5MDUiCiAgICAgICAgIHg9IjE1MS4xNDgwNCIKICAgICAgICAgeT0iMTIwLjUyMjU3IgogICAgICAgICByeD0iMC42OTk5OTk5OSIKICAgICAgICAgcnk9IjAuNzA0NDUwMzEiIC8+CiAgICAgIDxyZWN0CiAgICAgICAgIHN0eWxlPSJkaXNwbGF5OmlubGluZTtmaWxsOm5vbmU7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOiNmOWY5Zjk7c3Ryb2tlLXdpZHRoOjE7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxO3BhaW50LW9yZGVyOm5vcm1hbCIKICAgICAgICAgaWQ9InJlY3QxMCIKICAgICAgICAgd2lkdGg9IjMyLjY0NzQ4NCIKICAgICAgICAgaGVpZ2h0PSIyMS40NTk4MTgiCiAgICAgICAgIHg9IjExOS4yNDAwNiIKICAgICAgICAgeT0iMTIxLjAyMjU3IiAvPgogICAgPC9nPgogIDwvZz4KPC9zdmc+Cg==">
                        建植看板</label>
                    <label><input type="radio" name="kanban-type" id="type-5" value="other" checked>その他</label>
                </div>
            </div>

            <hr>

            <div>
                <label><button id="photo_b" class="border-button" style="display:block;width:100%;text-align:center;">📷写真を添付</button><input type="file" id="photo"></label>
            </div>

            <label>固定対象：<select id="fixed-part">
                    <option value="wall" id="fixed-part-default" selected>建物の壁面</option>
                    <option value="poll_exclusive" id="fixed-part-pollE">専用ポール</option>
                    <option value="poll" id="fixed-part-poll">兼用ポール（電柱など）</option>
                    <option value="other" id="fixed-part-other">その他</option>
                </select></label>
            <label>ポールの数：<input type="number" id="poll-num" min="1" max="20" placeholder="省略可"></label>
            <label>固定金具の数（ブラケット）：<input type="number" id="blacket-num" min="1" max="20" placeholder="省略可"></label>
            <label>さび 度合：<select id="rust">
                    <option value="lv1" selected id="rust-default">Lv.1_さび目視不可</option>
                    <option value="lv2">Lv.2_さび目視可／汚ダレあり</option>
                    <option value="lv3">Lv.3_さびで内容が分からない</option>
                </select></label>
            <label><input type="checkbox" id="huredome">振れ止め棒</label>
            <!--<label><input type="checkbox" id="caster">キャスター式</label>-->
            <label><input type="checkbox" id="light">電飾</label>

            <label>特記事項：<textarea placeholder="傾きなど各所見" id="appendix" rows="2"></textarea></label>

            <button id="append">⊕ 追加</button>
        </div>
    </dialog>

    <dialog id="menu">
        <h3><button id="menu_cancel">＜</button> メニュー</h3>

        <div>
            <button id="download_result">結果のダウンロード</button>
            <button id="download_root">移動ルートのダウンロード</button>
            <hr>
            <button id="share">結果の共有</button>
            <button id="share_r">共有状況を表示</button>
            <hr>
            <button id="reset">データのリセット</button>
        </div>
    </dialog>

    <div id="controls">
        <button id="moveToMyPosition" class="border-button" title="地図を現在地へ移動">📌</button>
        <button id="add" title="データを登録">+</button>
    </div>

    <script>
        var groupName;

        document.getElementById("reset").addEventListener("click", function () {
            var deleteReq = indexedDB.deleteDatabase("record");
            record = null;

            deleteReq.onsuccess = function (event) {
                location.reload()
            }

            deleteReq.onerror = function () {
                alert("リセットに失敗")
            }
        })

        document.getElementById("download_result").addEventListener("click", function () {
            const blob = new Blob([JSON.stringify(record.kanban)], { type: "application/geo+json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "Result.geojson";
            a.click();
            URL.revokeObjectURL(url);
        })

        document.getElementById("download_root").addEventListener("click", function () {
            const blob = new Blob([JSON.stringify(turf.lineString(record.location_history))], { type: "application/geo+json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "Root.geojson";
            a.click();
            URL.revokeObjectURL(url);
        })


        document.getElementById("share_r").addEventListener("click", function () {
            window.open("./share.html")
        })

        document.getElementById("share").addEventListener("click", function () {
            groupName = prompt("班の名前を入力（なんでもOK）", groupName ? groupName : "")
            if (groupName) {

                var send_data = {
                    groupName: groupName,
                    message: { kanban: record.kanban, location_history: turf.lineString(record.location_history) }
                }

                fetch('https://script.google.com/macros/s/AKfycbz6lLRZhqTRTz4forAVmZlIkMka4Fn-wNQeEhh74dVS0Ct0uxMA69J59g2TF0QuMx6McA/exec', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'text/plain'
                    },
                    body: JSON.stringify(send_data)
                })
                    .then(response => response.json())
                    .then(result => {
                        alert("共有が完了しました。")
                    })
                    .catch(error => {
                        alert("共有に失敗しました。")
                    });

                /*
                                const socket = new WebSocket('wss://cloud.achex.ca/horikawa-taiwan-jishin-tankyu329053480934');
                
                                socket.addEventListener('open', function (event) {
                                    console.log('open', event)
                                    socket.send('{"auth":"' + groupName + '", "password":"Aufgreiu543897%$ew!s"}');
                                    socket.send(JSON.stringify({ "to": "receiver", "msg": { kanban: record.kanban, location_history: turf.lineString(record.location_history) } }));
                                    alert("共有しました。")
                                });*/
            }
        })

        //   条件により項目を隠す
        //   歩いた軌跡
        //   予定道表示
        //   削除機能（編集いらん）
        //   位置調整画面
        //  localstorage
        //   リセット機能
        //   出力機能
        //リロード防止
        //オフライン地図・切り替え(OSMエクスポート)?
        //   OSM編集する
        //   写真（ときどき）
        //   achex共有
        //表表示？


        var record = {
            location_history: [],
            kanban: {
                "type": "FeatureCollection",
                "features": []
            }
        }
        var offlinemap = "data:image/png;base64,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"
        var map = new maplibregl.Map({
            container: 'map',
            attributionControl: false,
            localIdeographFontFamily: true,
            style: {
                version: 8,
                glyphs: "https://tile.openstreetmap.jp/fonts/{fontstack}/{range}.pbf",
                sources: {
                    "offlineMap": {
                        "type": "image",
                        "url": offlinemap,
                        "coordinates": [
                            [121.511, 25.065],
                            [121.52, 25.065],
                            [121.52, 25.05],
                            [121.511, 25.05]
                        ]
                    },
                    rtile: {
                        type: 'raster',
                        tiles: [
                            'https://tile.openstreetmap.org/{z}/{x}/{y}.png',
                        ],
                        tileSize: 256,
                        minzoom: 1,
                        maxzoom: 19,
                        attribution: '&copy; OpenStreetMap contributors',
                    },
                    kanban_points: {
                        type: "geojson",
                        data: { type: "FeatureCollection", features: [] },
                    },
                    'location-radius': {
                        type: 'geojson',
                        data: { "type": "Feature", "properties": {}, "geometry": { "type": "Polygon", "coordinates": [] } }
                    },
                    'location-history': {
                        type: 'geojson',
                        data: { "type": "Feature", "properties": {}, "geometry": { "type": "LineString", "coordinates": [] } }
                    },
                    'basic-root': {
                        type: 'geojson',
                        data: { "type": "FeatureCollection", "features": [{ "type": "Feature", "properties": { "Name": "メインルート" }, "geometry": { "type": "LineString", "coordinates": [[121.51574, 25.05362], [121.51605, 25.05355], [121.51601, 25.05336], [121.51596, 25.05319], [121.51593, 25.05308], [121.51591, 25.053], [121.51589, 25.05292], [121.51587, 25.05287], [121.51583, 25.05272], [121.51577, 25.05252], [121.5157, 25.05228], [121.51568, 25.05221], [121.51563, 25.05202], [121.51561, 25.05195], [121.51559, 25.05188], [121.51559, 25.05186], [121.51543, 25.05131], [121.51534, 25.05132], [121.5149, 25.05141], [121.51482, 25.05142], [121.51476, 25.05144], [121.51424, 25.05156], [121.51403, 25.0516], [121.51394, 25.05163], [121.51385, 25.05166], [121.51389, 25.05193], [121.51392, 25.05219], [121.51393, 25.05228], [121.51394, 25.05235], [121.51395, 25.05245], [121.51396, 25.05254], [121.51398, 25.05267], [121.51399, 25.05277], [121.51404, 25.05298], [121.51407, 25.05315], [121.51412, 25.05339], [121.51415, 25.0535], [121.51417, 25.05359], [121.51423, 25.05398], [121.51409, 25.05401], [121.51409, 25.05408], [121.51428, 25.05413], [121.51438, 25.05417], [121.5145, 25.05419], [121.51457, 25.0542], [121.51466, 25.05421], [121.51473, 25.05421], [121.5149, 25.05486], [121.51507, 25.05545], [121.51509, 25.05552], [121.51514, 25.05571], [121.51517, 25.05579], [121.51522, 25.05584], [121.51529, 25.05608], [121.51531, 25.05611], [121.51533, 25.05618], [121.51543, 25.05665], [121.51548, 25.05686], [121.5155, 25.05695], [121.5155, 25.05699], [121.51414, 25.05696], [121.51402, 25.05696], [121.51391, 25.05695], [121.51382, 25.05695], [121.51375, 25.05695], [121.51365, 25.05695], [121.51364, 25.05704], [121.51359, 25.05756], [121.51358, 25.05764], [121.51356, 25.05777], [121.51355, 25.05785], [121.51355, 25.05797], [121.51354, 25.05817], [121.51353, 25.05824], [121.51352, 25.0592], [121.51352, 25.05927], [121.51351, 25.05934], [121.51348, 25.05955], [121.51347, 25.05973], [121.51345, 25.0599], [121.51342, 25.0601], [121.51342, 25.06015], [121.51342, 25.0602], [121.51341, 25.06028], [121.51341, 25.06037], [121.51341, 25.06047], [121.51341, 25.06062], [121.51341, 25.06074], [121.51341, 25.06081], [121.51341, 25.06095]] } }] }
                    },
                    'additional-root': {
                        type: 'geojson',
                        data: { "type": "FeatureCollection", "features": [{ "type": "Feature", "properties": { "Name": "追加ルート" }, "geometry": { "type": "LineString", "coordinates": [[121.51528, 25.05612], [121.51523, 25.05614], [121.5152, 25.05615], [121.51519, 25.05615], [121.51518, 25.05615], [121.51516, 25.05616], [121.51453, 25.05606], [121.51426, 25.056], [121.51409, 25.05595], [121.51407, 25.05602], [121.51405, 25.0561], [121.51403, 25.05616], [121.51402, 25.05619], [121.51397, 25.05643], [121.51396, 25.05648], [121.51396, 25.05652], [121.51395, 25.05659], [121.51405, 25.05661], [121.51407, 25.05661], [121.51413, 25.05662], [121.51424, 25.05664], [121.51448, 25.05668], [121.5146, 25.0567], [121.51471, 25.05672], [121.51481, 25.05674], [121.51492, 25.05676], [121.51494, 25.05676], [121.51495, 25.05675], [121.51497, 25.05675], [121.51498, 25.05675], [121.51498, 25.05674], [121.515, 25.05674], [121.51501, 25.05673], [121.51502, 25.05672], [121.51503, 25.0567], [121.51504, 25.05667], [121.51508, 25.05657], [121.51514, 25.05639], [121.51519, 25.05623], [121.51522, 25.05622], [121.51523, 25.05621], [121.51526, 25.0562], [121.5153, 25.05619]] } }] }
                    }
                },
                layers: [
                    {
                        id: 'offlineMap',
                        type: 'raster',
                        source: 'offlineMap',
                        minzoom: 0,
                        maxzoom: 22,
                    },
                    {
                        id: 'raster-tiles',
                        type: 'raster',
                        source: 'rtile',
                        minzoom: 0,
                        maxzoom: 22,
                    },
                    {
                        id: 'location-radius',
                        type: 'fill',
                        source: 'location-radius',
                        paint: {
                            'fill-color': '#8CCFFF',
                            'fill-opacity': 0.5
                        }
                    },
                    {
                        id: 'location-radius-outline',
                        type: 'line',
                        source: 'location-radius',
                        paint: {
                            'line-color': '#0094ff',
                            'line-width': 1
                        }
                    },
                    {
                        id: 'location-history-outline',
                        type: 'line',
                        source: 'location-history',
                        paint: {
                            'line-color': '#FFFFFF',
                            'line-width': 8
                        },
                        'layout': {
                            'line-join': 'round',
                            'line-cap': 'round'
                        },
                    },
                    {
                        id: 'location-history',
                        type: 'line',
                        source: 'location-history',
                        paint: {
                            'line-color': '#0094ff',
                            'line-width': 4
                        },
                        'layout': {
                            'line-join': 'round',
                            'line-cap': 'round'
                        },
                    },
                    {
                        id: 'basic-root',//additional-root
                        type: 'line',
                        source: 'basic-root',
                        paint: {
                            'line-color': '#0094ff',
                            "line-opacity": 0.5,
                            'line-width': 10
                        },
                        'layout': {
                            'line-join': 'round',
                            'line-cap': 'round'
                        },
                    },
                    {
                        id: 'additional-root',
                        type: 'line',
                        source: 'additional-root',
                        paint: {
                            'line-color': '#ff408c',
                            "line-opacity": 0.5,
                            'line-width': 10
                        },
                        'layout': {
                            'line-join': 'round',
                            'line-cap': 'round'
                        },
                    },
                ],
            },
            center: [121.51577474218095, 25.05452913527664], // 中心座標
            zoom: 14, // ズームレベル
        });

        map.addControl(
            new maplibregl.AttributionControl({ compact: true, }),
            "bottom-right"
        );



        map.on('load', async () => {
            image = await map.loadImage('data:image/png;base64,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');
            map.addImage('pin', image.data);

            map.addLayer({
                'id': 'kanban_points',
                'type': 'symbol',
                'source': 'kanban_points',
                'layout': {
                    'icon-image': 'pin',
                    'icon-size': 0.6,
                    "symbol-spacing": 1,
                    "icon-anchor": "bottom",
                    "icon-allow-overlap": true,
                }
            });

            map.on("click", "kanban_points", function (e) {
                console.log(e.features[0])
                var p = e.features[0].properties;

                var type_table = { "sode": "袖看板", "hekimen": "壁面看板", "oki": "置き看板", "kenshoku": "建植看板", "other": "その他の看板" }
                var fixedPart_table = { "wall": "壁", "poll_exclusive": "専用支柱", "poll": "兼用支柱", "other": "その他" }
                var rust_table = { "lv1": "目視不可", "lv2": "目視可／汚ダレあり", "lv3": "さびで内容が分からない" }

                var popup_str = "";
                if (p["img_base64"]) popup_str += "<img src='" + p["img_base64"] + "'>"
                popup_str += "<p>記録：" + p["record-date"] + "</p>"
                popup_str += "<p>設置：" + fixedPart_table[p["fixed-part"]] + "</p>"
                if (p["poll-num"]) popup_str += "<p>支柱：" + p["poll-num"] + "本</p>"
                if (p["blacket-num"]) popup_str += "<p>金具：" + p["blacket-num"] + "個</p>"
                popup_str += "<p>さび：" + rust_table[p["rust"]] + "</p>"
                popup_str += "<p>振れ止め棒：" + (p["huredome"] ? "あり" : "なし") + "</p>"
                if (p["caster"]) popup_str += "<p>キャスターあり</p>"
                if (p["light"]) popup_str += "<p>電飾あり</p>"
                if (p["appendix"]) popup_str += "<p>" + p["appendix"] + "</p>"
                popup_str += "<button onclick='removeFeature(" + p["id"] + ")'>この項目を削除</button>"

                new maplibregl.Popup({ className: "map-popup", offset: [0, -40] })
                    .setLngLat(e.features[0].geometry.coordinates)
                    .setHTML(popup_str)
                    .addTo(map);
            });
        });

        var map2 = new maplibregl.Map({
            container: 'map2',
            attributionControl: false,
            style: {
                version: 8,
                sources: {
                    "offlineMap": {
                        "type": "image",
                        "url": offlinemap,
                        "coordinates": [
                            [121.511, 25.065],
                            [121.52, 25.065],
                            [121.52, 25.05],
                            [121.511, 25.05]
                        ]
                    },
                    rtile: {
                        type: 'raster',
                        tiles: [
                            'https://tile.openstreetmap.org/{z}/{x}/{y}.png',
                        ],
                        tileSize: 256,
                        minzoom: 1,
                        maxzoom: 19,
                        attribution: '&copy; OpenStreetMap contributors',
                    },
                },
                layers: [
                    {
                        id: 'offlineMap',
                        type: 'raster',
                        source: 'offlineMap',
                        paint: { "raster-saturation": - 0.5, },
                        minzoom: 0,
                        maxzoom: 22,
                    },
                    {
                        id: 'raster-tiles',
                        type: 'raster',
                        source: 'rtile',
                        paint: { "raster-saturation": - 0.5, },
                        minzoom: 0,
                        maxzoom: 22,
                    },
                ],
            },
            center: [121.51577474218095, 25.05452913527664], // 中心座標
            zoom: 18, // ズームレベル
        });

        map2.addControl(
            new maplibregl.AttributionControl({ compact: true, }),
            "bottom-right"
        );

        var map2_marker = new maplibregl.Marker({ color: '#ff0000' }).setLngLat([0, 0]).addTo(map2);

        map2.on("click", (e) => {
            var _position = [e.lngLat.lng, e.lngLat.lat]
            map2.flyTo({
                center: _position,
                zoom: 18,
            });
            map2_marker.setLngLat(_position)
        });

        var UserMarker;

        map.on("load", function () {
            map.fitBounds([
                [
                    121.5132274292913,
                    25.06087424013235
                ], [
                    121.5183220550706,
                    25.04818370192629
                ]
            ]);

            var el = document.createElement("div")
            el.classList.add("positionIcon")
            UserMarker = new maplibregl.Marker({ element: el })
                .setLngLat([0, 0])
                .addTo(map);

            drawLocation()
        })


        window.addEventListener("load", function () {
            //位置監視
            navigator.geolocation.watchPosition(
                function (position) {
                    currentLocation = { accuracy: "Low", coords: position.coords, date: new Date() }
                    drawLocation()
                },
                function (e) {
                    console.log("error")
                },
                {
                    maximumAge: 5000,//5秒間過去データ表示を認める（電池）
                    timeout: 1000,//高速要求
                    enableHighAccuracy: false//高精度要求しない（電池・反応速度）
                }
            );
            loadData()
        })

        function removeFeature(id) {
            record.kanban.features = record.kanban.features.filter(function (e) {
                return e.properties.id != id
            })

            saveData()
            drawKanban()
        }

        function loadData() {
            var openReq = indexedDB.open("record", 1);
            openReq.onupgradeneeded = function (event) {
                var db = event.target.result;
                db.createObjectStore("record_table", { keyPath: 'id' })
            }
            openReq.onsuccess = function (event) {
                try {
                    var storeName = 'sampleStore';

                    var db = event.target.result;
                    var trans = db.transaction("record_table", 'readonly');
                    var store = trans.objectStore("record_table");
                    var getReq = store.get("record_01");

                    getReq.onsuccess = function (event) {
                        if (event.target.result) {
                            record = (event.target.result).data; // {id : 'A1', name : 'test'}
                            drawKanban()
                        } else {
                            console.log("データなし0")
                        }
                    }
                    getReq.onerror = function (event) {
                        console.log("データなし1")
                    }
                } catch (err) {
                    return console.log("データなし4", err)
                }
            }
        }

        function saveData() {
            if (!record) return;
            var openReq = indexedDB.open("record");

            openReq.onupgradeneeded = function (event) {
                var db = event.target.result;
                db.createObjectStore("record_table", { keyPath: 'id' })
            }
            openReq.onsuccess = function (event) {
                var db = event.target.result;
                var trans = db.transaction("record_table", 'readwrite');
                var store = trans.objectStore("record_table");
                var putReq = store.put({ id: "record_01", data: record });

                putReq.onsuccess = function () {
                    console.log('put data success');
                }

                trans.oncomplete = function () {
                    console.log('transaction complete');
                }
            }
        }

        window.addEventListener('beforeunload', () => {
            saveData()
        })

        var currentLocation = { accuracy: null, coords: { longitude: null, latitude: null }, date: null }

        function drawLocation() {
            var LngLat = [currentLocation.coords.longitude, currentLocation.coords.latitude];
            if (!LngLat[0] || !LngLat[1]) return;
            if (!record.location_history.at(-1) || record.location_history.at(-1).join(",") !== LngLat.join(",")) {
                record.location_history.push(LngLat)
            }

            if (UserMarker) UserMarker.setLngLat(LngLat)

            if (map.getSource('location-radius')) {
                const radius = currentLocation.coords.accuracy; // kilometer
                const options = {
                    steps: 64,
                    units: 'meters'
                };
                const circle = turf.circle(LngLat, radius, options);

                map.getSource('location-radius').setData(circle)
            }

            if (map.getSource('location-history') && record.location_history.length > 1) {
                var line = turf.lineString(record.location_history);
                map.getSource('location-history').setData(line)
            }

            console.log(currentLocation)
        }

        function drawKanban() {
            if (map) map.getSource("kanban_points").setData(record.kanban);
        }

        document.getElementById("moveToMyPosition").addEventListener("click", function () {
            map.flyTo({
                center: [currentLocation.coords.longitude, currentLocation.coords.latitude],
                zoom: 16,
                bearing: 0,
                speed: 7,
                curve: 1,
            })
        });

        document.getElementById("photo_b").addEventListener("click", function () {
            document.getElementById("photo").click()
        })

        document.getElementById("appendix").addEventListener("focus", function () {
            document.getElementById("appendix").setAttribute("rows", 7)
        })

        document.getElementById("add").addEventListener("click", function () {
            //フォームリセット
            document.getElementById("type-5").checked = true
            document.getElementById("fixed-part-default").selected = true
            document.getElementById("poll-num").value = null;
            document.getElementById("blacket-num").value = null;
            document.getElementById("rust-default").selected = true
            document.getElementById("huredome").checked = false
            //document.getElementById("caster").checked = false
            document.getElementById("light").checked = false
            document.getElementById("appendix").value = null;
            document.getElementById("photo").value = "";
            document.getElementById("photo_b").innerText = "📷写真を添付"

            document.getElementById("appendix").setAttribute("rows", 2)

            //地図位置修正
            var _position = [currentLocation.coords.longitude, currentLocation.coords.latitude]
            map2.jumpTo({
                center: _position,
                zoom: 18,
            });
            map2_marker.setLngLat(_position)

            //高精度位置取得
            navigator.geolocation.getCurrentPosition(
                function (position) {
                    currentLocation = { accuracy: "High", coords: position.coords, date: new Date() }
                    drawLocation();

                    var _position = [position.coords.longitude, position.coords.latitude]
                    map2.jumpTo({
                        center: _position,
                        zoom: 18,
                    });
                    map2_marker.setLngLat(_position)
                },
                function (e) {
                    console.log("error", e)
                },
                {
                    maximumAge: 0,//古い位置を認めない
                    timeout: 3000,//来ない場合しばらく待つ
                    enableHighAccuracy: true//高精度要求
                }
            );

            document.getElementById("dialog").showModal()
        });
        document.getElementById("append").addEventListener("click", function () {
            document.getElementById("dialog").close()

            function format_number(str) {
                if (!str || isNaN(str)) return null;
                else return Number(str)
            }


            if (record.kanban.features.length) var max_id = Math.max(...record.kanban.features.map(e => e.properties.id));
            else var max_id = -1;

            var geojsonF = {
                "type": "Feature",
                "properties": {
                    id: max_id + 1,
                    "record-date": new Date().toLocaleString(),
                    type: document.querySelector("input[name='kanban-type']:checked").value,
                    "fixed-part": document.getElementById("fixed-part").value,
                    "poll-num": format_number(document.getElementById("poll-num").value),
                    "blacket-num": format_number(document.getElementById("blacket-num").value),
                    "rust": document.getElementById("rust").value,
                    "huredome": document.getElementById("huredome").checked,
                    //"caster": document.getElementById("caster").checked,
                    "light": document.getElementById("light").checked,
                    "appendix": document.getElementById("appendix").value,
                },
                "geometry": {
                    "coordinates": [
                        map2_marker.getLngLat().lng, map2_marker.getLngLat().lat
                    ],
                    "type": "Point"
                }
            }

            const file = document.getElementById("photo").files[0]
            const reader = new FileReader()
            reader.addEventListener('load', e => {
                var img = new Image();
                img.src = reader.result;
                img.onload = function () {
                    geojsonF.properties.img_base64 = resizeImg(this)
                    record.kanban.features.push(geojsonF)
                    saveData()
                    drawKanban()
                }

            })

            if (file) {
                reader.readAsDataURL(file);
            } else {
                record.kanban.features.push(geojsonF)
                saveData()
                drawKanban()
            }
        });

        document.getElementById("cancel").addEventListener("click", function () {
            document.getElementById("dialog").close()
        });

        document.getElementById("photo").addEventListener('change', function () {
            const file = document.getElementById("photo").files[0]
            if (!file.type.match('image.*')) {
                file.value = ""
                alert('画像ではないファイルが選択されました。画像を選択してください。');
                return;
            }
            document.getElementById("photo_b").innerText = "📷写真 添付済み"
        });

        document.getElementById("menu_show").addEventListener("click", function () {
            document.getElementById("menu").showModal()
        })
        document.getElementById("menu_cancel").addEventListener("click", function () {
            document.getElementById("menu").close()
        })

        document.querySelectorAll("input[name='kanban-type']").forEach(function (el) {
            el.addEventListener("change", function () {
                var type = document.querySelector("input[name='kanban-type']:checked").value

                document.getElementById("huredome").disabled = (type == "hekimen")
                if (type == "hekimen") document.getElementById("huredome").checked = false

                document.getElementById("poll-num").disabled = (type == "hekimen")
                if (type == "hekimen") document.getElementById("poll-num").value = null

                if (type == "hekimen") document.getElementById("fixed-part-default").selected = true
                document.getElementById("fixed-part-pollE").disabled = (type == "hekimen")
                document.getElementById("fixed-part-poll").disabled = (type == "hekimen")

                if (type == "kenshoku") document.getElementById("fixed-part-pollE").selected = true
                document.getElementById("fixed-part-default").disabled = (type == "kenshoku")
            })
        })

        function resizeImg(imgData) {
            var width = 150
            var height = Math.round(imgData.height * (width / imgData.width))
            console.log(imgData, width, height, imgData.height)
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(imgData, 0, 0, width, height);
            return canvas.toDataURL('image/png')
        }
    </script>
</body>

</html>